{"solidity/InterchainAppExample.sol:AppConfigLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212203805bc1ed2d485d86a54715fe6f890b22e8cc29673a80eb50099a73c810c86da64736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212203805bc1ed2d485d86a54715fe6f890b22e8cc29673a80eb50099a73c810c86da64736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainAppV1Events.sol\n\nabstract contract InterchainAppV1Events {\n    event AppConfigV1Set(uint256 requiredResponses, uint256 optimisticPeriod);\n    event AppLinked(uint256 indexed chainId, bytes32 indexed remoteApp);\n    event InterchainClientSet(address interchainClient);\n    event ExecutionServiceSet(address executionService);\n    event TrustedModuleAdded(address module);\n    event TrustedModuleRemoved(address module);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    function appReceive(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    uint8 constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint8 version);\n\n    /// @notice Encodes versioned app config into a bytes format.\n    /// @param version      The version of the app config.\n    /// @param appConfig    The app config to encode.\n    function encodeVersionedAppConfig(uint8 version, bytes memory appConfig) internal pure returns (bytes memory) {\n        return abi.encode(version, appConfig);\n    }\n\n    /// @notice Decodes versioned app config from a bytes format back into a version and app config.\n    /// @param data         The versioned app config data in bytes format.\n    /// @return version     The version of the app config.\n    /// @return appConfig   The app config as bytes.\n    function decodeVersionedAppConfig(bytes memory data)\n        internal\n        pure\n        returns (uint8 version, bytes memory appConfig)\n    {\n        (version, appConfig) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return encodeVersionedAppConfig(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal pure returns (AppConfigV1 memory) {\n        (uint8 version, bytes memory appConfig) = decodeVersionedAppConfig(data);\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(appConfig, (AppConfigV1));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    uint8 constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint8 version);\n\n    /// @notice Encodes versioned options into a bytes format.\n    /// @param version      The version of the options.\n    /// @param options      The options to encode.\n    function encodeVersionedOptions(uint8 version, bytes memory options) internal pure returns (bytes memory) {\n        return abi.encode(version, options);\n    }\n\n    /// @notice Decodes versioned options from a bytes format back into a version and options.\n    /// @param data         The versioned options data in bytes format.\n    /// @return version     The version of the options.\n    /// @return options     The options as bytes.\n    function decodeVersionedOptions(bytes memory data) internal pure returns (uint8 version, bytes memory options) {\n        (version, options) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return encodeVersionedOptions(OPTIONS_V1, abi.encode(options));\n    }\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal pure returns (OptionsV1 memory) {\n        (uint8 version, bytes memory options) = decodeVersionedOptions(data);\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(options, (OptionsV1));\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/libs/InterchainTransaction.sol\n\nstruct InterchainTransaction {\n    uint256 srcChainId;\n    bytes32 srcSender;\n    uint256 dstChainId;\n    bytes32 dstReceiver;\n    uint256 dbNonce;\n    uint64 entryIndex;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint256 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    function constructLocalTransaction(\n        address srcSender,\n        uint256 dstChainId,\n        bytes32 dstReceiver,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: block.chainid,\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(transaction);\n    }\n\n    function decodeTransaction(bytes memory encodedTx) internal pure returns (InterchainTransaction memory) {\n        return abi.decode(encodedTx, (InterchainTransaction));\n    }\n\n    function transactionId(InterchainTransaction memory transaction) internal pure returns (bytes32) {\n        return keccak256(abi.encode(transaction));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint256 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__NoLinkedClient(uint256 chainId);\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint256 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint256 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint256 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint256 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint256 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param message              The message being sent.\n    function getInterchainFee(\n        uint256 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint256 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint256 chainId) external view returns (address);\n}\n\n// contracts/apps/InterchainAppV1.sol\n\nabstract contract InterchainAppV1 is InterchainAppV1Events, IInterchainApp {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    // TODO: naming, visibility\n    address public interchain;\n\n    /// @dev Required responses and optimistic period for the module responses.\n    AppConfigV1 private _appConfigV1;\n    /// @dev Address of the linked app deployed on the remote chain.\n    mapping(uint256 chainId =\u003e bytes32 remoteApp) private _linkedApp;\n    /// @dev Trusted Interchain modules.\n    EnumerableSet.AddressSet private _trustedModules;\n    /// @dev Execution Service to use for sending messages.\n    address private _executionService;\n\n    error InterchainApp__BalanceTooLow(uint256 actual, uint256 expected);\n    error InterchainApp__CallerNotInterchainClient(address caller);\n    error InterchainApp__InterchainClientNotSet();\n    error InterchainApp__ModuleAlreadyAdded(address module);\n    error InterchainApp__ModuleNotAdded(address module);\n    error InterchainApp__ReceiverNotSet(uint256 chainId);\n    error InterchainApp__SameChainId(uint256 chainId);\n    error InterchainApp__SenderNotAllowed(uint256 srcChainId, bytes32 sender);\n\n    /// @inheritdoc IInterchainApp\n    function appReceive(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        if (msg.sender != interchain) revert InterchainApp__CallerNotInterchainClient(msg.sender);\n        if (srcChainId == block.chainid) revert InterchainApp__SameChainId(srcChainId);\n        if (!isAllowedSender(srcChainId, sender)) revert InterchainApp__SenderNotAllowed(srcChainId, sender);\n        _receiveMessage(srcChainId, sender, dbNonce, entryIndex, message);\n        // Note: application may elect to emit an event in `_receiveMessage`, so we don't emit a generic event here.\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainApp\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules) {\n        // Note: the getters for app config and modules could be overridden in the derived contracts.\n        appConfig = getAppConfigV1().encodeAppConfigV1();\n        modules = getReceivingModules();\n    }\n\n    /// @notice Returns the app config for receiving messages.\n    /// @dev Could be overridden in the derived contracts.\n    function getAppConfigV1() public view virtual returns (AppConfigV1 memory) {\n        return _appConfigV1;\n    }\n\n    /// @notice Returns the address of the Execution Service to use for sending messages.\n    /// @dev Could be overridden in the derived contracts.\n    function getExecutionService() public view virtual returns (address) {\n        return _executionService;\n    }\n\n    /// @notice Returns the linked app address (as bytes32) for the given chain ID.\n    /// @dev Could be overridden in the derived contracts.\n    function getLinkedApp(uint256 chainId) public view virtual returns (bytes32) {\n        return _linkedApp[chainId];\n    }\n\n    /// @notice Returns the list of modules used for sending messages.\n    /// @dev Could be overridden in the derived contracts.\n    function getSendingModules() public view virtual returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    /// @notice Returns the list of modules used for receiving messages.\n    /// @dev Could be overridden in the derived contracts.\n    function getReceivingModules() public view virtual returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    /// @notice Checks whether the sender is allowed to send messages to the current app.\n    /// @dev Could be overridden in the derived contracts.\n    function isAllowedSender(uint256 srcChainId, bytes32 sender) public view virtual returns (bool) {\n        return _linkedApp[srcChainId] == sender;\n    }\n\n    /// @notice Returns the current app version.\n    /// @dev Could be overridden in the derived contracts.\n    function getAppVersion() public pure virtual returns (uint256) {\n        return 1;\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Links the remote app to the current app.\n    /// Will revert if the chainId is the same as the chainId of the local app.\n    /// Note: Should be guarded with permissions check.\n    function _linkRemoteApp(uint256 chainId, bytes32 remoteApp) internal {\n        if (chainId == block.chainid) revert InterchainApp__SameChainId(chainId);\n        _linkedApp[chainId] = remoteApp;\n        emit AppLinked(chainId, remoteApp);\n    }\n\n    /// @dev Thin wrapper around _linkRemoteApp to accept EVM address as a parameter.\n    function _linkRemoteAppEVM(uint256 chainId, address remoteApp) internal {\n        _linkRemoteApp(chainId, TypeCasts.addressToBytes32(remoteApp));\n    }\n\n    /// @dev Adds the module to the trusted modules set.\n    /// Will revert if the module is already added.\n    /// Note: Should be guarded with permissions check.\n    function _addTrustedModule(address module) internal {\n        bool added = _trustedModules.add(module);\n        if (!added) revert InterchainApp__ModuleAlreadyAdded(module);\n        emit TrustedModuleAdded(module);\n    }\n\n    /// @dev Removes the module from the trusted modules set.\n    /// Will revert if the module is not added.\n    /// Note: Should be guarded with permissions check.\n    function _removeTrustedModule(address module) internal {\n        bool removed = _trustedModules.remove(module);\n        if (!removed) revert InterchainApp__ModuleNotAdded(module);\n        emit TrustedModuleRemoved(module);\n    }\n\n    /// @dev Sets the app config:\n    /// - requiredResponses: the number of module responses required for accepting the message\n    /// - optimisticPeriod: the minimum time after which the module responses are considered final\n    /// Note: Should be guarded with permissions check.\n    function _setAppConfigV1(AppConfigV1 memory appConfig) internal {\n        _appConfigV1 = appConfig;\n        emit AppConfigV1Set(appConfig.requiredResponses, appConfig.optimisticPeriod);\n    }\n\n    /// @dev Sets the execution service address.\n    /// Note: Should be guarded with permissions check.\n    function _setExecutionService(address executionService) internal {\n        _executionService = executionService;\n        emit ExecutionServiceSet(executionService);\n    }\n\n    /// @dev Sets the interchain client address.\n    /// Note: Should be guarded with permissions check.\n    function _setInterchainClient(address interchain_) internal {\n        interchain = interchain_;\n        emit InterchainClientSet(interchain_);\n    }\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to send the message to the linked app.\n    function _sendInterchainMessage(\n        uint256 dstChainId,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _sendInterchainMessage(dstChainId, getLinkedApp(dstChainId), messageFee, options, message);\n    }\n\n    /// @dev Thin wrapper around _sendInterchainMessage to accept EVM address as a parameter.\n    function _sendInterchainMessageEVM(\n        uint256 dstChainId,\n        address receiver,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _sendInterchainMessage(dstChainId, TypeCasts.addressToBytes32(receiver), messageFee, options, message);\n    }\n\n    /// @dev Performs necessary checks and sends an interchain message.\n    function _sendInterchainMessage(\n        uint256 dstChainId,\n        bytes32 receiver,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        address cachedInterchain = interchain;\n//        if (cachedInterchain == address(0)) revert InterchainApp__InterchainClientNotSet();\n//        if (dstChainId == block.chainid) revert InterchainApp__SameChainId(dstChainId);\n//        if (receiver == 0) revert InterchainApp__ReceiverNotSet(dstChainId);\n//        if (address(this).balance \u003c messageFee) revert InterchainApp__BalanceTooLow(address(this).balance, messageFee);\n        return IInterchainClientV1(cachedInterchain).interchainSend{value: messageFee}(\n            dstChainId, receiver, getExecutionService(), getSendingModules(), options.encodeOptionsV1(), message\n        );\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        virtual;\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee for sending an Interchain message.\n    function _getInterchainFee(\n        uint256 dstChainId,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        address cachedInterchain = interchain;\n        if (cachedInterchain == address(0)) revert InterchainApp__InterchainClientNotSet();\n        return IInterchainClientV1(cachedInterchain).getInterchainFee(\n            dstChainId, getExecutionService(), getSendingModules(), options.encodeOptionsV1(), message\n        );\n    }\n}\n\n// contracts/apps/OwnableApp.sol\n\nabstract contract OwnableApp is InterchainAppV1, Ownable {\n    constructor(address owner_) Ownable(owner_) {}\n\n    /// @notice Allows the owner to link the remote app for the given chain ID.\n    /// - This address will be used as the receiver for the messages sent from this chain.\n    /// - This address will be the only trusted sender for the messages sent to this chain.\n    function linkRemoteApp(uint256 chainId, bytes32 remoteApp) external onlyOwner {\n        _linkRemoteApp(chainId, remoteApp);\n    }\n\n    /// @notice This wrapper for `linkRemoteApp` to accept EVM address as a parameter.\n    function linkRemoteAppEVM(uint256 chainId, address remoteApp) external onlyOwner {\n        _linkRemoteAppEVM(chainId, remoteApp);\n    }\n\n    /// @notice Allows the owner to add the module to the trusted modules set.\n    /// - This set of modules will be used to verify message sent from this chain.\n    /// - This set of modules will be used to verify message sent to this chain.\n    function addTrustedModule(address module) external onlyOwner {\n        _addTrustedModule(module);\n    }\n\n    /// @notice Allows the owner to remove the module from the trusted modules set.\n    function removeTrustedModule(address module) external onlyOwner {\n        _removeTrustedModule(module);\n    }\n\n    /// @notice Allows the owner to set the app config for the current app. App config includes:\n    /// - requiredResponses: the number of module responses required for accepting the message\n    /// - optimisticPeriod: the minimum time after which the module responses are considered final\n    function setAppConfigV1(AppConfigV1 memory appConfig) external onlyOwner {\n        _setAppConfigV1(appConfig);\n    }\n\n    /// @notice Allows the owner to set the address of the Execution Service.\n    /// This address will be used to request execution of the messages sent from this chain,\n    /// by supplying the Service's execution fee.\n    function setExecutionService(address executionService) external onlyOwner {\n        _setExecutionService(executionService);\n    }\n\n    /// @notice Allows the owner to set the address of the InterchainClient contract.\n    function setInterchainClient(address interchain_) external onlyOwner {\n        _setInterchainClient(interchain_);\n    }\n}\n\n// contracts/apps/InterchainAppExample.sol\n\ncontract InterchainAppExample is OwnableApp {\n    event MessageReceived(uint256 srcChainId, bytes32 sender, uint256 dbNonce, uint64 entryIndex, bytes message);\n    event MessageSent(uint256 dstChainId, uint256 dbNonce, uint64 entryIndex, bytes32 transactionId);\n\n    constructor(address owner_) OwnableApp(owner_) {}\n\n    /// @notice Sends a basic message to the destination chain.\n    function sendMessage(uint256 dstChainId, uint256 gasLimit, bytes calldata message) external payable {\n        InterchainTxDescriptor memory desc = _sendInterchainMessage({\n            dstChainId: dstChainId,\n            messageFee: msg.value,\n            options: OptionsV1({gasLimit: gasLimit, gasAirdrop: 0}),\n            message: message\n        });\n        emit MessageSent(dstChainId, desc.dbNonce, desc.entryIndex, desc.transactionId);\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        override\n    {\n        emit MessageReceived(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"1167:2072:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;1167:2072:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"1167:2072:0:-:0;;;;;;;;","abiDefinition":[{"inputs":[{"internalType":"uint8","name":"version","type":"uint8"}],"name":"AppConfigLib__IncorrectVersion","type":"error"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"AppConfigLib__IncorrectVersion\",\"type\":\"error\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainAppExample.sol\":\"AppConfigLib\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainAppExample.sol\":{\"keccak256\":\"0x86f91eccd427db2c0e6cbbdb2244f577ed8111343e9ad8aa6476b8b0bd7cb65c\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://c9a5bce8ffbdc1808235baa92fe6b0fff964c26898bb155a1b06e5ea3e4f3940\",\"dweb:/ipfs/QmZqjYVRz4JL5Pjz9TZqVSy7PUZGsabLKsxtHXP44i3TVK\"]}},\"version\":1}"},"hashes":{}},"solidity/InterchainAppExample.sol:Context":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainAppV1Events.sol\n\nabstract contract InterchainAppV1Events {\n    event AppConfigV1Set(uint256 requiredResponses, uint256 optimisticPeriod);\n    event AppLinked(uint256 indexed chainId, bytes32 indexed remoteApp);\n    event InterchainClientSet(address interchainClient);\n    event ExecutionServiceSet(address executionService);\n    event TrustedModuleAdded(address module);\n    event TrustedModuleRemoved(address module);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    function appReceive(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    uint8 constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint8 version);\n\n    /// @notice Encodes versioned app config into a bytes format.\n    /// @param version      The version of the app config.\n    /// @param appConfig    The app config to encode.\n    function encodeVersionedAppConfig(uint8 version, bytes memory appConfig) internal pure returns (bytes memory) {\n        return abi.encode(version, appConfig);\n    }\n\n    /// @notice Decodes versioned app config from a bytes format back into a version and app config.\n    /// @param data         The versioned app config data in bytes format.\n    /// @return version     The version of the app config.\n    /// @return appConfig   The app config as bytes.\n    function decodeVersionedAppConfig(bytes memory data)\n        internal\n        pure\n        returns (uint8 version, bytes memory appConfig)\n    {\n        (version, appConfig) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return encodeVersionedAppConfig(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal pure returns (AppConfigV1 memory) {\n        (uint8 version, bytes memory appConfig) = decodeVersionedAppConfig(data);\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(appConfig, (AppConfigV1));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    uint8 constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint8 version);\n\n    /// @notice Encodes versioned options into a bytes format.\n    /// @param version      The version of the options.\n    /// @param options      The options to encode.\n    function encodeVersionedOptions(uint8 version, bytes memory options) internal pure returns (bytes memory) {\n        return abi.encode(version, options);\n    }\n\n    /// @notice Decodes versioned options from a bytes format back into a version and options.\n    /// @param data         The versioned options data in bytes format.\n    /// @return version     The version of the options.\n    /// @return options     The options as bytes.\n    function decodeVersionedOptions(bytes memory data) internal pure returns (uint8 version, bytes memory options) {\n        (version, options) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return encodeVersionedOptions(OPTIONS_V1, abi.encode(options));\n    }\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal pure returns (OptionsV1 memory) {\n        (uint8 version, bytes memory options) = decodeVersionedOptions(data);\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(options, (OptionsV1));\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/libs/InterchainTransaction.sol\n\nstruct InterchainTransaction {\n    uint256 srcChainId;\n    bytes32 srcSender;\n    uint256 dstChainId;\n    bytes32 dstReceiver;\n    uint256 dbNonce;\n    uint64 entryIndex;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint256 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    function constructLocalTransaction(\n        address srcSender,\n        uint256 dstChainId,\n        bytes32 dstReceiver,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: block.chainid,\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(transaction);\n    }\n\n    function decodeTransaction(bytes memory encodedTx) internal pure returns (InterchainTransaction memory) {\n        return abi.decode(encodedTx, (InterchainTransaction));\n    }\n\n    function transactionId(InterchainTransaction memory transaction) internal pure returns (bytes32) {\n        return keccak256(abi.encode(transaction));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint256 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__NoLinkedClient(uint256 chainId);\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint256 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint256 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint256 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint256 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint256 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param message              The message being sent.\n    function getInterchainFee(\n        uint256 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint256 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint256 chainId) external view returns (address);\n}\n\n// contracts/apps/InterchainAppV1.sol\n\nabstract contract InterchainAppV1 is InterchainAppV1Events, IInterchainApp {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    // TODO: naming, visibility\n    address public interchain;\n\n    /// @dev Required responses and optimistic period for the module responses.\n    AppConfigV1 private _appConfigV1;\n    /// @dev Address of the linked app deployed on the remote chain.\n    mapping(uint256 chainId =\u003e bytes32 remoteApp) private _linkedApp;\n    /// @dev Trusted Interchain modules.\n    EnumerableSet.AddressSet private _trustedModules;\n    /// @dev Execution Service to use for sending messages.\n    address private _executionService;\n\n    error InterchainApp__BalanceTooLow(uint256 actual, uint256 expected);\n    error InterchainApp__CallerNotInterchainClient(address caller);\n    error InterchainApp__InterchainClientNotSet();\n    error InterchainApp__ModuleAlreadyAdded(address module);\n    error InterchainApp__ModuleNotAdded(address module);\n    error InterchainApp__ReceiverNotSet(uint256 chainId);\n    error InterchainApp__SameChainId(uint256 chainId);\n    error InterchainApp__SenderNotAllowed(uint256 srcChainId, bytes32 sender);\n\n    /// @inheritdoc IInterchainApp\n    function appReceive(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        if (msg.sender != interchain) revert InterchainApp__CallerNotInterchainClient(msg.sender);\n        if (srcChainId == block.chainid) revert InterchainApp__SameChainId(srcChainId);\n        if (!isAllowedSender(srcChainId, sender)) revert InterchainApp__SenderNotAllowed(srcChainId, sender);\n        _receiveMessage(srcChainId, sender, dbNonce, entryIndex, message);\n        // Note: application may elect to emit an event in `_receiveMessage`, so we don't emit a generic event here.\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainApp\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules) {\n        // Note: the getters for app config and modules could be overridden in the derived contracts.\n        appConfig = getAppConfigV1().encodeAppConfigV1();\n        modules = getReceivingModules();\n    }\n\n    /// @notice Returns the app config for receiving messages.\n    /// @dev Could be overridden in the derived contracts.\n    function getAppConfigV1() public view virtual returns (AppConfigV1 memory) {\n        return _appConfigV1;\n    }\n\n    /// @notice Returns the address of the Execution Service to use for sending messages.\n    /// @dev Could be overridden in the derived contracts.\n    function getExecutionService() public view virtual returns (address) {\n        return _executionService;\n    }\n\n    /// @notice Returns the linked app address (as bytes32) for the given chain ID.\n    /// @dev Could be overridden in the derived contracts.\n    function getLinkedApp(uint256 chainId) public view virtual returns (bytes32) {\n        return _linkedApp[chainId];\n    }\n\n    /// @notice Returns the list of modules used for sending messages.\n    /// @dev Could be overridden in the derived contracts.\n    function getSendingModules() public view virtual returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    /// @notice Returns the list of modules used for receiving messages.\n    /// @dev Could be overridden in the derived contracts.\n    function getReceivingModules() public view virtual returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    /// @notice Checks whether the sender is allowed to send messages to the current app.\n    /// @dev Could be overridden in the derived contracts.\n    function isAllowedSender(uint256 srcChainId, bytes32 sender) public view virtual returns (bool) {\n        return _linkedApp[srcChainId] == sender;\n    }\n\n    /// @notice Returns the current app version.\n    /// @dev Could be overridden in the derived contracts.\n    function getAppVersion() public pure virtual returns (uint256) {\n        return 1;\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Links the remote app to the current app.\n    /// Will revert if the chainId is the same as the chainId of the local app.\n    /// Note: Should be guarded with permissions check.\n    function _linkRemoteApp(uint256 chainId, bytes32 remoteApp) internal {\n        if (chainId == block.chainid) revert InterchainApp__SameChainId(chainId);\n        _linkedApp[chainId] = remoteApp;\n        emit AppLinked(chainId, remoteApp);\n    }\n\n    /// @dev Thin wrapper around _linkRemoteApp to accept EVM address as a parameter.\n    function _linkRemoteAppEVM(uint256 chainId, address remoteApp) internal {\n        _linkRemoteApp(chainId, TypeCasts.addressToBytes32(remoteApp));\n    }\n\n    /// @dev Adds the module to the trusted modules set.\n    /// Will revert if the module is already added.\n    /// Note: Should be guarded with permissions check.\n    function _addTrustedModule(address module) internal {\n        bool added = _trustedModules.add(module);\n        if (!added) revert InterchainApp__ModuleAlreadyAdded(module);\n        emit TrustedModuleAdded(module);\n    }\n\n    /// @dev Removes the module from the trusted modules set.\n    /// Will revert if the module is not added.\n    /// Note: Should be guarded with permissions check.\n    function _removeTrustedModule(address module) internal {\n        bool removed = _trustedModules.remove(module);\n        if (!removed) revert InterchainApp__ModuleNotAdded(module);\n        emit TrustedModuleRemoved(module);\n    }\n\n    /// @dev Sets the app config:\n    /// - requiredResponses: the number of module responses required for accepting the message\n    /// - optimisticPeriod: the minimum time after which the module responses are considered final\n    /// Note: Should be guarded with permissions check.\n    function _setAppConfigV1(AppConfigV1 memory appConfig) internal {\n        _appConfigV1 = appConfig;\n        emit AppConfigV1Set(appConfig.requiredResponses, appConfig.optimisticPeriod);\n    }\n\n    /// @dev Sets the execution service address.\n    /// Note: Should be guarded with permissions check.\n    function _setExecutionService(address executionService) internal {\n        _executionService = executionService;\n        emit ExecutionServiceSet(executionService);\n    }\n\n    /// @dev Sets the interchain client address.\n    /// Note: Should be guarded with permissions check.\n    function _setInterchainClient(address interchain_) internal {\n        interchain = interchain_;\n        emit InterchainClientSet(interchain_);\n    }\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to send the message to the linked app.\n    function _sendInterchainMessage(\n        uint256 dstChainId,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _sendInterchainMessage(dstChainId, getLinkedApp(dstChainId), messageFee, options, message);\n    }\n\n    /// @dev Thin wrapper around _sendInterchainMessage to accept EVM address as a parameter.\n    function _sendInterchainMessageEVM(\n        uint256 dstChainId,\n        address receiver,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _sendInterchainMessage(dstChainId, TypeCasts.addressToBytes32(receiver), messageFee, options, message);\n    }\n\n    /// @dev Performs necessary checks and sends an interchain message.\n    function _sendInterchainMessage(\n        uint256 dstChainId,\n        bytes32 receiver,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        address cachedInterchain = interchain;\n//        if (cachedInterchain == address(0)) revert InterchainApp__InterchainClientNotSet();\n//        if (dstChainId == block.chainid) revert InterchainApp__SameChainId(dstChainId);\n//        if (receiver == 0) revert InterchainApp__ReceiverNotSet(dstChainId);\n//        if (address(this).balance \u003c messageFee) revert InterchainApp__BalanceTooLow(address(this).balance, messageFee);\n        return IInterchainClientV1(cachedInterchain).interchainSend{value: messageFee}(\n            dstChainId, receiver, getExecutionService(), getSendingModules(), options.encodeOptionsV1(), message\n        );\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        virtual;\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee for sending an Interchain message.\n    function _getInterchainFee(\n        uint256 dstChainId,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        address cachedInterchain = interchain;\n        if (cachedInterchain == address(0)) revert InterchainApp__InterchainClientNotSet();\n        return IInterchainClientV1(cachedInterchain).getInterchainFee(\n            dstChainId, getExecutionService(), getSendingModules(), options.encodeOptionsV1(), message\n        );\n    }\n}\n\n// contracts/apps/OwnableApp.sol\n\nabstract contract OwnableApp is InterchainAppV1, Ownable {\n    constructor(address owner_) Ownable(owner_) {}\n\n    /// @notice Allows the owner to link the remote app for the given chain ID.\n    /// - This address will be used as the receiver for the messages sent from this chain.\n    /// - This address will be the only trusted sender for the messages sent to this chain.\n    function linkRemoteApp(uint256 chainId, bytes32 remoteApp) external onlyOwner {\n        _linkRemoteApp(chainId, remoteApp);\n    }\n\n    /// @notice This wrapper for `linkRemoteApp` to accept EVM address as a parameter.\n    function linkRemoteAppEVM(uint256 chainId, address remoteApp) external onlyOwner {\n        _linkRemoteAppEVM(chainId, remoteApp);\n    }\n\n    /// @notice Allows the owner to add the module to the trusted modules set.\n    /// - This set of modules will be used to verify message sent from this chain.\n    /// - This set of modules will be used to verify message sent to this chain.\n    function addTrustedModule(address module) external onlyOwner {\n        _addTrustedModule(module);\n    }\n\n    /// @notice Allows the owner to remove the module from the trusted modules set.\n    function removeTrustedModule(address module) external onlyOwner {\n        _removeTrustedModule(module);\n    }\n\n    /// @notice Allows the owner to set the app config for the current app. App config includes:\n    /// - requiredResponses: the number of module responses required for accepting the message\n    /// - optimisticPeriod: the minimum time after which the module responses are considered final\n    function setAppConfigV1(AppConfigV1 memory appConfig) external onlyOwner {\n        _setAppConfigV1(appConfig);\n    }\n\n    /// @notice Allows the owner to set the address of the Execution Service.\n    /// This address will be used to request execution of the messages sent from this chain,\n    /// by supplying the Service's execution fee.\n    function setExecutionService(address executionService) external onlyOwner {\n        _setExecutionService(executionService);\n    }\n\n    /// @notice Allows the owner to set the address of the InterchainClient contract.\n    function setInterchainClient(address interchain_) external onlyOwner {\n        _setInterchainClient(interchain_);\n    }\n}\n\n// contracts/apps/InterchainAppExample.sol\n\ncontract InterchainAppExample is OwnableApp {\n    event MessageReceived(uint256 srcChainId, bytes32 sender, uint256 dbNonce, uint64 entryIndex, bytes message);\n    event MessageSent(uint256 dstChainId, uint256 dbNonce, uint64 entryIndex, bytes32 transactionId);\n\n    constructor(address owner_) OwnableApp(owner_) {}\n\n    /// @notice Sends a basic message to the destination chain.\n    function sendMessage(uint256 dstChainId, uint256 gasLimit, bytes calldata message) external payable {\n        InterchainTxDescriptor memory desc = _sendInterchainMessage({\n            dstChainId: dstChainId,\n            messageFee: msg.value,\n            options: OptionsV1({gasLimit: gasLimit, gasAirdrop: 0}),\n            message: message\n        });\n        emit MessageSent(dstChainId, desc.dbNonce, desc.entryIndex, desc.transactionId);\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        override\n    {\n        emit MessageReceived(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"details":"Provides information about the current execution context, including the sender of the transaction and its data. While these are generally available via msg.sender and msg.data, they should not be accessed in such a direct manner, since when dealing with meta-transactions the account sending and paying for execution may not be the actual sender (as far as an application is concerned). This contract is only required for intermediate, library-like contracts.","kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"details\":\"Provides information about the current execution context, including the sender of the transaction and its data. While these are generally available via msg.sender and msg.data, they should not be accessed in such a direct manner, since when dealing with meta-transactions the account sending and paying for execution may not be the actual sender (as far as an application is concerned). This contract is only required for intermediate, library-like contracts.\",\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainAppExample.sol\":\"Context\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainAppExample.sol\":{\"keccak256\":\"0x86f91eccd427db2c0e6cbbdb2244f577ed8111343e9ad8aa6476b8b0bd7cb65c\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://c9a5bce8ffbdc1808235baa92fe6b0fff964c26898bb155a1b06e5ea3e4f3940\",\"dweb:/ipfs/QmZqjYVRz4JL5Pjz9TZqVSy7PUZGsabLKsxtHXP44i3TVK\"]}},\"version\":1}"},"hashes":{}},"solidity/InterchainAppExample.sol:EnumerableSet":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122029c69061428181d463c0d29a13bc99ffb08948f2955beb1d5593bb91297201ae64736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122029c69061428181d463c0d29a13bc99ffb08948f2955beb1d5593bb91297201ae64736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainAppV1Events.sol\n\nabstract contract InterchainAppV1Events {\n    event AppConfigV1Set(uint256 requiredResponses, uint256 optimisticPeriod);\n    event AppLinked(uint256 indexed chainId, bytes32 indexed remoteApp);\n    event InterchainClientSet(address interchainClient);\n    event ExecutionServiceSet(address executionService);\n    event TrustedModuleAdded(address module);\n    event TrustedModuleRemoved(address module);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    function appReceive(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    uint8 constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint8 version);\n\n    /// @notice Encodes versioned app config into a bytes format.\n    /// @param version      The version of the app config.\n    /// @param appConfig    The app config to encode.\n    function encodeVersionedAppConfig(uint8 version, bytes memory appConfig) internal pure returns (bytes memory) {\n        return abi.encode(version, appConfig);\n    }\n\n    /// @notice Decodes versioned app config from a bytes format back into a version and app config.\n    /// @param data         The versioned app config data in bytes format.\n    /// @return version     The version of the app config.\n    /// @return appConfig   The app config as bytes.\n    function decodeVersionedAppConfig(bytes memory data)\n        internal\n        pure\n        returns (uint8 version, bytes memory appConfig)\n    {\n        (version, appConfig) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return encodeVersionedAppConfig(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal pure returns (AppConfigV1 memory) {\n        (uint8 version, bytes memory appConfig) = decodeVersionedAppConfig(data);\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(appConfig, (AppConfigV1));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    uint8 constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint8 version);\n\n    /// @notice Encodes versioned options into a bytes format.\n    /// @param version      The version of the options.\n    /// @param options      The options to encode.\n    function encodeVersionedOptions(uint8 version, bytes memory options) internal pure returns (bytes memory) {\n        return abi.encode(version, options);\n    }\n\n    /// @notice Decodes versioned options from a bytes format back into a version and options.\n    /// @param data         The versioned options data in bytes format.\n    /// @return version     The version of the options.\n    /// @return options     The options as bytes.\n    function decodeVersionedOptions(bytes memory data) internal pure returns (uint8 version, bytes memory options) {\n        (version, options) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return encodeVersionedOptions(OPTIONS_V1, abi.encode(options));\n    }\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal pure returns (OptionsV1 memory) {\n        (uint8 version, bytes memory options) = decodeVersionedOptions(data);\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(options, (OptionsV1));\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/libs/InterchainTransaction.sol\n\nstruct InterchainTransaction {\n    uint256 srcChainId;\n    bytes32 srcSender;\n    uint256 dstChainId;\n    bytes32 dstReceiver;\n    uint256 dbNonce;\n    uint64 entryIndex;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint256 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    function constructLocalTransaction(\n        address srcSender,\n        uint256 dstChainId,\n        bytes32 dstReceiver,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: block.chainid,\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(transaction);\n    }\n\n    function decodeTransaction(bytes memory encodedTx) internal pure returns (InterchainTransaction memory) {\n        return abi.decode(encodedTx, (InterchainTransaction));\n    }\n\n    function transactionId(InterchainTransaction memory transaction) internal pure returns (bytes32) {\n        return keccak256(abi.encode(transaction));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint256 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__NoLinkedClient(uint256 chainId);\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint256 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint256 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint256 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint256 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint256 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param message              The message being sent.\n    function getInterchainFee(\n        uint256 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint256 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint256 chainId) external view returns (address);\n}\n\n// contracts/apps/InterchainAppV1.sol\n\nabstract contract InterchainAppV1 is InterchainAppV1Events, IInterchainApp {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    // TODO: naming, visibility\n    address public interchain;\n\n    /// @dev Required responses and optimistic period for the module responses.\n    AppConfigV1 private _appConfigV1;\n    /// @dev Address of the linked app deployed on the remote chain.\n    mapping(uint256 chainId =\u003e bytes32 remoteApp) private _linkedApp;\n    /// @dev Trusted Interchain modules.\n    EnumerableSet.AddressSet private _trustedModules;\n    /// @dev Execution Service to use for sending messages.\n    address private _executionService;\n\n    error InterchainApp__BalanceTooLow(uint256 actual, uint256 expected);\n    error InterchainApp__CallerNotInterchainClient(address caller);\n    error InterchainApp__InterchainClientNotSet();\n    error InterchainApp__ModuleAlreadyAdded(address module);\n    error InterchainApp__ModuleNotAdded(address module);\n    error InterchainApp__ReceiverNotSet(uint256 chainId);\n    error InterchainApp__SameChainId(uint256 chainId);\n    error InterchainApp__SenderNotAllowed(uint256 srcChainId, bytes32 sender);\n\n    /// @inheritdoc IInterchainApp\n    function appReceive(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        if (msg.sender != interchain) revert InterchainApp__CallerNotInterchainClient(msg.sender);\n        if (srcChainId == block.chainid) revert InterchainApp__SameChainId(srcChainId);\n        if (!isAllowedSender(srcChainId, sender)) revert InterchainApp__SenderNotAllowed(srcChainId, sender);\n        _receiveMessage(srcChainId, sender, dbNonce, entryIndex, message);\n        // Note: application may elect to emit an event in `_receiveMessage`, so we don't emit a generic event here.\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainApp\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules) {\n        // Note: the getters for app config and modules could be overridden in the derived contracts.\n        appConfig = getAppConfigV1().encodeAppConfigV1();\n        modules = getReceivingModules();\n    }\n\n    /// @notice Returns the app config for receiving messages.\n    /// @dev Could be overridden in the derived contracts.\n    function getAppConfigV1() public view virtual returns (AppConfigV1 memory) {\n        return _appConfigV1;\n    }\n\n    /// @notice Returns the address of the Execution Service to use for sending messages.\n    /// @dev Could be overridden in the derived contracts.\n    function getExecutionService() public view virtual returns (address) {\n        return _executionService;\n    }\n\n    /// @notice Returns the linked app address (as bytes32) for the given chain ID.\n    /// @dev Could be overridden in the derived contracts.\n    function getLinkedApp(uint256 chainId) public view virtual returns (bytes32) {\n        return _linkedApp[chainId];\n    }\n\n    /// @notice Returns the list of modules used for sending messages.\n    /// @dev Could be overridden in the derived contracts.\n    function getSendingModules() public view virtual returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    /// @notice Returns the list of modules used for receiving messages.\n    /// @dev Could be overridden in the derived contracts.\n    function getReceivingModules() public view virtual returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    /// @notice Checks whether the sender is allowed to send messages to the current app.\n    /// @dev Could be overridden in the derived contracts.\n    function isAllowedSender(uint256 srcChainId, bytes32 sender) public view virtual returns (bool) {\n        return _linkedApp[srcChainId] == sender;\n    }\n\n    /// @notice Returns the current app version.\n    /// @dev Could be overridden in the derived contracts.\n    function getAppVersion() public pure virtual returns (uint256) {\n        return 1;\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Links the remote app to the current app.\n    /// Will revert if the chainId is the same as the chainId of the local app.\n    /// Note: Should be guarded with permissions check.\n    function _linkRemoteApp(uint256 chainId, bytes32 remoteApp) internal {\n        if (chainId == block.chainid) revert InterchainApp__SameChainId(chainId);\n        _linkedApp[chainId] = remoteApp;\n        emit AppLinked(chainId, remoteApp);\n    }\n\n    /// @dev Thin wrapper around _linkRemoteApp to accept EVM address as a parameter.\n    function _linkRemoteAppEVM(uint256 chainId, address remoteApp) internal {\n        _linkRemoteApp(chainId, TypeCasts.addressToBytes32(remoteApp));\n    }\n\n    /// @dev Adds the module to the trusted modules set.\n    /// Will revert if the module is already added.\n    /// Note: Should be guarded with permissions check.\n    function _addTrustedModule(address module) internal {\n        bool added = _trustedModules.add(module);\n        if (!added) revert InterchainApp__ModuleAlreadyAdded(module);\n        emit TrustedModuleAdded(module);\n    }\n\n    /// @dev Removes the module from the trusted modules set.\n    /// Will revert if the module is not added.\n    /// Note: Should be guarded with permissions check.\n    function _removeTrustedModule(address module) internal {\n        bool removed = _trustedModules.remove(module);\n        if (!removed) revert InterchainApp__ModuleNotAdded(module);\n        emit TrustedModuleRemoved(module);\n    }\n\n    /// @dev Sets the app config:\n    /// - requiredResponses: the number of module responses required for accepting the message\n    /// - optimisticPeriod: the minimum time after which the module responses are considered final\n    /// Note: Should be guarded with permissions check.\n    function _setAppConfigV1(AppConfigV1 memory appConfig) internal {\n        _appConfigV1 = appConfig;\n        emit AppConfigV1Set(appConfig.requiredResponses, appConfig.optimisticPeriod);\n    }\n\n    /// @dev Sets the execution service address.\n    /// Note: Should be guarded with permissions check.\n    function _setExecutionService(address executionService) internal {\n        _executionService = executionService;\n        emit ExecutionServiceSet(executionService);\n    }\n\n    /// @dev Sets the interchain client address.\n    /// Note: Should be guarded with permissions check.\n    function _setInterchainClient(address interchain_) internal {\n        interchain = interchain_;\n        emit InterchainClientSet(interchain_);\n    }\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to send the message to the linked app.\n    function _sendInterchainMessage(\n        uint256 dstChainId,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _sendInterchainMessage(dstChainId, getLinkedApp(dstChainId), messageFee, options, message);\n    }\n\n    /// @dev Thin wrapper around _sendInterchainMessage to accept EVM address as a parameter.\n    function _sendInterchainMessageEVM(\n        uint256 dstChainId,\n        address receiver,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _sendInterchainMessage(dstChainId, TypeCasts.addressToBytes32(receiver), messageFee, options, message);\n    }\n\n    /// @dev Performs necessary checks and sends an interchain message.\n    function _sendInterchainMessage(\n        uint256 dstChainId,\n        bytes32 receiver,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        address cachedInterchain = interchain;\n//        if (cachedInterchain == address(0)) revert InterchainApp__InterchainClientNotSet();\n//        if (dstChainId == block.chainid) revert InterchainApp__SameChainId(dstChainId);\n//        if (receiver == 0) revert InterchainApp__ReceiverNotSet(dstChainId);\n//        if (address(this).balance \u003c messageFee) revert InterchainApp__BalanceTooLow(address(this).balance, messageFee);\n        return IInterchainClientV1(cachedInterchain).interchainSend{value: messageFee}(\n            dstChainId, receiver, getExecutionService(), getSendingModules(), options.encodeOptionsV1(), message\n        );\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        virtual;\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee for sending an Interchain message.\n    function _getInterchainFee(\n        uint256 dstChainId,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        address cachedInterchain = interchain;\n        if (cachedInterchain == address(0)) revert InterchainApp__InterchainClientNotSet();\n        return IInterchainClientV1(cachedInterchain).getInterchainFee(\n            dstChainId, getExecutionService(), getSendingModules(), options.encodeOptionsV1(), message\n        );\n    }\n}\n\n// contracts/apps/OwnableApp.sol\n\nabstract contract OwnableApp is InterchainAppV1, Ownable {\n    constructor(address owner_) Ownable(owner_) {}\n\n    /// @notice Allows the owner to link the remote app for the given chain ID.\n    /// - This address will be used as the receiver for the messages sent from this chain.\n    /// - This address will be the only trusted sender for the messages sent to this chain.\n    function linkRemoteApp(uint256 chainId, bytes32 remoteApp) external onlyOwner {\n        _linkRemoteApp(chainId, remoteApp);\n    }\n\n    /// @notice This wrapper for `linkRemoteApp` to accept EVM address as a parameter.\n    function linkRemoteAppEVM(uint256 chainId, address remoteApp) external onlyOwner {\n        _linkRemoteAppEVM(chainId, remoteApp);\n    }\n\n    /// @notice Allows the owner to add the module to the trusted modules set.\n    /// - This set of modules will be used to verify message sent from this chain.\n    /// - This set of modules will be used to verify message sent to this chain.\n    function addTrustedModule(address module) external onlyOwner {\n        _addTrustedModule(module);\n    }\n\n    /// @notice Allows the owner to remove the module from the trusted modules set.\n    function removeTrustedModule(address module) external onlyOwner {\n        _removeTrustedModule(module);\n    }\n\n    /// @notice Allows the owner to set the app config for the current app. App config includes:\n    /// - requiredResponses: the number of module responses required for accepting the message\n    /// - optimisticPeriod: the minimum time after which the module responses are considered final\n    function setAppConfigV1(AppConfigV1 memory appConfig) external onlyOwner {\n        _setAppConfigV1(appConfig);\n    }\n\n    /// @notice Allows the owner to set the address of the Execution Service.\n    /// This address will be used to request execution of the messages sent from this chain,\n    /// by supplying the Service's execution fee.\n    function setExecutionService(address executionService) external onlyOwner {\n        _setExecutionService(executionService);\n    }\n\n    /// @notice Allows the owner to set the address of the InterchainClient contract.\n    function setInterchainClient(address interchain_) external onlyOwner {\n        _setInterchainClient(interchain_);\n    }\n}\n\n// contracts/apps/InterchainAppExample.sol\n\ncontract InterchainAppExample is OwnableApp {\n    event MessageReceived(uint256 srcChainId, bytes32 sender, uint256 dbNonce, uint64 entryIndex, bytes message);\n    event MessageSent(uint256 dstChainId, uint256 dbNonce, uint64 entryIndex, bytes32 transactionId);\n\n    constructor(address owner_) OwnableApp(owner_) {}\n\n    /// @notice Sends a basic message to the destination chain.\n    function sendMessage(uint256 dstChainId, uint256 gasLimit, bytes calldata message) external payable {\n        InterchainTxDescriptor memory desc = _sendInterchainMessage({\n            dstChainId: dstChainId,\n            messageFee: msg.value,\n            options: OptionsV1({gasLimit: gasLimit, gasAirdrop: 0}),\n            message: message\n        });\n        emit MessageSent(dstChainId, desc.dbNonce, desc.entryIndex, desc.transactionId);\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        override\n    {\n        emit MessageReceived(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"8343:11640:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;8343:11640:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"8343:11640:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"details":"Library for managing https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive types. Sets have the following properties: - Elements are added, removed, and checked for existence in constant time (O(1)). - Elements are enumerated in O(n). No guarantees are made on the ordering. ```solidity contract Example {     // Add the library methods     using EnumerableSet for EnumerableSet.AddressSet;     // Declare a set state variable     EnumerableSet.AddressSet private mySet; } ``` As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`) and `uint256` (`UintSet`) are supported. [WARNING] ==== Trying to delete such a structure from storage will likely result in data corruption, rendering the structure unusable. See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info. In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an array of EnumerableSet. ====","kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"details\":\"Library for managing https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive types. Sets have the following properties: - Elements are added, removed, and checked for existence in constant time (O(1)). - Elements are enumerated in O(n). No guarantees are made on the ordering. ```solidity contract Example {     // Add the library methods     using EnumerableSet for EnumerableSet.AddressSet;     // Declare a set state variable     EnumerableSet.AddressSet private mySet; } ``` As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`) and `uint256` (`UintSet`) are supported. [WARNING] ==== Trying to delete such a structure from storage will likely result in data corruption, rendering the structure unusable. See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info. In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an array of EnumerableSet. ====\",\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainAppExample.sol\":\"EnumerableSet\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainAppExample.sol\":{\"keccak256\":\"0x86f91eccd427db2c0e6cbbdb2244f577ed8111343e9ad8aa6476b8b0bd7cb65c\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://c9a5bce8ffbdc1808235baa92fe6b0fff964c26898bb155a1b06e5ea3e4f3940\",\"dweb:/ipfs/QmZqjYVRz4JL5Pjz9TZqVSy7PUZGsabLKsxtHXP44i3TVK\"]}},\"version\":1}"},"hashes":{}},"solidity/InterchainAppExample.sol:IInterchainApp":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainAppV1Events.sol\n\nabstract contract InterchainAppV1Events {\n    event AppConfigV1Set(uint256 requiredResponses, uint256 optimisticPeriod);\n    event AppLinked(uint256 indexed chainId, bytes32 indexed remoteApp);\n    event InterchainClientSet(address interchainClient);\n    event ExecutionServiceSet(address executionService);\n    event TrustedModuleAdded(address module);\n    event TrustedModuleRemoved(address module);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    function appReceive(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    uint8 constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint8 version);\n\n    /// @notice Encodes versioned app config into a bytes format.\n    /// @param version      The version of the app config.\n    /// @param appConfig    The app config to encode.\n    function encodeVersionedAppConfig(uint8 version, bytes memory appConfig) internal pure returns (bytes memory) {\n        return abi.encode(version, appConfig);\n    }\n\n    /// @notice Decodes versioned app config from a bytes format back into a version and app config.\n    /// @param data         The versioned app config data in bytes format.\n    /// @return version     The version of the app config.\n    /// @return appConfig   The app config as bytes.\n    function decodeVersionedAppConfig(bytes memory data)\n        internal\n        pure\n        returns (uint8 version, bytes memory appConfig)\n    {\n        (version, appConfig) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return encodeVersionedAppConfig(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal pure returns (AppConfigV1 memory) {\n        (uint8 version, bytes memory appConfig) = decodeVersionedAppConfig(data);\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(appConfig, (AppConfigV1));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    uint8 constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint8 version);\n\n    /// @notice Encodes versioned options into a bytes format.\n    /// @param version      The version of the options.\n    /// @param options      The options to encode.\n    function encodeVersionedOptions(uint8 version, bytes memory options) internal pure returns (bytes memory) {\n        return abi.encode(version, options);\n    }\n\n    /// @notice Decodes versioned options from a bytes format back into a version and options.\n    /// @param data         The versioned options data in bytes format.\n    /// @return version     The version of the options.\n    /// @return options     The options as bytes.\n    function decodeVersionedOptions(bytes memory data) internal pure returns (uint8 version, bytes memory options) {\n        (version, options) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return encodeVersionedOptions(OPTIONS_V1, abi.encode(options));\n    }\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal pure returns (OptionsV1 memory) {\n        (uint8 version, bytes memory options) = decodeVersionedOptions(data);\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(options, (OptionsV1));\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/libs/InterchainTransaction.sol\n\nstruct InterchainTransaction {\n    uint256 srcChainId;\n    bytes32 srcSender;\n    uint256 dstChainId;\n    bytes32 dstReceiver;\n    uint256 dbNonce;\n    uint64 entryIndex;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint256 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    function constructLocalTransaction(\n        address srcSender,\n        uint256 dstChainId,\n        bytes32 dstReceiver,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: block.chainid,\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(transaction);\n    }\n\n    function decodeTransaction(bytes memory encodedTx) internal pure returns (InterchainTransaction memory) {\n        return abi.decode(encodedTx, (InterchainTransaction));\n    }\n\n    function transactionId(InterchainTransaction memory transaction) internal pure returns (bytes32) {\n        return keccak256(abi.encode(transaction));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint256 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__NoLinkedClient(uint256 chainId);\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint256 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint256 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint256 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint256 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint256 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param message              The message being sent.\n    function getInterchainFee(\n        uint256 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint256 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint256 chainId) external view returns (address);\n}\n\n// contracts/apps/InterchainAppV1.sol\n\nabstract contract InterchainAppV1 is InterchainAppV1Events, IInterchainApp {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    // TODO: naming, visibility\n    address public interchain;\n\n    /// @dev Required responses and optimistic period for the module responses.\n    AppConfigV1 private _appConfigV1;\n    /// @dev Address of the linked app deployed on the remote chain.\n    mapping(uint256 chainId =\u003e bytes32 remoteApp) private _linkedApp;\n    /// @dev Trusted Interchain modules.\n    EnumerableSet.AddressSet private _trustedModules;\n    /// @dev Execution Service to use for sending messages.\n    address private _executionService;\n\n    error InterchainApp__BalanceTooLow(uint256 actual, uint256 expected);\n    error InterchainApp__CallerNotInterchainClient(address caller);\n    error InterchainApp__InterchainClientNotSet();\n    error InterchainApp__ModuleAlreadyAdded(address module);\n    error InterchainApp__ModuleNotAdded(address module);\n    error InterchainApp__ReceiverNotSet(uint256 chainId);\n    error InterchainApp__SameChainId(uint256 chainId);\n    error InterchainApp__SenderNotAllowed(uint256 srcChainId, bytes32 sender);\n\n    /// @inheritdoc IInterchainApp\n    function appReceive(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        if (msg.sender != interchain) revert InterchainApp__CallerNotInterchainClient(msg.sender);\n        if (srcChainId == block.chainid) revert InterchainApp__SameChainId(srcChainId);\n        if (!isAllowedSender(srcChainId, sender)) revert InterchainApp__SenderNotAllowed(srcChainId, sender);\n        _receiveMessage(srcChainId, sender, dbNonce, entryIndex, message);\n        // Note: application may elect to emit an event in `_receiveMessage`, so we don't emit a generic event here.\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainApp\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules) {\n        // Note: the getters for app config and modules could be overridden in the derived contracts.\n        appConfig = getAppConfigV1().encodeAppConfigV1();\n        modules = getReceivingModules();\n    }\n\n    /// @notice Returns the app config for receiving messages.\n    /// @dev Could be overridden in the derived contracts.\n    function getAppConfigV1() public view virtual returns (AppConfigV1 memory) {\n        return _appConfigV1;\n    }\n\n    /// @notice Returns the address of the Execution Service to use for sending messages.\n    /// @dev Could be overridden in the derived contracts.\n    function getExecutionService() public view virtual returns (address) {\n        return _executionService;\n    }\n\n    /// @notice Returns the linked app address (as bytes32) for the given chain ID.\n    /// @dev Could be overridden in the derived contracts.\n    function getLinkedApp(uint256 chainId) public view virtual returns (bytes32) {\n        return _linkedApp[chainId];\n    }\n\n    /// @notice Returns the list of modules used for sending messages.\n    /// @dev Could be overridden in the derived contracts.\n    function getSendingModules() public view virtual returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    /// @notice Returns the list of modules used for receiving messages.\n    /// @dev Could be overridden in the derived contracts.\n    function getReceivingModules() public view virtual returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    /// @notice Checks whether the sender is allowed to send messages to the current app.\n    /// @dev Could be overridden in the derived contracts.\n    function isAllowedSender(uint256 srcChainId, bytes32 sender) public view virtual returns (bool) {\n        return _linkedApp[srcChainId] == sender;\n    }\n\n    /// @notice Returns the current app version.\n    /// @dev Could be overridden in the derived contracts.\n    function getAppVersion() public pure virtual returns (uint256) {\n        return 1;\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Links the remote app to the current app.\n    /// Will revert if the chainId is the same as the chainId of the local app.\n    /// Note: Should be guarded with permissions check.\n    function _linkRemoteApp(uint256 chainId, bytes32 remoteApp) internal {\n        if (chainId == block.chainid) revert InterchainApp__SameChainId(chainId);\n        _linkedApp[chainId] = remoteApp;\n        emit AppLinked(chainId, remoteApp);\n    }\n\n    /// @dev Thin wrapper around _linkRemoteApp to accept EVM address as a parameter.\n    function _linkRemoteAppEVM(uint256 chainId, address remoteApp) internal {\n        _linkRemoteApp(chainId, TypeCasts.addressToBytes32(remoteApp));\n    }\n\n    /// @dev Adds the module to the trusted modules set.\n    /// Will revert if the module is already added.\n    /// Note: Should be guarded with permissions check.\n    function _addTrustedModule(address module) internal {\n        bool added = _trustedModules.add(module);\n        if (!added) revert InterchainApp__ModuleAlreadyAdded(module);\n        emit TrustedModuleAdded(module);\n    }\n\n    /// @dev Removes the module from the trusted modules set.\n    /// Will revert if the module is not added.\n    /// Note: Should be guarded with permissions check.\n    function _removeTrustedModule(address module) internal {\n        bool removed = _trustedModules.remove(module);\n        if (!removed) revert InterchainApp__ModuleNotAdded(module);\n        emit TrustedModuleRemoved(module);\n    }\n\n    /// @dev Sets the app config:\n    /// - requiredResponses: the number of module responses required for accepting the message\n    /// - optimisticPeriod: the minimum time after which the module responses are considered final\n    /// Note: Should be guarded with permissions check.\n    function _setAppConfigV1(AppConfigV1 memory appConfig) internal {\n        _appConfigV1 = appConfig;\n        emit AppConfigV1Set(appConfig.requiredResponses, appConfig.optimisticPeriod);\n    }\n\n    /// @dev Sets the execution service address.\n    /// Note: Should be guarded with permissions check.\n    function _setExecutionService(address executionService) internal {\n        _executionService = executionService;\n        emit ExecutionServiceSet(executionService);\n    }\n\n    /// @dev Sets the interchain client address.\n    /// Note: Should be guarded with permissions check.\n    function _setInterchainClient(address interchain_) internal {\n        interchain = interchain_;\n        emit InterchainClientSet(interchain_);\n    }\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to send the message to the linked app.\n    function _sendInterchainMessage(\n        uint256 dstChainId,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _sendInterchainMessage(dstChainId, getLinkedApp(dstChainId), messageFee, options, message);\n    }\n\n    /// @dev Thin wrapper around _sendInterchainMessage to accept EVM address as a parameter.\n    function _sendInterchainMessageEVM(\n        uint256 dstChainId,\n        address receiver,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _sendInterchainMessage(dstChainId, TypeCasts.addressToBytes32(receiver), messageFee, options, message);\n    }\n\n    /// @dev Performs necessary checks and sends an interchain message.\n    function _sendInterchainMessage(\n        uint256 dstChainId,\n        bytes32 receiver,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        address cachedInterchain = interchain;\n//        if (cachedInterchain == address(0)) revert InterchainApp__InterchainClientNotSet();\n//        if (dstChainId == block.chainid) revert InterchainApp__SameChainId(dstChainId);\n//        if (receiver == 0) revert InterchainApp__ReceiverNotSet(dstChainId);\n//        if (address(this).balance \u003c messageFee) revert InterchainApp__BalanceTooLow(address(this).balance, messageFee);\n        return IInterchainClientV1(cachedInterchain).interchainSend{value: messageFee}(\n            dstChainId, receiver, getExecutionService(), getSendingModules(), options.encodeOptionsV1(), message\n        );\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        virtual;\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee for sending an Interchain message.\n    function _getInterchainFee(\n        uint256 dstChainId,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        address cachedInterchain = interchain;\n        if (cachedInterchain == address(0)) revert InterchainApp__InterchainClientNotSet();\n        return IInterchainClientV1(cachedInterchain).getInterchainFee(\n            dstChainId, getExecutionService(), getSendingModules(), options.encodeOptionsV1(), message\n        );\n    }\n}\n\n// contracts/apps/OwnableApp.sol\n\nabstract contract OwnableApp is InterchainAppV1, Ownable {\n    constructor(address owner_) Ownable(owner_) {}\n\n    /// @notice Allows the owner to link the remote app for the given chain ID.\n    /// - This address will be used as the receiver for the messages sent from this chain.\n    /// - This address will be the only trusted sender for the messages sent to this chain.\n    function linkRemoteApp(uint256 chainId, bytes32 remoteApp) external onlyOwner {\n        _linkRemoteApp(chainId, remoteApp);\n    }\n\n    /// @notice This wrapper for `linkRemoteApp` to accept EVM address as a parameter.\n    function linkRemoteAppEVM(uint256 chainId, address remoteApp) external onlyOwner {\n        _linkRemoteAppEVM(chainId, remoteApp);\n    }\n\n    /// @notice Allows the owner to add the module to the trusted modules set.\n    /// - This set of modules will be used to verify message sent from this chain.\n    /// - This set of modules will be used to verify message sent to this chain.\n    function addTrustedModule(address module) external onlyOwner {\n        _addTrustedModule(module);\n    }\n\n    /// @notice Allows the owner to remove the module from the trusted modules set.\n    function removeTrustedModule(address module) external onlyOwner {\n        _removeTrustedModule(module);\n    }\n\n    /// @notice Allows the owner to set the app config for the current app. App config includes:\n    /// - requiredResponses: the number of module responses required for accepting the message\n    /// - optimisticPeriod: the minimum time after which the module responses are considered final\n    function setAppConfigV1(AppConfigV1 memory appConfig) external onlyOwner {\n        _setAppConfigV1(appConfig);\n    }\n\n    /// @notice Allows the owner to set the address of the Execution Service.\n    /// This address will be used to request execution of the messages sent from this chain,\n    /// by supplying the Service's execution fee.\n    function setExecutionService(address executionService) external onlyOwner {\n        _setExecutionService(executionService);\n    }\n\n    /// @notice Allows the owner to set the address of the InterchainClient contract.\n    function setInterchainClient(address interchain_) external onlyOwner {\n        _setInterchainClient(interchain_);\n    }\n}\n\n// contracts/apps/InterchainAppExample.sol\n\ncontract InterchainAppExample is OwnableApp {\n    event MessageReceived(uint256 srcChainId, bytes32 sender, uint256 dbNonce, uint64 entryIndex, bytes message);\n    event MessageSent(uint256 dstChainId, uint256 dbNonce, uint64 entryIndex, bytes32 transactionId);\n\n    constructor(address owner_) OwnableApp(owner_) {}\n\n    /// @notice Sends a basic message to the destination chain.\n    function sendMessage(uint256 dstChainId, uint256 gasLimit, bytes calldata message) external payable {\n        InterchainTxDescriptor memory desc = _sendInterchainMessage({\n            dstChainId: dstChainId,\n            messageFee: msg.value,\n            options: OptionsV1({gasLimit: gasLimit, gasAirdrop: 0}),\n            message: message\n        });\n        emit MessageSent(dstChainId, desc.dbNonce, desc.entryIndex, desc.transactionId);\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        override\n    {\n        emit MessageReceived(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"bytes32","name":"sender","type":"bytes32"},{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"uint64","name":"entryIndex","type":"uint64"},{"internalType":"bytes","name":"message","type":"bytes"}],"name":"appReceive","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"getReceivingConfig","outputs":[{"internalType":"bytes","name":"appConfig","type":"bytes"},{"internalType":"address[]","name":"modules","type":"address[]"}],"stateMutability":"view","type":"function"}],"userDoc":{"kind":"user","methods":{},"notice":"Minimal interface for the Interchain App to work with the Interchain Client.","version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"appReceive\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReceivingConfig\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"appConfig\",\"type\":\"bytes\"},{\"internalType\":\"address[]\",\"name\":\"modules\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"Minimal interface for the Interchain App to work with the Interchain Client.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainAppExample.sol\":\"IInterchainApp\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainAppExample.sol\":{\"keccak256\":\"0x86f91eccd427db2c0e6cbbdb2244f577ed8111343e9ad8aa6476b8b0bd7cb65c\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://c9a5bce8ffbdc1808235baa92fe6b0fff964c26898bb155a1b06e5ea3e4f3940\",\"dweb:/ipfs/QmZqjYVRz4JL5Pjz9TZqVSy7PUZGsabLKsxtHXP44i3TVK\"]}},\"version\":1}"},"hashes":{"appReceive(uint256,bytes32,uint256,uint64,bytes)":"68a69847","getReceivingConfig()":"287bc057"}},"solidity/InterchainAppExample.sol:IInterchainClientV1":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainAppV1Events.sol\n\nabstract contract InterchainAppV1Events {\n    event AppConfigV1Set(uint256 requiredResponses, uint256 optimisticPeriod);\n    event AppLinked(uint256 indexed chainId, bytes32 indexed remoteApp);\n    event InterchainClientSet(address interchainClient);\n    event ExecutionServiceSet(address executionService);\n    event TrustedModuleAdded(address module);\n    event TrustedModuleRemoved(address module);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    function appReceive(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    uint8 constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint8 version);\n\n    /// @notice Encodes versioned app config into a bytes format.\n    /// @param version      The version of the app config.\n    /// @param appConfig    The app config to encode.\n    function encodeVersionedAppConfig(uint8 version, bytes memory appConfig) internal pure returns (bytes memory) {\n        return abi.encode(version, appConfig);\n    }\n\n    /// @notice Decodes versioned app config from a bytes format back into a version and app config.\n    /// @param data         The versioned app config data in bytes format.\n    /// @return version     The version of the app config.\n    /// @return appConfig   The app config as bytes.\n    function decodeVersionedAppConfig(bytes memory data)\n        internal\n        pure\n        returns (uint8 version, bytes memory appConfig)\n    {\n        (version, appConfig) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return encodeVersionedAppConfig(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal pure returns (AppConfigV1 memory) {\n        (uint8 version, bytes memory appConfig) = decodeVersionedAppConfig(data);\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(appConfig, (AppConfigV1));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    uint8 constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint8 version);\n\n    /// @notice Encodes versioned options into a bytes format.\n    /// @param version      The version of the options.\n    /// @param options      The options to encode.\n    function encodeVersionedOptions(uint8 version, bytes memory options) internal pure returns (bytes memory) {\n        return abi.encode(version, options);\n    }\n\n    /// @notice Decodes versioned options from a bytes format back into a version and options.\n    /// @param data         The versioned options data in bytes format.\n    /// @return version     The version of the options.\n    /// @return options     The options as bytes.\n    function decodeVersionedOptions(bytes memory data) internal pure returns (uint8 version, bytes memory options) {\n        (version, options) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return encodeVersionedOptions(OPTIONS_V1, abi.encode(options));\n    }\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal pure returns (OptionsV1 memory) {\n        (uint8 version, bytes memory options) = decodeVersionedOptions(data);\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(options, (OptionsV1));\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/libs/InterchainTransaction.sol\n\nstruct InterchainTransaction {\n    uint256 srcChainId;\n    bytes32 srcSender;\n    uint256 dstChainId;\n    bytes32 dstReceiver;\n    uint256 dbNonce;\n    uint64 entryIndex;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint256 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    function constructLocalTransaction(\n        address srcSender,\n        uint256 dstChainId,\n        bytes32 dstReceiver,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: block.chainid,\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(transaction);\n    }\n\n    function decodeTransaction(bytes memory encodedTx) internal pure returns (InterchainTransaction memory) {\n        return abi.decode(encodedTx, (InterchainTransaction));\n    }\n\n    function transactionId(InterchainTransaction memory transaction) internal pure returns (bytes32) {\n        return keccak256(abi.encode(transaction));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint256 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__NoLinkedClient(uint256 chainId);\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint256 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint256 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint256 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint256 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint256 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param message              The message being sent.\n    function getInterchainFee(\n        uint256 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint256 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint256 chainId) external view returns (address);\n}\n\n// contracts/apps/InterchainAppV1.sol\n\nabstract contract InterchainAppV1 is InterchainAppV1Events, IInterchainApp {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    // TODO: naming, visibility\n    address public interchain;\n\n    /// @dev Required responses and optimistic period for the module responses.\n    AppConfigV1 private _appConfigV1;\n    /// @dev Address of the linked app deployed on the remote chain.\n    mapping(uint256 chainId =\u003e bytes32 remoteApp) private _linkedApp;\n    /// @dev Trusted Interchain modules.\n    EnumerableSet.AddressSet private _trustedModules;\n    /// @dev Execution Service to use for sending messages.\n    address private _executionService;\n\n    error InterchainApp__BalanceTooLow(uint256 actual, uint256 expected);\n    error InterchainApp__CallerNotInterchainClient(address caller);\n    error InterchainApp__InterchainClientNotSet();\n    error InterchainApp__ModuleAlreadyAdded(address module);\n    error InterchainApp__ModuleNotAdded(address module);\n    error InterchainApp__ReceiverNotSet(uint256 chainId);\n    error InterchainApp__SameChainId(uint256 chainId);\n    error InterchainApp__SenderNotAllowed(uint256 srcChainId, bytes32 sender);\n\n    /// @inheritdoc IInterchainApp\n    function appReceive(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        if (msg.sender != interchain) revert InterchainApp__CallerNotInterchainClient(msg.sender);\n        if (srcChainId == block.chainid) revert InterchainApp__SameChainId(srcChainId);\n        if (!isAllowedSender(srcChainId, sender)) revert InterchainApp__SenderNotAllowed(srcChainId, sender);\n        _receiveMessage(srcChainId, sender, dbNonce, entryIndex, message);\n        // Note: application may elect to emit an event in `_receiveMessage`, so we don't emit a generic event here.\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainApp\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules) {\n        // Note: the getters for app config and modules could be overridden in the derived contracts.\n        appConfig = getAppConfigV1().encodeAppConfigV1();\n        modules = getReceivingModules();\n    }\n\n    /// @notice Returns the app config for receiving messages.\n    /// @dev Could be overridden in the derived contracts.\n    function getAppConfigV1() public view virtual returns (AppConfigV1 memory) {\n        return _appConfigV1;\n    }\n\n    /// @notice Returns the address of the Execution Service to use for sending messages.\n    /// @dev Could be overridden in the derived contracts.\n    function getExecutionService() public view virtual returns (address) {\n        return _executionService;\n    }\n\n    /// @notice Returns the linked app address (as bytes32) for the given chain ID.\n    /// @dev Could be overridden in the derived contracts.\n    function getLinkedApp(uint256 chainId) public view virtual returns (bytes32) {\n        return _linkedApp[chainId];\n    }\n\n    /// @notice Returns the list of modules used for sending messages.\n    /// @dev Could be overridden in the derived contracts.\n    function getSendingModules() public view virtual returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    /// @notice Returns the list of modules used for receiving messages.\n    /// @dev Could be overridden in the derived contracts.\n    function getReceivingModules() public view virtual returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    /// @notice Checks whether the sender is allowed to send messages to the current app.\n    /// @dev Could be overridden in the derived contracts.\n    function isAllowedSender(uint256 srcChainId, bytes32 sender) public view virtual returns (bool) {\n        return _linkedApp[srcChainId] == sender;\n    }\n\n    /// @notice Returns the current app version.\n    /// @dev Could be overridden in the derived contracts.\n    function getAppVersion() public pure virtual returns (uint256) {\n        return 1;\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Links the remote app to the current app.\n    /// Will revert if the chainId is the same as the chainId of the local app.\n    /// Note: Should be guarded with permissions check.\n    function _linkRemoteApp(uint256 chainId, bytes32 remoteApp) internal {\n        if (chainId == block.chainid) revert InterchainApp__SameChainId(chainId);\n        _linkedApp[chainId] = remoteApp;\n        emit AppLinked(chainId, remoteApp);\n    }\n\n    /// @dev Thin wrapper around _linkRemoteApp to accept EVM address as a parameter.\n    function _linkRemoteAppEVM(uint256 chainId, address remoteApp) internal {\n        _linkRemoteApp(chainId, TypeCasts.addressToBytes32(remoteApp));\n    }\n\n    /// @dev Adds the module to the trusted modules set.\n    /// Will revert if the module is already added.\n    /// Note: Should be guarded with permissions check.\n    function _addTrustedModule(address module) internal {\n        bool added = _trustedModules.add(module);\n        if (!added) revert InterchainApp__ModuleAlreadyAdded(module);\n        emit TrustedModuleAdded(module);\n    }\n\n    /// @dev Removes the module from the trusted modules set.\n    /// Will revert if the module is not added.\n    /// Note: Should be guarded with permissions check.\n    function _removeTrustedModule(address module) internal {\n        bool removed = _trustedModules.remove(module);\n        if (!removed) revert InterchainApp__ModuleNotAdded(module);\n        emit TrustedModuleRemoved(module);\n    }\n\n    /// @dev Sets the app config:\n    /// - requiredResponses: the number of module responses required for accepting the message\n    /// - optimisticPeriod: the minimum time after which the module responses are considered final\n    /// Note: Should be guarded with permissions check.\n    function _setAppConfigV1(AppConfigV1 memory appConfig) internal {\n        _appConfigV1 = appConfig;\n        emit AppConfigV1Set(appConfig.requiredResponses, appConfig.optimisticPeriod);\n    }\n\n    /// @dev Sets the execution service address.\n    /// Note: Should be guarded with permissions check.\n    function _setExecutionService(address executionService) internal {\n        _executionService = executionService;\n        emit ExecutionServiceSet(executionService);\n    }\n\n    /// @dev Sets the interchain client address.\n    /// Note: Should be guarded with permissions check.\n    function _setInterchainClient(address interchain_) internal {\n        interchain = interchain_;\n        emit InterchainClientSet(interchain_);\n    }\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to send the message to the linked app.\n    function _sendInterchainMessage(\n        uint256 dstChainId,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _sendInterchainMessage(dstChainId, getLinkedApp(dstChainId), messageFee, options, message);\n    }\n\n    /// @dev Thin wrapper around _sendInterchainMessage to accept EVM address as a parameter.\n    function _sendInterchainMessageEVM(\n        uint256 dstChainId,\n        address receiver,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _sendInterchainMessage(dstChainId, TypeCasts.addressToBytes32(receiver), messageFee, options, message);\n    }\n\n    /// @dev Performs necessary checks and sends an interchain message.\n    function _sendInterchainMessage(\n        uint256 dstChainId,\n        bytes32 receiver,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        address cachedInterchain = interchain;\n//        if (cachedInterchain == address(0)) revert InterchainApp__InterchainClientNotSet();\n//        if (dstChainId == block.chainid) revert InterchainApp__SameChainId(dstChainId);\n//        if (receiver == 0) revert InterchainApp__ReceiverNotSet(dstChainId);\n//        if (address(this).balance \u003c messageFee) revert InterchainApp__BalanceTooLow(address(this).balance, messageFee);\n        return IInterchainClientV1(cachedInterchain).interchainSend{value: messageFee}(\n            dstChainId, receiver, getExecutionService(), getSendingModules(), options.encodeOptionsV1(), message\n        );\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        virtual;\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee for sending an Interchain message.\n    function _getInterchainFee(\n        uint256 dstChainId,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        address cachedInterchain = interchain;\n        if (cachedInterchain == address(0)) revert InterchainApp__InterchainClientNotSet();\n        return IInterchainClientV1(cachedInterchain).getInterchainFee(\n            dstChainId, getExecutionService(), getSendingModules(), options.encodeOptionsV1(), message\n        );\n    }\n}\n\n// contracts/apps/OwnableApp.sol\n\nabstract contract OwnableApp is InterchainAppV1, Ownable {\n    constructor(address owner_) Ownable(owner_) {}\n\n    /// @notice Allows the owner to link the remote app for the given chain ID.\n    /// - This address will be used as the receiver for the messages sent from this chain.\n    /// - This address will be the only trusted sender for the messages sent to this chain.\n    function linkRemoteApp(uint256 chainId, bytes32 remoteApp) external onlyOwner {\n        _linkRemoteApp(chainId, remoteApp);\n    }\n\n    /// @notice This wrapper for `linkRemoteApp` to accept EVM address as a parameter.\n    function linkRemoteAppEVM(uint256 chainId, address remoteApp) external onlyOwner {\n        _linkRemoteAppEVM(chainId, remoteApp);\n    }\n\n    /// @notice Allows the owner to add the module to the trusted modules set.\n    /// - This set of modules will be used to verify message sent from this chain.\n    /// - This set of modules will be used to verify message sent to this chain.\n    function addTrustedModule(address module) external onlyOwner {\n        _addTrustedModule(module);\n    }\n\n    /// @notice Allows the owner to remove the module from the trusted modules set.\n    function removeTrustedModule(address module) external onlyOwner {\n        _removeTrustedModule(module);\n    }\n\n    /// @notice Allows the owner to set the app config for the current app. App config includes:\n    /// - requiredResponses: the number of module responses required for accepting the message\n    /// - optimisticPeriod: the minimum time after which the module responses are considered final\n    function setAppConfigV1(AppConfigV1 memory appConfig) external onlyOwner {\n        _setAppConfigV1(appConfig);\n    }\n\n    /// @notice Allows the owner to set the address of the Execution Service.\n    /// This address will be used to request execution of the messages sent from this chain,\n    /// by supplying the Service's execution fee.\n    function setExecutionService(address executionService) external onlyOwner {\n        _setExecutionService(executionService);\n    }\n\n    /// @notice Allows the owner to set the address of the InterchainClient contract.\n    function setInterchainClient(address interchain_) external onlyOwner {\n        _setInterchainClient(interchain_);\n    }\n}\n\n// contracts/apps/InterchainAppExample.sol\n\ncontract InterchainAppExample is OwnableApp {\n    event MessageReceived(uint256 srcChainId, bytes32 sender, uint256 dbNonce, uint64 entryIndex, bytes message);\n    event MessageSent(uint256 dstChainId, uint256 dbNonce, uint64 entryIndex, bytes32 transactionId);\n\n    constructor(address owner_) OwnableApp(owner_) {}\n\n    /// @notice Sends a basic message to the destination chain.\n    function sendMessage(uint256 dstChainId, uint256 gasLimit, bytes calldata message) external payable {\n        InterchainTxDescriptor memory desc = _sendInterchainMessage({\n            dstChainId: dstChainId,\n            messageFee: msg.value,\n            options: OptionsV1({gasLimit: gasLimit, gasAirdrop: 0}),\n            message: message\n        });\n        emit MessageSent(dstChainId, desc.dbNonce, desc.entryIndex, desc.transactionId);\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        override\n    {\n        emit MessageReceived(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"uint256","name":"actual","type":"uint256"},{"internalType":"uint256","name":"required","type":"uint256"}],"name":"InterchainClientV1__FeeAmountTooLow","type":"error"},{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"}],"name":"InterchainClientV1__IncorrectDstChainId","type":"error"},{"inputs":[{"internalType":"uint256","name":"actual","type":"uint256"},{"internalType":"uint256","name":"required","type":"uint256"}],"name":"InterchainClientV1__IncorrectMsgValue","type":"error"},{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"}],"name":"InterchainClientV1__NoLinkedClient","type":"error"},{"inputs":[{"internalType":"bytes32","name":"client","type":"bytes32"}],"name":"InterchainClientV1__NotEVMClient","type":"error"},{"inputs":[{"internalType":"uint256","name":"actual","type":"uint256"},{"internalType":"uint256","name":"required","type":"uint256"}],"name":"InterchainClientV1__NotEnoughResponses","type":"error"},{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"}],"name":"InterchainClientV1__NotRemoteChainId","type":"error"},{"inputs":[{"internalType":"bytes32","name":"transactionId","type":"bytes32"}],"name":"InterchainClientV1__TxAlreadyExecuted","type":"error"},{"inputs":[{"internalType":"bytes32","name":"transactionId","type":"bytes32"}],"name":"InterchainClientV1__TxNotExecuted","type":"error"},{"inputs":[],"name":"InterchainClientV1__ZeroReceiver","type":"error"},{"inputs":[],"name":"InterchainClientV1__ZeroRequiredResponses","type":"error"},{"inputs":[{"internalType":"bytes","name":"transaction","type":"bytes"}],"name":"getExecutor","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"transactionId","type":"bytes32"}],"name":"getExecutorById","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"dstChainId","type":"uint256"},{"internalType":"address","name":"srcExecutionService","type":"address"},{"internalType":"address[]","name":"srcModules","type":"address[]"},{"internalType":"bytes","name":"options","type":"bytes"},{"internalType":"bytes","name":"message","type":"bytes"}],"name":"getInterchainFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"}],"name":"getLinkedClient","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"}],"name":"getLinkedClientEVM","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"gasLimit","type":"uint256"},{"internalType":"bytes","name":"transaction","type":"bytes"},{"internalType":"bytes32[]","name":"proof","type":"bytes32[]"}],"name":"interchainExecute","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint256","name":"dstChainId","type":"uint256"},{"internalType":"bytes32","name":"receiver","type":"bytes32"},{"internalType":"address","name":"srcExecutionService","type":"address"},{"internalType":"address[]","name":"srcModules","type":"address[]"},{"internalType":"bytes","name":"options","type":"bytes"},{"internalType":"bytes","name":"message","type":"bytes"}],"name":"interchainSend","outputs":[{"components":[{"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"uint64","name":"entryIndex","type":"uint64"}],"internalType":"struct InterchainTxDescriptor","name":"desc","type":"tuple"}],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint256","name":"dstChainId","type":"uint256"},{"internalType":"address","name":"receiver","type":"address"},{"internalType":"address","name":"srcExecutionService","type":"address"},{"internalType":"address[]","name":"srcModules","type":"address[]"},{"internalType":"bytes","name":"options","type":"bytes"},{"internalType":"bytes","name":"message","type":"bytes"}],"name":"interchainSendEVM","outputs":[{"components":[{"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"uint64","name":"entryIndex","type":"uint64"}],"internalType":"struct InterchainTxDescriptor","name":"desc","type":"tuple"}],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"bytes","name":"transaction","type":"bytes"},{"internalType":"bytes32[]","name":"proof","type":"bytes32[]"}],"name":"isExecutable","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"executionFees_","type":"address"}],"name":"setExecutionFees","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"},{"internalType":"bytes32","name":"client","type":"bytes32"}],"name":"setLinkedClient","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"transactionId","type":"bytes32"}],"name":"writeExecutionProof","outputs":[{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"uint64","name":"entryIndex","type":"uint64"}],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{"getExecutor(bytes)":{"notice":"Returns the address of the executor for a transaction that has been sent to the local chain."},"getExecutorById(bytes32)":{"notice":"Returns the address of the executor for a transaction that has been sent to the local chain."},"getInterchainFee(uint256,address,address[],bytes,bytes)":{"notice":"Returns the fee for sending an Interchain message."},"getLinkedClient(uint256)":{"notice":"Returns the address of the linked client (as bytes32) for a specific chain ID."},"getLinkedClientEVM(uint256)":{"notice":"Returns the EVM address of the linked client for a specific chain ID."},"interchainExecute(uint256,bytes,bytes32[])":{"notice":"Executes a transaction that has been sent via the Interchain."},"interchainSend(uint256,bytes32,address,address[],bytes,bytes)":{"notice":"Sends a message to another chain via the Interchain Communication Protocol."},"isExecutable(bytes,bytes32[])":{"notice":"Checks if a transaction is executable."},"setExecutionFees(address)":{"notice":"Sets the address of the ExecutionFees contract."},"setLinkedClient(uint256,bytes32)":{"notice":"Sets the linked client for a specific chain ID."},"writeExecutionProof(bytes32)":{"notice":"Writes the proof of execution for a transaction into the InterchainDB."}},"version":1},"developerDoc":{"kind":"dev","methods":{"getInterchainFee(uint256,address,address[],bytes,bytes)":{"params":{"dstChainId":"The chain ID of the destination chain.","message":"The message being sent.","options":"Execution options for the message sent, currently gas limit + native gas drop.","srcExecutionService":"The address of the execution service to use for the message.","srcModules":"The source modules involved in the message sending."}},"getLinkedClient(uint256)":{"details":"Will return 0x0 if no client is linked for the chain ID."},"getLinkedClientEVM(uint256)":{"details":"Will return 0x0 if no client is linked for the chain ID. Will revert if the client is not an EVM client."},"interchainExecute(uint256,bytes,bytes32[])":{"details":"The transaction must have been previously sent and recorded. Transaction data includes the requested gas limit, but the executors could specify a different gas limit. If the specified gas limit is lower than requested, the requested gas limit will be used. Otherwise, the specified gas limit will be used. This allows to execute the transactions with requested gas limit set too low.","params":{"gasLimit":"The gas limit to use for the execution.","proof":"The Merkle proof for transaction execution, fetched from the source chain.","transaction":"The transaction data."}},"interchainSend(uint256,bytes32,address,address[],bytes,bytes)":{"details":"Charges a fee for the message, which is payable upon calling this function: - Verification fees: paid to every module that verifies the message. - Execution fee: paid to the executor that executes the message. Note: while a specific execution service is specified to request the execution of the message, any executor is able to execute the message on destination chain, earning the execution fee.","params":{"dstChainId":"The chain ID of the destination chain.","message":"The message being sent.","options":"Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.","receiver":"The address of the receiver on the destination chain.","srcExecutionService":"The address of the execution service to use for the message.","srcModules":"The source modules involved in the message sending."},"returns":{"desc":"The descriptor of the sent transaction: - transactionId: the ID of the transaction that was sent. - dbNonce: the database nonce of the batch containing the written entry for transaction. - entryIndex: the index of the written entry for transaction within the batch."}},"isExecutable(bytes,bytes32[])":{"details":"Determines if a transaction meets the criteria to be executed based on: - If approved modules have written to the InterchainDB - If the threshold of approved modules have been met - If the optimistic window has passed for all modules","params":{"proof":"The Merkle proof for transaction execution, fetched from the source chain.","transaction":"The InterchainTransaction struct to be checked."},"returns":{"_0":"bool Returns true if the transaction is executable, false otherwise."}},"setExecutionFees(address)":{"details":"Only callable by the contract owner or an authorized account.","params":{"executionFees_":"The address of the ExecutionFees contract."}},"setLinkedClient(uint256,bytes32)":{"details":"Stores the address of the linked client in a mapping with the chain ID as the key.","params":{"chainId":"The chain ID for which the client is being set.","client":"The address of the client being linked."}},"writeExecutionProof(bytes32)":{"details":"Will revert if the transaction has not been executed.","params":{"transactionId":"The ID of the transaction to write the proof for."},"returns":{"dbNonce":"        The database nonce of the batch containing the written proof for transaction.","entryIndex":"     The index of the written proof for transaction within the batch."}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"required\",\"type\":\"uint256\"}],\"name\":\"InterchainClientV1__FeeAmountTooLow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"InterchainClientV1__IncorrectDstChainId\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"required\",\"type\":\"uint256\"}],\"name\":\"InterchainClientV1__IncorrectMsgValue\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"InterchainClientV1__NoLinkedClient\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"client\",\"type\":\"bytes32\"}],\"name\":\"InterchainClientV1__NotEVMClient\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"required\",\"type\":\"uint256\"}],\"name\":\"InterchainClientV1__NotEnoughResponses\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"InterchainClientV1__NotRemoteChainId\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"}],\"name\":\"InterchainClientV1__TxAlreadyExecuted\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"}],\"name\":\"InterchainClientV1__TxNotExecuted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InterchainClientV1__ZeroReceiver\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InterchainClientV1__ZeroRequiredResponses\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"transaction\",\"type\":\"bytes\"}],\"name\":\"getExecutor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"}],\"name\":\"getExecutorById\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dstChainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"srcExecutionService\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"},{\"internalType\":\"bytes\",\"name\":\"options\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"getInterchainFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"getLinkedClient\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"getLinkedClientEVM\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"transaction\",\"type\":\"bytes\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"interchainExecute\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dstChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"receiver\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"srcExecutionService\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"},{\"internalType\":\"bytes\",\"name\":\"options\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"interchainSend\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"}],\"internalType\":\"struct InterchainTxDescriptor\",\"name\":\"desc\",\"type\":\"tuple\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dstChainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"srcExecutionService\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"},{\"internalType\":\"bytes\",\"name\":\"options\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"interchainSendEVM\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"}],\"internalType\":\"struct InterchainTxDescriptor\",\"name\":\"desc\",\"type\":\"tuple\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"transaction\",\"type\":\"bytes\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"isExecutable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"executionFees_\",\"type\":\"address\"}],\"name\":\"setExecutionFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"client\",\"type\":\"bytes32\"}],\"name\":\"setLinkedClient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"}],\"name\":\"writeExecutionProof\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"getInterchainFee(uint256,address,address[],bytes,bytes)\":{\"params\":{\"dstChainId\":\"The chain ID of the destination chain.\",\"message\":\"The message being sent.\",\"options\":\"Execution options for the message sent, currently gas limit + native gas drop.\",\"srcExecutionService\":\"The address of the execution service to use for the message.\",\"srcModules\":\"The source modules involved in the message sending.\"}},\"getLinkedClient(uint256)\":{\"details\":\"Will return 0x0 if no client is linked for the chain ID.\"},\"getLinkedClientEVM(uint256)\":{\"details\":\"Will return 0x0 if no client is linked for the chain ID. Will revert if the client is not an EVM client.\"},\"interchainExecute(uint256,bytes,bytes32[])\":{\"details\":\"The transaction must have been previously sent and recorded. Transaction data includes the requested gas limit, but the executors could specify a different gas limit. If the specified gas limit is lower than requested, the requested gas limit will be used. Otherwise, the specified gas limit will be used. This allows to execute the transactions with requested gas limit set too low.\",\"params\":{\"gasLimit\":\"The gas limit to use for the execution.\",\"proof\":\"The Merkle proof for transaction execution, fetched from the source chain.\",\"transaction\":\"The transaction data.\"}},\"interchainSend(uint256,bytes32,address,address[],bytes,bytes)\":{\"details\":\"Charges a fee for the message, which is payable upon calling this function: - Verification fees: paid to every module that verifies the message. - Execution fee: paid to the executor that executes the message. Note: while a specific execution service is specified to request the execution of the message, any executor is able to execute the message on destination chain, earning the execution fee.\",\"params\":{\"dstChainId\":\"The chain ID of the destination chain.\",\"message\":\"The message being sent.\",\"options\":\"Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\",\"receiver\":\"The address of the receiver on the destination chain.\",\"srcExecutionService\":\"The address of the execution service to use for the message.\",\"srcModules\":\"The source modules involved in the message sending.\"},\"returns\":{\"desc\":\"The descriptor of the sent transaction: - transactionId: the ID of the transaction that was sent. - dbNonce: the database nonce of the batch containing the written entry for transaction. - entryIndex: the index of the written entry for transaction within the batch.\"}},\"isExecutable(bytes,bytes32[])\":{\"details\":\"Determines if a transaction meets the criteria to be executed based on: - If approved modules have written to the InterchainDB - If the threshold of approved modules have been met - If the optimistic window has passed for all modules\",\"params\":{\"proof\":\"The Merkle proof for transaction execution, fetched from the source chain.\",\"transaction\":\"The InterchainTransaction struct to be checked.\"},\"returns\":{\"_0\":\"bool Returns true if the transaction is executable, false otherwise.\"}},\"setExecutionFees(address)\":{\"details\":\"Only callable by the contract owner or an authorized account.\",\"params\":{\"executionFees_\":\"The address of the ExecutionFees contract.\"}},\"setLinkedClient(uint256,bytes32)\":{\"details\":\"Stores the address of the linked client in a mapping with the chain ID as the key.\",\"params\":{\"chainId\":\"The chain ID for which the client is being set.\",\"client\":\"The address of the client being linked.\"}},\"writeExecutionProof(bytes32)\":{\"details\":\"Will revert if the transaction has not been executed.\",\"params\":{\"transactionId\":\"The ID of the transaction to write the proof for.\"},\"returns\":{\"dbNonce\":\"        The database nonce of the batch containing the written proof for transaction.\",\"entryIndex\":\"     The index of the written proof for transaction within the batch.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"getExecutor(bytes)\":{\"notice\":\"Returns the address of the executor for a transaction that has been sent to the local chain.\"},\"getExecutorById(bytes32)\":{\"notice\":\"Returns the address of the executor for a transaction that has been sent to the local chain.\"},\"getInterchainFee(uint256,address,address[],bytes,bytes)\":{\"notice\":\"Returns the fee for sending an Interchain message.\"},\"getLinkedClient(uint256)\":{\"notice\":\"Returns the address of the linked client (as bytes32) for a specific chain ID.\"},\"getLinkedClientEVM(uint256)\":{\"notice\":\"Returns the EVM address of the linked client for a specific chain ID.\"},\"interchainExecute(uint256,bytes,bytes32[])\":{\"notice\":\"Executes a transaction that has been sent via the Interchain.\"},\"interchainSend(uint256,bytes32,address,address[],bytes,bytes)\":{\"notice\":\"Sends a message to another chain via the Interchain Communication Protocol.\"},\"isExecutable(bytes,bytes32[])\":{\"notice\":\"Checks if a transaction is executable.\"},\"setExecutionFees(address)\":{\"notice\":\"Sets the address of the ExecutionFees contract.\"},\"setLinkedClient(uint256,bytes32)\":{\"notice\":\"Sets the linked client for a specific chain ID.\"},\"writeExecutionProof(bytes32)\":{\"notice\":\"Writes the proof of execution for a transaction into the InterchainDB.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainAppExample.sol\":\"IInterchainClientV1\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainAppExample.sol\":{\"keccak256\":\"0x86f91eccd427db2c0e6cbbdb2244f577ed8111343e9ad8aa6476b8b0bd7cb65c\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://c9a5bce8ffbdc1808235baa92fe6b0fff964c26898bb155a1b06e5ea3e4f3940\",\"dweb:/ipfs/QmZqjYVRz4JL5Pjz9TZqVSy7PUZGsabLKsxtHXP44i3TVK\"]}},\"version\":1}"},"hashes":{"getExecutor(bytes)":"f92a79ff","getExecutorById(bytes32)":"f1a61fac","getInterchainFee(uint256,address,address[],bytes,bytes)":"3c383e7b","getLinkedClient(uint256)":"aa102ec4","getLinkedClientEVM(uint256)":"02172a35","interchainExecute(uint256,bytes,bytes32[])":"53b67d74","interchainSend(uint256,bytes32,address,address[],bytes,bytes)":"98939d28","interchainSendEVM(uint256,address,address,address[],bytes,bytes)":"827f940d","isExecutable(bytes,bytes32[])":"1450c281","setExecutionFees(address)":"3dc68b87","setLinkedClient(uint256,bytes32)":"f34234c8","writeExecutionProof(bytes32)":"90e81077"}},"solidity/InterchainAppExample.sol:InterchainAppExample":{"code":"0x608060405234801561001057600080fd5b506040516115c33803806115c383398101604081905261002f916100c2565b80806001600160a01b03811661005f57604051631e4fbdf760e01b81526000600482015260240160405180910390fd5b61006881610070565b5050506100f2565b600780546001600160a01b038381166001600160a01b0319831681179093556040519116919082907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e090600090a35050565b6000602082840312156100d457600080fd5b81516001600160a01b03811681146100eb57600080fd5b9392505050565b6114c2806101016000396000f3fe60806040526004361061016a5760003560e01c80638da5cb5b116100cb578063b9b74b181161007f578063dc2b907511610059578063dc2b90751461040f578063ea13398f14610335578063f2fde38b1461043f57600080fd5b8063b9b74b1814610397578063c313c807146103c4578063cb5038fb146103ef57600080fd5b8063a45e107a116100b0578063a45e107a14610335578063af8fcc8e14610357578063b70c40b31461037757600080fd5b80638da5cb5b146102ec578063a20ce5101461031757600080fd5b806351a308021161012257806370838975116101075780637083897514610243578063715018a6146102955780637717a647146102aa57600080fd5b806351a308021461021057806368a698471461023057600080fd5b806327efcbb71161015357806327efcbb7146101a4578063287bc057146101c4578063496774b1146101f057600080fd5b80630ca709ee1461016f5780630d32b50514610184575b600080fd5b61018261017d366004610f65565b61045f565b005b34801561019057600080fd5b5061018261019f366004610fb8565b61051c565b3480156101b057600080fd5b506101826101bf366004611057565b610530565b3480156101d057600080fd5b506101d9610541565b6040516101e7929190611127565b60405180910390f35b3480156101fc57600080fd5b5061018261020b366004611057565b61058a565b34801561021c57600080fd5b5061018261022b36600461114c565b61059b565b61018261023e366004611184565b6105b1565b34801561024f57600080fd5b506000546102709073ffffffffffffffffffffffffffffffffffffffff1681565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020016101e7565b3480156102a157600080fd5b506101826106a5565b3480156102b657600080fd5b50604080518082018252600080825260209182015281518083019092526001548252600254908201526040516101e791906111f7565b3480156102f857600080fd5b5060075473ffffffffffffffffffffffffffffffffffffffff16610270565b34801561032357600080fd5b5060015b6040519081526020016101e7565b34801561034157600080fd5b5061034a6106b9565b6040516101e7919061120e565b34801561036357600080fd5b50610182610372366004611221565b6106ca565b34801561038357600080fd5b50610182610392366004611057565b6106dc565b3480156103a357600080fd5b506103276103b236600461124d565b60009081526003602052604090205490565b3480156103d057600080fd5b5060065473ffffffffffffffffffffffffffffffffffffffff16610270565b3480156103fb57600080fd5b5061018261040a366004611057565b6106ed565b34801561041b57600080fd5b5061042f61042a36600461114c565b6106fe565b60405190151581526020016101e7565b34801561044b57600080fd5b5061018261045a366004611057565b610716565b60006104b885346040518060400160405280888152602001600081525086868080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061077792505050565b602080820151604080840151845182518b81529485019390935267ffffffffffffffff169083015260608201529091507f2ef16db2691a32543ce5591798c4992f4cfbbcd446874f1437d99da53d600e7c9060800160405180910390a15050505050565b6105246107bf565b61052d81610812565b50565b6105386107bf565b61052d8161085e565b60608061057a6105756040805180820182526000808252602091820152815180830190925260015482526002549082015290565b6108d1565b91506105846106b9565b90509091565b6105926107bf565b61052d816108fd565b6105a36107bf565b6105ad8282610970565b5050565b60005473ffffffffffffffffffffffffffffffffffffffff163314610609576040517f3e336bbb0000000000000000000000000000000000000000000000000000000081523360048201526024015b60405180910390fd5b468603610645576040517fbfae2eb700000000000000000000000000000000000000000000000000000000815260048101879052602401610600565b61064f86866106fe565b61068f576040517f327f41230000000000000000000000000000000000000000000000000000000081526004810187905260248101869052604401610600565b61069d8686868686866109eb565b505050505050565b6106ad6107bf565b6106b76000610a34565b565b60606106c56004610aab565b905090565b6106d26107bf565b6105ad8282610abf565b6106e46107bf565b61052d81610adf565b6106f56107bf565b61052d81610b8b565b60008281526003602052604090205481145b92915050565b61071e6107bf565b73ffffffffffffffffffffffffffffffffffffffff811661076e576040517f1e4fbdf700000000000000000000000000000000000000000000000000000000815260006004820152602401610600565b61052d81610a34565b60408051606081018252600080825260208201819052918101919091526107b6856107ae8760009081526003602052604090205490565b868686610c2f565b95945050505050565b60075473ffffffffffffffffffffffffffffffffffffffff1633146106b7576040517f118cdaa7000000000000000000000000000000000000000000000000000000008152336004820152602401610600565b80516001819055602080830151600281905560408051938452918301527f156e53f21add5e964d33e39e015675e24d4568202b47744bd8cc6080f76deabf91015b60405180910390a150565b600080547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff83169081179091556040519081527feec21067aa320b611516f448454be9fae691403167636e737345cab1f262d5d790602001610853565b60606107106001836040516020016108e991906111f7565b604051602081830303815290604052610d0e565b600680547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff83169081179091556040519081527f56f2046f579030345e1c12cfd7e2d297e4059c24d30ac1a5cb27a8ee1d53526e90602001610853565b4682036109ac576040517fbfae2eb700000000000000000000000000000000000000000000000000000000815260048101839052602401610600565b60008281526003602052604080822083905551829184917f622d488f4fb24881af2fe5b552b249253a21e4a6fa77d12e69f61ee0fdfb9a319190a35050565b7fc5b07cf0d424748241636d3a67366b44ac88118c42bef024abcb7fd138df79a6868686868686604051610a2496959493929190611266565b60405180910390a1505050505050565b6007805473ffffffffffffffffffffffffffffffffffffffff8381167fffffffffffffffffffffffff0000000000000000000000000000000000000000831681179093556040519116919082907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e090600090a35050565b60606000610ab883610d3a565b9392505050565b6105ad8273ffffffffffffffffffffffffffffffffffffffff8316610970565b6000610aec600483610d96565b905080610b3d576040517fb12a48e600000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff83166004820152602401610600565b60405173ffffffffffffffffffffffffffffffffffffffff831681527f91071153b5721fdadecd5ab74cedca9c0faa62c94f02ef659df2241602698385906020015b60405180910390a15050565b6000610b98600483610db8565b905080610be9576040517f856e38ac00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff83166004820152602401610600565b60405173ffffffffffffffffffffffffffffffffffffffff831681527f0f92a0308a1fb283891a96a4cf077b8499cca0159d8e6ccc8d12096a5011750990602001610b7f565b604080516060810182526000808252602082018190529181019190915260005473ffffffffffffffffffffffffffffffffffffffff16806398939d28868989610c8d60065473ffffffffffffffffffffffffffffffffffffffff1690565b610c956106b9565b610c9e8b6108d1565b8a6040518863ffffffff1660e01b8152600401610cc0969594939291906112d9565b60606040518083038185885af1158015610cde573d6000803e3d6000fd5b50505050506040513d601f19601f82011682018060405250810190610d039190611347565b979650505050505050565b60608282604051602001610d239291906113d0565b604051602081830303815290604052905092915050565b606081600001805480602002602001604051908101604052809291908181526020018280548015610d8a57602002820191906000526020600020905b815481526020019060010190808311610d76575b50505050509050919050565b6000610ab88373ffffffffffffffffffffffffffffffffffffffff8416610dda565b6000610ab88373ffffffffffffffffffffffffffffffffffffffff8416610ecd565b60008181526001830160205260408120548015610ec3576000610dfe6001836113f4565b8554909150600090610e12906001906113f4565b9050808214610e77576000866000018281548110610e3257610e3261142e565b9060005260206000200154905080876000018481548110610e5557610e5561142e565b6000918252602080832090910192909255918252600188019052604090208390555b8554869080610e8857610e8861145d565b600190038181906000526020600020016000905590558560010160008681526020019081526020016000206000905560019350505050610710565b6000915050610710565b6000818152600183016020526040812054610f1457508154600181810184556000848152602080822090930184905584548482528286019093526040902091909155610710565b506000610710565b60008083601f840112610f2e57600080fd5b50813567ffffffffffffffff811115610f4657600080fd5b602083019150836020828501011115610f5e57600080fd5b9250929050565b60008060008060608587031215610f7b57600080fd5b8435935060208501359250604085013567ffffffffffffffff811115610fa057600080fd5b610fac87828801610f1c565b95989497509550505050565b600060408284031215610fca57600080fd5b6040516040810181811067ffffffffffffffff82111715611014577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b604052823581526020928301359281019290925250919050565b803573ffffffffffffffffffffffffffffffffffffffff8116811461105257600080fd5b919050565b60006020828403121561106957600080fd5b610ab88261102e565b6000815180845260005b818110156110985760208185018101518683018201520161107c565b5060006020828601015260207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f83011685010191505092915050565b600081518084526020808501945080840160005b8381101561111c57815173ffffffffffffffffffffffffffffffffffffffff16875295820195908201906001016110ea565b509495945050505050565b60408152600061113a6040830185611072565b82810360208401526107b681856110d6565b6000806040838503121561115f57600080fd5b50508035926020909101359150565b67ffffffffffffffff8116811461052d57600080fd5b60008060008060008060a0878903121561119d57600080fd5b86359550602087013594506040870135935060608701356111bd8161116e565b9250608087013567ffffffffffffffff8111156111d957600080fd5b6111e589828a01610f1c565b979a9699509497509295939492505050565b815181526020808301519082015260408101610710565b602081526000610ab860208301846110d6565b6000806040838503121561123457600080fd5b823591506112446020840161102e565b90509250929050565b60006020828403121561125f57600080fd5b5035919050565b86815285602082015284604082015267ffffffffffffffff8416606082015260a060808201528160a0820152818360c0830137600081830160c090810191909152601f9092017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016010195945050505050565b86815285602082015273ffffffffffffffffffffffffffffffffffffffff8516604082015260c06060820152600061131460c08301866110d6565b82810360808401526113268186611072565b905082810360a084015261133a8185611072565b9998505050505050505050565b60006060828403121561135957600080fd5b6040516060810181811067ffffffffffffffff821117156113a3577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b8060405250825181526020830151602082015260408301516113c48161116e565b60408201529392505050565b60ff831681526040602082015260006113ec6040830184611072565b949350505050565b81810381811115610710577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603160045260246000fdfea264697066735822122040f1c693b92da71651021745a29a4fea6c65d62b75e4c70e3e1c7cfc205dfa6164736f6c63430008140033","runtime-code":"0x60806040526004361061016a5760003560e01c80638da5cb5b116100cb578063b9b74b181161007f578063dc2b907511610059578063dc2b90751461040f578063ea13398f14610335578063f2fde38b1461043f57600080fd5b8063b9b74b1814610397578063c313c807146103c4578063cb5038fb146103ef57600080fd5b8063a45e107a116100b0578063a45e107a14610335578063af8fcc8e14610357578063b70c40b31461037757600080fd5b80638da5cb5b146102ec578063a20ce5101461031757600080fd5b806351a308021161012257806370838975116101075780637083897514610243578063715018a6146102955780637717a647146102aa57600080fd5b806351a308021461021057806368a698471461023057600080fd5b806327efcbb71161015357806327efcbb7146101a4578063287bc057146101c4578063496774b1146101f057600080fd5b80630ca709ee1461016f5780630d32b50514610184575b600080fd5b61018261017d366004610f65565b61045f565b005b34801561019057600080fd5b5061018261019f366004610fb8565b61051c565b3480156101b057600080fd5b506101826101bf366004611057565b610530565b3480156101d057600080fd5b506101d9610541565b6040516101e7929190611127565b60405180910390f35b3480156101fc57600080fd5b5061018261020b366004611057565b61058a565b34801561021c57600080fd5b5061018261022b36600461114c565b61059b565b61018261023e366004611184565b6105b1565b34801561024f57600080fd5b506000546102709073ffffffffffffffffffffffffffffffffffffffff1681565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020016101e7565b3480156102a157600080fd5b506101826106a5565b3480156102b657600080fd5b50604080518082018252600080825260209182015281518083019092526001548252600254908201526040516101e791906111f7565b3480156102f857600080fd5b5060075473ffffffffffffffffffffffffffffffffffffffff16610270565b34801561032357600080fd5b5060015b6040519081526020016101e7565b34801561034157600080fd5b5061034a6106b9565b6040516101e7919061120e565b34801561036357600080fd5b50610182610372366004611221565b6106ca565b34801561038357600080fd5b50610182610392366004611057565b6106dc565b3480156103a357600080fd5b506103276103b236600461124d565b60009081526003602052604090205490565b3480156103d057600080fd5b5060065473ffffffffffffffffffffffffffffffffffffffff16610270565b3480156103fb57600080fd5b5061018261040a366004611057565b6106ed565b34801561041b57600080fd5b5061042f61042a36600461114c565b6106fe565b60405190151581526020016101e7565b34801561044b57600080fd5b5061018261045a366004611057565b610716565b60006104b885346040518060400160405280888152602001600081525086868080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061077792505050565b602080820151604080840151845182518b81529485019390935267ffffffffffffffff169083015260608201529091507f2ef16db2691a32543ce5591798c4992f4cfbbcd446874f1437d99da53d600e7c9060800160405180910390a15050505050565b6105246107bf565b61052d81610812565b50565b6105386107bf565b61052d8161085e565b60608061057a6105756040805180820182526000808252602091820152815180830190925260015482526002549082015290565b6108d1565b91506105846106b9565b90509091565b6105926107bf565b61052d816108fd565b6105a36107bf565b6105ad8282610970565b5050565b60005473ffffffffffffffffffffffffffffffffffffffff163314610609576040517f3e336bbb0000000000000000000000000000000000000000000000000000000081523360048201526024015b60405180910390fd5b468603610645576040517fbfae2eb700000000000000000000000000000000000000000000000000000000815260048101879052602401610600565b61064f86866106fe565b61068f576040517f327f41230000000000000000000000000000000000000000000000000000000081526004810187905260248101869052604401610600565b61069d8686868686866109eb565b505050505050565b6106ad6107bf565b6106b76000610a34565b565b60606106c56004610aab565b905090565b6106d26107bf565b6105ad8282610abf565b6106e46107bf565b61052d81610adf565b6106f56107bf565b61052d81610b8b565b60008281526003602052604090205481145b92915050565b61071e6107bf565b73ffffffffffffffffffffffffffffffffffffffff811661076e576040517f1e4fbdf700000000000000000000000000000000000000000000000000000000815260006004820152602401610600565b61052d81610a34565b60408051606081018252600080825260208201819052918101919091526107b6856107ae8760009081526003602052604090205490565b868686610c2f565b95945050505050565b60075473ffffffffffffffffffffffffffffffffffffffff1633146106b7576040517f118cdaa7000000000000000000000000000000000000000000000000000000008152336004820152602401610600565b80516001819055602080830151600281905560408051938452918301527f156e53f21add5e964d33e39e015675e24d4568202b47744bd8cc6080f76deabf91015b60405180910390a150565b600080547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff83169081179091556040519081527feec21067aa320b611516f448454be9fae691403167636e737345cab1f262d5d790602001610853565b60606107106001836040516020016108e991906111f7565b604051602081830303815290604052610d0e565b600680547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff83169081179091556040519081527f56f2046f579030345e1c12cfd7e2d297e4059c24d30ac1a5cb27a8ee1d53526e90602001610853565b4682036109ac576040517fbfae2eb700000000000000000000000000000000000000000000000000000000815260048101839052602401610600565b60008281526003602052604080822083905551829184917f622d488f4fb24881af2fe5b552b249253a21e4a6fa77d12e69f61ee0fdfb9a319190a35050565b7fc5b07cf0d424748241636d3a67366b44ac88118c42bef024abcb7fd138df79a6868686868686604051610a2496959493929190611266565b60405180910390a1505050505050565b6007805473ffffffffffffffffffffffffffffffffffffffff8381167fffffffffffffffffffffffff0000000000000000000000000000000000000000831681179093556040519116919082907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e090600090a35050565b60606000610ab883610d3a565b9392505050565b6105ad8273ffffffffffffffffffffffffffffffffffffffff8316610970565b6000610aec600483610d96565b905080610b3d576040517fb12a48e600000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff83166004820152602401610600565b60405173ffffffffffffffffffffffffffffffffffffffff831681527f91071153b5721fdadecd5ab74cedca9c0faa62c94f02ef659df2241602698385906020015b60405180910390a15050565b6000610b98600483610db8565b905080610be9576040517f856e38ac00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff83166004820152602401610600565b60405173ffffffffffffffffffffffffffffffffffffffff831681527f0f92a0308a1fb283891a96a4cf077b8499cca0159d8e6ccc8d12096a5011750990602001610b7f565b604080516060810182526000808252602082018190529181019190915260005473ffffffffffffffffffffffffffffffffffffffff16806398939d28868989610c8d60065473ffffffffffffffffffffffffffffffffffffffff1690565b610c956106b9565b610c9e8b6108d1565b8a6040518863ffffffff1660e01b8152600401610cc0969594939291906112d9565b60606040518083038185885af1158015610cde573d6000803e3d6000fd5b50505050506040513d601f19601f82011682018060405250810190610d039190611347565b979650505050505050565b60608282604051602001610d239291906113d0565b604051602081830303815290604052905092915050565b606081600001805480602002602001604051908101604052809291908181526020018280548015610d8a57602002820191906000526020600020905b815481526020019060010190808311610d76575b50505050509050919050565b6000610ab88373ffffffffffffffffffffffffffffffffffffffff8416610dda565b6000610ab88373ffffffffffffffffffffffffffffffffffffffff8416610ecd565b60008181526001830160205260408120548015610ec3576000610dfe6001836113f4565b8554909150600090610e12906001906113f4565b9050808214610e77576000866000018281548110610e3257610e3261142e565b9060005260206000200154905080876000018481548110610e5557610e5561142e565b6000918252602080832090910192909255918252600188019052604090208390555b8554869080610e8857610e8861145d565b600190038181906000526020600020016000905590558560010160008681526020019081526020016000206000905560019350505050610710565b6000915050610710565b6000818152600183016020526040812054610f1457508154600181810184556000848152602080822090930184905584548482528286019093526040902091909155610710565b506000610710565b60008083601f840112610f2e57600080fd5b50813567ffffffffffffffff811115610f4657600080fd5b602083019150836020828501011115610f5e57600080fd5b9250929050565b60008060008060608587031215610f7b57600080fd5b8435935060208501359250604085013567ffffffffffffffff811115610fa057600080fd5b610fac87828801610f1c565b95989497509550505050565b600060408284031215610fca57600080fd5b6040516040810181811067ffffffffffffffff82111715611014577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b604052823581526020928301359281019290925250919050565b803573ffffffffffffffffffffffffffffffffffffffff8116811461105257600080fd5b919050565b60006020828403121561106957600080fd5b610ab88261102e565b6000815180845260005b818110156110985760208185018101518683018201520161107c565b5060006020828601015260207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f83011685010191505092915050565b600081518084526020808501945080840160005b8381101561111c57815173ffffffffffffffffffffffffffffffffffffffff16875295820195908201906001016110ea565b509495945050505050565b60408152600061113a6040830185611072565b82810360208401526107b681856110d6565b6000806040838503121561115f57600080fd5b50508035926020909101359150565b67ffffffffffffffff8116811461052d57600080fd5b60008060008060008060a0878903121561119d57600080fd5b86359550602087013594506040870135935060608701356111bd8161116e565b9250608087013567ffffffffffffffff8111156111d957600080fd5b6111e589828a01610f1c565b979a9699509497509295939492505050565b815181526020808301519082015260408101610710565b602081526000610ab860208301846110d6565b6000806040838503121561123457600080fd5b823591506112446020840161102e565b90509250929050565b60006020828403121561125f57600080fd5b5035919050565b86815285602082015284604082015267ffffffffffffffff8416606082015260a060808201528160a0820152818360c0830137600081830160c090810191909152601f9092017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016010195945050505050565b86815285602082015273ffffffffffffffffffffffffffffffffffffffff8516604082015260c06060820152600061131460c08301866110d6565b82810360808401526113268186611072565b905082810360a084015261133a8185611072565b9998505050505050505050565b60006060828403121561135957600080fd5b6040516060810181811067ffffffffffffffff821117156113a3577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b8060405250825181526020830151602082015260408301516113c48161116e565b60408201529392505050565b60ff831681526040602082015260006113ec6040830184611072565b949350505050565b81810381811115610710577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603160045260246000fdfea264697066735822122040f1c693b92da71651021745a29a4fea6c65d62b75e4c70e3e1c7cfc205dfa6164736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainAppV1Events.sol\n\nabstract contract InterchainAppV1Events {\n    event AppConfigV1Set(uint256 requiredResponses, uint256 optimisticPeriod);\n    event AppLinked(uint256 indexed chainId, bytes32 indexed remoteApp);\n    event InterchainClientSet(address interchainClient);\n    event ExecutionServiceSet(address executionService);\n    event TrustedModuleAdded(address module);\n    event TrustedModuleRemoved(address module);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    function appReceive(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    uint8 constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint8 version);\n\n    /// @notice Encodes versioned app config into a bytes format.\n    /// @param version      The version of the app config.\n    /// @param appConfig    The app config to encode.\n    function encodeVersionedAppConfig(uint8 version, bytes memory appConfig) internal pure returns (bytes memory) {\n        return abi.encode(version, appConfig);\n    }\n\n    /// @notice Decodes versioned app config from a bytes format back into a version and app config.\n    /// @param data         The versioned app config data in bytes format.\n    /// @return version     The version of the app config.\n    /// @return appConfig   The app config as bytes.\n    function decodeVersionedAppConfig(bytes memory data)\n        internal\n        pure\n        returns (uint8 version, bytes memory appConfig)\n    {\n        (version, appConfig) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return encodeVersionedAppConfig(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal pure returns (AppConfigV1 memory) {\n        (uint8 version, bytes memory appConfig) = decodeVersionedAppConfig(data);\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(appConfig, (AppConfigV1));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    uint8 constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint8 version);\n\n    /// @notice Encodes versioned options into a bytes format.\n    /// @param version      The version of the options.\n    /// @param options      The options to encode.\n    function encodeVersionedOptions(uint8 version, bytes memory options) internal pure returns (bytes memory) {\n        return abi.encode(version, options);\n    }\n\n    /// @notice Decodes versioned options from a bytes format back into a version and options.\n    /// @param data         The versioned options data in bytes format.\n    /// @return version     The version of the options.\n    /// @return options     The options as bytes.\n    function decodeVersionedOptions(bytes memory data) internal pure returns (uint8 version, bytes memory options) {\n        (version, options) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return encodeVersionedOptions(OPTIONS_V1, abi.encode(options));\n    }\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal pure returns (OptionsV1 memory) {\n        (uint8 version, bytes memory options) = decodeVersionedOptions(data);\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(options, (OptionsV1));\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/libs/InterchainTransaction.sol\n\nstruct InterchainTransaction {\n    uint256 srcChainId;\n    bytes32 srcSender;\n    uint256 dstChainId;\n    bytes32 dstReceiver;\n    uint256 dbNonce;\n    uint64 entryIndex;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint256 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    function constructLocalTransaction(\n        address srcSender,\n        uint256 dstChainId,\n        bytes32 dstReceiver,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: block.chainid,\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(transaction);\n    }\n\n    function decodeTransaction(bytes memory encodedTx) internal pure returns (InterchainTransaction memory) {\n        return abi.decode(encodedTx, (InterchainTransaction));\n    }\n\n    function transactionId(InterchainTransaction memory transaction) internal pure returns (bytes32) {\n        return keccak256(abi.encode(transaction));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint256 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__NoLinkedClient(uint256 chainId);\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint256 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint256 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint256 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint256 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint256 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param message              The message being sent.\n    function getInterchainFee(\n        uint256 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint256 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint256 chainId) external view returns (address);\n}\n\n// contracts/apps/InterchainAppV1.sol\n\nabstract contract InterchainAppV1 is InterchainAppV1Events, IInterchainApp {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    // TODO: naming, visibility\n    address public interchain;\n\n    /// @dev Required responses and optimistic period for the module responses.\n    AppConfigV1 private _appConfigV1;\n    /// @dev Address of the linked app deployed on the remote chain.\n    mapping(uint256 chainId =\u003e bytes32 remoteApp) private _linkedApp;\n    /// @dev Trusted Interchain modules.\n    EnumerableSet.AddressSet private _trustedModules;\n    /// @dev Execution Service to use for sending messages.\n    address private _executionService;\n\n    error InterchainApp__BalanceTooLow(uint256 actual, uint256 expected);\n    error InterchainApp__CallerNotInterchainClient(address caller);\n    error InterchainApp__InterchainClientNotSet();\n    error InterchainApp__ModuleAlreadyAdded(address module);\n    error InterchainApp__ModuleNotAdded(address module);\n    error InterchainApp__ReceiverNotSet(uint256 chainId);\n    error InterchainApp__SameChainId(uint256 chainId);\n    error InterchainApp__SenderNotAllowed(uint256 srcChainId, bytes32 sender);\n\n    /// @inheritdoc IInterchainApp\n    function appReceive(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        if (msg.sender != interchain) revert InterchainApp__CallerNotInterchainClient(msg.sender);\n        if (srcChainId == block.chainid) revert InterchainApp__SameChainId(srcChainId);\n        if (!isAllowedSender(srcChainId, sender)) revert InterchainApp__SenderNotAllowed(srcChainId, sender);\n        _receiveMessage(srcChainId, sender, dbNonce, entryIndex, message);\n        // Note: application may elect to emit an event in `_receiveMessage`, so we don't emit a generic event here.\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainApp\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules) {\n        // Note: the getters for app config and modules could be overridden in the derived contracts.\n        appConfig = getAppConfigV1().encodeAppConfigV1();\n        modules = getReceivingModules();\n    }\n\n    /// @notice Returns the app config for receiving messages.\n    /// @dev Could be overridden in the derived contracts.\n    function getAppConfigV1() public view virtual returns (AppConfigV1 memory) {\n        return _appConfigV1;\n    }\n\n    /// @notice Returns the address of the Execution Service to use for sending messages.\n    /// @dev Could be overridden in the derived contracts.\n    function getExecutionService() public view virtual returns (address) {\n        return _executionService;\n    }\n\n    /// @notice Returns the linked app address (as bytes32) for the given chain ID.\n    /// @dev Could be overridden in the derived contracts.\n    function getLinkedApp(uint256 chainId) public view virtual returns (bytes32) {\n        return _linkedApp[chainId];\n    }\n\n    /// @notice Returns the list of modules used for sending messages.\n    /// @dev Could be overridden in the derived contracts.\n    function getSendingModules() public view virtual returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    /// @notice Returns the list of modules used for receiving messages.\n    /// @dev Could be overridden in the derived contracts.\n    function getReceivingModules() public view virtual returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    /// @notice Checks whether the sender is allowed to send messages to the current app.\n    /// @dev Could be overridden in the derived contracts.\n    function isAllowedSender(uint256 srcChainId, bytes32 sender) public view virtual returns (bool) {\n        return _linkedApp[srcChainId] == sender;\n    }\n\n    /// @notice Returns the current app version.\n    /// @dev Could be overridden in the derived contracts.\n    function getAppVersion() public pure virtual returns (uint256) {\n        return 1;\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Links the remote app to the current app.\n    /// Will revert if the chainId is the same as the chainId of the local app.\n    /// Note: Should be guarded with permissions check.\n    function _linkRemoteApp(uint256 chainId, bytes32 remoteApp) internal {\n        if (chainId == block.chainid) revert InterchainApp__SameChainId(chainId);\n        _linkedApp[chainId] = remoteApp;\n        emit AppLinked(chainId, remoteApp);\n    }\n\n    /// @dev Thin wrapper around _linkRemoteApp to accept EVM address as a parameter.\n    function _linkRemoteAppEVM(uint256 chainId, address remoteApp) internal {\n        _linkRemoteApp(chainId, TypeCasts.addressToBytes32(remoteApp));\n    }\n\n    /// @dev Adds the module to the trusted modules set.\n    /// Will revert if the module is already added.\n    /// Note: Should be guarded with permissions check.\n    function _addTrustedModule(address module) internal {\n        bool added = _trustedModules.add(module);\n        if (!added) revert InterchainApp__ModuleAlreadyAdded(module);\n        emit TrustedModuleAdded(module);\n    }\n\n    /// @dev Removes the module from the trusted modules set.\n    /// Will revert if the module is not added.\n    /// Note: Should be guarded with permissions check.\n    function _removeTrustedModule(address module) internal {\n        bool removed = _trustedModules.remove(module);\n        if (!removed) revert InterchainApp__ModuleNotAdded(module);\n        emit TrustedModuleRemoved(module);\n    }\n\n    /// @dev Sets the app config:\n    /// - requiredResponses: the number of module responses required for accepting the message\n    /// - optimisticPeriod: the minimum time after which the module responses are considered final\n    /// Note: Should be guarded with permissions check.\n    function _setAppConfigV1(AppConfigV1 memory appConfig) internal {\n        _appConfigV1 = appConfig;\n        emit AppConfigV1Set(appConfig.requiredResponses, appConfig.optimisticPeriod);\n    }\n\n    /// @dev Sets the execution service address.\n    /// Note: Should be guarded with permissions check.\n    function _setExecutionService(address executionService) internal {\n        _executionService = executionService;\n        emit ExecutionServiceSet(executionService);\n    }\n\n    /// @dev Sets the interchain client address.\n    /// Note: Should be guarded with permissions check.\n    function _setInterchainClient(address interchain_) internal {\n        interchain = interchain_;\n        emit InterchainClientSet(interchain_);\n    }\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to send the message to the linked app.\n    function _sendInterchainMessage(\n        uint256 dstChainId,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _sendInterchainMessage(dstChainId, getLinkedApp(dstChainId), messageFee, options, message);\n    }\n\n    /// @dev Thin wrapper around _sendInterchainMessage to accept EVM address as a parameter.\n    function _sendInterchainMessageEVM(\n        uint256 dstChainId,\n        address receiver,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _sendInterchainMessage(dstChainId, TypeCasts.addressToBytes32(receiver), messageFee, options, message);\n    }\n\n    /// @dev Performs necessary checks and sends an interchain message.\n    function _sendInterchainMessage(\n        uint256 dstChainId,\n        bytes32 receiver,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        address cachedInterchain = interchain;\n//        if (cachedInterchain == address(0)) revert InterchainApp__InterchainClientNotSet();\n//        if (dstChainId == block.chainid) revert InterchainApp__SameChainId(dstChainId);\n//        if (receiver == 0) revert InterchainApp__ReceiverNotSet(dstChainId);\n//        if (address(this).balance \u003c messageFee) revert InterchainApp__BalanceTooLow(address(this).balance, messageFee);\n        return IInterchainClientV1(cachedInterchain).interchainSend{value: messageFee}(\n            dstChainId, receiver, getExecutionService(), getSendingModules(), options.encodeOptionsV1(), message\n        );\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        virtual;\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee for sending an Interchain message.\n    function _getInterchainFee(\n        uint256 dstChainId,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        address cachedInterchain = interchain;\n        if (cachedInterchain == address(0)) revert InterchainApp__InterchainClientNotSet();\n        return IInterchainClientV1(cachedInterchain).getInterchainFee(\n            dstChainId, getExecutionService(), getSendingModules(), options.encodeOptionsV1(), message\n        );\n    }\n}\n\n// contracts/apps/OwnableApp.sol\n\nabstract contract OwnableApp is InterchainAppV1, Ownable {\n    constructor(address owner_) Ownable(owner_) {}\n\n    /// @notice Allows the owner to link the remote app for the given chain ID.\n    /// - This address will be used as the receiver for the messages sent from this chain.\n    /// - This address will be the only trusted sender for the messages sent to this chain.\n    function linkRemoteApp(uint256 chainId, bytes32 remoteApp) external onlyOwner {\n        _linkRemoteApp(chainId, remoteApp);\n    }\n\n    /// @notice This wrapper for `linkRemoteApp` to accept EVM address as a parameter.\n    function linkRemoteAppEVM(uint256 chainId, address remoteApp) external onlyOwner {\n        _linkRemoteAppEVM(chainId, remoteApp);\n    }\n\n    /// @notice Allows the owner to add the module to the trusted modules set.\n    /// - This set of modules will be used to verify message sent from this chain.\n    /// - This set of modules will be used to verify message sent to this chain.\n    function addTrustedModule(address module) external onlyOwner {\n        _addTrustedModule(module);\n    }\n\n    /// @notice Allows the owner to remove the module from the trusted modules set.\n    function removeTrustedModule(address module) external onlyOwner {\n        _removeTrustedModule(module);\n    }\n\n    /// @notice Allows the owner to set the app config for the current app. App config includes:\n    /// - requiredResponses: the number of module responses required for accepting the message\n    /// - optimisticPeriod: the minimum time after which the module responses are considered final\n    function setAppConfigV1(AppConfigV1 memory appConfig) external onlyOwner {\n        _setAppConfigV1(appConfig);\n    }\n\n    /// @notice Allows the owner to set the address of the Execution Service.\n    /// This address will be used to request execution of the messages sent from this chain,\n    /// by supplying the Service's execution fee.\n    function setExecutionService(address executionService) external onlyOwner {\n        _setExecutionService(executionService);\n    }\n\n    /// @notice Allows the owner to set the address of the InterchainClient contract.\n    function setInterchainClient(address interchain_) external onlyOwner {\n        _setInterchainClient(interchain_);\n    }\n}\n\n// contracts/apps/InterchainAppExample.sol\n\ncontract InterchainAppExample is OwnableApp {\n    event MessageReceived(uint256 srcChainId, bytes32 sender, uint256 dbNonce, uint64 entryIndex, bytes message);\n    event MessageSent(uint256 dstChainId, uint256 dbNonce, uint64 entryIndex, bytes32 transactionId);\n\n    constructor(address owner_) OwnableApp(owner_) {}\n\n    /// @notice Sends a basic message to the destination chain.\n    function sendMessage(uint256 dstChainId, uint256 gasLimit, bytes calldata message) external payable {\n        InterchainTxDescriptor memory desc = _sendInterchainMessage({\n            dstChainId: dstChainId,\n            messageFee: msg.value,\n            options: OptionsV1({gasLimit: gasLimit, gasAirdrop: 0}),\n            message: message\n        });\n        emit MessageSent(dstChainId, desc.dbNonce, desc.entryIndex, desc.transactionId);\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        override\n    {\n        emit MessageReceived(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"45068:1247:0:-:0;;;45335:49;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;45374:6;;-1:-1:-1;;;;;22873:26:0;;22869:95;;22922:31;;-1:-1:-1;;;22922:31:0;;22950:1;22922:31;;;455:51:1;428:18;;22922:31:0;;;;;;;22869:95;22973:32;22992:12;22973:18;:32::i;:::-;22825:187;42817:46;45335:49;45068:1247;;24512:187;24604:6;;;-1:-1:-1;;;;;24620:17:0;;;-1:-1:-1;;;;;;24620:17:0;;;;;;;24652:40;;24604:6;;;24620:17;24604:6;;24652:40;;24585:16;;24652:40;24575:124;24512:187;:::o;14:290:1:-;84:6;137:2;125:9;116:7;112:23;108:32;105:52;;;153:1;150;143:12;105:52;179:16;;-1:-1:-1;;;;;224:31:1;;214:42;;204:70;;270:1;267;260:12;204:70;293:5;14:290;-1:-1:-1;;;14:290:1:o;309:203::-;45068:1247:0;;;;;;","srcMapRuntime":"45068:1247:0:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;45454:447;;;;;;:::i;:::-;;:::i;:::-;;44337:116;;;;;;;;;;-1:-1:-1;44337:116:0;;;;;:::i;:::-;;:::i;44901:119::-;;;;;;;;;;-1:-1:-1;44901:119:0;;;;;:::i;:::-;;:::i;34352:311::-;;;;;;;;;;;;;:::i;:::-;;;;;;;;:::i;:::-;;;;;;;;44680:129;;;;;;;;;;-1:-1:-1;44680:129:0;;;;;:::i;:::-;;:::i;43132:::-;;;;;;;;;;-1:-1:-1;43132:129:0;;;;;:::i;:::-;;:::i;33282:695::-;;;;;;:::i;:::-;;:::i;32259:25::-;;;;;;;;;;-1:-1:-1;32259:25:0;;;;;;;;;;;4690:42:1;4678:55;;;4660:74;;4648:2;4633:18;32259:25:0;4514:226:1;23893:101:0;;;;;;;;;;;;;:::i;34791:111::-;;;;;;;;;;-1:-1:-1;;;;;;;;;;;;;;;;;;34876:19:0;;;;;;;;34883:12;34876:19;;;;;;;;;34791:111;;;;;;:::i;23238:85::-;;;;;;;;;;-1:-1:-1;23310:6:0;;;;23238:85;;36381:88;;;;;;;;;;-1:-1:-1;36461:1:0;36381:88;;;5307:25:1;;;5295:2;5280:18;36381:88:0;5161:177:1;35834:126:0;;;;;;;;;;;;;:::i;:::-;;;;;;;:::i;43354:135::-;;;;;;;;;;-1:-1:-1;43354:135:0;;;;;:::i;:::-;;:::i;43931:109::-;;;;;;;;;;-1:-1:-1;43931:109:0;;;;;:::i;:::-;;:::i;35316:120::-;;;;;;;;;;-1:-1:-1;35316:120:0;;;;;:::i;:::-;35384:7;35410:19;;;:10;:19;;;;;;;35316:120;35057:110;;;;;;;;;;-1:-1:-1;35143:17:0;;;;35057:110;;43738:103;;;;;;;;;;-1:-1:-1;43738:103:0;;;;;:::i;:::-;;:::i;36115:152::-;;;;;;;;;;-1:-1:-1;36115:152:0;;;;;:::i;:::-;;:::i;:::-;;;6400:14:1;;6393:22;6375:41;;6363:2;6348:18;36115:152:0;6235:187:1;24143:215:0;;;;;;;;;;-1:-1:-1;24143:215:0;;;;;:::i;:::-;;:::i;45454:447::-;45564:34;45601:204;45650:10;45686:9;45718:46;;;;;;;;45739:8;45718:46;;;;45761:1;45718:46;;;45787:7;;45601:204;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;45601:22:0;;-1:-1:-1;;;45601:204:0:i;:::-;45844:12;;;;;45858:15;;;;;45875:18;;45820:74;;6656:25:1;;;6697:18;;;6690:34;;;;6772:18;6760:31;6740:18;;;6733:59;6823:2;6808:18;;6801:34;45564:241:0;;-1:-1:-1;45820:74:0;;6643:3:1;6628:19;45820:74:0;;;;;;;45554:347;45454:447;;;;:::o;44337:116::-;23131:13;:11;:13::i;:::-;44420:26:::1;44436:9;44420:15;:26::i;:::-;44337:116:::0;:::o;44901:119::-;23131:13;:11;:13::i;:::-;44980:33:::1;45001:11;44980:20;:33::i;34352:311::-:0;34405:22;34429:24;34579:36;:16;-1:-1:-1;;;;;;;;;;;;;;;;;34876:19:0;;;;;;;;34883:12;34876:19;;;;;;;;;;34791:111;34579:16;:34;:36::i;:::-;34567:48;;34635:21;:19;:21::i;:::-;34625:31;;34352:311;;:::o;44680:129::-;23131:13;:11;:13::i;:::-;44764:38:::1;44785:16;44764:20;:38::i;43132:129::-:0;23131:13;:11;:13::i;:::-;43220:34:::1;43235:7;43244:9;43220:14;:34::i;:::-;43132:129:::0;;:::o;33282:695::-;33509:10;;;;33495;:24;33491:89;;33528:52;;;;;33569:10;33528:52;;;4660:74:1;4633:18;;33528:52:0;;;;;;;;33491:89;33608:13;33594:10;:27;33590:78;;33630:38;;;;;;;;5307:25:1;;;5280:18;;33630:38:0;5161:177:1;33590:78:0;33683:35;33699:10;33711:6;33683:15;:35::i;:::-;33678:100;;33727:51;;;;;;;;7020:25:1;;;7061:18;;;7054:34;;;6993:18;;33727:51:0;6846:248:1;33678:100:0;33788:65;33804:10;33816:6;33824:7;33833:10;33845:7;;33788:15;:65::i;:::-;33282:695;;;;;;:::o;23893:101::-;23131:13;:11;:13::i;:::-;23957:30:::1;23984:1;23957:18;:30::i;:::-;23893:101::o:0;35834:126::-;35894:16;35929:24;:15;:22;:24::i;:::-;35922:31;;35834:126;:::o;43354:135::-;23131:13;:11;:13::i;:::-;43445:37:::1;43463:7;43472:9;43445:17;:37::i;43931:109::-:0;23131:13;:11;:13::i;:::-;44005:28:::1;44026:6;44005:20;:28::i;43738:103::-:0;23131:13;:11;:13::i;:::-;43809:25:::1;43827:6;43809:17;:25::i;36115:152::-:0;36205:4;36228:22;;;:10;:22;;;;;;:32;;36115:152;;;;;:::o;24143:215::-;23131:13;:11;:13::i;:::-;24227:22:::1;::::0;::::1;24223:91;;24272:31;::::0;::::1;::::0;;24300:1:::1;24272:31;::::0;::::1;4660:74:1::0;4633:18;;24272:31:0::1;4514:226:1::0;24223:91:0::1;24323:28;24342:8;24323:18;:28::i;39674:346::-:0;-1:-1:-1;;;;;;;;;;;;;;;;;;;;;;;;;39923:90:0;39946:10;39958:24;39971:10;35384:7;35410:19;;;:10;:19;;;;;;;35316:120;39958:24;39984:10;39996:7;40005;39923:22;:90::i;:::-;39916:97;39674:346;-1:-1:-1;;;;;39674:346:0:o;23396:162::-;23310:6;;23455:23;23310:6;6769:10;23455:23;23451:101;;23501:40;;;;;6769:10;23501:40;;;4660:74:1;4633:18;;23501:40:0;4514:226:1;38536:191:0;38610:24;;:12;:24;;;;;;;;;;;;38649:71;;;7020:25:1;;;7061:18;;;7054:34;38649:71:0;;6993:18:1;38649:71:0;;;;;;;;38536:191;:::o;39119:148::-;39189:10;:24;;;;;;;;;;;;;39228:32;;4660:74:1;;;39228:32:0;;4648:2:1;4633:18;39228:32:0;4514:226:1;2263:180:0;2343:12;2374:62;1225:1;2425:9;2414:21;;;;;;;;:::i;:::-;;;;;;;;;;;;;2374:24;:62::i;38838:170::-;38913:17;:36;;;;;;;;;;;;;38964:37;;4660:74:1;;;38964:37:0;;4648:2:1;4633:18;38964:37:0;4514:226:1;36969:243:0;37063:13;37052:7;:24;37048:72;;37085:35;;;;;;;;5307:25:1;;;5280:18;;37085:35:0;5161:177:1;37048:72:0;37130:19;;;;:10;:19;;;;;;:31;;;37176:29;37152:9;;37141:7;;37176:29;;37130:19;37176:29;36969:243;;:::o;46021:292::-;46241:65;46257:10;46269:6;46277:7;46286:10;46298:7;;46241:65;;;;;;;;;;;:::i;:::-;;;;;;;;46021:292;;;;;;:::o;24512:187::-;24604:6;;;;24620:17;;;;;;;;;;;24652:40;;24604:6;;;24620:17;24604:6;;24652:40;;24585:16;;24652:40;24575:124;24512:187;:::o;17283:300::-;17346:16;17374:22;17399:19;17407:3;17399:7;:19::i;:::-;17374:44;17283:300;-1:-1:-1;;;17283:300:0:o;37304:151::-;37386:62;37401:7;5872:22;;;37386:14;:62::i;38018:228::-;38083:12;38098:30;:15;38121:6;38098:22;:30::i;:::-;38083:45;;38143:7;38138:58;;38159:37;;;;;4690:42:1;4678:55;;38159:37:0;;;4660:74:1;4633:18;;38159:37:0;4514:226:1;38138:58:0;38211:28;;4690:42:1;4678:55;;4660:74;;38211:28:0;;4648:2:1;4633:18;38211:28:0;;;;;;;;38073:173;38018:228;:::o;37626:220::-;37688:10;37701:27;:15;37721:6;37701:19;:27::i;:::-;37688:40;;37743:5;37738:60;;37757:41;;;;;4690:42:1;4678:55;;37757:41:0;;;4660:74:1;4633:18;;37757:41:0;4514:226:1;37738:60:0;37813:26;;4690:42:1;4678:55;;4660:74;;37813:26:0;;4648:2:1;4633:18;37813:26:0;4514:226:1;40585:909:0;-1:-1:-1;;;;;;;;;;;;;;;;;;;;;;;;;40853:24:0;40880:10;;;;41292:52;41352:10;41377;41389:8;41399:21;35143:17;;;;;35057:110;41399:21;41422:19;:17;:19::i;:::-;41443:25;:7;:23;:25::i;:::-;41470:7;41292:195;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;41285:202;40585:909;-1:-1:-1;;;;;;;40585:909:0:o;1470:164::-;1566:12;1608:7;1617:9;1597:30;;;;;;;;;:::i;:::-;;;;;;;;;;;;;1590:37;;1470:164;;;;:::o;12594:109::-;12650:16;12685:3;:11;;12678:18;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;12594:109;;;:::o;15647:156::-;15720:4;15743:53;15751:3;15771:23;;;15743:7;:53::i;15329:150::-;15399:4;15422:50;15427:3;15447:23;;;15422:4;:50::i;9828:1368::-;9894:4;10023:21;;;:14;;;:21;;;;;;10059:13;;10055:1135;;10426:18;10447:12;10458:1;10447:8;:12;:::i;:::-;10493:18;;10426:33;;-1:-1:-1;10473:17:0;;10493:22;;10514:1;;10493:22;:::i;:::-;10473:42;;10548:9;10534:10;:23;10530:378;;10577:17;10597:3;:11;;10609:9;10597:22;;;;;;;;:::i;:::-;;;;;;;;;10577:42;;10744:9;10718:3;:11;;10730:10;10718:23;;;;;;;;:::i;:::-;;;;;;;;;;;;:35;;;;10857:25;;;:14;;;:25;;;;;:36;;;10530:378;10986:17;;:3;;:17;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;11089:3;:14;;:21;11104:5;11089:21;;;;;;;;;;;11082:28;;;11132:4;11125:11;;;;;;;10055:1135;11174:5;11167:12;;;;;9254:406;9317:4;11373:21;;;:14;;;:21;;;;;;9333:321;;-1:-1:-1;9375:23:0;;;;;;;;:11;:23;;;;;;;;;;;;;9557:18;;9533:21;;;:14;;;:21;;;;;;:42;;;;9589:11;;9333:321;-1:-1:-1;9638:5:0;9631:12;;14:347:1;65:8;75:6;129:3;122:4;114:6;110:17;106:27;96:55;;147:1;144;137:12;96:55;-1:-1:-1;170:20:1;;213:18;202:30;;199:50;;;245:1;242;235:12;199:50;282:4;274:6;270:17;258:29;;334:3;327:4;318:6;310;306:19;302:30;299:39;296:59;;;351:1;348;341:12;296:59;14:347;;;;;:::o;366:545::-;454:6;462;470;478;531:2;519:9;510:7;506:23;502:32;499:52;;;547:1;544;537:12;499:52;583:9;570:23;560:33;;640:2;629:9;625:18;612:32;602:42;;695:2;684:9;680:18;667:32;722:18;714:6;711:30;708:50;;;754:1;751;744:12;708:50;793:58;843:7;834:6;823:9;819:22;793:58;:::i;:::-;366:545;;;;-1:-1:-1;870:8:1;-1:-1:-1;;;;366:545:1:o;916:660::-;1002:6;1055:2;1043:9;1034:7;1030:23;1026:32;1023:52;;;1071:1;1068;1061:12;1023:52;1104:2;1098:9;1146:2;1138:6;1134:15;1215:6;1203:10;1200:22;1179:18;1167:10;1164:34;1161:62;1158:242;;;1256:77;1253:1;1246:88;1357:4;1354:1;1347:15;1385:4;1382:1;1375:15;1158:242;1416:2;1409:22;1455:23;;1440:39;;1540:2;1525:18;;;1512:32;1495:15;;;1488:57;;;;-1:-1:-1;1447:6:1;916:660;-1:-1:-1;916:660:1:o;1581:196::-;1649:20;;1709:42;1698:54;;1688:65;;1678:93;;1767:1;1764;1757:12;1678:93;1581:196;;;:::o;1782:186::-;1841:6;1894:2;1882:9;1873:7;1869:23;1865:32;1862:52;;;1910:1;1907;1900:12;1862:52;1933:29;1952:9;1933:29;:::i;1973:481::-;2014:3;2052:5;2046:12;2079:6;2074:3;2067:19;2104:1;2114:162;2128:6;2125:1;2122:13;2114:162;;;2190:4;2246:13;;;2242:22;;2236:29;2218:11;;;2214:20;;2207:59;2143:12;2114:162;;;2118:3;2321:1;2314:4;2305:6;2300:3;2296:16;2292:27;2285:38;2443:4;2373:66;2368:2;2360:6;2356:15;2352:88;2347:3;2343:98;2339:109;2332:116;;;1973:481;;;;:::o;2459:484::-;2512:3;2550:5;2544:12;2577:6;2572:3;2565:19;2603:4;2632:2;2627:3;2623:12;2616:19;;2669:2;2662:5;2658:14;2690:1;2700:218;2714:6;2711:1;2708:13;2700:218;;;2779:13;;2794:42;2775:62;2763:75;;2858:12;;;;2893:15;;;;2736:1;2729:9;2700:218;;;-1:-1:-1;2934:3:1;;2459:484;-1:-1:-1;;;;;2459:484:1:o;2948:421::-;3173:2;3162:9;3155:21;3136:4;3199:44;3239:2;3228:9;3224:18;3216:6;3199:44;:::i;:::-;3291:9;3283:6;3279:22;3274:2;3263:9;3259:18;3252:50;3319:44;3356:6;3348;3319:44;:::i;3374:248::-;3442:6;3450;3503:2;3491:9;3482:7;3478:23;3474:32;3471:52;;;3519:1;3516;3509:12;3471:52;-1:-1:-1;;3542:23:1;;;3612:2;3597:18;;;3584:32;;-1:-1:-1;3374:248:1:o;3627:129::-;3712:18;3705:5;3701:30;3694:5;3691:41;3681:69;;3746:1;3743;3736:12;3761:748;3866:6;3874;3882;3890;3898;3906;3959:3;3947:9;3938:7;3934:23;3930:33;3927:53;;;3976:1;3973;3966:12;3927:53;4012:9;3999:23;3989:33;;4069:2;4058:9;4054:18;4041:32;4031:42;;4120:2;4109:9;4105:18;4092:32;4082:42;;4174:2;4163:9;4159:18;4146:32;4187:30;4211:5;4187:30;:::i;:::-;4236:5;-1:-1:-1;4292:3:1;4277:19;;4264:33;4320:18;4309:30;;4306:50;;;4352:1;4349;4342:12;4306:50;4391:58;4441:7;4432:6;4421:9;4417:22;4391:58;:::i;:::-;3761:748;;;;-1:-1:-1;3761:748:1;;-1:-1:-1;3761:748:1;;4468:8;;3761:748;-1:-1:-1;;;3761:748:1:o;4902:254::-;4822:12;;4810:25;;4884:4;4873:16;;;4867:23;4851:14;;;4844:47;5090:2;5075:18;;5102:48;4745:152;5343:261;5522:2;5511:9;5504:21;5485:4;5542:56;5594:2;5583:9;5579:18;5571:6;5542:56;:::i;5609:254::-;5677:6;5685;5738:2;5726:9;5717:7;5713:23;5709:32;5706:52;;;5754:1;5751;5744:12;5706:52;5790:9;5777:23;5767:33;;5819:38;5853:2;5842:9;5838:18;5819:38;:::i;:::-;5809:48;;5609:254;;;;;:::o;5868:180::-;5927:6;5980:2;5968:9;5959:7;5955:23;5951:32;5948:52;;;5996:1;5993;5986:12;5948:52;-1:-1:-1;6019:23:1;;5868:180;-1:-1:-1;5868:180:1:o;7352:760::-;7619:6;7608:9;7601:25;7662:6;7657:2;7646:9;7642:18;7635:34;7705:6;7700:2;7689:9;7685:18;7678:34;7760:18;7752:6;7748:31;7743:2;7732:9;7728:18;7721:59;7817:3;7811;7800:9;7796:19;7789:32;7858:6;7852:3;7841:9;7837:19;7830:35;7916:6;7908;7902:3;7891:9;7887:19;7874:49;7973:1;7943:22;;;7967:3;7939:32;;;7932:43;;;;8027:2;8015:15;;;8032:66;8011:88;7996:104;7992:114;;7352:760;-1:-1:-1;;;;;7352:760:1:o;8117:847::-;8472:6;8461:9;8454:25;8515:6;8510:2;8499:9;8495:18;8488:34;8570:42;8562:6;8558:55;8553:2;8542:9;8538:18;8531:83;8650:3;8645:2;8634:9;8630:18;8623:31;8435:4;8677:57;8729:3;8718:9;8714:19;8706:6;8677:57;:::i;:::-;8783:9;8775:6;8771:22;8765:3;8754:9;8750:19;8743:51;8817:32;8842:6;8834;8817:32;:::i;:::-;8803:46;;8898:9;8890:6;8886:22;8880:3;8869:9;8865:19;8858:51;8926:32;8951:6;8943;8926:32;:::i;:::-;8918:40;8117:847;-1:-1:-1;;;;;;;;;8117:847:1:o;8969:794::-;9078:6;9131:2;9119:9;9110:7;9106:23;9102:32;9099:52;;;9147:1;9144;9137:12;9099:52;9180:2;9174:9;9222:2;9214:6;9210:15;9291:6;9279:10;9276:22;9255:18;9243:10;9240:34;9237:62;9234:242;;;9332:77;9329:1;9322:88;9433:4;9430:1;9423:15;9461:4;9458:1;9451:15;9234:242;9496:10;9492:2;9485:22;;9537:9;9531:16;9523:6;9516:32;9602:2;9591:9;9587:18;9581:25;9576:2;9568:6;9564:15;9557:50;9650:2;9639:9;9635:18;9629:25;9663:30;9687:5;9663:30;:::i;:::-;9721:2;9709:15;;9702:30;9713:6;8969:794;-1:-1:-1;;;8969:794:1:o;9768:295::-;9951:4;9943:6;9939:17;9928:9;9921:36;9993:2;9988;9977:9;9973:18;9966:30;9902:4;10013:44;10053:2;10042:9;10038:18;10030:6;10013:44;:::i;:::-;10005:52;9768:295;-1:-1:-1;;;;9768:295:1:o;10325:282::-;10392:9;;;10413:11;;;10410:191;;;10457:77;10454:1;10447:88;10558:4;10555:1;10548:15;10586:4;10583:1;10576:15;10612:184;10664:77;10661:1;10654:88;10761:4;10758:1;10751:15;10785:4;10782:1;10775:15;10801:184;10853:77;10850:1;10843:88;10950:4;10947:1;10940:15;10974:4;10971:1;10964:15","abiDefinition":[{"inputs":[{"internalType":"address","name":"owner_","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"inputs":[{"internalType":"uint256","name":"actual","type":"uint256"},{"internalType":"uint256","name":"expected","type":"uint256"}],"name":"InterchainApp__BalanceTooLow","type":"error"},{"inputs":[{"internalType":"address","name":"caller","type":"address"}],"name":"InterchainApp__CallerNotInterchainClient","type":"error"},{"inputs":[],"name":"InterchainApp__InterchainClientNotSet","type":"error"},{"inputs":[{"internalType":"address","name":"module","type":"address"}],"name":"InterchainApp__ModuleAlreadyAdded","type":"error"},{"inputs":[{"internalType":"address","name":"module","type":"address"}],"name":"InterchainApp__ModuleNotAdded","type":"error"},{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"}],"name":"InterchainApp__ReceiverNotSet","type":"error"},{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"}],"name":"InterchainApp__SameChainId","type":"error"},{"inputs":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"bytes32","name":"sender","type":"bytes32"}],"name":"InterchainApp__SenderNotAllowed","type":"error"},{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"OwnableInvalidOwner","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"OwnableUnauthorizedAccount","type":"error"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"requiredResponses","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"optimisticPeriod","type":"uint256"}],"name":"AppConfigV1Set","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"chainId","type":"uint256"},{"indexed":true,"internalType":"bytes32","name":"remoteApp","type":"bytes32"}],"name":"AppLinked","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"executionService","type":"address"}],"name":"ExecutionServiceSet","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"interchainClient","type":"address"}],"name":"InterchainClientSet","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"srcChainId","type":"uint256"},{"indexed":false,"internalType":"bytes32","name":"sender","type":"bytes32"},{"indexed":false,"internalType":"uint256","name":"dbNonce","type":"uint256"},{"indexed":false,"internalType":"uint64","name":"entryIndex","type":"uint64"},{"indexed":false,"internalType":"bytes","name":"message","type":"bytes"}],"name":"MessageReceived","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"dstChainId","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"dbNonce","type":"uint256"},{"indexed":false,"internalType":"uint64","name":"entryIndex","type":"uint64"},{"indexed":false,"internalType":"bytes32","name":"transactionId","type":"bytes32"}],"name":"MessageSent","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"module","type":"address"}],"name":"TrustedModuleAdded","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"module","type":"address"}],"name":"TrustedModuleRemoved","type":"event"},{"inputs":[{"internalType":"address","name":"module","type":"address"}],"name":"addTrustedModule","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"bytes32","name":"sender","type":"bytes32"},{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"uint64","name":"entryIndex","type":"uint64"},{"internalType":"bytes","name":"message","type":"bytes"}],"name":"appReceive","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"getAppConfigV1","outputs":[{"components":[{"internalType":"uint256","name":"requiredResponses","type":"uint256"},{"internalType":"uint256","name":"optimisticPeriod","type":"uint256"}],"internalType":"struct AppConfigV1","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getAppVersion","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"getExecutionService","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"}],"name":"getLinkedApp","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getReceivingConfig","outputs":[{"internalType":"bytes","name":"appConfig","type":"bytes"},{"internalType":"address[]","name":"modules","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getReceivingModules","outputs":[{"internalType":"address[]","name":"","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getSendingModules","outputs":[{"internalType":"address[]","name":"","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"interchain","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"bytes32","name":"sender","type":"bytes32"}],"name":"isAllowedSender","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"},{"internalType":"bytes32","name":"remoteApp","type":"bytes32"}],"name":"linkRemoteApp","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"},{"internalType":"address","name":"remoteApp","type":"address"}],"name":"linkRemoteAppEVM","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"module","type":"address"}],"name":"removeTrustedModule","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"dstChainId","type":"uint256"},{"internalType":"uint256","name":"gasLimit","type":"uint256"},{"internalType":"bytes","name":"message","type":"bytes"}],"name":"sendMessage","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"components":[{"internalType":"uint256","name":"requiredResponses","type":"uint256"},{"internalType":"uint256","name":"optimisticPeriod","type":"uint256"}],"internalType":"struct AppConfigV1","name":"appConfig","type":"tuple"}],"name":"setAppConfigV1","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"executionService","type":"address"}],"name":"setExecutionService","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"interchain_","type":"address"}],"name":"setInterchainClient","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{"addTrustedModule(address)":{"notice":"Allows the owner to add the module to the trusted modules set. - This set of modules will be used to verify message sent from this chain. - This set of modules will be used to verify message sent to this chain."},"getAppConfigV1()":{"notice":"Returns the app config for receiving messages."},"getAppVersion()":{"notice":"Returns the current app version."},"getExecutionService()":{"notice":"Returns the address of the Execution Service to use for sending messages."},"getLinkedApp(uint256)":{"notice":"Returns the linked app address (as bytes32) for the given chain ID."},"getReceivingModules()":{"notice":"Returns the list of modules used for receiving messages."},"getSendingModules()":{"notice":"Returns the list of modules used for sending messages."},"isAllowedSender(uint256,bytes32)":{"notice":"Checks whether the sender is allowed to send messages to the current app."},"linkRemoteApp(uint256,bytes32)":{"notice":"Allows the owner to link the remote app for the given chain ID. - This address will be used as the receiver for the messages sent from this chain. - This address will be the only trusted sender for the messages sent to this chain."},"linkRemoteAppEVM(uint256,address)":{"notice":"This wrapper for `linkRemoteApp` to accept EVM address as a parameter."},"removeTrustedModule(address)":{"notice":"Allows the owner to remove the module from the trusted modules set."},"sendMessage(uint256,uint256,bytes)":{"notice":"Sends a basic message to the destination chain."},"setAppConfigV1((uint256,uint256))":{"notice":"Allows the owner to set the app config for the current app. App config includes: - requiredResponses: the number of module responses required for accepting the message - optimisticPeriod: the minimum time after which the module responses are considered final"},"setExecutionService(address)":{"notice":"Allows the owner to set the address of the Execution Service. This address will be used to request execution of the messages sent from this chain, by supplying the Service's execution fee."},"setInterchainClient(address)":{"notice":"Allows the owner to set the address of the InterchainClient contract."}},"version":1},"developerDoc":{"errors":{"OwnableInvalidOwner(address)":[{"details":"The owner is not a valid owner account. (eg. `address(0)`)"}],"OwnableUnauthorizedAccount(address)":[{"details":"The caller account is not authorized to perform an operation."}]},"kind":"dev","methods":{"getAppConfigV1()":{"details":"Could be overridden in the derived contracts."},"getAppVersion()":{"details":"Could be overridden in the derived contracts."},"getExecutionService()":{"details":"Could be overridden in the derived contracts."},"getLinkedApp(uint256)":{"details":"Could be overridden in the derived contracts."},"getReceivingModules()":{"details":"Could be overridden in the derived contracts."},"getSendingModules()":{"details":"Could be overridden in the derived contracts."},"isAllowedSender(uint256,bytes32)":{"details":"Could be overridden in the derived contracts."},"owner()":{"details":"Returns the address of the current owner."},"renounceOwnership()":{"details":"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."},"transferOwnership(address)":{"details":"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expected\",\"type\":\"uint256\"}],\"name\":\"InterchainApp__BalanceTooLow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"InterchainApp__CallerNotInterchainClient\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InterchainApp__InterchainClientNotSet\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"InterchainApp__ModuleAlreadyAdded\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"InterchainApp__ModuleNotAdded\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"InterchainApp__ReceiverNotSet\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"InterchainApp__SameChainId\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"}],\"name\":\"InterchainApp__SenderNotAllowed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requiredResponses\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"optimisticPeriod\",\"type\":\"uint256\"}],\"name\":\"AppConfigV1Set\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"remoteApp\",\"type\":\"bytes32\"}],\"name\":\"AppLinked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"executionService\",\"type\":\"address\"}],\"name\":\"ExecutionServiceSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"interchainClient\",\"type\":\"address\"}],\"name\":\"InterchainClientSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"MessageReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dstChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"}],\"name\":\"MessageSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"TrustedModuleAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"TrustedModuleRemoved\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"addTrustedModule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"appReceive\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAppConfigV1\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"requiredResponses\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"optimisticPeriod\",\"type\":\"uint256\"}],\"internalType\":\"struct AppConfigV1\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAppVersion\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getExecutionService\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"getLinkedApp\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReceivingConfig\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"appConfig\",\"type\":\"bytes\"},{\"internalType\":\"address[]\",\"name\":\"modules\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReceivingModules\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSendingModules\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"interchain\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"}],\"name\":\"isAllowedSender\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"remoteApp\",\"type\":\"bytes32\"}],\"name\":\"linkRemoteApp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"remoteApp\",\"type\":\"address\"}],\"name\":\"linkRemoteAppEVM\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"removeTrustedModule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dstChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"sendMessage\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"requiredResponses\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"optimisticPeriod\",\"type\":\"uint256\"}],\"internalType\":\"struct AppConfigV1\",\"name\":\"appConfig\",\"type\":\"tuple\"}],\"name\":\"setAppConfigV1\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"executionService\",\"type\":\"address\"}],\"name\":\"setExecutionService\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"interchain_\",\"type\":\"address\"}],\"name\":\"setInterchainClient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"errors\":{\"OwnableInvalidOwner(address)\":[{\"details\":\"The owner is not a valid owner account. (eg. `address(0)`)\"}],\"OwnableUnauthorizedAccount(address)\":[{\"details\":\"The caller account is not authorized to perform an operation.\"}]},\"kind\":\"dev\",\"methods\":{\"getAppConfigV1()\":{\"details\":\"Could be overridden in the derived contracts.\"},\"getAppVersion()\":{\"details\":\"Could be overridden in the derived contracts.\"},\"getExecutionService()\":{\"details\":\"Could be overridden in the derived contracts.\"},\"getLinkedApp(uint256)\":{\"details\":\"Could be overridden in the derived contracts.\"},\"getReceivingModules()\":{\"details\":\"Could be overridden in the derived contracts.\"},\"getSendingModules()\":{\"details\":\"Could be overridden in the derived contracts.\"},\"isAllowedSender(uint256,bytes32)\":{\"details\":\"Could be overridden in the derived contracts.\"},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner.\"},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"addTrustedModule(address)\":{\"notice\":\"Allows the owner to add the module to the trusted modules set. - This set of modules will be used to verify message sent from this chain. - This set of modules will be used to verify message sent to this chain.\"},\"getAppConfigV1()\":{\"notice\":\"Returns the app config for receiving messages.\"},\"getAppVersion()\":{\"notice\":\"Returns the current app version.\"},\"getExecutionService()\":{\"notice\":\"Returns the address of the Execution Service to use for sending messages.\"},\"getLinkedApp(uint256)\":{\"notice\":\"Returns the linked app address (as bytes32) for the given chain ID.\"},\"getReceivingModules()\":{\"notice\":\"Returns the list of modules used for receiving messages.\"},\"getSendingModules()\":{\"notice\":\"Returns the list of modules used for sending messages.\"},\"isAllowedSender(uint256,bytes32)\":{\"notice\":\"Checks whether the sender is allowed to send messages to the current app.\"},\"linkRemoteApp(uint256,bytes32)\":{\"notice\":\"Allows the owner to link the remote app for the given chain ID. - This address will be used as the receiver for the messages sent from this chain. - This address will be the only trusted sender for the messages sent to this chain.\"},\"linkRemoteAppEVM(uint256,address)\":{\"notice\":\"This wrapper for `linkRemoteApp` to accept EVM address as a parameter.\"},\"removeTrustedModule(address)\":{\"notice\":\"Allows the owner to remove the module from the trusted modules set.\"},\"sendMessage(uint256,uint256,bytes)\":{\"notice\":\"Sends a basic message to the destination chain.\"},\"setAppConfigV1((uint256,uint256))\":{\"notice\":\"Allows the owner to set the app config for the current app. App config includes: - requiredResponses: the number of module responses required for accepting the message - optimisticPeriod: the minimum time after which the module responses are considered final\"},\"setExecutionService(address)\":{\"notice\":\"Allows the owner to set the address of the Execution Service. This address will be used to request execution of the messages sent from this chain, by supplying the Service's execution fee.\"},\"setInterchainClient(address)\":{\"notice\":\"Allows the owner to set the address of the InterchainClient contract.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainAppExample.sol\":\"InterchainAppExample\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainAppExample.sol\":{\"keccak256\":\"0x86f91eccd427db2c0e6cbbdb2244f577ed8111343e9ad8aa6476b8b0bd7cb65c\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://c9a5bce8ffbdc1808235baa92fe6b0fff964c26898bb155a1b06e5ea3e4f3940\",\"dweb:/ipfs/QmZqjYVRz4JL5Pjz9TZqVSy7PUZGsabLKsxtHXP44i3TVK\"]}},\"version\":1}"},"hashes":{"addTrustedModule(address)":"cb5038fb","appReceive(uint256,bytes32,uint256,uint64,bytes)":"68a69847","getAppConfigV1()":"7717a647","getAppVersion()":"a20ce510","getExecutionService()":"c313c807","getLinkedApp(uint256)":"b9b74b18","getReceivingConfig()":"287bc057","getReceivingModules()":"a45e107a","getSendingModules()":"ea13398f","interchain()":"70838975","isAllowedSender(uint256,bytes32)":"dc2b9075","linkRemoteApp(uint256,bytes32)":"51a30802","linkRemoteAppEVM(uint256,address)":"af8fcc8e","owner()":"8da5cb5b","removeTrustedModule(address)":"b70c40b3","renounceOwnership()":"715018a6","sendMessage(uint256,uint256,bytes)":"0ca709ee","setAppConfigV1((uint256,uint256))":"0d32b505","setExecutionService(address)":"496774b1","setInterchainClient(address)":"27efcbb7","transferOwnership(address)":"f2fde38b"}},"solidity/InterchainAppExample.sol:InterchainAppV1":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainAppV1Events.sol\n\nabstract contract InterchainAppV1Events {\n    event AppConfigV1Set(uint256 requiredResponses, uint256 optimisticPeriod);\n    event AppLinked(uint256 indexed chainId, bytes32 indexed remoteApp);\n    event InterchainClientSet(address interchainClient);\n    event ExecutionServiceSet(address executionService);\n    event TrustedModuleAdded(address module);\n    event TrustedModuleRemoved(address module);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    function appReceive(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    uint8 constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint8 version);\n\n    /// @notice Encodes versioned app config into a bytes format.\n    /// @param version      The version of the app config.\n    /// @param appConfig    The app config to encode.\n    function encodeVersionedAppConfig(uint8 version, bytes memory appConfig) internal pure returns (bytes memory) {\n        return abi.encode(version, appConfig);\n    }\n\n    /// @notice Decodes versioned app config from a bytes format back into a version and app config.\n    /// @param data         The versioned app config data in bytes format.\n    /// @return version     The version of the app config.\n    /// @return appConfig   The app config as bytes.\n    function decodeVersionedAppConfig(bytes memory data)\n        internal\n        pure\n        returns (uint8 version, bytes memory appConfig)\n    {\n        (version, appConfig) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return encodeVersionedAppConfig(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal pure returns (AppConfigV1 memory) {\n        (uint8 version, bytes memory appConfig) = decodeVersionedAppConfig(data);\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(appConfig, (AppConfigV1));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    uint8 constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint8 version);\n\n    /// @notice Encodes versioned options into a bytes format.\n    /// @param version      The version of the options.\n    /// @param options      The options to encode.\n    function encodeVersionedOptions(uint8 version, bytes memory options) internal pure returns (bytes memory) {\n        return abi.encode(version, options);\n    }\n\n    /// @notice Decodes versioned options from a bytes format back into a version and options.\n    /// @param data         The versioned options data in bytes format.\n    /// @return version     The version of the options.\n    /// @return options     The options as bytes.\n    function decodeVersionedOptions(bytes memory data) internal pure returns (uint8 version, bytes memory options) {\n        (version, options) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return encodeVersionedOptions(OPTIONS_V1, abi.encode(options));\n    }\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal pure returns (OptionsV1 memory) {\n        (uint8 version, bytes memory options) = decodeVersionedOptions(data);\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(options, (OptionsV1));\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/libs/InterchainTransaction.sol\n\nstruct InterchainTransaction {\n    uint256 srcChainId;\n    bytes32 srcSender;\n    uint256 dstChainId;\n    bytes32 dstReceiver;\n    uint256 dbNonce;\n    uint64 entryIndex;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint256 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    function constructLocalTransaction(\n        address srcSender,\n        uint256 dstChainId,\n        bytes32 dstReceiver,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: block.chainid,\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(transaction);\n    }\n\n    function decodeTransaction(bytes memory encodedTx) internal pure returns (InterchainTransaction memory) {\n        return abi.decode(encodedTx, (InterchainTransaction));\n    }\n\n    function transactionId(InterchainTransaction memory transaction) internal pure returns (bytes32) {\n        return keccak256(abi.encode(transaction));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint256 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__NoLinkedClient(uint256 chainId);\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint256 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint256 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint256 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint256 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint256 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param message              The message being sent.\n    function getInterchainFee(\n        uint256 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint256 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint256 chainId) external view returns (address);\n}\n\n// contracts/apps/InterchainAppV1.sol\n\nabstract contract InterchainAppV1 is InterchainAppV1Events, IInterchainApp {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    // TODO: naming, visibility\n    address public interchain;\n\n    /// @dev Required responses and optimistic period for the module responses.\n    AppConfigV1 private _appConfigV1;\n    /// @dev Address of the linked app deployed on the remote chain.\n    mapping(uint256 chainId =\u003e bytes32 remoteApp) private _linkedApp;\n    /// @dev Trusted Interchain modules.\n    EnumerableSet.AddressSet private _trustedModules;\n    /// @dev Execution Service to use for sending messages.\n    address private _executionService;\n\n    error InterchainApp__BalanceTooLow(uint256 actual, uint256 expected);\n    error InterchainApp__CallerNotInterchainClient(address caller);\n    error InterchainApp__InterchainClientNotSet();\n    error InterchainApp__ModuleAlreadyAdded(address module);\n    error InterchainApp__ModuleNotAdded(address module);\n    error InterchainApp__ReceiverNotSet(uint256 chainId);\n    error InterchainApp__SameChainId(uint256 chainId);\n    error InterchainApp__SenderNotAllowed(uint256 srcChainId, bytes32 sender);\n\n    /// @inheritdoc IInterchainApp\n    function appReceive(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        if (msg.sender != interchain) revert InterchainApp__CallerNotInterchainClient(msg.sender);\n        if (srcChainId == block.chainid) revert InterchainApp__SameChainId(srcChainId);\n        if (!isAllowedSender(srcChainId, sender)) revert InterchainApp__SenderNotAllowed(srcChainId, sender);\n        _receiveMessage(srcChainId, sender, dbNonce, entryIndex, message);\n        // Note: application may elect to emit an event in `_receiveMessage`, so we don't emit a generic event here.\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainApp\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules) {\n        // Note: the getters for app config and modules could be overridden in the derived contracts.\n        appConfig = getAppConfigV1().encodeAppConfigV1();\n        modules = getReceivingModules();\n    }\n\n    /// @notice Returns the app config for receiving messages.\n    /// @dev Could be overridden in the derived contracts.\n    function getAppConfigV1() public view virtual returns (AppConfigV1 memory) {\n        return _appConfigV1;\n    }\n\n    /// @notice Returns the address of the Execution Service to use for sending messages.\n    /// @dev Could be overridden in the derived contracts.\n    function getExecutionService() public view virtual returns (address) {\n        return _executionService;\n    }\n\n    /// @notice Returns the linked app address (as bytes32) for the given chain ID.\n    /// @dev Could be overridden in the derived contracts.\n    function getLinkedApp(uint256 chainId) public view virtual returns (bytes32) {\n        return _linkedApp[chainId];\n    }\n\n    /// @notice Returns the list of modules used for sending messages.\n    /// @dev Could be overridden in the derived contracts.\n    function getSendingModules() public view virtual returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    /// @notice Returns the list of modules used for receiving messages.\n    /// @dev Could be overridden in the derived contracts.\n    function getReceivingModules() public view virtual returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    /// @notice Checks whether the sender is allowed to send messages to the current app.\n    /// @dev Could be overridden in the derived contracts.\n    function isAllowedSender(uint256 srcChainId, bytes32 sender) public view virtual returns (bool) {\n        return _linkedApp[srcChainId] == sender;\n    }\n\n    /// @notice Returns the current app version.\n    /// @dev Could be overridden in the derived contracts.\n    function getAppVersion() public pure virtual returns (uint256) {\n        return 1;\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Links the remote app to the current app.\n    /// Will revert if the chainId is the same as the chainId of the local app.\n    /// Note: Should be guarded with permissions check.\n    function _linkRemoteApp(uint256 chainId, bytes32 remoteApp) internal {\n        if (chainId == block.chainid) revert InterchainApp__SameChainId(chainId);\n        _linkedApp[chainId] = remoteApp;\n        emit AppLinked(chainId, remoteApp);\n    }\n\n    /// @dev Thin wrapper around _linkRemoteApp to accept EVM address as a parameter.\n    function _linkRemoteAppEVM(uint256 chainId, address remoteApp) internal {\n        _linkRemoteApp(chainId, TypeCasts.addressToBytes32(remoteApp));\n    }\n\n    /// @dev Adds the module to the trusted modules set.\n    /// Will revert if the module is already added.\n    /// Note: Should be guarded with permissions check.\n    function _addTrustedModule(address module) internal {\n        bool added = _trustedModules.add(module);\n        if (!added) revert InterchainApp__ModuleAlreadyAdded(module);\n        emit TrustedModuleAdded(module);\n    }\n\n    /// @dev Removes the module from the trusted modules set.\n    /// Will revert if the module is not added.\n    /// Note: Should be guarded with permissions check.\n    function _removeTrustedModule(address module) internal {\n        bool removed = _trustedModules.remove(module);\n        if (!removed) revert InterchainApp__ModuleNotAdded(module);\n        emit TrustedModuleRemoved(module);\n    }\n\n    /// @dev Sets the app config:\n    /// - requiredResponses: the number of module responses required for accepting the message\n    /// - optimisticPeriod: the minimum time after which the module responses are considered final\n    /// Note: Should be guarded with permissions check.\n    function _setAppConfigV1(AppConfigV1 memory appConfig) internal {\n        _appConfigV1 = appConfig;\n        emit AppConfigV1Set(appConfig.requiredResponses, appConfig.optimisticPeriod);\n    }\n\n    /// @dev Sets the execution service address.\n    /// Note: Should be guarded with permissions check.\n    function _setExecutionService(address executionService) internal {\n        _executionService = executionService;\n        emit ExecutionServiceSet(executionService);\n    }\n\n    /// @dev Sets the interchain client address.\n    /// Note: Should be guarded with permissions check.\n    function _setInterchainClient(address interchain_) internal {\n        interchain = interchain_;\n        emit InterchainClientSet(interchain_);\n    }\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to send the message to the linked app.\n    function _sendInterchainMessage(\n        uint256 dstChainId,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _sendInterchainMessage(dstChainId, getLinkedApp(dstChainId), messageFee, options, message);\n    }\n\n    /// @dev Thin wrapper around _sendInterchainMessage to accept EVM address as a parameter.\n    function _sendInterchainMessageEVM(\n        uint256 dstChainId,\n        address receiver,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _sendInterchainMessage(dstChainId, TypeCasts.addressToBytes32(receiver), messageFee, options, message);\n    }\n\n    /// @dev Performs necessary checks and sends an interchain message.\n    function _sendInterchainMessage(\n        uint256 dstChainId,\n        bytes32 receiver,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        address cachedInterchain = interchain;\n//        if (cachedInterchain == address(0)) revert InterchainApp__InterchainClientNotSet();\n//        if (dstChainId == block.chainid) revert InterchainApp__SameChainId(dstChainId);\n//        if (receiver == 0) revert InterchainApp__ReceiverNotSet(dstChainId);\n//        if (address(this).balance \u003c messageFee) revert InterchainApp__BalanceTooLow(address(this).balance, messageFee);\n        return IInterchainClientV1(cachedInterchain).interchainSend{value: messageFee}(\n            dstChainId, receiver, getExecutionService(), getSendingModules(), options.encodeOptionsV1(), message\n        );\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        virtual;\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee for sending an Interchain message.\n    function _getInterchainFee(\n        uint256 dstChainId,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        address cachedInterchain = interchain;\n        if (cachedInterchain == address(0)) revert InterchainApp__InterchainClientNotSet();\n        return IInterchainClientV1(cachedInterchain).getInterchainFee(\n            dstChainId, getExecutionService(), getSendingModules(), options.encodeOptionsV1(), message\n        );\n    }\n}\n\n// contracts/apps/OwnableApp.sol\n\nabstract contract OwnableApp is InterchainAppV1, Ownable {\n    constructor(address owner_) Ownable(owner_) {}\n\n    /// @notice Allows the owner to link the remote app for the given chain ID.\n    /// - This address will be used as the receiver for the messages sent from this chain.\n    /// - This address will be the only trusted sender for the messages sent to this chain.\n    function linkRemoteApp(uint256 chainId, bytes32 remoteApp) external onlyOwner {\n        _linkRemoteApp(chainId, remoteApp);\n    }\n\n    /// @notice This wrapper for `linkRemoteApp` to accept EVM address as a parameter.\n    function linkRemoteAppEVM(uint256 chainId, address remoteApp) external onlyOwner {\n        _linkRemoteAppEVM(chainId, remoteApp);\n    }\n\n    /// @notice Allows the owner to add the module to the trusted modules set.\n    /// - This set of modules will be used to verify message sent from this chain.\n    /// - This set of modules will be used to verify message sent to this chain.\n    function addTrustedModule(address module) external onlyOwner {\n        _addTrustedModule(module);\n    }\n\n    /// @notice Allows the owner to remove the module from the trusted modules set.\n    function removeTrustedModule(address module) external onlyOwner {\n        _removeTrustedModule(module);\n    }\n\n    /// @notice Allows the owner to set the app config for the current app. App config includes:\n    /// - requiredResponses: the number of module responses required for accepting the message\n    /// - optimisticPeriod: the minimum time after which the module responses are considered final\n    function setAppConfigV1(AppConfigV1 memory appConfig) external onlyOwner {\n        _setAppConfigV1(appConfig);\n    }\n\n    /// @notice Allows the owner to set the address of the Execution Service.\n    /// This address will be used to request execution of the messages sent from this chain,\n    /// by supplying the Service's execution fee.\n    function setExecutionService(address executionService) external onlyOwner {\n        _setExecutionService(executionService);\n    }\n\n    /// @notice Allows the owner to set the address of the InterchainClient contract.\n    function setInterchainClient(address interchain_) external onlyOwner {\n        _setInterchainClient(interchain_);\n    }\n}\n\n// contracts/apps/InterchainAppExample.sol\n\ncontract InterchainAppExample is OwnableApp {\n    event MessageReceived(uint256 srcChainId, bytes32 sender, uint256 dbNonce, uint64 entryIndex, bytes message);\n    event MessageSent(uint256 dstChainId, uint256 dbNonce, uint64 entryIndex, bytes32 transactionId);\n\n    constructor(address owner_) OwnableApp(owner_) {}\n\n    /// @notice Sends a basic message to the destination chain.\n    function sendMessage(uint256 dstChainId, uint256 gasLimit, bytes calldata message) external payable {\n        InterchainTxDescriptor memory desc = _sendInterchainMessage({\n            dstChainId: dstChainId,\n            messageFee: msg.value,\n            options: OptionsV1({gasLimit: gasLimit, gasAirdrop: 0}),\n            message: message\n        });\n        emit MessageSent(dstChainId, desc.dbNonce, desc.entryIndex, desc.transactionId);\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        override\n    {\n        emit MessageReceived(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"uint256","name":"actual","type":"uint256"},{"internalType":"uint256","name":"expected","type":"uint256"}],"name":"InterchainApp__BalanceTooLow","type":"error"},{"inputs":[{"internalType":"address","name":"caller","type":"address"}],"name":"InterchainApp__CallerNotInterchainClient","type":"error"},{"inputs":[],"name":"InterchainApp__InterchainClientNotSet","type":"error"},{"inputs":[{"internalType":"address","name":"module","type":"address"}],"name":"InterchainApp__ModuleAlreadyAdded","type":"error"},{"inputs":[{"internalType":"address","name":"module","type":"address"}],"name":"InterchainApp__ModuleNotAdded","type":"error"},{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"}],"name":"InterchainApp__ReceiverNotSet","type":"error"},{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"}],"name":"InterchainApp__SameChainId","type":"error"},{"inputs":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"bytes32","name":"sender","type":"bytes32"}],"name":"InterchainApp__SenderNotAllowed","type":"error"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"requiredResponses","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"optimisticPeriod","type":"uint256"}],"name":"AppConfigV1Set","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"chainId","type":"uint256"},{"indexed":true,"internalType":"bytes32","name":"remoteApp","type":"bytes32"}],"name":"AppLinked","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"executionService","type":"address"}],"name":"ExecutionServiceSet","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"interchainClient","type":"address"}],"name":"InterchainClientSet","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"module","type":"address"}],"name":"TrustedModuleAdded","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"module","type":"address"}],"name":"TrustedModuleRemoved","type":"event"},{"inputs":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"bytes32","name":"sender","type":"bytes32"},{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"uint64","name":"entryIndex","type":"uint64"},{"internalType":"bytes","name":"message","type":"bytes"}],"name":"appReceive","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"getAppConfigV1","outputs":[{"components":[{"internalType":"uint256","name":"requiredResponses","type":"uint256"},{"internalType":"uint256","name":"optimisticPeriod","type":"uint256"}],"internalType":"struct AppConfigV1","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getAppVersion","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"getExecutionService","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"}],"name":"getLinkedApp","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getReceivingConfig","outputs":[{"internalType":"bytes","name":"appConfig","type":"bytes"},{"internalType":"address[]","name":"modules","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getReceivingModules","outputs":[{"internalType":"address[]","name":"","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getSendingModules","outputs":[{"internalType":"address[]","name":"","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"interchain","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"bytes32","name":"sender","type":"bytes32"}],"name":"isAllowedSender","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"}],"userDoc":{"kind":"user","methods":{"getAppConfigV1()":{"notice":"Returns the app config for receiving messages."},"getAppVersion()":{"notice":"Returns the current app version."},"getExecutionService()":{"notice":"Returns the address of the Execution Service to use for sending messages."},"getLinkedApp(uint256)":{"notice":"Returns the linked app address (as bytes32) for the given chain ID."},"getReceivingModules()":{"notice":"Returns the list of modules used for receiving messages."},"getSendingModules()":{"notice":"Returns the list of modules used for sending messages."},"isAllowedSender(uint256,bytes32)":{"notice":"Checks whether the sender is allowed to send messages to the current app."}},"version":1},"developerDoc":{"kind":"dev","methods":{"getAppConfigV1()":{"details":"Could be overridden in the derived contracts."},"getAppVersion()":{"details":"Could be overridden in the derived contracts."},"getExecutionService()":{"details":"Could be overridden in the derived contracts."},"getLinkedApp(uint256)":{"details":"Could be overridden in the derived contracts."},"getReceivingModules()":{"details":"Could be overridden in the derived contracts."},"getSendingModules()":{"details":"Could be overridden in the derived contracts."},"isAllowedSender(uint256,bytes32)":{"details":"Could be overridden in the derived contracts."}},"stateVariables":{"_appConfigV1":{"details":"Required responses and optimistic period for the module responses."},"_executionService":{"details":"Execution Service to use for sending messages."},"_linkedApp":{"details":"Address of the linked app deployed on the remote chain."},"_trustedModules":{"details":"Trusted Interchain modules."}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expected\",\"type\":\"uint256\"}],\"name\":\"InterchainApp__BalanceTooLow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"InterchainApp__CallerNotInterchainClient\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InterchainApp__InterchainClientNotSet\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"InterchainApp__ModuleAlreadyAdded\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"InterchainApp__ModuleNotAdded\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"InterchainApp__ReceiverNotSet\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"InterchainApp__SameChainId\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"}],\"name\":\"InterchainApp__SenderNotAllowed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requiredResponses\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"optimisticPeriod\",\"type\":\"uint256\"}],\"name\":\"AppConfigV1Set\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"remoteApp\",\"type\":\"bytes32\"}],\"name\":\"AppLinked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"executionService\",\"type\":\"address\"}],\"name\":\"ExecutionServiceSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"interchainClient\",\"type\":\"address\"}],\"name\":\"InterchainClientSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"TrustedModuleAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"TrustedModuleRemoved\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"appReceive\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAppConfigV1\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"requiredResponses\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"optimisticPeriod\",\"type\":\"uint256\"}],\"internalType\":\"struct AppConfigV1\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAppVersion\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getExecutionService\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"getLinkedApp\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReceivingConfig\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"appConfig\",\"type\":\"bytes\"},{\"internalType\":\"address[]\",\"name\":\"modules\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReceivingModules\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSendingModules\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"interchain\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"}],\"name\":\"isAllowedSender\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"getAppConfigV1()\":{\"details\":\"Could be overridden in the derived contracts.\"},\"getAppVersion()\":{\"details\":\"Could be overridden in the derived contracts.\"},\"getExecutionService()\":{\"details\":\"Could be overridden in the derived contracts.\"},\"getLinkedApp(uint256)\":{\"details\":\"Could be overridden in the derived contracts.\"},\"getReceivingModules()\":{\"details\":\"Could be overridden in the derived contracts.\"},\"getSendingModules()\":{\"details\":\"Could be overridden in the derived contracts.\"},\"isAllowedSender(uint256,bytes32)\":{\"details\":\"Could be overridden in the derived contracts.\"}},\"stateVariables\":{\"_appConfigV1\":{\"details\":\"Required responses and optimistic period for the module responses.\"},\"_executionService\":{\"details\":\"Execution Service to use for sending messages.\"},\"_linkedApp\":{\"details\":\"Address of the linked app deployed on the remote chain.\"},\"_trustedModules\":{\"details\":\"Trusted Interchain modules.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"getAppConfigV1()\":{\"notice\":\"Returns the app config for receiving messages.\"},\"getAppVersion()\":{\"notice\":\"Returns the current app version.\"},\"getExecutionService()\":{\"notice\":\"Returns the address of the Execution Service to use for sending messages.\"},\"getLinkedApp(uint256)\":{\"notice\":\"Returns the linked app address (as bytes32) for the given chain ID.\"},\"getReceivingModules()\":{\"notice\":\"Returns the list of modules used for receiving messages.\"},\"getSendingModules()\":{\"notice\":\"Returns the list of modules used for sending messages.\"},\"isAllowedSender(uint256,bytes32)\":{\"notice\":\"Checks whether the sender is allowed to send messages to the current app.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainAppExample.sol\":\"InterchainAppV1\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainAppExample.sol\":{\"keccak256\":\"0x86f91eccd427db2c0e6cbbdb2244f577ed8111343e9ad8aa6476b8b0bd7cb65c\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://c9a5bce8ffbdc1808235baa92fe6b0fff964c26898bb155a1b06e5ea3e4f3940\",\"dweb:/ipfs/QmZqjYVRz4JL5Pjz9TZqVSy7PUZGsabLKsxtHXP44i3TVK\"]}},\"version\":1}"},"hashes":{"appReceive(uint256,bytes32,uint256,uint64,bytes)":"68a69847","getAppConfigV1()":"7717a647","getAppVersion()":"a20ce510","getExecutionService()":"c313c807","getLinkedApp(uint256)":"b9b74b18","getReceivingConfig()":"287bc057","getReceivingModules()":"a45e107a","getSendingModules()":"ea13398f","interchain()":"70838975","isAllowedSender(uint256,bytes32)":"dc2b9075"}},"solidity/InterchainAppExample.sol:InterchainAppV1Events":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainAppV1Events.sol\n\nabstract contract InterchainAppV1Events {\n    event AppConfigV1Set(uint256 requiredResponses, uint256 optimisticPeriod);\n    event AppLinked(uint256 indexed chainId, bytes32 indexed remoteApp);\n    event InterchainClientSet(address interchainClient);\n    event ExecutionServiceSet(address executionService);\n    event TrustedModuleAdded(address module);\n    event TrustedModuleRemoved(address module);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    function appReceive(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    uint8 constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint8 version);\n\n    /// @notice Encodes versioned app config into a bytes format.\n    /// @param version      The version of the app config.\n    /// @param appConfig    The app config to encode.\n    function encodeVersionedAppConfig(uint8 version, bytes memory appConfig) internal pure returns (bytes memory) {\n        return abi.encode(version, appConfig);\n    }\n\n    /// @notice Decodes versioned app config from a bytes format back into a version and app config.\n    /// @param data         The versioned app config data in bytes format.\n    /// @return version     The version of the app config.\n    /// @return appConfig   The app config as bytes.\n    function decodeVersionedAppConfig(bytes memory data)\n        internal\n        pure\n        returns (uint8 version, bytes memory appConfig)\n    {\n        (version, appConfig) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return encodeVersionedAppConfig(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal pure returns (AppConfigV1 memory) {\n        (uint8 version, bytes memory appConfig) = decodeVersionedAppConfig(data);\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(appConfig, (AppConfigV1));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    uint8 constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint8 version);\n\n    /// @notice Encodes versioned options into a bytes format.\n    /// @param version      The version of the options.\n    /// @param options      The options to encode.\n    function encodeVersionedOptions(uint8 version, bytes memory options) internal pure returns (bytes memory) {\n        return abi.encode(version, options);\n    }\n\n    /// @notice Decodes versioned options from a bytes format back into a version and options.\n    /// @param data         The versioned options data in bytes format.\n    /// @return version     The version of the options.\n    /// @return options     The options as bytes.\n    function decodeVersionedOptions(bytes memory data) internal pure returns (uint8 version, bytes memory options) {\n        (version, options) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return encodeVersionedOptions(OPTIONS_V1, abi.encode(options));\n    }\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal pure returns (OptionsV1 memory) {\n        (uint8 version, bytes memory options) = decodeVersionedOptions(data);\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(options, (OptionsV1));\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/libs/InterchainTransaction.sol\n\nstruct InterchainTransaction {\n    uint256 srcChainId;\n    bytes32 srcSender;\n    uint256 dstChainId;\n    bytes32 dstReceiver;\n    uint256 dbNonce;\n    uint64 entryIndex;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint256 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    function constructLocalTransaction(\n        address srcSender,\n        uint256 dstChainId,\n        bytes32 dstReceiver,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: block.chainid,\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(transaction);\n    }\n\n    function decodeTransaction(bytes memory encodedTx) internal pure returns (InterchainTransaction memory) {\n        return abi.decode(encodedTx, (InterchainTransaction));\n    }\n\n    function transactionId(InterchainTransaction memory transaction) internal pure returns (bytes32) {\n        return keccak256(abi.encode(transaction));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint256 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__NoLinkedClient(uint256 chainId);\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint256 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint256 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint256 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint256 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint256 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param message              The message being sent.\n    function getInterchainFee(\n        uint256 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint256 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint256 chainId) external view returns (address);\n}\n\n// contracts/apps/InterchainAppV1.sol\n\nabstract contract InterchainAppV1 is InterchainAppV1Events, IInterchainApp {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    // TODO: naming, visibility\n    address public interchain;\n\n    /// @dev Required responses and optimistic period for the module responses.\n    AppConfigV1 private _appConfigV1;\n    /// @dev Address of the linked app deployed on the remote chain.\n    mapping(uint256 chainId =\u003e bytes32 remoteApp) private _linkedApp;\n    /// @dev Trusted Interchain modules.\n    EnumerableSet.AddressSet private _trustedModules;\n    /// @dev Execution Service to use for sending messages.\n    address private _executionService;\n\n    error InterchainApp__BalanceTooLow(uint256 actual, uint256 expected);\n    error InterchainApp__CallerNotInterchainClient(address caller);\n    error InterchainApp__InterchainClientNotSet();\n    error InterchainApp__ModuleAlreadyAdded(address module);\n    error InterchainApp__ModuleNotAdded(address module);\n    error InterchainApp__ReceiverNotSet(uint256 chainId);\n    error InterchainApp__SameChainId(uint256 chainId);\n    error InterchainApp__SenderNotAllowed(uint256 srcChainId, bytes32 sender);\n\n    /// @inheritdoc IInterchainApp\n    function appReceive(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        if (msg.sender != interchain) revert InterchainApp__CallerNotInterchainClient(msg.sender);\n        if (srcChainId == block.chainid) revert InterchainApp__SameChainId(srcChainId);\n        if (!isAllowedSender(srcChainId, sender)) revert InterchainApp__SenderNotAllowed(srcChainId, sender);\n        _receiveMessage(srcChainId, sender, dbNonce, entryIndex, message);\n        // Note: application may elect to emit an event in `_receiveMessage`, so we don't emit a generic event here.\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainApp\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules) {\n        // Note: the getters for app config and modules could be overridden in the derived contracts.\n        appConfig = getAppConfigV1().encodeAppConfigV1();\n        modules = getReceivingModules();\n    }\n\n    /// @notice Returns the app config for receiving messages.\n    /// @dev Could be overridden in the derived contracts.\n    function getAppConfigV1() public view virtual returns (AppConfigV1 memory) {\n        return _appConfigV1;\n    }\n\n    /// @notice Returns the address of the Execution Service to use for sending messages.\n    /// @dev Could be overridden in the derived contracts.\n    function getExecutionService() public view virtual returns (address) {\n        return _executionService;\n    }\n\n    /// @notice Returns the linked app address (as bytes32) for the given chain ID.\n    /// @dev Could be overridden in the derived contracts.\n    function getLinkedApp(uint256 chainId) public view virtual returns (bytes32) {\n        return _linkedApp[chainId];\n    }\n\n    /// @notice Returns the list of modules used for sending messages.\n    /// @dev Could be overridden in the derived contracts.\n    function getSendingModules() public view virtual returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    /// @notice Returns the list of modules used for receiving messages.\n    /// @dev Could be overridden in the derived contracts.\n    function getReceivingModules() public view virtual returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    /// @notice Checks whether the sender is allowed to send messages to the current app.\n    /// @dev Could be overridden in the derived contracts.\n    function isAllowedSender(uint256 srcChainId, bytes32 sender) public view virtual returns (bool) {\n        return _linkedApp[srcChainId] == sender;\n    }\n\n    /// @notice Returns the current app version.\n    /// @dev Could be overridden in the derived contracts.\n    function getAppVersion() public pure virtual returns (uint256) {\n        return 1;\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Links the remote app to the current app.\n    /// Will revert if the chainId is the same as the chainId of the local app.\n    /// Note: Should be guarded with permissions check.\n    function _linkRemoteApp(uint256 chainId, bytes32 remoteApp) internal {\n        if (chainId == block.chainid) revert InterchainApp__SameChainId(chainId);\n        _linkedApp[chainId] = remoteApp;\n        emit AppLinked(chainId, remoteApp);\n    }\n\n    /// @dev Thin wrapper around _linkRemoteApp to accept EVM address as a parameter.\n    function _linkRemoteAppEVM(uint256 chainId, address remoteApp) internal {\n        _linkRemoteApp(chainId, TypeCasts.addressToBytes32(remoteApp));\n    }\n\n    /// @dev Adds the module to the trusted modules set.\n    /// Will revert if the module is already added.\n    /// Note: Should be guarded with permissions check.\n    function _addTrustedModule(address module) internal {\n        bool added = _trustedModules.add(module);\n        if (!added) revert InterchainApp__ModuleAlreadyAdded(module);\n        emit TrustedModuleAdded(module);\n    }\n\n    /// @dev Removes the module from the trusted modules set.\n    /// Will revert if the module is not added.\n    /// Note: Should be guarded with permissions check.\n    function _removeTrustedModule(address module) internal {\n        bool removed = _trustedModules.remove(module);\n        if (!removed) revert InterchainApp__ModuleNotAdded(module);\n        emit TrustedModuleRemoved(module);\n    }\n\n    /// @dev Sets the app config:\n    /// - requiredResponses: the number of module responses required for accepting the message\n    /// - optimisticPeriod: the minimum time after which the module responses are considered final\n    /// Note: Should be guarded with permissions check.\n    function _setAppConfigV1(AppConfigV1 memory appConfig) internal {\n        _appConfigV1 = appConfig;\n        emit AppConfigV1Set(appConfig.requiredResponses, appConfig.optimisticPeriod);\n    }\n\n    /// @dev Sets the execution service address.\n    /// Note: Should be guarded with permissions check.\n    function _setExecutionService(address executionService) internal {\n        _executionService = executionService;\n        emit ExecutionServiceSet(executionService);\n    }\n\n    /// @dev Sets the interchain client address.\n    /// Note: Should be guarded with permissions check.\n    function _setInterchainClient(address interchain_) internal {\n        interchain = interchain_;\n        emit InterchainClientSet(interchain_);\n    }\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to send the message to the linked app.\n    function _sendInterchainMessage(\n        uint256 dstChainId,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _sendInterchainMessage(dstChainId, getLinkedApp(dstChainId), messageFee, options, message);\n    }\n\n    /// @dev Thin wrapper around _sendInterchainMessage to accept EVM address as a parameter.\n    function _sendInterchainMessageEVM(\n        uint256 dstChainId,\n        address receiver,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _sendInterchainMessage(dstChainId, TypeCasts.addressToBytes32(receiver), messageFee, options, message);\n    }\n\n    /// @dev Performs necessary checks and sends an interchain message.\n    function _sendInterchainMessage(\n        uint256 dstChainId,\n        bytes32 receiver,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        address cachedInterchain = interchain;\n//        if (cachedInterchain == address(0)) revert InterchainApp__InterchainClientNotSet();\n//        if (dstChainId == block.chainid) revert InterchainApp__SameChainId(dstChainId);\n//        if (receiver == 0) revert InterchainApp__ReceiverNotSet(dstChainId);\n//        if (address(this).balance \u003c messageFee) revert InterchainApp__BalanceTooLow(address(this).balance, messageFee);\n        return IInterchainClientV1(cachedInterchain).interchainSend{value: messageFee}(\n            dstChainId, receiver, getExecutionService(), getSendingModules(), options.encodeOptionsV1(), message\n        );\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        virtual;\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee for sending an Interchain message.\n    function _getInterchainFee(\n        uint256 dstChainId,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        address cachedInterchain = interchain;\n        if (cachedInterchain == address(0)) revert InterchainApp__InterchainClientNotSet();\n        return IInterchainClientV1(cachedInterchain).getInterchainFee(\n            dstChainId, getExecutionService(), getSendingModules(), options.encodeOptionsV1(), message\n        );\n    }\n}\n\n// contracts/apps/OwnableApp.sol\n\nabstract contract OwnableApp is InterchainAppV1, Ownable {\n    constructor(address owner_) Ownable(owner_) {}\n\n    /// @notice Allows the owner to link the remote app for the given chain ID.\n    /// - This address will be used as the receiver for the messages sent from this chain.\n    /// - This address will be the only trusted sender for the messages sent to this chain.\n    function linkRemoteApp(uint256 chainId, bytes32 remoteApp) external onlyOwner {\n        _linkRemoteApp(chainId, remoteApp);\n    }\n\n    /// @notice This wrapper for `linkRemoteApp` to accept EVM address as a parameter.\n    function linkRemoteAppEVM(uint256 chainId, address remoteApp) external onlyOwner {\n        _linkRemoteAppEVM(chainId, remoteApp);\n    }\n\n    /// @notice Allows the owner to add the module to the trusted modules set.\n    /// - This set of modules will be used to verify message sent from this chain.\n    /// - This set of modules will be used to verify message sent to this chain.\n    function addTrustedModule(address module) external onlyOwner {\n        _addTrustedModule(module);\n    }\n\n    /// @notice Allows the owner to remove the module from the trusted modules set.\n    function removeTrustedModule(address module) external onlyOwner {\n        _removeTrustedModule(module);\n    }\n\n    /// @notice Allows the owner to set the app config for the current app. App config includes:\n    /// - requiredResponses: the number of module responses required for accepting the message\n    /// - optimisticPeriod: the minimum time after which the module responses are considered final\n    function setAppConfigV1(AppConfigV1 memory appConfig) external onlyOwner {\n        _setAppConfigV1(appConfig);\n    }\n\n    /// @notice Allows the owner to set the address of the Execution Service.\n    /// This address will be used to request execution of the messages sent from this chain,\n    /// by supplying the Service's execution fee.\n    function setExecutionService(address executionService) external onlyOwner {\n        _setExecutionService(executionService);\n    }\n\n    /// @notice Allows the owner to set the address of the InterchainClient contract.\n    function setInterchainClient(address interchain_) external onlyOwner {\n        _setInterchainClient(interchain_);\n    }\n}\n\n// contracts/apps/InterchainAppExample.sol\n\ncontract InterchainAppExample is OwnableApp {\n    event MessageReceived(uint256 srcChainId, bytes32 sender, uint256 dbNonce, uint64 entryIndex, bytes message);\n    event MessageSent(uint256 dstChainId, uint256 dbNonce, uint64 entryIndex, bytes32 transactionId);\n\n    constructor(address owner_) OwnableApp(owner_) {}\n\n    /// @notice Sends a basic message to the destination chain.\n    function sendMessage(uint256 dstChainId, uint256 gasLimit, bytes calldata message) external payable {\n        InterchainTxDescriptor memory desc = _sendInterchainMessage({\n            dstChainId: dstChainId,\n            messageFee: msg.value,\n            options: OptionsV1({gasLimit: gasLimit, gasAirdrop: 0}),\n            message: message\n        });\n        emit MessageSent(dstChainId, desc.dbNonce, desc.entryIndex, desc.transactionId);\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        override\n    {\n        emit MessageReceived(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"requiredResponses","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"optimisticPeriod","type":"uint256"}],"name":"AppConfigV1Set","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"chainId","type":"uint256"},{"indexed":true,"internalType":"bytes32","name":"remoteApp","type":"bytes32"}],"name":"AppLinked","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"executionService","type":"address"}],"name":"ExecutionServiceSet","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"interchainClient","type":"address"}],"name":"InterchainClientSet","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"module","type":"address"}],"name":"TrustedModuleAdded","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"module","type":"address"}],"name":"TrustedModuleRemoved","type":"event"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requiredResponses\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"optimisticPeriod\",\"type\":\"uint256\"}],\"name\":\"AppConfigV1Set\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"remoteApp\",\"type\":\"bytes32\"}],\"name\":\"AppLinked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"executionService\",\"type\":\"address\"}],\"name\":\"ExecutionServiceSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"interchainClient\",\"type\":\"address\"}],\"name\":\"InterchainClientSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"TrustedModuleAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"TrustedModuleRemoved\",\"type\":\"event\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainAppExample.sol\":\"InterchainAppV1Events\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainAppExample.sol\":{\"keccak256\":\"0x86f91eccd427db2c0e6cbbdb2244f577ed8111343e9ad8aa6476b8b0bd7cb65c\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://c9a5bce8ffbdc1808235baa92fe6b0fff964c26898bb155a1b06e5ea3e4f3940\",\"dweb:/ipfs/QmZqjYVRz4JL5Pjz9TZqVSy7PUZGsabLKsxtHXP44i3TVK\"]}},\"version\":1}"},"hashes":{}},"solidity/InterchainAppExample.sol:InterchainTransactionLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212200266f504ae0cb4fe549168bfb1a2f2855f00026d29c4a1a418569df55aee0d2664736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212200266f504ae0cb4fe549168bfb1a2f2855f00026d29c4a1a418569df55aee0d2664736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainAppV1Events.sol\n\nabstract contract InterchainAppV1Events {\n    event AppConfigV1Set(uint256 requiredResponses, uint256 optimisticPeriod);\n    event AppLinked(uint256 indexed chainId, bytes32 indexed remoteApp);\n    event InterchainClientSet(address interchainClient);\n    event ExecutionServiceSet(address executionService);\n    event TrustedModuleAdded(address module);\n    event TrustedModuleRemoved(address module);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    function appReceive(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    uint8 constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint8 version);\n\n    /// @notice Encodes versioned app config into a bytes format.\n    /// @param version      The version of the app config.\n    /// @param appConfig    The app config to encode.\n    function encodeVersionedAppConfig(uint8 version, bytes memory appConfig) internal pure returns (bytes memory) {\n        return abi.encode(version, appConfig);\n    }\n\n    /// @notice Decodes versioned app config from a bytes format back into a version and app config.\n    /// @param data         The versioned app config data in bytes format.\n    /// @return version     The version of the app config.\n    /// @return appConfig   The app config as bytes.\n    function decodeVersionedAppConfig(bytes memory data)\n        internal\n        pure\n        returns (uint8 version, bytes memory appConfig)\n    {\n        (version, appConfig) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return encodeVersionedAppConfig(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal pure returns (AppConfigV1 memory) {\n        (uint8 version, bytes memory appConfig) = decodeVersionedAppConfig(data);\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(appConfig, (AppConfigV1));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    uint8 constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint8 version);\n\n    /// @notice Encodes versioned options into a bytes format.\n    /// @param version      The version of the options.\n    /// @param options      The options to encode.\n    function encodeVersionedOptions(uint8 version, bytes memory options) internal pure returns (bytes memory) {\n        return abi.encode(version, options);\n    }\n\n    /// @notice Decodes versioned options from a bytes format back into a version and options.\n    /// @param data         The versioned options data in bytes format.\n    /// @return version     The version of the options.\n    /// @return options     The options as bytes.\n    function decodeVersionedOptions(bytes memory data) internal pure returns (uint8 version, bytes memory options) {\n        (version, options) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return encodeVersionedOptions(OPTIONS_V1, abi.encode(options));\n    }\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal pure returns (OptionsV1 memory) {\n        (uint8 version, bytes memory options) = decodeVersionedOptions(data);\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(options, (OptionsV1));\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/libs/InterchainTransaction.sol\n\nstruct InterchainTransaction {\n    uint256 srcChainId;\n    bytes32 srcSender;\n    uint256 dstChainId;\n    bytes32 dstReceiver;\n    uint256 dbNonce;\n    uint64 entryIndex;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint256 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    function constructLocalTransaction(\n        address srcSender,\n        uint256 dstChainId,\n        bytes32 dstReceiver,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: block.chainid,\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(transaction);\n    }\n\n    function decodeTransaction(bytes memory encodedTx) internal pure returns (InterchainTransaction memory) {\n        return abi.decode(encodedTx, (InterchainTransaction));\n    }\n\n    function transactionId(InterchainTransaction memory transaction) internal pure returns (bytes32) {\n        return keccak256(abi.encode(transaction));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint256 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__NoLinkedClient(uint256 chainId);\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint256 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint256 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint256 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint256 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint256 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param message              The message being sent.\n    function getInterchainFee(\n        uint256 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint256 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint256 chainId) external view returns (address);\n}\n\n// contracts/apps/InterchainAppV1.sol\n\nabstract contract InterchainAppV1 is InterchainAppV1Events, IInterchainApp {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    // TODO: naming, visibility\n    address public interchain;\n\n    /// @dev Required responses and optimistic period for the module responses.\n    AppConfigV1 private _appConfigV1;\n    /// @dev Address of the linked app deployed on the remote chain.\n    mapping(uint256 chainId =\u003e bytes32 remoteApp) private _linkedApp;\n    /// @dev Trusted Interchain modules.\n    EnumerableSet.AddressSet private _trustedModules;\n    /// @dev Execution Service to use for sending messages.\n    address private _executionService;\n\n    error InterchainApp__BalanceTooLow(uint256 actual, uint256 expected);\n    error InterchainApp__CallerNotInterchainClient(address caller);\n    error InterchainApp__InterchainClientNotSet();\n    error InterchainApp__ModuleAlreadyAdded(address module);\n    error InterchainApp__ModuleNotAdded(address module);\n    error InterchainApp__ReceiverNotSet(uint256 chainId);\n    error InterchainApp__SameChainId(uint256 chainId);\n    error InterchainApp__SenderNotAllowed(uint256 srcChainId, bytes32 sender);\n\n    /// @inheritdoc IInterchainApp\n    function appReceive(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        if (msg.sender != interchain) revert InterchainApp__CallerNotInterchainClient(msg.sender);\n        if (srcChainId == block.chainid) revert InterchainApp__SameChainId(srcChainId);\n        if (!isAllowedSender(srcChainId, sender)) revert InterchainApp__SenderNotAllowed(srcChainId, sender);\n        _receiveMessage(srcChainId, sender, dbNonce, entryIndex, message);\n        // Note: application may elect to emit an event in `_receiveMessage`, so we don't emit a generic event here.\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainApp\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules) {\n        // Note: the getters for app config and modules could be overridden in the derived contracts.\n        appConfig = getAppConfigV1().encodeAppConfigV1();\n        modules = getReceivingModules();\n    }\n\n    /// @notice Returns the app config for receiving messages.\n    /// @dev Could be overridden in the derived contracts.\n    function getAppConfigV1() public view virtual returns (AppConfigV1 memory) {\n        return _appConfigV1;\n    }\n\n    /// @notice Returns the address of the Execution Service to use for sending messages.\n    /// @dev Could be overridden in the derived contracts.\n    function getExecutionService() public view virtual returns (address) {\n        return _executionService;\n    }\n\n    /// @notice Returns the linked app address (as bytes32) for the given chain ID.\n    /// @dev Could be overridden in the derived contracts.\n    function getLinkedApp(uint256 chainId) public view virtual returns (bytes32) {\n        return _linkedApp[chainId];\n    }\n\n    /// @notice Returns the list of modules used for sending messages.\n    /// @dev Could be overridden in the derived contracts.\n    function getSendingModules() public view virtual returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    /// @notice Returns the list of modules used for receiving messages.\n    /// @dev Could be overridden in the derived contracts.\n    function getReceivingModules() public view virtual returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    /// @notice Checks whether the sender is allowed to send messages to the current app.\n    /// @dev Could be overridden in the derived contracts.\n    function isAllowedSender(uint256 srcChainId, bytes32 sender) public view virtual returns (bool) {\n        return _linkedApp[srcChainId] == sender;\n    }\n\n    /// @notice Returns the current app version.\n    /// @dev Could be overridden in the derived contracts.\n    function getAppVersion() public pure virtual returns (uint256) {\n        return 1;\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Links the remote app to the current app.\n    /// Will revert if the chainId is the same as the chainId of the local app.\n    /// Note: Should be guarded with permissions check.\n    function _linkRemoteApp(uint256 chainId, bytes32 remoteApp) internal {\n        if (chainId == block.chainid) revert InterchainApp__SameChainId(chainId);\n        _linkedApp[chainId] = remoteApp;\n        emit AppLinked(chainId, remoteApp);\n    }\n\n    /// @dev Thin wrapper around _linkRemoteApp to accept EVM address as a parameter.\n    function _linkRemoteAppEVM(uint256 chainId, address remoteApp) internal {\n        _linkRemoteApp(chainId, TypeCasts.addressToBytes32(remoteApp));\n    }\n\n    /// @dev Adds the module to the trusted modules set.\n    /// Will revert if the module is already added.\n    /// Note: Should be guarded with permissions check.\n    function _addTrustedModule(address module) internal {\n        bool added = _trustedModules.add(module);\n        if (!added) revert InterchainApp__ModuleAlreadyAdded(module);\n        emit TrustedModuleAdded(module);\n    }\n\n    /// @dev Removes the module from the trusted modules set.\n    /// Will revert if the module is not added.\n    /// Note: Should be guarded with permissions check.\n    function _removeTrustedModule(address module) internal {\n        bool removed = _trustedModules.remove(module);\n        if (!removed) revert InterchainApp__ModuleNotAdded(module);\n        emit TrustedModuleRemoved(module);\n    }\n\n    /// @dev Sets the app config:\n    /// - requiredResponses: the number of module responses required for accepting the message\n    /// - optimisticPeriod: the minimum time after which the module responses are considered final\n    /// Note: Should be guarded with permissions check.\n    function _setAppConfigV1(AppConfigV1 memory appConfig) internal {\n        _appConfigV1 = appConfig;\n        emit AppConfigV1Set(appConfig.requiredResponses, appConfig.optimisticPeriod);\n    }\n\n    /// @dev Sets the execution service address.\n    /// Note: Should be guarded with permissions check.\n    function _setExecutionService(address executionService) internal {\n        _executionService = executionService;\n        emit ExecutionServiceSet(executionService);\n    }\n\n    /// @dev Sets the interchain client address.\n    /// Note: Should be guarded with permissions check.\n    function _setInterchainClient(address interchain_) internal {\n        interchain = interchain_;\n        emit InterchainClientSet(interchain_);\n    }\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to send the message to the linked app.\n    function _sendInterchainMessage(\n        uint256 dstChainId,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _sendInterchainMessage(dstChainId, getLinkedApp(dstChainId), messageFee, options, message);\n    }\n\n    /// @dev Thin wrapper around _sendInterchainMessage to accept EVM address as a parameter.\n    function _sendInterchainMessageEVM(\n        uint256 dstChainId,\n        address receiver,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _sendInterchainMessage(dstChainId, TypeCasts.addressToBytes32(receiver), messageFee, options, message);\n    }\n\n    /// @dev Performs necessary checks and sends an interchain message.\n    function _sendInterchainMessage(\n        uint256 dstChainId,\n        bytes32 receiver,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        address cachedInterchain = interchain;\n//        if (cachedInterchain == address(0)) revert InterchainApp__InterchainClientNotSet();\n//        if (dstChainId == block.chainid) revert InterchainApp__SameChainId(dstChainId);\n//        if (receiver == 0) revert InterchainApp__ReceiverNotSet(dstChainId);\n//        if (address(this).balance \u003c messageFee) revert InterchainApp__BalanceTooLow(address(this).balance, messageFee);\n        return IInterchainClientV1(cachedInterchain).interchainSend{value: messageFee}(\n            dstChainId, receiver, getExecutionService(), getSendingModules(), options.encodeOptionsV1(), message\n        );\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        virtual;\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee for sending an Interchain message.\n    function _getInterchainFee(\n        uint256 dstChainId,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        address cachedInterchain = interchain;\n        if (cachedInterchain == address(0)) revert InterchainApp__InterchainClientNotSet();\n        return IInterchainClientV1(cachedInterchain).getInterchainFee(\n            dstChainId, getExecutionService(), getSendingModules(), options.encodeOptionsV1(), message\n        );\n    }\n}\n\n// contracts/apps/OwnableApp.sol\n\nabstract contract OwnableApp is InterchainAppV1, Ownable {\n    constructor(address owner_) Ownable(owner_) {}\n\n    /// @notice Allows the owner to link the remote app for the given chain ID.\n    /// - This address will be used as the receiver for the messages sent from this chain.\n    /// - This address will be the only trusted sender for the messages sent to this chain.\n    function linkRemoteApp(uint256 chainId, bytes32 remoteApp) external onlyOwner {\n        _linkRemoteApp(chainId, remoteApp);\n    }\n\n    /// @notice This wrapper for `linkRemoteApp` to accept EVM address as a parameter.\n    function linkRemoteAppEVM(uint256 chainId, address remoteApp) external onlyOwner {\n        _linkRemoteAppEVM(chainId, remoteApp);\n    }\n\n    /// @notice Allows the owner to add the module to the trusted modules set.\n    /// - This set of modules will be used to verify message sent from this chain.\n    /// - This set of modules will be used to verify message sent to this chain.\n    function addTrustedModule(address module) external onlyOwner {\n        _addTrustedModule(module);\n    }\n\n    /// @notice Allows the owner to remove the module from the trusted modules set.\n    function removeTrustedModule(address module) external onlyOwner {\n        _removeTrustedModule(module);\n    }\n\n    /// @notice Allows the owner to set the app config for the current app. App config includes:\n    /// - requiredResponses: the number of module responses required for accepting the message\n    /// - optimisticPeriod: the minimum time after which the module responses are considered final\n    function setAppConfigV1(AppConfigV1 memory appConfig) external onlyOwner {\n        _setAppConfigV1(appConfig);\n    }\n\n    /// @notice Allows the owner to set the address of the Execution Service.\n    /// This address will be used to request execution of the messages sent from this chain,\n    /// by supplying the Service's execution fee.\n    function setExecutionService(address executionService) external onlyOwner {\n        _setExecutionService(executionService);\n    }\n\n    /// @notice Allows the owner to set the address of the InterchainClient contract.\n    function setInterchainClient(address interchain_) external onlyOwner {\n        _setInterchainClient(interchain_);\n    }\n}\n\n// contracts/apps/InterchainAppExample.sol\n\ncontract InterchainAppExample is OwnableApp {\n    event MessageReceived(uint256 srcChainId, bytes32 sender, uint256 dbNonce, uint64 entryIndex, bytes message);\n    event MessageSent(uint256 dstChainId, uint256 dbNonce, uint64 entryIndex, bytes32 transactionId);\n\n    constructor(address owner_) OwnableApp(owner_) {}\n\n    /// @notice Sends a basic message to the destination chain.\n    function sendMessage(uint256 dstChainId, uint256 gasLimit, bytes calldata message) external payable {\n        InterchainTxDescriptor memory desc = _sendInterchainMessage({\n            dstChainId: dstChainId,\n            messageFee: msg.value,\n            options: OptionsV1({gasLimit: gasLimit, gasAirdrop: 0}),\n            message: message\n        });\n        emit MessageSent(dstChainId, desc.dbNonce, desc.entryIndex, desc.transactionId);\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        override\n    {\n        emit MessageReceived(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"20414:1229:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;20414:1229:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"20414:1229:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainAppExample.sol\":\"InterchainTransactionLib\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainAppExample.sol\":{\"keccak256\":\"0x86f91eccd427db2c0e6cbbdb2244f577ed8111343e9ad8aa6476b8b0bd7cb65c\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://c9a5bce8ffbdc1808235baa92fe6b0fff964c26898bb155a1b06e5ea3e4f3940\",\"dweb:/ipfs/QmZqjYVRz4JL5Pjz9TZqVSy7PUZGsabLKsxtHXP44i3TVK\"]}},\"version\":1}"},"hashes":{}},"solidity/InterchainAppExample.sol:OptionsLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122071c9247030d68be02964480144f71e6a09c58885518aee55d257c6114d80dda364736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122071c9247030d68be02964480144f71e6a09c58885518aee55d257c6114d80dda364736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainAppV1Events.sol\n\nabstract contract InterchainAppV1Events {\n    event AppConfigV1Set(uint256 requiredResponses, uint256 optimisticPeriod);\n    event AppLinked(uint256 indexed chainId, bytes32 indexed remoteApp);\n    event InterchainClientSet(address interchainClient);\n    event ExecutionServiceSet(address executionService);\n    event TrustedModuleAdded(address module);\n    event TrustedModuleRemoved(address module);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    function appReceive(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    uint8 constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint8 version);\n\n    /// @notice Encodes versioned app config into a bytes format.\n    /// @param version      The version of the app config.\n    /// @param appConfig    The app config to encode.\n    function encodeVersionedAppConfig(uint8 version, bytes memory appConfig) internal pure returns (bytes memory) {\n        return abi.encode(version, appConfig);\n    }\n\n    /// @notice Decodes versioned app config from a bytes format back into a version and app config.\n    /// @param data         The versioned app config data in bytes format.\n    /// @return version     The version of the app config.\n    /// @return appConfig   The app config as bytes.\n    function decodeVersionedAppConfig(bytes memory data)\n        internal\n        pure\n        returns (uint8 version, bytes memory appConfig)\n    {\n        (version, appConfig) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return encodeVersionedAppConfig(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal pure returns (AppConfigV1 memory) {\n        (uint8 version, bytes memory appConfig) = decodeVersionedAppConfig(data);\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(appConfig, (AppConfigV1));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    uint8 constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint8 version);\n\n    /// @notice Encodes versioned options into a bytes format.\n    /// @param version      The version of the options.\n    /// @param options      The options to encode.\n    function encodeVersionedOptions(uint8 version, bytes memory options) internal pure returns (bytes memory) {\n        return abi.encode(version, options);\n    }\n\n    /// @notice Decodes versioned options from a bytes format back into a version and options.\n    /// @param data         The versioned options data in bytes format.\n    /// @return version     The version of the options.\n    /// @return options     The options as bytes.\n    function decodeVersionedOptions(bytes memory data) internal pure returns (uint8 version, bytes memory options) {\n        (version, options) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return encodeVersionedOptions(OPTIONS_V1, abi.encode(options));\n    }\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal pure returns (OptionsV1 memory) {\n        (uint8 version, bytes memory options) = decodeVersionedOptions(data);\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(options, (OptionsV1));\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/libs/InterchainTransaction.sol\n\nstruct InterchainTransaction {\n    uint256 srcChainId;\n    bytes32 srcSender;\n    uint256 dstChainId;\n    bytes32 dstReceiver;\n    uint256 dbNonce;\n    uint64 entryIndex;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint256 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    function constructLocalTransaction(\n        address srcSender,\n        uint256 dstChainId,\n        bytes32 dstReceiver,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: block.chainid,\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(transaction);\n    }\n\n    function decodeTransaction(bytes memory encodedTx) internal pure returns (InterchainTransaction memory) {\n        return abi.decode(encodedTx, (InterchainTransaction));\n    }\n\n    function transactionId(InterchainTransaction memory transaction) internal pure returns (bytes32) {\n        return keccak256(abi.encode(transaction));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint256 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__NoLinkedClient(uint256 chainId);\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint256 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint256 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint256 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint256 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint256 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param message              The message being sent.\n    function getInterchainFee(\n        uint256 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint256 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint256 chainId) external view returns (address);\n}\n\n// contracts/apps/InterchainAppV1.sol\n\nabstract contract InterchainAppV1 is InterchainAppV1Events, IInterchainApp {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    // TODO: naming, visibility\n    address public interchain;\n\n    /// @dev Required responses and optimistic period for the module responses.\n    AppConfigV1 private _appConfigV1;\n    /// @dev Address of the linked app deployed on the remote chain.\n    mapping(uint256 chainId =\u003e bytes32 remoteApp) private _linkedApp;\n    /// @dev Trusted Interchain modules.\n    EnumerableSet.AddressSet private _trustedModules;\n    /// @dev Execution Service to use for sending messages.\n    address private _executionService;\n\n    error InterchainApp__BalanceTooLow(uint256 actual, uint256 expected);\n    error InterchainApp__CallerNotInterchainClient(address caller);\n    error InterchainApp__InterchainClientNotSet();\n    error InterchainApp__ModuleAlreadyAdded(address module);\n    error InterchainApp__ModuleNotAdded(address module);\n    error InterchainApp__ReceiverNotSet(uint256 chainId);\n    error InterchainApp__SameChainId(uint256 chainId);\n    error InterchainApp__SenderNotAllowed(uint256 srcChainId, bytes32 sender);\n\n    /// @inheritdoc IInterchainApp\n    function appReceive(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        if (msg.sender != interchain) revert InterchainApp__CallerNotInterchainClient(msg.sender);\n        if (srcChainId == block.chainid) revert InterchainApp__SameChainId(srcChainId);\n        if (!isAllowedSender(srcChainId, sender)) revert InterchainApp__SenderNotAllowed(srcChainId, sender);\n        _receiveMessage(srcChainId, sender, dbNonce, entryIndex, message);\n        // Note: application may elect to emit an event in `_receiveMessage`, so we don't emit a generic event here.\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainApp\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules) {\n        // Note: the getters for app config and modules could be overridden in the derived contracts.\n        appConfig = getAppConfigV1().encodeAppConfigV1();\n        modules = getReceivingModules();\n    }\n\n    /// @notice Returns the app config for receiving messages.\n    /// @dev Could be overridden in the derived contracts.\n    function getAppConfigV1() public view virtual returns (AppConfigV1 memory) {\n        return _appConfigV1;\n    }\n\n    /// @notice Returns the address of the Execution Service to use for sending messages.\n    /// @dev Could be overridden in the derived contracts.\n    function getExecutionService() public view virtual returns (address) {\n        return _executionService;\n    }\n\n    /// @notice Returns the linked app address (as bytes32) for the given chain ID.\n    /// @dev Could be overridden in the derived contracts.\n    function getLinkedApp(uint256 chainId) public view virtual returns (bytes32) {\n        return _linkedApp[chainId];\n    }\n\n    /// @notice Returns the list of modules used for sending messages.\n    /// @dev Could be overridden in the derived contracts.\n    function getSendingModules() public view virtual returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    /// @notice Returns the list of modules used for receiving messages.\n    /// @dev Could be overridden in the derived contracts.\n    function getReceivingModules() public view virtual returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    /// @notice Checks whether the sender is allowed to send messages to the current app.\n    /// @dev Could be overridden in the derived contracts.\n    function isAllowedSender(uint256 srcChainId, bytes32 sender) public view virtual returns (bool) {\n        return _linkedApp[srcChainId] == sender;\n    }\n\n    /// @notice Returns the current app version.\n    /// @dev Could be overridden in the derived contracts.\n    function getAppVersion() public pure virtual returns (uint256) {\n        return 1;\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Links the remote app to the current app.\n    /// Will revert if the chainId is the same as the chainId of the local app.\n    /// Note: Should be guarded with permissions check.\n    function _linkRemoteApp(uint256 chainId, bytes32 remoteApp) internal {\n        if (chainId == block.chainid) revert InterchainApp__SameChainId(chainId);\n        _linkedApp[chainId] = remoteApp;\n        emit AppLinked(chainId, remoteApp);\n    }\n\n    /// @dev Thin wrapper around _linkRemoteApp to accept EVM address as a parameter.\n    function _linkRemoteAppEVM(uint256 chainId, address remoteApp) internal {\n        _linkRemoteApp(chainId, TypeCasts.addressToBytes32(remoteApp));\n    }\n\n    /// @dev Adds the module to the trusted modules set.\n    /// Will revert if the module is already added.\n    /// Note: Should be guarded with permissions check.\n    function _addTrustedModule(address module) internal {\n        bool added = _trustedModules.add(module);\n        if (!added) revert InterchainApp__ModuleAlreadyAdded(module);\n        emit TrustedModuleAdded(module);\n    }\n\n    /// @dev Removes the module from the trusted modules set.\n    /// Will revert if the module is not added.\n    /// Note: Should be guarded with permissions check.\n    function _removeTrustedModule(address module) internal {\n        bool removed = _trustedModules.remove(module);\n        if (!removed) revert InterchainApp__ModuleNotAdded(module);\n        emit TrustedModuleRemoved(module);\n    }\n\n    /// @dev Sets the app config:\n    /// - requiredResponses: the number of module responses required for accepting the message\n    /// - optimisticPeriod: the minimum time after which the module responses are considered final\n    /// Note: Should be guarded with permissions check.\n    function _setAppConfigV1(AppConfigV1 memory appConfig) internal {\n        _appConfigV1 = appConfig;\n        emit AppConfigV1Set(appConfig.requiredResponses, appConfig.optimisticPeriod);\n    }\n\n    /// @dev Sets the execution service address.\n    /// Note: Should be guarded with permissions check.\n    function _setExecutionService(address executionService) internal {\n        _executionService = executionService;\n        emit ExecutionServiceSet(executionService);\n    }\n\n    /// @dev Sets the interchain client address.\n    /// Note: Should be guarded with permissions check.\n    function _setInterchainClient(address interchain_) internal {\n        interchain = interchain_;\n        emit InterchainClientSet(interchain_);\n    }\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to send the message to the linked app.\n    function _sendInterchainMessage(\n        uint256 dstChainId,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _sendInterchainMessage(dstChainId, getLinkedApp(dstChainId), messageFee, options, message);\n    }\n\n    /// @dev Thin wrapper around _sendInterchainMessage to accept EVM address as a parameter.\n    function _sendInterchainMessageEVM(\n        uint256 dstChainId,\n        address receiver,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _sendInterchainMessage(dstChainId, TypeCasts.addressToBytes32(receiver), messageFee, options, message);\n    }\n\n    /// @dev Performs necessary checks and sends an interchain message.\n    function _sendInterchainMessage(\n        uint256 dstChainId,\n        bytes32 receiver,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        address cachedInterchain = interchain;\n//        if (cachedInterchain == address(0)) revert InterchainApp__InterchainClientNotSet();\n//        if (dstChainId == block.chainid) revert InterchainApp__SameChainId(dstChainId);\n//        if (receiver == 0) revert InterchainApp__ReceiverNotSet(dstChainId);\n//        if (address(this).balance \u003c messageFee) revert InterchainApp__BalanceTooLow(address(this).balance, messageFee);\n        return IInterchainClientV1(cachedInterchain).interchainSend{value: messageFee}(\n            dstChainId, receiver, getExecutionService(), getSendingModules(), options.encodeOptionsV1(), message\n        );\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        virtual;\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee for sending an Interchain message.\n    function _getInterchainFee(\n        uint256 dstChainId,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        address cachedInterchain = interchain;\n        if (cachedInterchain == address(0)) revert InterchainApp__InterchainClientNotSet();\n        return IInterchainClientV1(cachedInterchain).getInterchainFee(\n            dstChainId, getExecutionService(), getSendingModules(), options.encodeOptionsV1(), message\n        );\n    }\n}\n\n// contracts/apps/OwnableApp.sol\n\nabstract contract OwnableApp is InterchainAppV1, Ownable {\n    constructor(address owner_) Ownable(owner_) {}\n\n    /// @notice Allows the owner to link the remote app for the given chain ID.\n    /// - This address will be used as the receiver for the messages sent from this chain.\n    /// - This address will be the only trusted sender for the messages sent to this chain.\n    function linkRemoteApp(uint256 chainId, bytes32 remoteApp) external onlyOwner {\n        _linkRemoteApp(chainId, remoteApp);\n    }\n\n    /// @notice This wrapper for `linkRemoteApp` to accept EVM address as a parameter.\n    function linkRemoteAppEVM(uint256 chainId, address remoteApp) external onlyOwner {\n        _linkRemoteAppEVM(chainId, remoteApp);\n    }\n\n    /// @notice Allows the owner to add the module to the trusted modules set.\n    /// - This set of modules will be used to verify message sent from this chain.\n    /// - This set of modules will be used to verify message sent to this chain.\n    function addTrustedModule(address module) external onlyOwner {\n        _addTrustedModule(module);\n    }\n\n    /// @notice Allows the owner to remove the module from the trusted modules set.\n    function removeTrustedModule(address module) external onlyOwner {\n        _removeTrustedModule(module);\n    }\n\n    /// @notice Allows the owner to set the app config for the current app. App config includes:\n    /// - requiredResponses: the number of module responses required for accepting the message\n    /// - optimisticPeriod: the minimum time after which the module responses are considered final\n    function setAppConfigV1(AppConfigV1 memory appConfig) external onlyOwner {\n        _setAppConfigV1(appConfig);\n    }\n\n    /// @notice Allows the owner to set the address of the Execution Service.\n    /// This address will be used to request execution of the messages sent from this chain,\n    /// by supplying the Service's execution fee.\n    function setExecutionService(address executionService) external onlyOwner {\n        _setExecutionService(executionService);\n    }\n\n    /// @notice Allows the owner to set the address of the InterchainClient contract.\n    function setInterchainClient(address interchain_) external onlyOwner {\n        _setInterchainClient(interchain_);\n    }\n}\n\n// contracts/apps/InterchainAppExample.sol\n\ncontract InterchainAppExample is OwnableApp {\n    event MessageReceived(uint256 srcChainId, bytes32 sender, uint256 dbNonce, uint64 entryIndex, bytes message);\n    event MessageSent(uint256 dstChainId, uint256 dbNonce, uint64 entryIndex, bytes32 transactionId);\n\n    constructor(address owner_) OwnableApp(owner_) {}\n\n    /// @notice Sends a basic message to the destination chain.\n    function sendMessage(uint256 dstChainId, uint256 gasLimit, bytes calldata message) external payable {\n        InterchainTxDescriptor memory desc = _sendInterchainMessage({\n            dstChainId: dstChainId,\n            messageFee: msg.value,\n            options: OptionsV1({gasLimit: gasLimit, gasAirdrop: 0}),\n            message: message\n        });\n        emit MessageSent(dstChainId, desc.dbNonce, desc.entryIndex, desc.transactionId);\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        override\n    {\n        emit MessageReceived(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"3758:1958:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;3758:1958:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"3758:1958:0:-:0;;;;;;;;","abiDefinition":[{"inputs":[{"internalType":"uint8","name":"version","type":"uint8"}],"name":"OptionsLib__IncorrectVersion","type":"error"}],"userDoc":{"kind":"user","methods":{},"notice":"A library for encoding and decoding Interchain options related to interchain messages.","version":1},"developerDoc":{"kind":"dev","methods":{},"title":"OptionsLib","version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"OptionsLib__IncorrectVersion\",\"type\":\"error\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"title\":\"OptionsLib\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"A library for encoding and decoding Interchain options related to interchain messages.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainAppExample.sol\":\"OptionsLib\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainAppExample.sol\":{\"keccak256\":\"0x86f91eccd427db2c0e6cbbdb2244f577ed8111343e9ad8aa6476b8b0bd7cb65c\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://c9a5bce8ffbdc1808235baa92fe6b0fff964c26898bb155a1b06e5ea3e4f3940\",\"dweb:/ipfs/QmZqjYVRz4JL5Pjz9TZqVSy7PUZGsabLKsxtHXP44i3TVK\"]}},\"version\":1}"},"hashes":{}},"solidity/InterchainAppExample.sol:Ownable":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainAppV1Events.sol\n\nabstract contract InterchainAppV1Events {\n    event AppConfigV1Set(uint256 requiredResponses, uint256 optimisticPeriod);\n    event AppLinked(uint256 indexed chainId, bytes32 indexed remoteApp);\n    event InterchainClientSet(address interchainClient);\n    event ExecutionServiceSet(address executionService);\n    event TrustedModuleAdded(address module);\n    event TrustedModuleRemoved(address module);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    function appReceive(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    uint8 constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint8 version);\n\n    /// @notice Encodes versioned app config into a bytes format.\n    /// @param version      The version of the app config.\n    /// @param appConfig    The app config to encode.\n    function encodeVersionedAppConfig(uint8 version, bytes memory appConfig) internal pure returns (bytes memory) {\n        return abi.encode(version, appConfig);\n    }\n\n    /// @notice Decodes versioned app config from a bytes format back into a version and app config.\n    /// @param data         The versioned app config data in bytes format.\n    /// @return version     The version of the app config.\n    /// @return appConfig   The app config as bytes.\n    function decodeVersionedAppConfig(bytes memory data)\n        internal\n        pure\n        returns (uint8 version, bytes memory appConfig)\n    {\n        (version, appConfig) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return encodeVersionedAppConfig(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal pure returns (AppConfigV1 memory) {\n        (uint8 version, bytes memory appConfig) = decodeVersionedAppConfig(data);\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(appConfig, (AppConfigV1));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    uint8 constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint8 version);\n\n    /// @notice Encodes versioned options into a bytes format.\n    /// @param version      The version of the options.\n    /// @param options      The options to encode.\n    function encodeVersionedOptions(uint8 version, bytes memory options) internal pure returns (bytes memory) {\n        return abi.encode(version, options);\n    }\n\n    /// @notice Decodes versioned options from a bytes format back into a version and options.\n    /// @param data         The versioned options data in bytes format.\n    /// @return version     The version of the options.\n    /// @return options     The options as bytes.\n    function decodeVersionedOptions(bytes memory data) internal pure returns (uint8 version, bytes memory options) {\n        (version, options) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return encodeVersionedOptions(OPTIONS_V1, abi.encode(options));\n    }\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal pure returns (OptionsV1 memory) {\n        (uint8 version, bytes memory options) = decodeVersionedOptions(data);\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(options, (OptionsV1));\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/libs/InterchainTransaction.sol\n\nstruct InterchainTransaction {\n    uint256 srcChainId;\n    bytes32 srcSender;\n    uint256 dstChainId;\n    bytes32 dstReceiver;\n    uint256 dbNonce;\n    uint64 entryIndex;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint256 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    function constructLocalTransaction(\n        address srcSender,\n        uint256 dstChainId,\n        bytes32 dstReceiver,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: block.chainid,\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(transaction);\n    }\n\n    function decodeTransaction(bytes memory encodedTx) internal pure returns (InterchainTransaction memory) {\n        return abi.decode(encodedTx, (InterchainTransaction));\n    }\n\n    function transactionId(InterchainTransaction memory transaction) internal pure returns (bytes32) {\n        return keccak256(abi.encode(transaction));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint256 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__NoLinkedClient(uint256 chainId);\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint256 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint256 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint256 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint256 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint256 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param message              The message being sent.\n    function getInterchainFee(\n        uint256 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint256 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint256 chainId) external view returns (address);\n}\n\n// contracts/apps/InterchainAppV1.sol\n\nabstract contract InterchainAppV1 is InterchainAppV1Events, IInterchainApp {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    // TODO: naming, visibility\n    address public interchain;\n\n    /// @dev Required responses and optimistic period for the module responses.\n    AppConfigV1 private _appConfigV1;\n    /// @dev Address of the linked app deployed on the remote chain.\n    mapping(uint256 chainId =\u003e bytes32 remoteApp) private _linkedApp;\n    /// @dev Trusted Interchain modules.\n    EnumerableSet.AddressSet private _trustedModules;\n    /// @dev Execution Service to use for sending messages.\n    address private _executionService;\n\n    error InterchainApp__BalanceTooLow(uint256 actual, uint256 expected);\n    error InterchainApp__CallerNotInterchainClient(address caller);\n    error InterchainApp__InterchainClientNotSet();\n    error InterchainApp__ModuleAlreadyAdded(address module);\n    error InterchainApp__ModuleNotAdded(address module);\n    error InterchainApp__ReceiverNotSet(uint256 chainId);\n    error InterchainApp__SameChainId(uint256 chainId);\n    error InterchainApp__SenderNotAllowed(uint256 srcChainId, bytes32 sender);\n\n    /// @inheritdoc IInterchainApp\n    function appReceive(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        if (msg.sender != interchain) revert InterchainApp__CallerNotInterchainClient(msg.sender);\n        if (srcChainId == block.chainid) revert InterchainApp__SameChainId(srcChainId);\n        if (!isAllowedSender(srcChainId, sender)) revert InterchainApp__SenderNotAllowed(srcChainId, sender);\n        _receiveMessage(srcChainId, sender, dbNonce, entryIndex, message);\n        // Note: application may elect to emit an event in `_receiveMessage`, so we don't emit a generic event here.\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainApp\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules) {\n        // Note: the getters for app config and modules could be overridden in the derived contracts.\n        appConfig = getAppConfigV1().encodeAppConfigV1();\n        modules = getReceivingModules();\n    }\n\n    /// @notice Returns the app config for receiving messages.\n    /// @dev Could be overridden in the derived contracts.\n    function getAppConfigV1() public view virtual returns (AppConfigV1 memory) {\n        return _appConfigV1;\n    }\n\n    /// @notice Returns the address of the Execution Service to use for sending messages.\n    /// @dev Could be overridden in the derived contracts.\n    function getExecutionService() public view virtual returns (address) {\n        return _executionService;\n    }\n\n    /// @notice Returns the linked app address (as bytes32) for the given chain ID.\n    /// @dev Could be overridden in the derived contracts.\n    function getLinkedApp(uint256 chainId) public view virtual returns (bytes32) {\n        return _linkedApp[chainId];\n    }\n\n    /// @notice Returns the list of modules used for sending messages.\n    /// @dev Could be overridden in the derived contracts.\n    function getSendingModules() public view virtual returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    /// @notice Returns the list of modules used for receiving messages.\n    /// @dev Could be overridden in the derived contracts.\n    function getReceivingModules() public view virtual returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    /// @notice Checks whether the sender is allowed to send messages to the current app.\n    /// @dev Could be overridden in the derived contracts.\n    function isAllowedSender(uint256 srcChainId, bytes32 sender) public view virtual returns (bool) {\n        return _linkedApp[srcChainId] == sender;\n    }\n\n    /// @notice Returns the current app version.\n    /// @dev Could be overridden in the derived contracts.\n    function getAppVersion() public pure virtual returns (uint256) {\n        return 1;\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Links the remote app to the current app.\n    /// Will revert if the chainId is the same as the chainId of the local app.\n    /// Note: Should be guarded with permissions check.\n    function _linkRemoteApp(uint256 chainId, bytes32 remoteApp) internal {\n        if (chainId == block.chainid) revert InterchainApp__SameChainId(chainId);\n        _linkedApp[chainId] = remoteApp;\n        emit AppLinked(chainId, remoteApp);\n    }\n\n    /// @dev Thin wrapper around _linkRemoteApp to accept EVM address as a parameter.\n    function _linkRemoteAppEVM(uint256 chainId, address remoteApp) internal {\n        _linkRemoteApp(chainId, TypeCasts.addressToBytes32(remoteApp));\n    }\n\n    /// @dev Adds the module to the trusted modules set.\n    /// Will revert if the module is already added.\n    /// Note: Should be guarded with permissions check.\n    function _addTrustedModule(address module) internal {\n        bool added = _trustedModules.add(module);\n        if (!added) revert InterchainApp__ModuleAlreadyAdded(module);\n        emit TrustedModuleAdded(module);\n    }\n\n    /// @dev Removes the module from the trusted modules set.\n    /// Will revert if the module is not added.\n    /// Note: Should be guarded with permissions check.\n    function _removeTrustedModule(address module) internal {\n        bool removed = _trustedModules.remove(module);\n        if (!removed) revert InterchainApp__ModuleNotAdded(module);\n        emit TrustedModuleRemoved(module);\n    }\n\n    /// @dev Sets the app config:\n    /// - requiredResponses: the number of module responses required for accepting the message\n    /// - optimisticPeriod: the minimum time after which the module responses are considered final\n    /// Note: Should be guarded with permissions check.\n    function _setAppConfigV1(AppConfigV1 memory appConfig) internal {\n        _appConfigV1 = appConfig;\n        emit AppConfigV1Set(appConfig.requiredResponses, appConfig.optimisticPeriod);\n    }\n\n    /// @dev Sets the execution service address.\n    /// Note: Should be guarded with permissions check.\n    function _setExecutionService(address executionService) internal {\n        _executionService = executionService;\n        emit ExecutionServiceSet(executionService);\n    }\n\n    /// @dev Sets the interchain client address.\n    /// Note: Should be guarded with permissions check.\n    function _setInterchainClient(address interchain_) internal {\n        interchain = interchain_;\n        emit InterchainClientSet(interchain_);\n    }\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to send the message to the linked app.\n    function _sendInterchainMessage(\n        uint256 dstChainId,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _sendInterchainMessage(dstChainId, getLinkedApp(dstChainId), messageFee, options, message);\n    }\n\n    /// @dev Thin wrapper around _sendInterchainMessage to accept EVM address as a parameter.\n    function _sendInterchainMessageEVM(\n        uint256 dstChainId,\n        address receiver,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _sendInterchainMessage(dstChainId, TypeCasts.addressToBytes32(receiver), messageFee, options, message);\n    }\n\n    /// @dev Performs necessary checks and sends an interchain message.\n    function _sendInterchainMessage(\n        uint256 dstChainId,\n        bytes32 receiver,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        address cachedInterchain = interchain;\n//        if (cachedInterchain == address(0)) revert InterchainApp__InterchainClientNotSet();\n//        if (dstChainId == block.chainid) revert InterchainApp__SameChainId(dstChainId);\n//        if (receiver == 0) revert InterchainApp__ReceiverNotSet(dstChainId);\n//        if (address(this).balance \u003c messageFee) revert InterchainApp__BalanceTooLow(address(this).balance, messageFee);\n        return IInterchainClientV1(cachedInterchain).interchainSend{value: messageFee}(\n            dstChainId, receiver, getExecutionService(), getSendingModules(), options.encodeOptionsV1(), message\n        );\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        virtual;\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee for sending an Interchain message.\n    function _getInterchainFee(\n        uint256 dstChainId,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        address cachedInterchain = interchain;\n        if (cachedInterchain == address(0)) revert InterchainApp__InterchainClientNotSet();\n        return IInterchainClientV1(cachedInterchain).getInterchainFee(\n            dstChainId, getExecutionService(), getSendingModules(), options.encodeOptionsV1(), message\n        );\n    }\n}\n\n// contracts/apps/OwnableApp.sol\n\nabstract contract OwnableApp is InterchainAppV1, Ownable {\n    constructor(address owner_) Ownable(owner_) {}\n\n    /// @notice Allows the owner to link the remote app for the given chain ID.\n    /// - This address will be used as the receiver for the messages sent from this chain.\n    /// - This address will be the only trusted sender for the messages sent to this chain.\n    function linkRemoteApp(uint256 chainId, bytes32 remoteApp) external onlyOwner {\n        _linkRemoteApp(chainId, remoteApp);\n    }\n\n    /// @notice This wrapper for `linkRemoteApp` to accept EVM address as a parameter.\n    function linkRemoteAppEVM(uint256 chainId, address remoteApp) external onlyOwner {\n        _linkRemoteAppEVM(chainId, remoteApp);\n    }\n\n    /// @notice Allows the owner to add the module to the trusted modules set.\n    /// - This set of modules will be used to verify message sent from this chain.\n    /// - This set of modules will be used to verify message sent to this chain.\n    function addTrustedModule(address module) external onlyOwner {\n        _addTrustedModule(module);\n    }\n\n    /// @notice Allows the owner to remove the module from the trusted modules set.\n    function removeTrustedModule(address module) external onlyOwner {\n        _removeTrustedModule(module);\n    }\n\n    /// @notice Allows the owner to set the app config for the current app. App config includes:\n    /// - requiredResponses: the number of module responses required for accepting the message\n    /// - optimisticPeriod: the minimum time after which the module responses are considered final\n    function setAppConfigV1(AppConfigV1 memory appConfig) external onlyOwner {\n        _setAppConfigV1(appConfig);\n    }\n\n    /// @notice Allows the owner to set the address of the Execution Service.\n    /// This address will be used to request execution of the messages sent from this chain,\n    /// by supplying the Service's execution fee.\n    function setExecutionService(address executionService) external onlyOwner {\n        _setExecutionService(executionService);\n    }\n\n    /// @notice Allows the owner to set the address of the InterchainClient contract.\n    function setInterchainClient(address interchain_) external onlyOwner {\n        _setInterchainClient(interchain_);\n    }\n}\n\n// contracts/apps/InterchainAppExample.sol\n\ncontract InterchainAppExample is OwnableApp {\n    event MessageReceived(uint256 srcChainId, bytes32 sender, uint256 dbNonce, uint64 entryIndex, bytes message);\n    event MessageSent(uint256 dstChainId, uint256 dbNonce, uint64 entryIndex, bytes32 transactionId);\n\n    constructor(address owner_) OwnableApp(owner_) {}\n\n    /// @notice Sends a basic message to the destination chain.\n    function sendMessage(uint256 dstChainId, uint256 gasLimit, bytes calldata message) external payable {\n        InterchainTxDescriptor memory desc = _sendInterchainMessage({\n            dstChainId: dstChainId,\n            messageFee: msg.value,\n            options: OptionsV1({gasLimit: gasLimit, gasAirdrop: 0}),\n            message: message\n        });\n        emit MessageSent(dstChainId, desc.dbNonce, desc.entryIndex, desc.transactionId);\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        override\n    {\n        emit MessageReceived(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"OwnableInvalidOwner","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"OwnableUnauthorizedAccount","type":"error"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"details":"Contract module which provides a basic access control mechanism, where there is an account (an owner) that can be granted exclusive access to specific functions. The initial owner is set to the address provided by the deployer. This can later be changed with {transferOwnership}. This module is used through inheritance. It will make available the modifier `onlyOwner`, which can be applied to your functions to restrict their use to the owner.","errors":{"OwnableInvalidOwner(address)":[{"details":"The owner is not a valid owner account. (eg. `address(0)`)"}],"OwnableUnauthorizedAccount(address)":[{"details":"The caller account is not authorized to perform an operation."}]},"kind":"dev","methods":{"constructor":{"details":"Initializes the contract setting the address provided by the deployer as the initial owner."},"owner()":{"details":"Returns the address of the current owner."},"renounceOwnership()":{"details":"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."},"transferOwnership(address)":{"details":"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Contract module which provides a basic access control mechanism, where there is an account (an owner) that can be granted exclusive access to specific functions. The initial owner is set to the address provided by the deployer. This can later be changed with {transferOwnership}. This module is used through inheritance. It will make available the modifier `onlyOwner`, which can be applied to your functions to restrict their use to the owner.\",\"errors\":{\"OwnableInvalidOwner(address)\":[{\"details\":\"The owner is not a valid owner account. (eg. `address(0)`)\"}],\"OwnableUnauthorizedAccount(address)\":[{\"details\":\"The caller account is not authorized to perform an operation.\"}]},\"kind\":\"dev\",\"methods\":{\"constructor\":{\"details\":\"Initializes the contract setting the address provided by the deployer as the initial owner.\"},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner.\"},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainAppExample.sol\":\"Ownable\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainAppExample.sol\":{\"keccak256\":\"0x86f91eccd427db2c0e6cbbdb2244f577ed8111343e9ad8aa6476b8b0bd7cb65c\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://c9a5bce8ffbdc1808235baa92fe6b0fff964c26898bb155a1b06e5ea3e4f3940\",\"dweb:/ipfs/QmZqjYVRz4JL5Pjz9TZqVSy7PUZGsabLKsxtHXP44i3TVK\"]}},\"version\":1}"},"hashes":{"owner()":"8da5cb5b","renounceOwnership()":"715018a6","transferOwnership(address)":"f2fde38b"}},"solidity/InterchainAppExample.sol:OwnableApp":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainAppV1Events.sol\n\nabstract contract InterchainAppV1Events {\n    event AppConfigV1Set(uint256 requiredResponses, uint256 optimisticPeriod);\n    event AppLinked(uint256 indexed chainId, bytes32 indexed remoteApp);\n    event InterchainClientSet(address interchainClient);\n    event ExecutionServiceSet(address executionService);\n    event TrustedModuleAdded(address module);\n    event TrustedModuleRemoved(address module);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    function appReceive(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    uint8 constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint8 version);\n\n    /// @notice Encodes versioned app config into a bytes format.\n    /// @param version      The version of the app config.\n    /// @param appConfig    The app config to encode.\n    function encodeVersionedAppConfig(uint8 version, bytes memory appConfig) internal pure returns (bytes memory) {\n        return abi.encode(version, appConfig);\n    }\n\n    /// @notice Decodes versioned app config from a bytes format back into a version and app config.\n    /// @param data         The versioned app config data in bytes format.\n    /// @return version     The version of the app config.\n    /// @return appConfig   The app config as bytes.\n    function decodeVersionedAppConfig(bytes memory data)\n        internal\n        pure\n        returns (uint8 version, bytes memory appConfig)\n    {\n        (version, appConfig) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return encodeVersionedAppConfig(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal pure returns (AppConfigV1 memory) {\n        (uint8 version, bytes memory appConfig) = decodeVersionedAppConfig(data);\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(appConfig, (AppConfigV1));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    uint8 constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint8 version);\n\n    /// @notice Encodes versioned options into a bytes format.\n    /// @param version      The version of the options.\n    /// @param options      The options to encode.\n    function encodeVersionedOptions(uint8 version, bytes memory options) internal pure returns (bytes memory) {\n        return abi.encode(version, options);\n    }\n\n    /// @notice Decodes versioned options from a bytes format back into a version and options.\n    /// @param data         The versioned options data in bytes format.\n    /// @return version     The version of the options.\n    /// @return options     The options as bytes.\n    function decodeVersionedOptions(bytes memory data) internal pure returns (uint8 version, bytes memory options) {\n        (version, options) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return encodeVersionedOptions(OPTIONS_V1, abi.encode(options));\n    }\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal pure returns (OptionsV1 memory) {\n        (uint8 version, bytes memory options) = decodeVersionedOptions(data);\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(options, (OptionsV1));\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/libs/InterchainTransaction.sol\n\nstruct InterchainTransaction {\n    uint256 srcChainId;\n    bytes32 srcSender;\n    uint256 dstChainId;\n    bytes32 dstReceiver;\n    uint256 dbNonce;\n    uint64 entryIndex;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint256 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    function constructLocalTransaction(\n        address srcSender,\n        uint256 dstChainId,\n        bytes32 dstReceiver,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: block.chainid,\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(transaction);\n    }\n\n    function decodeTransaction(bytes memory encodedTx) internal pure returns (InterchainTransaction memory) {\n        return abi.decode(encodedTx, (InterchainTransaction));\n    }\n\n    function transactionId(InterchainTransaction memory transaction) internal pure returns (bytes32) {\n        return keccak256(abi.encode(transaction));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint256 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__NoLinkedClient(uint256 chainId);\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint256 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint256 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint256 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint256 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint256 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param message              The message being sent.\n    function getInterchainFee(\n        uint256 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint256 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint256 chainId) external view returns (address);\n}\n\n// contracts/apps/InterchainAppV1.sol\n\nabstract contract InterchainAppV1 is InterchainAppV1Events, IInterchainApp {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    // TODO: naming, visibility\n    address public interchain;\n\n    /// @dev Required responses and optimistic period for the module responses.\n    AppConfigV1 private _appConfigV1;\n    /// @dev Address of the linked app deployed on the remote chain.\n    mapping(uint256 chainId =\u003e bytes32 remoteApp) private _linkedApp;\n    /// @dev Trusted Interchain modules.\n    EnumerableSet.AddressSet private _trustedModules;\n    /// @dev Execution Service to use for sending messages.\n    address private _executionService;\n\n    error InterchainApp__BalanceTooLow(uint256 actual, uint256 expected);\n    error InterchainApp__CallerNotInterchainClient(address caller);\n    error InterchainApp__InterchainClientNotSet();\n    error InterchainApp__ModuleAlreadyAdded(address module);\n    error InterchainApp__ModuleNotAdded(address module);\n    error InterchainApp__ReceiverNotSet(uint256 chainId);\n    error InterchainApp__SameChainId(uint256 chainId);\n    error InterchainApp__SenderNotAllowed(uint256 srcChainId, bytes32 sender);\n\n    /// @inheritdoc IInterchainApp\n    function appReceive(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        if (msg.sender != interchain) revert InterchainApp__CallerNotInterchainClient(msg.sender);\n        if (srcChainId == block.chainid) revert InterchainApp__SameChainId(srcChainId);\n        if (!isAllowedSender(srcChainId, sender)) revert InterchainApp__SenderNotAllowed(srcChainId, sender);\n        _receiveMessage(srcChainId, sender, dbNonce, entryIndex, message);\n        // Note: application may elect to emit an event in `_receiveMessage`, so we don't emit a generic event here.\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainApp\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules) {\n        // Note: the getters for app config and modules could be overridden in the derived contracts.\n        appConfig = getAppConfigV1().encodeAppConfigV1();\n        modules = getReceivingModules();\n    }\n\n    /// @notice Returns the app config for receiving messages.\n    /// @dev Could be overridden in the derived contracts.\n    function getAppConfigV1() public view virtual returns (AppConfigV1 memory) {\n        return _appConfigV1;\n    }\n\n    /// @notice Returns the address of the Execution Service to use for sending messages.\n    /// @dev Could be overridden in the derived contracts.\n    function getExecutionService() public view virtual returns (address) {\n        return _executionService;\n    }\n\n    /// @notice Returns the linked app address (as bytes32) for the given chain ID.\n    /// @dev Could be overridden in the derived contracts.\n    function getLinkedApp(uint256 chainId) public view virtual returns (bytes32) {\n        return _linkedApp[chainId];\n    }\n\n    /// @notice Returns the list of modules used for sending messages.\n    /// @dev Could be overridden in the derived contracts.\n    function getSendingModules() public view virtual returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    /// @notice Returns the list of modules used for receiving messages.\n    /// @dev Could be overridden in the derived contracts.\n    function getReceivingModules() public view virtual returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    /// @notice Checks whether the sender is allowed to send messages to the current app.\n    /// @dev Could be overridden in the derived contracts.\n    function isAllowedSender(uint256 srcChainId, bytes32 sender) public view virtual returns (bool) {\n        return _linkedApp[srcChainId] == sender;\n    }\n\n    /// @notice Returns the current app version.\n    /// @dev Could be overridden in the derived contracts.\n    function getAppVersion() public pure virtual returns (uint256) {\n        return 1;\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Links the remote app to the current app.\n    /// Will revert if the chainId is the same as the chainId of the local app.\n    /// Note: Should be guarded with permissions check.\n    function _linkRemoteApp(uint256 chainId, bytes32 remoteApp) internal {\n        if (chainId == block.chainid) revert InterchainApp__SameChainId(chainId);\n        _linkedApp[chainId] = remoteApp;\n        emit AppLinked(chainId, remoteApp);\n    }\n\n    /// @dev Thin wrapper around _linkRemoteApp to accept EVM address as a parameter.\n    function _linkRemoteAppEVM(uint256 chainId, address remoteApp) internal {\n        _linkRemoteApp(chainId, TypeCasts.addressToBytes32(remoteApp));\n    }\n\n    /// @dev Adds the module to the trusted modules set.\n    /// Will revert if the module is already added.\n    /// Note: Should be guarded with permissions check.\n    function _addTrustedModule(address module) internal {\n        bool added = _trustedModules.add(module);\n        if (!added) revert InterchainApp__ModuleAlreadyAdded(module);\n        emit TrustedModuleAdded(module);\n    }\n\n    /// @dev Removes the module from the trusted modules set.\n    /// Will revert if the module is not added.\n    /// Note: Should be guarded with permissions check.\n    function _removeTrustedModule(address module) internal {\n        bool removed = _trustedModules.remove(module);\n        if (!removed) revert InterchainApp__ModuleNotAdded(module);\n        emit TrustedModuleRemoved(module);\n    }\n\n    /// @dev Sets the app config:\n    /// - requiredResponses: the number of module responses required for accepting the message\n    /// - optimisticPeriod: the minimum time after which the module responses are considered final\n    /// Note: Should be guarded with permissions check.\n    function _setAppConfigV1(AppConfigV1 memory appConfig) internal {\n        _appConfigV1 = appConfig;\n        emit AppConfigV1Set(appConfig.requiredResponses, appConfig.optimisticPeriod);\n    }\n\n    /// @dev Sets the execution service address.\n    /// Note: Should be guarded with permissions check.\n    function _setExecutionService(address executionService) internal {\n        _executionService = executionService;\n        emit ExecutionServiceSet(executionService);\n    }\n\n    /// @dev Sets the interchain client address.\n    /// Note: Should be guarded with permissions check.\n    function _setInterchainClient(address interchain_) internal {\n        interchain = interchain_;\n        emit InterchainClientSet(interchain_);\n    }\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to send the message to the linked app.\n    function _sendInterchainMessage(\n        uint256 dstChainId,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _sendInterchainMessage(dstChainId, getLinkedApp(dstChainId), messageFee, options, message);\n    }\n\n    /// @dev Thin wrapper around _sendInterchainMessage to accept EVM address as a parameter.\n    function _sendInterchainMessageEVM(\n        uint256 dstChainId,\n        address receiver,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _sendInterchainMessage(dstChainId, TypeCasts.addressToBytes32(receiver), messageFee, options, message);\n    }\n\n    /// @dev Performs necessary checks and sends an interchain message.\n    function _sendInterchainMessage(\n        uint256 dstChainId,\n        bytes32 receiver,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        address cachedInterchain = interchain;\n//        if (cachedInterchain == address(0)) revert InterchainApp__InterchainClientNotSet();\n//        if (dstChainId == block.chainid) revert InterchainApp__SameChainId(dstChainId);\n//        if (receiver == 0) revert InterchainApp__ReceiverNotSet(dstChainId);\n//        if (address(this).balance \u003c messageFee) revert InterchainApp__BalanceTooLow(address(this).balance, messageFee);\n        return IInterchainClientV1(cachedInterchain).interchainSend{value: messageFee}(\n            dstChainId, receiver, getExecutionService(), getSendingModules(), options.encodeOptionsV1(), message\n        );\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        virtual;\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee for sending an Interchain message.\n    function _getInterchainFee(\n        uint256 dstChainId,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        address cachedInterchain = interchain;\n        if (cachedInterchain == address(0)) revert InterchainApp__InterchainClientNotSet();\n        return IInterchainClientV1(cachedInterchain).getInterchainFee(\n            dstChainId, getExecutionService(), getSendingModules(), options.encodeOptionsV1(), message\n        );\n    }\n}\n\n// contracts/apps/OwnableApp.sol\n\nabstract contract OwnableApp is InterchainAppV1, Ownable {\n    constructor(address owner_) Ownable(owner_) {}\n\n    /// @notice Allows the owner to link the remote app for the given chain ID.\n    /// - This address will be used as the receiver for the messages sent from this chain.\n    /// - This address will be the only trusted sender for the messages sent to this chain.\n    function linkRemoteApp(uint256 chainId, bytes32 remoteApp) external onlyOwner {\n        _linkRemoteApp(chainId, remoteApp);\n    }\n\n    /// @notice This wrapper for `linkRemoteApp` to accept EVM address as a parameter.\n    function linkRemoteAppEVM(uint256 chainId, address remoteApp) external onlyOwner {\n        _linkRemoteAppEVM(chainId, remoteApp);\n    }\n\n    /// @notice Allows the owner to add the module to the trusted modules set.\n    /// - This set of modules will be used to verify message sent from this chain.\n    /// - This set of modules will be used to verify message sent to this chain.\n    function addTrustedModule(address module) external onlyOwner {\n        _addTrustedModule(module);\n    }\n\n    /// @notice Allows the owner to remove the module from the trusted modules set.\n    function removeTrustedModule(address module) external onlyOwner {\n        _removeTrustedModule(module);\n    }\n\n    /// @notice Allows the owner to set the app config for the current app. App config includes:\n    /// - requiredResponses: the number of module responses required for accepting the message\n    /// - optimisticPeriod: the minimum time after which the module responses are considered final\n    function setAppConfigV1(AppConfigV1 memory appConfig) external onlyOwner {\n        _setAppConfigV1(appConfig);\n    }\n\n    /// @notice Allows the owner to set the address of the Execution Service.\n    /// This address will be used to request execution of the messages sent from this chain,\n    /// by supplying the Service's execution fee.\n    function setExecutionService(address executionService) external onlyOwner {\n        _setExecutionService(executionService);\n    }\n\n    /// @notice Allows the owner to set the address of the InterchainClient contract.\n    function setInterchainClient(address interchain_) external onlyOwner {\n        _setInterchainClient(interchain_);\n    }\n}\n\n// contracts/apps/InterchainAppExample.sol\n\ncontract InterchainAppExample is OwnableApp {\n    event MessageReceived(uint256 srcChainId, bytes32 sender, uint256 dbNonce, uint64 entryIndex, bytes message);\n    event MessageSent(uint256 dstChainId, uint256 dbNonce, uint64 entryIndex, bytes32 transactionId);\n\n    constructor(address owner_) OwnableApp(owner_) {}\n\n    /// @notice Sends a basic message to the destination chain.\n    function sendMessage(uint256 dstChainId, uint256 gasLimit, bytes calldata message) external payable {\n        InterchainTxDescriptor memory desc = _sendInterchainMessage({\n            dstChainId: dstChainId,\n            messageFee: msg.value,\n            options: OptionsV1({gasLimit: gasLimit, gasAirdrop: 0}),\n            message: message\n        });\n        emit MessageSent(dstChainId, desc.dbNonce, desc.entryIndex, desc.transactionId);\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        override\n    {\n        emit MessageReceived(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"uint256","name":"actual","type":"uint256"},{"internalType":"uint256","name":"expected","type":"uint256"}],"name":"InterchainApp__BalanceTooLow","type":"error"},{"inputs":[{"internalType":"address","name":"caller","type":"address"}],"name":"InterchainApp__CallerNotInterchainClient","type":"error"},{"inputs":[],"name":"InterchainApp__InterchainClientNotSet","type":"error"},{"inputs":[{"internalType":"address","name":"module","type":"address"}],"name":"InterchainApp__ModuleAlreadyAdded","type":"error"},{"inputs":[{"internalType":"address","name":"module","type":"address"}],"name":"InterchainApp__ModuleNotAdded","type":"error"},{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"}],"name":"InterchainApp__ReceiverNotSet","type":"error"},{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"}],"name":"InterchainApp__SameChainId","type":"error"},{"inputs":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"bytes32","name":"sender","type":"bytes32"}],"name":"InterchainApp__SenderNotAllowed","type":"error"},{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"OwnableInvalidOwner","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"OwnableUnauthorizedAccount","type":"error"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"requiredResponses","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"optimisticPeriod","type":"uint256"}],"name":"AppConfigV1Set","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"chainId","type":"uint256"},{"indexed":true,"internalType":"bytes32","name":"remoteApp","type":"bytes32"}],"name":"AppLinked","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"executionService","type":"address"}],"name":"ExecutionServiceSet","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"interchainClient","type":"address"}],"name":"InterchainClientSet","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"module","type":"address"}],"name":"TrustedModuleAdded","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"module","type":"address"}],"name":"TrustedModuleRemoved","type":"event"},{"inputs":[{"internalType":"address","name":"module","type":"address"}],"name":"addTrustedModule","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"bytes32","name":"sender","type":"bytes32"},{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"uint64","name":"entryIndex","type":"uint64"},{"internalType":"bytes","name":"message","type":"bytes"}],"name":"appReceive","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"getAppConfigV1","outputs":[{"components":[{"internalType":"uint256","name":"requiredResponses","type":"uint256"},{"internalType":"uint256","name":"optimisticPeriod","type":"uint256"}],"internalType":"struct AppConfigV1","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getAppVersion","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"getExecutionService","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"}],"name":"getLinkedApp","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getReceivingConfig","outputs":[{"internalType":"bytes","name":"appConfig","type":"bytes"},{"internalType":"address[]","name":"modules","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getReceivingModules","outputs":[{"internalType":"address[]","name":"","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getSendingModules","outputs":[{"internalType":"address[]","name":"","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"interchain","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"bytes32","name":"sender","type":"bytes32"}],"name":"isAllowedSender","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"},{"internalType":"bytes32","name":"remoteApp","type":"bytes32"}],"name":"linkRemoteApp","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"},{"internalType":"address","name":"remoteApp","type":"address"}],"name":"linkRemoteAppEVM","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"module","type":"address"}],"name":"removeTrustedModule","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"components":[{"internalType":"uint256","name":"requiredResponses","type":"uint256"},{"internalType":"uint256","name":"optimisticPeriod","type":"uint256"}],"internalType":"struct AppConfigV1","name":"appConfig","type":"tuple"}],"name":"setAppConfigV1","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"executionService","type":"address"}],"name":"setExecutionService","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"interchain_","type":"address"}],"name":"setInterchainClient","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{"addTrustedModule(address)":{"notice":"Allows the owner to add the module to the trusted modules set. - This set of modules will be used to verify message sent from this chain. - This set of modules will be used to verify message sent to this chain."},"getAppConfigV1()":{"notice":"Returns the app config for receiving messages."},"getAppVersion()":{"notice":"Returns the current app version."},"getExecutionService()":{"notice":"Returns the address of the Execution Service to use for sending messages."},"getLinkedApp(uint256)":{"notice":"Returns the linked app address (as bytes32) for the given chain ID."},"getReceivingModules()":{"notice":"Returns the list of modules used for receiving messages."},"getSendingModules()":{"notice":"Returns the list of modules used for sending messages."},"isAllowedSender(uint256,bytes32)":{"notice":"Checks whether the sender is allowed to send messages to the current app."},"linkRemoteApp(uint256,bytes32)":{"notice":"Allows the owner to link the remote app for the given chain ID. - This address will be used as the receiver for the messages sent from this chain. - This address will be the only trusted sender for the messages sent to this chain."},"linkRemoteAppEVM(uint256,address)":{"notice":"This wrapper for `linkRemoteApp` to accept EVM address as a parameter."},"removeTrustedModule(address)":{"notice":"Allows the owner to remove the module from the trusted modules set."},"setAppConfigV1((uint256,uint256))":{"notice":"Allows the owner to set the app config for the current app. App config includes: - requiredResponses: the number of module responses required for accepting the message - optimisticPeriod: the minimum time after which the module responses are considered final"},"setExecutionService(address)":{"notice":"Allows the owner to set the address of the Execution Service. This address will be used to request execution of the messages sent from this chain, by supplying the Service's execution fee."},"setInterchainClient(address)":{"notice":"Allows the owner to set the address of the InterchainClient contract."}},"version":1},"developerDoc":{"errors":{"OwnableInvalidOwner(address)":[{"details":"The owner is not a valid owner account. (eg. `address(0)`)"}],"OwnableUnauthorizedAccount(address)":[{"details":"The caller account is not authorized to perform an operation."}]},"kind":"dev","methods":{"getAppConfigV1()":{"details":"Could be overridden in the derived contracts."},"getAppVersion()":{"details":"Could be overridden in the derived contracts."},"getExecutionService()":{"details":"Could be overridden in the derived contracts."},"getLinkedApp(uint256)":{"details":"Could be overridden in the derived contracts."},"getReceivingModules()":{"details":"Could be overridden in the derived contracts."},"getSendingModules()":{"details":"Could be overridden in the derived contracts."},"isAllowedSender(uint256,bytes32)":{"details":"Could be overridden in the derived contracts."},"owner()":{"details":"Returns the address of the current owner."},"renounceOwnership()":{"details":"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."},"transferOwnership(address)":{"details":"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expected\",\"type\":\"uint256\"}],\"name\":\"InterchainApp__BalanceTooLow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"InterchainApp__CallerNotInterchainClient\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InterchainApp__InterchainClientNotSet\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"InterchainApp__ModuleAlreadyAdded\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"InterchainApp__ModuleNotAdded\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"InterchainApp__ReceiverNotSet\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"InterchainApp__SameChainId\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"}],\"name\":\"InterchainApp__SenderNotAllowed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requiredResponses\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"optimisticPeriod\",\"type\":\"uint256\"}],\"name\":\"AppConfigV1Set\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"remoteApp\",\"type\":\"bytes32\"}],\"name\":\"AppLinked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"executionService\",\"type\":\"address\"}],\"name\":\"ExecutionServiceSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"interchainClient\",\"type\":\"address\"}],\"name\":\"InterchainClientSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"TrustedModuleAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"TrustedModuleRemoved\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"addTrustedModule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"appReceive\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAppConfigV1\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"requiredResponses\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"optimisticPeriod\",\"type\":\"uint256\"}],\"internalType\":\"struct AppConfigV1\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAppVersion\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getExecutionService\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"getLinkedApp\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReceivingConfig\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"appConfig\",\"type\":\"bytes\"},{\"internalType\":\"address[]\",\"name\":\"modules\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReceivingModules\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSendingModules\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"interchain\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"}],\"name\":\"isAllowedSender\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"remoteApp\",\"type\":\"bytes32\"}],\"name\":\"linkRemoteApp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"remoteApp\",\"type\":\"address\"}],\"name\":\"linkRemoteAppEVM\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"removeTrustedModule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"requiredResponses\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"optimisticPeriod\",\"type\":\"uint256\"}],\"internalType\":\"struct AppConfigV1\",\"name\":\"appConfig\",\"type\":\"tuple\"}],\"name\":\"setAppConfigV1\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"executionService\",\"type\":\"address\"}],\"name\":\"setExecutionService\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"interchain_\",\"type\":\"address\"}],\"name\":\"setInterchainClient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"errors\":{\"OwnableInvalidOwner(address)\":[{\"details\":\"The owner is not a valid owner account. (eg. `address(0)`)\"}],\"OwnableUnauthorizedAccount(address)\":[{\"details\":\"The caller account is not authorized to perform an operation.\"}]},\"kind\":\"dev\",\"methods\":{\"getAppConfigV1()\":{\"details\":\"Could be overridden in the derived contracts.\"},\"getAppVersion()\":{\"details\":\"Could be overridden in the derived contracts.\"},\"getExecutionService()\":{\"details\":\"Could be overridden in the derived contracts.\"},\"getLinkedApp(uint256)\":{\"details\":\"Could be overridden in the derived contracts.\"},\"getReceivingModules()\":{\"details\":\"Could be overridden in the derived contracts.\"},\"getSendingModules()\":{\"details\":\"Could be overridden in the derived contracts.\"},\"isAllowedSender(uint256,bytes32)\":{\"details\":\"Could be overridden in the derived contracts.\"},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner.\"},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"addTrustedModule(address)\":{\"notice\":\"Allows the owner to add the module to the trusted modules set. - This set of modules will be used to verify message sent from this chain. - This set of modules will be used to verify message sent to this chain.\"},\"getAppConfigV1()\":{\"notice\":\"Returns the app config for receiving messages.\"},\"getAppVersion()\":{\"notice\":\"Returns the current app version.\"},\"getExecutionService()\":{\"notice\":\"Returns the address of the Execution Service to use for sending messages.\"},\"getLinkedApp(uint256)\":{\"notice\":\"Returns the linked app address (as bytes32) for the given chain ID.\"},\"getReceivingModules()\":{\"notice\":\"Returns the list of modules used for receiving messages.\"},\"getSendingModules()\":{\"notice\":\"Returns the list of modules used for sending messages.\"},\"isAllowedSender(uint256,bytes32)\":{\"notice\":\"Checks whether the sender is allowed to send messages to the current app.\"},\"linkRemoteApp(uint256,bytes32)\":{\"notice\":\"Allows the owner to link the remote app for the given chain ID. - This address will be used as the receiver for the messages sent from this chain. - This address will be the only trusted sender for the messages sent to this chain.\"},\"linkRemoteAppEVM(uint256,address)\":{\"notice\":\"This wrapper for `linkRemoteApp` to accept EVM address as a parameter.\"},\"removeTrustedModule(address)\":{\"notice\":\"Allows the owner to remove the module from the trusted modules set.\"},\"setAppConfigV1((uint256,uint256))\":{\"notice\":\"Allows the owner to set the app config for the current app. App config includes: - requiredResponses: the number of module responses required for accepting the message - optimisticPeriod: the minimum time after which the module responses are considered final\"},\"setExecutionService(address)\":{\"notice\":\"Allows the owner to set the address of the Execution Service. This address will be used to request execution of the messages sent from this chain, by supplying the Service's execution fee.\"},\"setInterchainClient(address)\":{\"notice\":\"Allows the owner to set the address of the InterchainClient contract.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainAppExample.sol\":\"OwnableApp\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainAppExample.sol\":{\"keccak256\":\"0x86f91eccd427db2c0e6cbbdb2244f577ed8111343e9ad8aa6476b8b0bd7cb65c\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://c9a5bce8ffbdc1808235baa92fe6b0fff964c26898bb155a1b06e5ea3e4f3940\",\"dweb:/ipfs/QmZqjYVRz4JL5Pjz9TZqVSy7PUZGsabLKsxtHXP44i3TVK\"]}},\"version\":1}"},"hashes":{"addTrustedModule(address)":"cb5038fb","appReceive(uint256,bytes32,uint256,uint64,bytes)":"68a69847","getAppConfigV1()":"7717a647","getAppVersion()":"a20ce510","getExecutionService()":"c313c807","getLinkedApp(uint256)":"b9b74b18","getReceivingConfig()":"287bc057","getReceivingModules()":"a45e107a","getSendingModules()":"ea13398f","interchain()":"70838975","isAllowedSender(uint256,bytes32)":"dc2b9075","linkRemoteApp(uint256,bytes32)":"51a30802","linkRemoteAppEVM(uint256,address)":"af8fcc8e","owner()":"8da5cb5b","removeTrustedModule(address)":"b70c40b3","renounceOwnership()":"715018a6","setAppConfigV1((uint256,uint256))":"0d32b505","setExecutionService(address)":"496774b1","setInterchainClient(address)":"27efcbb7","transferOwnership(address)":"f2fde38b"}},"solidity/InterchainAppExample.sol:TypeCasts":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122076184d3e1f969ca26a66b617ee155f38855803fe2db9d94b3eb04bf014cccee164736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122076184d3e1f969ca26a66b617ee155f38855803fe2db9d94b3eb04bf014cccee164736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainAppV1Events.sol\n\nabstract contract InterchainAppV1Events {\n    event AppConfigV1Set(uint256 requiredResponses, uint256 optimisticPeriod);\n    event AppLinked(uint256 indexed chainId, bytes32 indexed remoteApp);\n    event InterchainClientSet(address interchainClient);\n    event ExecutionServiceSet(address executionService);\n    event TrustedModuleAdded(address module);\n    event TrustedModuleRemoved(address module);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    function appReceive(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    uint8 constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint8 version);\n\n    /// @notice Encodes versioned app config into a bytes format.\n    /// @param version      The version of the app config.\n    /// @param appConfig    The app config to encode.\n    function encodeVersionedAppConfig(uint8 version, bytes memory appConfig) internal pure returns (bytes memory) {\n        return abi.encode(version, appConfig);\n    }\n\n    /// @notice Decodes versioned app config from a bytes format back into a version and app config.\n    /// @param data         The versioned app config data in bytes format.\n    /// @return version     The version of the app config.\n    /// @return appConfig   The app config as bytes.\n    function decodeVersionedAppConfig(bytes memory data)\n        internal\n        pure\n        returns (uint8 version, bytes memory appConfig)\n    {\n        (version, appConfig) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return encodeVersionedAppConfig(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal pure returns (AppConfigV1 memory) {\n        (uint8 version, bytes memory appConfig) = decodeVersionedAppConfig(data);\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(appConfig, (AppConfigV1));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    uint8 constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint8 version);\n\n    /// @notice Encodes versioned options into a bytes format.\n    /// @param version      The version of the options.\n    /// @param options      The options to encode.\n    function encodeVersionedOptions(uint8 version, bytes memory options) internal pure returns (bytes memory) {\n        return abi.encode(version, options);\n    }\n\n    /// @notice Decodes versioned options from a bytes format back into a version and options.\n    /// @param data         The versioned options data in bytes format.\n    /// @return version     The version of the options.\n    /// @return options     The options as bytes.\n    function decodeVersionedOptions(bytes memory data) internal pure returns (uint8 version, bytes memory options) {\n        (version, options) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return encodeVersionedOptions(OPTIONS_V1, abi.encode(options));\n    }\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal pure returns (OptionsV1 memory) {\n        (uint8 version, bytes memory options) = decodeVersionedOptions(data);\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(options, (OptionsV1));\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/libs/InterchainTransaction.sol\n\nstruct InterchainTransaction {\n    uint256 srcChainId;\n    bytes32 srcSender;\n    uint256 dstChainId;\n    bytes32 dstReceiver;\n    uint256 dbNonce;\n    uint64 entryIndex;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint256 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    function constructLocalTransaction(\n        address srcSender,\n        uint256 dstChainId,\n        bytes32 dstReceiver,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: block.chainid,\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(transaction);\n    }\n\n    function decodeTransaction(bytes memory encodedTx) internal pure returns (InterchainTransaction memory) {\n        return abi.decode(encodedTx, (InterchainTransaction));\n    }\n\n    function transactionId(InterchainTransaction memory transaction) internal pure returns (bytes32) {\n        return keccak256(abi.encode(transaction));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint256 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__NoLinkedClient(uint256 chainId);\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint256 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint256 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint256 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint256 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint256 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param message              The message being sent.\n    function getInterchainFee(\n        uint256 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint256 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint256 chainId) external view returns (address);\n}\n\n// contracts/apps/InterchainAppV1.sol\n\nabstract contract InterchainAppV1 is InterchainAppV1Events, IInterchainApp {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    // TODO: naming, visibility\n    address public interchain;\n\n    /// @dev Required responses and optimistic period for the module responses.\n    AppConfigV1 private _appConfigV1;\n    /// @dev Address of the linked app deployed on the remote chain.\n    mapping(uint256 chainId =\u003e bytes32 remoteApp) private _linkedApp;\n    /// @dev Trusted Interchain modules.\n    EnumerableSet.AddressSet private _trustedModules;\n    /// @dev Execution Service to use for sending messages.\n    address private _executionService;\n\n    error InterchainApp__BalanceTooLow(uint256 actual, uint256 expected);\n    error InterchainApp__CallerNotInterchainClient(address caller);\n    error InterchainApp__InterchainClientNotSet();\n    error InterchainApp__ModuleAlreadyAdded(address module);\n    error InterchainApp__ModuleNotAdded(address module);\n    error InterchainApp__ReceiverNotSet(uint256 chainId);\n    error InterchainApp__SameChainId(uint256 chainId);\n    error InterchainApp__SenderNotAllowed(uint256 srcChainId, bytes32 sender);\n\n    /// @inheritdoc IInterchainApp\n    function appReceive(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        if (msg.sender != interchain) revert InterchainApp__CallerNotInterchainClient(msg.sender);\n        if (srcChainId == block.chainid) revert InterchainApp__SameChainId(srcChainId);\n        if (!isAllowedSender(srcChainId, sender)) revert InterchainApp__SenderNotAllowed(srcChainId, sender);\n        _receiveMessage(srcChainId, sender, dbNonce, entryIndex, message);\n        // Note: application may elect to emit an event in `_receiveMessage`, so we don't emit a generic event here.\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainApp\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules) {\n        // Note: the getters for app config and modules could be overridden in the derived contracts.\n        appConfig = getAppConfigV1().encodeAppConfigV1();\n        modules = getReceivingModules();\n    }\n\n    /// @notice Returns the app config for receiving messages.\n    /// @dev Could be overridden in the derived contracts.\n    function getAppConfigV1() public view virtual returns (AppConfigV1 memory) {\n        return _appConfigV1;\n    }\n\n    /// @notice Returns the address of the Execution Service to use for sending messages.\n    /// @dev Could be overridden in the derived contracts.\n    function getExecutionService() public view virtual returns (address) {\n        return _executionService;\n    }\n\n    /// @notice Returns the linked app address (as bytes32) for the given chain ID.\n    /// @dev Could be overridden in the derived contracts.\n    function getLinkedApp(uint256 chainId) public view virtual returns (bytes32) {\n        return _linkedApp[chainId];\n    }\n\n    /// @notice Returns the list of modules used for sending messages.\n    /// @dev Could be overridden in the derived contracts.\n    function getSendingModules() public view virtual returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    /// @notice Returns the list of modules used for receiving messages.\n    /// @dev Could be overridden in the derived contracts.\n    function getReceivingModules() public view virtual returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    /// @notice Checks whether the sender is allowed to send messages to the current app.\n    /// @dev Could be overridden in the derived contracts.\n    function isAllowedSender(uint256 srcChainId, bytes32 sender) public view virtual returns (bool) {\n        return _linkedApp[srcChainId] == sender;\n    }\n\n    /// @notice Returns the current app version.\n    /// @dev Could be overridden in the derived contracts.\n    function getAppVersion() public pure virtual returns (uint256) {\n        return 1;\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Links the remote app to the current app.\n    /// Will revert if the chainId is the same as the chainId of the local app.\n    /// Note: Should be guarded with permissions check.\n    function _linkRemoteApp(uint256 chainId, bytes32 remoteApp) internal {\n        if (chainId == block.chainid) revert InterchainApp__SameChainId(chainId);\n        _linkedApp[chainId] = remoteApp;\n        emit AppLinked(chainId, remoteApp);\n    }\n\n    /// @dev Thin wrapper around _linkRemoteApp to accept EVM address as a parameter.\n    function _linkRemoteAppEVM(uint256 chainId, address remoteApp) internal {\n        _linkRemoteApp(chainId, TypeCasts.addressToBytes32(remoteApp));\n    }\n\n    /// @dev Adds the module to the trusted modules set.\n    /// Will revert if the module is already added.\n    /// Note: Should be guarded with permissions check.\n    function _addTrustedModule(address module) internal {\n        bool added = _trustedModules.add(module);\n        if (!added) revert InterchainApp__ModuleAlreadyAdded(module);\n        emit TrustedModuleAdded(module);\n    }\n\n    /// @dev Removes the module from the trusted modules set.\n    /// Will revert if the module is not added.\n    /// Note: Should be guarded with permissions check.\n    function _removeTrustedModule(address module) internal {\n        bool removed = _trustedModules.remove(module);\n        if (!removed) revert InterchainApp__ModuleNotAdded(module);\n        emit TrustedModuleRemoved(module);\n    }\n\n    /// @dev Sets the app config:\n    /// - requiredResponses: the number of module responses required for accepting the message\n    /// - optimisticPeriod: the minimum time after which the module responses are considered final\n    /// Note: Should be guarded with permissions check.\n    function _setAppConfigV1(AppConfigV1 memory appConfig) internal {\n        _appConfigV1 = appConfig;\n        emit AppConfigV1Set(appConfig.requiredResponses, appConfig.optimisticPeriod);\n    }\n\n    /// @dev Sets the execution service address.\n    /// Note: Should be guarded with permissions check.\n    function _setExecutionService(address executionService) internal {\n        _executionService = executionService;\n        emit ExecutionServiceSet(executionService);\n    }\n\n    /// @dev Sets the interchain client address.\n    /// Note: Should be guarded with permissions check.\n    function _setInterchainClient(address interchain_) internal {\n        interchain = interchain_;\n        emit InterchainClientSet(interchain_);\n    }\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to send the message to the linked app.\n    function _sendInterchainMessage(\n        uint256 dstChainId,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _sendInterchainMessage(dstChainId, getLinkedApp(dstChainId), messageFee, options, message);\n    }\n\n    /// @dev Thin wrapper around _sendInterchainMessage to accept EVM address as a parameter.\n    function _sendInterchainMessageEVM(\n        uint256 dstChainId,\n        address receiver,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _sendInterchainMessage(dstChainId, TypeCasts.addressToBytes32(receiver), messageFee, options, message);\n    }\n\n    /// @dev Performs necessary checks and sends an interchain message.\n    function _sendInterchainMessage(\n        uint256 dstChainId,\n        bytes32 receiver,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        address cachedInterchain = interchain;\n//        if (cachedInterchain == address(0)) revert InterchainApp__InterchainClientNotSet();\n//        if (dstChainId == block.chainid) revert InterchainApp__SameChainId(dstChainId);\n//        if (receiver == 0) revert InterchainApp__ReceiverNotSet(dstChainId);\n//        if (address(this).balance \u003c messageFee) revert InterchainApp__BalanceTooLow(address(this).balance, messageFee);\n        return IInterchainClientV1(cachedInterchain).interchainSend{value: messageFee}(\n            dstChainId, receiver, getExecutionService(), getSendingModules(), options.encodeOptionsV1(), message\n        );\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        virtual;\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee for sending an Interchain message.\n    function _getInterchainFee(\n        uint256 dstChainId,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        address cachedInterchain = interchain;\n        if (cachedInterchain == address(0)) revert InterchainApp__InterchainClientNotSet();\n        return IInterchainClientV1(cachedInterchain).getInterchainFee(\n            dstChainId, getExecutionService(), getSendingModules(), options.encodeOptionsV1(), message\n        );\n    }\n}\n\n// contracts/apps/OwnableApp.sol\n\nabstract contract OwnableApp is InterchainAppV1, Ownable {\n    constructor(address owner_) Ownable(owner_) {}\n\n    /// @notice Allows the owner to link the remote app for the given chain ID.\n    /// - This address will be used as the receiver for the messages sent from this chain.\n    /// - This address will be the only trusted sender for the messages sent to this chain.\n    function linkRemoteApp(uint256 chainId, bytes32 remoteApp) external onlyOwner {\n        _linkRemoteApp(chainId, remoteApp);\n    }\n\n    /// @notice This wrapper for `linkRemoteApp` to accept EVM address as a parameter.\n    function linkRemoteAppEVM(uint256 chainId, address remoteApp) external onlyOwner {\n        _linkRemoteAppEVM(chainId, remoteApp);\n    }\n\n    /// @notice Allows the owner to add the module to the trusted modules set.\n    /// - This set of modules will be used to verify message sent from this chain.\n    /// - This set of modules will be used to verify message sent to this chain.\n    function addTrustedModule(address module) external onlyOwner {\n        _addTrustedModule(module);\n    }\n\n    /// @notice Allows the owner to remove the module from the trusted modules set.\n    function removeTrustedModule(address module) external onlyOwner {\n        _removeTrustedModule(module);\n    }\n\n    /// @notice Allows the owner to set the app config for the current app. App config includes:\n    /// - requiredResponses: the number of module responses required for accepting the message\n    /// - optimisticPeriod: the minimum time after which the module responses are considered final\n    function setAppConfigV1(AppConfigV1 memory appConfig) external onlyOwner {\n        _setAppConfigV1(appConfig);\n    }\n\n    /// @notice Allows the owner to set the address of the Execution Service.\n    /// This address will be used to request execution of the messages sent from this chain,\n    /// by supplying the Service's execution fee.\n    function setExecutionService(address executionService) external onlyOwner {\n        _setExecutionService(executionService);\n    }\n\n    /// @notice Allows the owner to set the address of the InterchainClient contract.\n    function setInterchainClient(address interchain_) external onlyOwner {\n        _setInterchainClient(interchain_);\n    }\n}\n\n// contracts/apps/InterchainAppExample.sol\n\ncontract InterchainAppExample is OwnableApp {\n    event MessageReceived(uint256 srcChainId, bytes32 sender, uint256 dbNonce, uint64 entryIndex, bytes message);\n    event MessageSent(uint256 dstChainId, uint256 dbNonce, uint64 entryIndex, bytes32 transactionId);\n\n    constructor(address owner_) OwnableApp(owner_) {}\n\n    /// @notice Sends a basic message to the destination chain.\n    function sendMessage(uint256 dstChainId, uint256 gasLimit, bytes calldata message) external payable {\n        InterchainTxDescriptor memory desc = _sendInterchainMessage({\n            dstChainId: dstChainId,\n            messageFee: msg.value,\n            options: OptionsV1({gasLimit: gasLimit, gasAirdrop: 0}),\n            message: message\n        });\n        emit MessageSent(dstChainId, desc.dbNonce, desc.entryIndex, desc.transactionId);\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        override\n    {\n        emit MessageReceived(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"5751:280:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;5751:280:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"5751:280:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainAppExample.sol\":\"TypeCasts\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainAppExample.sol\":{\"keccak256\":\"0x86f91eccd427db2c0e6cbbdb2244f577ed8111343e9ad8aa6476b8b0bd7cb65c\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://c9a5bce8ffbdc1808235baa92fe6b0fff964c26898bb155a1b06e5ea3e4f3940\",\"dweb:/ipfs/QmZqjYVRz4JL5Pjz9TZqVSy7PUZGsabLKsxtHXP44i3TVK\"]}},\"version\":1}"},"hashes":{}}}