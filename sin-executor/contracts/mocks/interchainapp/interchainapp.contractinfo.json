{"solidity/ExampleAppV1.sol:AbstractICApp":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/AbstractICAppEvents.sol\n\nabstract contract AbstractICAppEvents {\n    event InterchainClientAdded(address client);\n    event InterchainClientRemoved(address client);\n    event LatestClientSet(address client);\n}\n\n// contracts/events/InterchainAppV1Events.sol\n\nabstract contract InterchainAppV1Events {\n    event AppConfigV1Set(uint256 requiredResponses, uint256 optimisticPeriod);\n    event AppLinked(uint256 indexed chainId, bytes32 indexed remoteApp);\n    event ExecutionServiceSet(address executionService);\n    event TrustedModuleAdded(address module);\n    event TrustedModuleRemoved(address module);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    /// @notice Allows the Interchain Client to pass the message to the Interchain App.\n    /// @dev App is responsible for keeping track of interchain clients, and must verify the message sender.\n    /// @param srcChainId   Chain ID of the source chain, where the message was sent from.\n    /// @param sender       Sender address on the source chain, as a bytes32 value.\n    /// @param dbNonce      The Interchain DB nonce of the batch containing the message entry.\n    /// @param entryIndex   The index of the message entry within the batch.\n    /// @param message      The message being sent.\n    function appReceive(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /// @notice Returns the verification configuration of the Interchain App.\n    /// @dev This configuration is used by the Interchain Client to verify that message has been confirmed\n    /// by the Interchain Modules on the destination chain.\n    /// Note: V1 version of AppConfig includes the required responses count, and optimistic period after which\n    /// the message is considered confirmed by the module. Following versions may include additional fields.\n    /// @return appConfig    The versioned configuration of the Interchain App, encoded as bytes.\n    /// @return modules      The list of Interchain Modules that app is trusting to confirm the messages.\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    uint8 constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint8 version);\n\n    /// @notice Encodes versioned app config into a bytes format.\n    /// @param version      The version of the app config.\n    /// @param appConfig    The app config to encode.\n    function encodeVersionedAppConfig(uint8 version, bytes memory appConfig) internal pure returns (bytes memory) {\n        return abi.encode(version, appConfig);\n    }\n\n    /// @notice Decodes versioned app config from a bytes format back into a version and app config.\n    /// @param data         The versioned app config data in bytes format.\n    /// @return version     The version of the app config.\n    /// @return appConfig   The app config as bytes.\n    function decodeVersionedAppConfig(bytes memory data)\n        internal\n        pure\n        returns (uint8 version, bytes memory appConfig)\n    {\n        (version, appConfig) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return encodeVersionedAppConfig(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal pure returns (AppConfigV1 memory) {\n        (uint8 version, bytes memory appConfig) = decodeVersionedAppConfig(data);\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(appConfig, (AppConfigV1));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    uint8 constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint8 version);\n\n    /// @notice Encodes versioned options into a bytes format.\n    /// @param version      The version of the options.\n    /// @param options      The options to encode.\n    function encodeVersionedOptions(uint8 version, bytes memory options) internal pure returns (bytes memory) {\n        return abi.encode(version, options);\n    }\n\n    /// @notice Decodes versioned options from a bytes format back into a version and options.\n    /// @param data         The versioned options data in bytes format.\n    /// @return version     The version of the options.\n    /// @return options     The options as bytes.\n    function decodeVersionedOptions(bytes memory data) internal pure returns (uint8 version, bytes memory options) {\n        (version, options) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return encodeVersionedOptions(OPTIONS_V1, abi.encode(options));\n    }\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal pure returns (OptionsV1 memory) {\n        (uint8 version, bytes memory options) = decodeVersionedOptions(data);\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(options, (OptionsV1));\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/IAccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n\n// node_modules/@openzeppelin/contracts/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance \u003c amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance \u003c value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 \u0026\u0026 target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/libs/InterchainTransaction.sol\n\nstruct InterchainTransaction {\n    uint256 srcChainId;\n    bytes32 srcSender;\n    uint256 dstChainId;\n    bytes32 dstReceiver;\n    uint256 dbNonce;\n    uint64 entryIndex;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint256 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    function constructLocalTransaction(\n        address srcSender,\n        uint256 dstChainId,\n        bytes32 dstReceiver,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: block.chainid,\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(transaction);\n    }\n\n    function decodeTransaction(bytes memory encodedTx) internal pure returns (InterchainTransaction memory) {\n        return abi.decode(encodedTx, (InterchainTransaction));\n    }\n\n    function transactionId(InterchainTransaction memory transaction) internal pure returns (bytes32) {\n        return keccak256(abi.encode(transaction));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/IAccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/IAccessControlEnumerable.sol)\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n// contracts/interfaces/IInterchainAppV1.sol\n\ninterface IInterchainAppV1 is IInterchainApp {\n    error InterchainApp__AppZeroAddress();\n    error InterchainApp__InvalidAppConfig(uint256 requiredResponses, uint256 optimisticPeriod);\n    error InterchainApp__ModuleAlreadyAdded(address module);\n    error InterchainApp__ModuleNotAdded(address module);\n    error InterchainApp__ModuleZeroAddress();\n    error InterchainApp__NotEVMLinkedApp(bytes32 linkedApp);\n\n    /// @notice Allows the owner to add the interchain client to the allowed clients set,\n    /// and optionally set the latest client to this one.\n    /// Note: only the allowed clients can send messages to this app.\n    /// Note: the latest client is used for sending messages from this app.\n    /// @param client       The address of the interchain client to add.\n    /// @param updateLatest Whether to set the latest client to this one.\n    function addInterchainClient(address client, bool updateLatest) external;\n\n    /// @notice Allows the owner to remove the interchain client from the allowed clients set.\n    /// If the client is the latest client, the latest client is set to the zero address.\n    /// @param client       The address of the interchain client to remove.\n    function removeInterchainClient(address client) external;\n\n    /// @notice Allows the owner to set the address of the latest interchain client.\n    /// @dev The new latest client must be an allowed client or zero address.\n    /// Setting the client to zero address effectively pauses the app ability to send messages,\n    /// while allowing to receive them.\n    /// @param client       The address of the latest interchain client.\n    function setLatestInterchainClient(address client) external;\n\n    /// @notice Allows the owner to link the remote app for the given chain ID.\n    /// - This address will be used as the receiver for the messages sent from this chain.\n    /// - This address will be the only trusted sender for the messages sent to this chain.\n    /// @param chainId      The remote chain ID.\n    /// @param remoteApp    The address of the remote app to link.\n    function linkRemoteApp(uint256 chainId, bytes32 remoteApp) external;\n\n    /// @notice Thin wrapper for `linkRemoteApp` to accept EVM address as a parameter.\n    function linkRemoteAppEVM(uint256 chainId, address remoteApp) external;\n\n    /// @notice Allows the owner to add the module to the trusted modules set.\n    /// - This set of modules will be used to verify both sent and received messages.\n    function addTrustedModule(address module) external;\n\n    /// @notice Allows the owner to remove the module from the trusted modules set.\n    function removeTrustedModule(address module) external;\n\n    /// @notice Allows the owner to set the app config for the current app. App config includes:\n    /// - requiredResponses: the number of module responses required for accepting the message\n    /// - optimisticPeriod: the minimum time after which the module responses are considered final\n    function setAppConfigV1(AppConfigV1 memory appConfig) external;\n\n    /// @notice Allows the owner to set the address of the Execution Service.\n    /// This address will be used to request execution of the messages sent from this chain,\n    /// by supplying the Service's execution fee.\n    function setExecutionService(address executionService) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Returns the app config for the current app: requiredResponses and optimisticPeriod.\n    function getAppConfigV1() external view returns (AppConfigV1 memory);\n\n    /// @notice Returns the address of the Execution Service used by this app for sending messages.\n    function getExecutionService() external view returns (address);\n\n    /// @notice Returns the list of Interchain Clients allowed to send messages to this app.\n    function getInterchainClients() external view returns (address[] memory);\n\n    /// @notice Returns the address of the latest interchain client.\n    /// This address is used for sending messages from this app.\n    function getLatestInterchainClient() external view returns (address);\n\n    /// @notice Returns the linked app address (as bytes32) for the given chain ID.\n    function getLinkedApp(uint256 chainId) external view returns (bytes32);\n\n    /// @notice Thin wrapper for `getLinkedApp` to return the linked app address as EVM address.\n    /// @dev Will revert if the linked app address is not an EVM address.\n    function getLinkedAppEVM(uint256 chainId) external view returns (address);\n\n    /// @notice Returns the list of Interchain Modules trusted by this app.\n    /// This set of modules will be used to verify both sent and received messages.\n    function getModules() external view returns (address[] memory);\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint256 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__NoLinkedClient(uint256 chainId);\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint256 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint256 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint256 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint256 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint256 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param message              The message being sent.\n    function getInterchainFee(\n        uint256 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint256 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint256 chainId) external view returns (address);\n}\n\n// node_modules/@openzeppelin/contracts/access/AccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account =\u003e bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role =\u003e RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n// contracts/apps/AbstractICApp.sol\n\nabstract contract AbstractICApp is AbstractICAppEvents, IInterchainApp {\n    using TypeCasts for address;\n\n    error InterchainApp__AlreadyLatestClient(address client);\n    error InterchainApp__BalanceTooLow(uint256 actual, uint256 required);\n    error InterchainApp__ClientAlreadyAdded(address client);\n    error InterchainApp__InterchainClientZeroAddress();\n    error InterchainApp__NotInterchainClient(address account);\n    error InterchainApp__ReceiverNotSet(uint256 chainId);\n    error InterchainApp__SameChainId(uint256 chainId);\n    error InterchainApp__SenderNotAllowed(uint256 srcChainId, bytes32 sender);\n\n    /// @inheritdoc IInterchainApp\n    function appReceive(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        if (!_isInterchainClient(msg.sender)) {\n            revert InterchainApp__NotInterchainClient(msg.sender);\n        }\n        if (srcChainId == block.chainid) {\n            revert InterchainApp__SameChainId(srcChainId);\n        }\n        if (!_isAllowedSender(srcChainId, sender)) {\n            revert InterchainApp__SenderNotAllowed(srcChainId, sender);\n        }\n        _receiveMessage(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n\n    /// @inheritdoc IInterchainApp\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules) {\n        appConfig = _getAppConfig();\n        modules = _getModules();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Performs necessary checks and adds an Interchain Client.\n    /// Optionally sets the latest client to this one.\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _addClient(address client, bool updateLatest) internal {\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (_isInterchainClient(client)) {\n            revert InterchainApp__ClientAlreadyAdded(client);\n        }\n        _toggleClientState(client, true);\n        emit InterchainClientAdded(client);\n        if (updateLatest) {\n            _setLatestClient(client);\n        }\n    }\n\n    /// @dev Performs necessary checks and removes an Interchain Client. If this client is the latest one,\n    /// the latest client is set to zero address (effectively pausing the app ability to send messages).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _removeClient(address client) internal {\n        if (!_isInterchainClient(client)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        _toggleClientState(client, false);\n        emit InterchainClientRemoved(client);\n        if (client == _getLatestClient()) {\n            _setLatestClient(address(0));\n        }\n    }\n\n    /// @dev Sets the latest Interchain Client to one of the allowed clients. Setting the client to zero address\n    /// is allowed and effectively pauses the app ability to send messages (but still allows to receive them).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _setLatestClient(address client) internal {\n        // New latest client must be an allowed client or zero address.\n        if (!_isInterchainClient(client) \u0026\u0026 client != address(0)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        if (client == _getLatestClient()) {\n            revert InterchainApp__AlreadyLatestClient(client);\n        }\n        _storeLatestClient(client);\n        emit LatestClientSet(client);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal virtual;\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal virtual;\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to accept EVM address as a parameter.\n    function _sendInterchainMessageEVM(\n        uint256 dstChainId,\n        address receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _sendInterchainMessage(dstChainId, receiver.addressToBytes32(), messageFee, options, message);\n    }\n\n    /// @dev Performs necessary checks and sends an interchain message.\n    function _sendInterchainMessage(\n        uint256 dstChainId,\n        bytes32 receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (dstChainId == block.chainid) {\n            revert InterchainApp__SameChainId(dstChainId);\n        }\n        if (receiver == 0) {\n            revert InterchainApp__ReceiverNotSet(dstChainId);\n        }\n        if (address(this).balance \u003c messageFee) {\n            revert InterchainApp__BalanceTooLow({actual: address(this).balance, required: messageFee});\n        }\n        return IInterchainClientV1(client).interchainSend{value: messageFee}(\n            dstChainId, receiver, _getExecutionService(), _getModules(), options, message\n        );\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        virtual;\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee for sending an Interchain message.\n    function _getInterchainFee(\n        uint256 dstChainId,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        return IInterchainClientV1(client).getInterchainFee(\n            dstChainId, _getExecutionService(), _getModules(), options, message\n        );\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view virtual returns (bytes memory);\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view virtual returns (address);\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view virtual returns (address);\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view virtual returns (address[] memory);\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint256 srcChainId, bytes32 sender) internal view virtual returns (bool);\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view virtual returns (bool);\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/AccessControlEnumerable.sol)\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 role =\u003e EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {AccessControl-_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool granted = super._grantRole(role, account);\n        if (granted) {\n            _roleMembers[role].add(account);\n        }\n        return granted;\n    }\n\n    /**\n     * @dev Overload {AccessControl-_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool revoked = super._revokeRole(role, account);\n        if (revoked) {\n            _roleMembers[role].remove(account);\n        }\n        return revoked;\n    }\n}\n\n// contracts/apps/ICAppV1.sol\n\nabstract contract ICAppV1 is AbstractICApp, AccessControlEnumerable, InterchainAppV1Events, IInterchainAppV1 {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Role to manage the Interchain setup of the app.\n    bytes32 public constant IC_GOVERNOR_ROLE = keccak256(\"IC_GOVERNOR_ROLE\");\n\n    /// @dev Address of the latest Interchain Client, used for sending messages.\n    address private _latestClient;\n\n    /// @dev Required responses and optimistic period for the module responses.\n    AppConfigV1 private _appConfigV1;\n    /// @dev Address of the linked app deployed on the remote chain.\n    mapping(uint256 chainId =\u003e bytes32 remoteApp) private _linkedApp;\n    /// @dev Interchain Clients allowed to send messages to this app.\n    EnumerableSet.AddressSet private _interchainClients;\n    /// @dev Trusted Interchain modules.\n    EnumerableSet.AddressSet private _trustedModules;\n    /// @dev Execution Service to use for sending messages.\n    address private _executionService;\n\n    constructor(address admin) {\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addInterchainClient(address client, bool updateLatest) external onlyRole(IC_GOVERNOR_ROLE) {\n        _addClient(client, updateLatest);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _removeClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setLatestInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _setLatestClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteApp(uint256 chainId, bytes32 remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteAppEVM(uint256 chainId, address remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp.addressToBytes32());\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (module == address(0)) {\n            revert InterchainApp__ModuleZeroAddress();\n        }\n        bool added = _trustedModules.add(module);\n        if (!added) {\n            revert InterchainApp__ModuleAlreadyAdded(module);\n        }\n        emit TrustedModuleAdded(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        bool removed = _trustedModules.remove(module);\n        if (!removed) {\n            revert InterchainApp__ModuleNotAdded(module);\n        }\n        emit TrustedModuleRemoved(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setAppConfigV1(AppConfigV1 memory appConfig) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (appConfig.requiredResponses == 0 || appConfig.optimisticPeriod == 0) {\n            revert InterchainApp__InvalidAppConfig(appConfig.requiredResponses, appConfig.optimisticPeriod);\n        }\n        _appConfigV1 = appConfig;\n        emit AppConfigV1Set(appConfig.requiredResponses, appConfig.optimisticPeriod);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setExecutionService(address executionService) external onlyRole(IC_GOVERNOR_ROLE) {\n        _executionService = executionService;\n        emit ExecutionServiceSet(executionService);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainAppV1\n    function getAppConfigV1() external view returns (AppConfigV1 memory) {\n        return _appConfigV1;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getExecutionService() external view returns (address) {\n        return _executionService;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getInterchainClients() external view returns (address[] memory) {\n        return _interchainClients.values();\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLatestInterchainClient() external view returns (address) {\n        return _latestClient;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedApp(uint256 chainId) external view returns (bytes32) {\n        return _linkedApp[chainId];\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedAppEVM(uint256 chainId) external view returns (address linkedAppEVM) {\n        bytes32 linkedApp = _linkedApp[chainId];\n        linkedAppEVM = linkedApp.bytes32ToAddress();\n        if (linkedAppEVM.addressToBytes32() != linkedApp) {\n            revert InterchainApp__NotEVMLinkedApp(linkedApp);\n        }\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getModules() external view returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Links the remote app to the current app.\n    /// Will revert if the chainId is the same as the chainId of the local app.\n    /// Note: Should be guarded with permissions check.\n    function _linkRemoteApp(uint256 chainId, bytes32 remoteApp) internal {\n        if (chainId == block.chainid) {\n            revert InterchainApp__SameChainId(chainId);\n        }\n        if (remoteApp == 0) {\n            revert InterchainApp__AppZeroAddress();\n        }\n        _linkedApp[chainId] = remoteApp;\n        emit AppLinked(chainId, remoteApp);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal override {\n        _latestClient = client;\n    }\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal override {\n        if (allowed) {\n            _interchainClients.add(client);\n        } else {\n            _interchainClients.remove(client);\n        }\n    }\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to send the message to the linked app.\n    function _sendToLinkedApp(\n        uint256 dstChainId,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _sendInterchainMessage(dstChainId, _linkedApp[dstChainId], messageFee, encodedOptions, message);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee to send a message to the linked app on the remote chain.\n    function _getMessageFee(\n        uint256 dstChainId,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _getInterchainFee(dstChainId, encodedOptions, message);\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view override returns (bytes memory) {\n        return _appConfigV1.encodeAppConfigV1();\n    }\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view override returns (address) {\n        return _executionService;\n    }\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view override returns (address) {\n        return _latestClient;\n    }\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view override returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint256 srcChainId, bytes32 sender) internal view override returns (bool) {\n        return _linkedApp[srcChainId] == sender;\n    }\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view override returns (bool) {\n        return _interchainClients.contains(caller);\n    }\n}\n\n// contracts/apps/examples/ExampleAppV1.sol\n\ncontract ExampleAppV1 is ICAppV1 {\n    event MessageReceived(uint256 srcChainId, bytes32 sender, uint256 dbNonce, uint64 entryIndex, bytes message);\n    event MessageSent(uint256 dstChainId, uint256 dbNonce, uint64 entryIndex, bytes32 transactionId);\n\n    constructor(address admin) ICAppV1(admin) {\n        _grantRole(IC_GOVERNOR_ROLE, admin);\n    }\n\n    /// @notice Allows the Admin to withdraw the native asset from the contract.\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        Address.sendValue(payable(msg.sender), address(this).balance);\n    }\n\n    /// @notice Sends a basic message to the destination chain.\n    function sendMessage(\n        uint256 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        InterchainTxDescriptor memory desc = _sendToLinkedApp({\n            dstChainId: dstChainId,\n            messageFee: msg.value,\n            options: OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}),\n            message: message\n        });\n        emit MessageSent(dstChainId, desc.dbNonce, desc.entryIndex, desc.transactionId);\n    }\n\n    /// @notice Returns the fee required to send a message using `sendMessage`.\n    function getMessageFee(\n        uint256 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes memory message\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _getMessageFee(dstChainId, OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}), message);\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        override\n    {\n        emit MessageReceived(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"address","name":"client","type":"address"}],"name":"InterchainApp__AlreadyLatestClient","type":"error"},{"inputs":[{"internalType":"uint256","name":"actual","type":"uint256"},{"internalType":"uint256","name":"required","type":"uint256"}],"name":"InterchainApp__BalanceTooLow","type":"error"},{"inputs":[{"internalType":"address","name":"client","type":"address"}],"name":"InterchainApp__ClientAlreadyAdded","type":"error"},{"inputs":[],"name":"InterchainApp__InterchainClientZeroAddress","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"InterchainApp__NotInterchainClient","type":"error"},{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"}],"name":"InterchainApp__ReceiverNotSet","type":"error"},{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"}],"name":"InterchainApp__SameChainId","type":"error"},{"inputs":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"bytes32","name":"sender","type":"bytes32"}],"name":"InterchainApp__SenderNotAllowed","type":"error"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"client","type":"address"}],"name":"InterchainClientAdded","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"client","type":"address"}],"name":"InterchainClientRemoved","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"client","type":"address"}],"name":"LatestClientSet","type":"event"},{"inputs":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"bytes32","name":"sender","type":"bytes32"},{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"uint64","name":"entryIndex","type":"uint64"},{"internalType":"bytes","name":"message","type":"bytes"}],"name":"appReceive","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"getReceivingConfig","outputs":[{"internalType":"bytes","name":"appConfig","type":"bytes"},{"internalType":"address[]","name":"modules","type":"address[]"}],"stateMutability":"view","type":"function"}],"userDoc":{"kind":"user","methods":{"appReceive(uint256,bytes32,uint256,uint64,bytes)":{"notice":"Allows the Interchain Client to pass the message to the Interchain App."},"getReceivingConfig()":{"notice":"Returns the verification configuration of the Interchain App."}},"version":1},"developerDoc":{"kind":"dev","methods":{"appReceive(uint256,bytes32,uint256,uint64,bytes)":{"details":"App is responsible for keeping track of interchain clients, and must verify the message sender.","params":{"dbNonce":"The Interchain DB nonce of the batch containing the message entry.","entryIndex":"The index of the message entry within the batch.","message":"The message being sent.","sender":"Sender address on the source chain, as a bytes32 value.","srcChainId":"Chain ID of the source chain, where the message was sent from."}},"getReceivingConfig()":{"details":"This configuration is used by the Interchain Client to verify that message has been confirmed by the Interchain Modules on the destination chain. Note: V1 version of AppConfig includes the required responses count, and optimistic period after which the message is considered confirmed by the module. Following versions may include additional fields.","returns":{"appConfig":"   The versioned configuration of the Interchain App, encoded as bytes.","modules":"     The list of Interchain Modules that app is trusting to confirm the messages."}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"}],\"name\":\"InterchainApp__AlreadyLatestClient\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"required\",\"type\":\"uint256\"}],\"name\":\"InterchainApp__BalanceTooLow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"}],\"name\":\"InterchainApp__ClientAlreadyAdded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InterchainApp__InterchainClientZeroAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"InterchainApp__NotInterchainClient\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"InterchainApp__ReceiverNotSet\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"InterchainApp__SameChainId\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"}],\"name\":\"InterchainApp__SenderNotAllowed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"}],\"name\":\"InterchainClientAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"}],\"name\":\"InterchainClientRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"}],\"name\":\"LatestClientSet\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"appReceive\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReceivingConfig\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"appConfig\",\"type\":\"bytes\"},{\"internalType\":\"address[]\",\"name\":\"modules\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"appReceive(uint256,bytes32,uint256,uint64,bytes)\":{\"details\":\"App is responsible for keeping track of interchain clients, and must verify the message sender.\",\"params\":{\"dbNonce\":\"The Interchain DB nonce of the batch containing the message entry.\",\"entryIndex\":\"The index of the message entry within the batch.\",\"message\":\"The message being sent.\",\"sender\":\"Sender address on the source chain, as a bytes32 value.\",\"srcChainId\":\"Chain ID of the source chain, where the message was sent from.\"}},\"getReceivingConfig()\":{\"details\":\"This configuration is used by the Interchain Client to verify that message has been confirmed by the Interchain Modules on the destination chain. Note: V1 version of AppConfig includes the required responses count, and optimistic period after which the message is considered confirmed by the module. Following versions may include additional fields.\",\"returns\":{\"appConfig\":\"   The versioned configuration of the Interchain App, encoded as bytes.\",\"modules\":\"     The list of Interchain Modules that app is trusting to confirm the messages.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"appReceive(uint256,bytes32,uint256,uint64,bytes)\":{\"notice\":\"Allows the Interchain Client to pass the message to the Interchain App.\"},\"getReceivingConfig()\":{\"notice\":\"Returns the verification configuration of the Interchain App.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/ExampleAppV1.sol\":\"AbstractICApp\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/ExampleAppV1.sol\":{\"keccak256\":\"0x4c94807e7a2671ad6fcf49fb03cfafa6f51f6b4596f34092fba0bf17b6d482cf\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://4fabc9aa6f6891674b77809808b14ff1f2e8829de650caafa1fb3c3444a07331\",\"dweb:/ipfs/QmVzYNSfkuSkXNaFKuNY3hmkdspssruAhQx4qZuJU3Ceg9\"]}},\"version\":1}"},"hashes":{"appReceive(uint256,bytes32,uint256,uint64,bytes)":"68a69847","getReceivingConfig()":"287bc057"}},"solidity/ExampleAppV1.sol:AbstractICAppEvents":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/AbstractICAppEvents.sol\n\nabstract contract AbstractICAppEvents {\n    event InterchainClientAdded(address client);\n    event InterchainClientRemoved(address client);\n    event LatestClientSet(address client);\n}\n\n// contracts/events/InterchainAppV1Events.sol\n\nabstract contract InterchainAppV1Events {\n    event AppConfigV1Set(uint256 requiredResponses, uint256 optimisticPeriod);\n    event AppLinked(uint256 indexed chainId, bytes32 indexed remoteApp);\n    event ExecutionServiceSet(address executionService);\n    event TrustedModuleAdded(address module);\n    event TrustedModuleRemoved(address module);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    /// @notice Allows the Interchain Client to pass the message to the Interchain App.\n    /// @dev App is responsible for keeping track of interchain clients, and must verify the message sender.\n    /// @param srcChainId   Chain ID of the source chain, where the message was sent from.\n    /// @param sender       Sender address on the source chain, as a bytes32 value.\n    /// @param dbNonce      The Interchain DB nonce of the batch containing the message entry.\n    /// @param entryIndex   The index of the message entry within the batch.\n    /// @param message      The message being sent.\n    function appReceive(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /// @notice Returns the verification configuration of the Interchain App.\n    /// @dev This configuration is used by the Interchain Client to verify that message has been confirmed\n    /// by the Interchain Modules on the destination chain.\n    /// Note: V1 version of AppConfig includes the required responses count, and optimistic period after which\n    /// the message is considered confirmed by the module. Following versions may include additional fields.\n    /// @return appConfig    The versioned configuration of the Interchain App, encoded as bytes.\n    /// @return modules      The list of Interchain Modules that app is trusting to confirm the messages.\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    uint8 constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint8 version);\n\n    /// @notice Encodes versioned app config into a bytes format.\n    /// @param version      The version of the app config.\n    /// @param appConfig    The app config to encode.\n    function encodeVersionedAppConfig(uint8 version, bytes memory appConfig) internal pure returns (bytes memory) {\n        return abi.encode(version, appConfig);\n    }\n\n    /// @notice Decodes versioned app config from a bytes format back into a version and app config.\n    /// @param data         The versioned app config data in bytes format.\n    /// @return version     The version of the app config.\n    /// @return appConfig   The app config as bytes.\n    function decodeVersionedAppConfig(bytes memory data)\n        internal\n        pure\n        returns (uint8 version, bytes memory appConfig)\n    {\n        (version, appConfig) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return encodeVersionedAppConfig(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal pure returns (AppConfigV1 memory) {\n        (uint8 version, bytes memory appConfig) = decodeVersionedAppConfig(data);\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(appConfig, (AppConfigV1));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    uint8 constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint8 version);\n\n    /// @notice Encodes versioned options into a bytes format.\n    /// @param version      The version of the options.\n    /// @param options      The options to encode.\n    function encodeVersionedOptions(uint8 version, bytes memory options) internal pure returns (bytes memory) {\n        return abi.encode(version, options);\n    }\n\n    /// @notice Decodes versioned options from a bytes format back into a version and options.\n    /// @param data         The versioned options data in bytes format.\n    /// @return version     The version of the options.\n    /// @return options     The options as bytes.\n    function decodeVersionedOptions(bytes memory data) internal pure returns (uint8 version, bytes memory options) {\n        (version, options) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return encodeVersionedOptions(OPTIONS_V1, abi.encode(options));\n    }\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal pure returns (OptionsV1 memory) {\n        (uint8 version, bytes memory options) = decodeVersionedOptions(data);\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(options, (OptionsV1));\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/IAccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n\n// node_modules/@openzeppelin/contracts/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance \u003c amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance \u003c value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 \u0026\u0026 target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/libs/InterchainTransaction.sol\n\nstruct InterchainTransaction {\n    uint256 srcChainId;\n    bytes32 srcSender;\n    uint256 dstChainId;\n    bytes32 dstReceiver;\n    uint256 dbNonce;\n    uint64 entryIndex;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint256 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    function constructLocalTransaction(\n        address srcSender,\n        uint256 dstChainId,\n        bytes32 dstReceiver,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: block.chainid,\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(transaction);\n    }\n\n    function decodeTransaction(bytes memory encodedTx) internal pure returns (InterchainTransaction memory) {\n        return abi.decode(encodedTx, (InterchainTransaction));\n    }\n\n    function transactionId(InterchainTransaction memory transaction) internal pure returns (bytes32) {\n        return keccak256(abi.encode(transaction));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/IAccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/IAccessControlEnumerable.sol)\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n// contracts/interfaces/IInterchainAppV1.sol\n\ninterface IInterchainAppV1 is IInterchainApp {\n    error InterchainApp__AppZeroAddress();\n    error InterchainApp__InvalidAppConfig(uint256 requiredResponses, uint256 optimisticPeriod);\n    error InterchainApp__ModuleAlreadyAdded(address module);\n    error InterchainApp__ModuleNotAdded(address module);\n    error InterchainApp__ModuleZeroAddress();\n    error InterchainApp__NotEVMLinkedApp(bytes32 linkedApp);\n\n    /// @notice Allows the owner to add the interchain client to the allowed clients set,\n    /// and optionally set the latest client to this one.\n    /// Note: only the allowed clients can send messages to this app.\n    /// Note: the latest client is used for sending messages from this app.\n    /// @param client       The address of the interchain client to add.\n    /// @param updateLatest Whether to set the latest client to this one.\n    function addInterchainClient(address client, bool updateLatest) external;\n\n    /// @notice Allows the owner to remove the interchain client from the allowed clients set.\n    /// If the client is the latest client, the latest client is set to the zero address.\n    /// @param client       The address of the interchain client to remove.\n    function removeInterchainClient(address client) external;\n\n    /// @notice Allows the owner to set the address of the latest interchain client.\n    /// @dev The new latest client must be an allowed client or zero address.\n    /// Setting the client to zero address effectively pauses the app ability to send messages,\n    /// while allowing to receive them.\n    /// @param client       The address of the latest interchain client.\n    function setLatestInterchainClient(address client) external;\n\n    /// @notice Allows the owner to link the remote app for the given chain ID.\n    /// - This address will be used as the receiver for the messages sent from this chain.\n    /// - This address will be the only trusted sender for the messages sent to this chain.\n    /// @param chainId      The remote chain ID.\n    /// @param remoteApp    The address of the remote app to link.\n    function linkRemoteApp(uint256 chainId, bytes32 remoteApp) external;\n\n    /// @notice Thin wrapper for `linkRemoteApp` to accept EVM address as a parameter.\n    function linkRemoteAppEVM(uint256 chainId, address remoteApp) external;\n\n    /// @notice Allows the owner to add the module to the trusted modules set.\n    /// - This set of modules will be used to verify both sent and received messages.\n    function addTrustedModule(address module) external;\n\n    /// @notice Allows the owner to remove the module from the trusted modules set.\n    function removeTrustedModule(address module) external;\n\n    /// @notice Allows the owner to set the app config for the current app. App config includes:\n    /// - requiredResponses: the number of module responses required for accepting the message\n    /// - optimisticPeriod: the minimum time after which the module responses are considered final\n    function setAppConfigV1(AppConfigV1 memory appConfig) external;\n\n    /// @notice Allows the owner to set the address of the Execution Service.\n    /// This address will be used to request execution of the messages sent from this chain,\n    /// by supplying the Service's execution fee.\n    function setExecutionService(address executionService) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Returns the app config for the current app: requiredResponses and optimisticPeriod.\n    function getAppConfigV1() external view returns (AppConfigV1 memory);\n\n    /// @notice Returns the address of the Execution Service used by this app for sending messages.\n    function getExecutionService() external view returns (address);\n\n    /// @notice Returns the list of Interchain Clients allowed to send messages to this app.\n    function getInterchainClients() external view returns (address[] memory);\n\n    /// @notice Returns the address of the latest interchain client.\n    /// This address is used for sending messages from this app.\n    function getLatestInterchainClient() external view returns (address);\n\n    /// @notice Returns the linked app address (as bytes32) for the given chain ID.\n    function getLinkedApp(uint256 chainId) external view returns (bytes32);\n\n    /// @notice Thin wrapper for `getLinkedApp` to return the linked app address as EVM address.\n    /// @dev Will revert if the linked app address is not an EVM address.\n    function getLinkedAppEVM(uint256 chainId) external view returns (address);\n\n    /// @notice Returns the list of Interchain Modules trusted by this app.\n    /// This set of modules will be used to verify both sent and received messages.\n    function getModules() external view returns (address[] memory);\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint256 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__NoLinkedClient(uint256 chainId);\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint256 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint256 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint256 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint256 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint256 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param message              The message being sent.\n    function getInterchainFee(\n        uint256 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint256 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint256 chainId) external view returns (address);\n}\n\n// node_modules/@openzeppelin/contracts/access/AccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account =\u003e bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role =\u003e RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n// contracts/apps/AbstractICApp.sol\n\nabstract contract AbstractICApp is AbstractICAppEvents, IInterchainApp {\n    using TypeCasts for address;\n\n    error InterchainApp__AlreadyLatestClient(address client);\n    error InterchainApp__BalanceTooLow(uint256 actual, uint256 required);\n    error InterchainApp__ClientAlreadyAdded(address client);\n    error InterchainApp__InterchainClientZeroAddress();\n    error InterchainApp__NotInterchainClient(address account);\n    error InterchainApp__ReceiverNotSet(uint256 chainId);\n    error InterchainApp__SameChainId(uint256 chainId);\n    error InterchainApp__SenderNotAllowed(uint256 srcChainId, bytes32 sender);\n\n    /// @inheritdoc IInterchainApp\n    function appReceive(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        if (!_isInterchainClient(msg.sender)) {\n            revert InterchainApp__NotInterchainClient(msg.sender);\n        }\n        if (srcChainId == block.chainid) {\n            revert InterchainApp__SameChainId(srcChainId);\n        }\n        if (!_isAllowedSender(srcChainId, sender)) {\n            revert InterchainApp__SenderNotAllowed(srcChainId, sender);\n        }\n        _receiveMessage(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n\n    /// @inheritdoc IInterchainApp\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules) {\n        appConfig = _getAppConfig();\n        modules = _getModules();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Performs necessary checks and adds an Interchain Client.\n    /// Optionally sets the latest client to this one.\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _addClient(address client, bool updateLatest) internal {\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (_isInterchainClient(client)) {\n            revert InterchainApp__ClientAlreadyAdded(client);\n        }\n        _toggleClientState(client, true);\n        emit InterchainClientAdded(client);\n        if (updateLatest) {\n            _setLatestClient(client);\n        }\n    }\n\n    /// @dev Performs necessary checks and removes an Interchain Client. If this client is the latest one,\n    /// the latest client is set to zero address (effectively pausing the app ability to send messages).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _removeClient(address client) internal {\n        if (!_isInterchainClient(client)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        _toggleClientState(client, false);\n        emit InterchainClientRemoved(client);\n        if (client == _getLatestClient()) {\n            _setLatestClient(address(0));\n        }\n    }\n\n    /// @dev Sets the latest Interchain Client to one of the allowed clients. Setting the client to zero address\n    /// is allowed and effectively pauses the app ability to send messages (but still allows to receive them).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _setLatestClient(address client) internal {\n        // New latest client must be an allowed client or zero address.\n        if (!_isInterchainClient(client) \u0026\u0026 client != address(0)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        if (client == _getLatestClient()) {\n            revert InterchainApp__AlreadyLatestClient(client);\n        }\n        _storeLatestClient(client);\n        emit LatestClientSet(client);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal virtual;\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal virtual;\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to accept EVM address as a parameter.\n    function _sendInterchainMessageEVM(\n        uint256 dstChainId,\n        address receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _sendInterchainMessage(dstChainId, receiver.addressToBytes32(), messageFee, options, message);\n    }\n\n    /// @dev Performs necessary checks and sends an interchain message.\n    function _sendInterchainMessage(\n        uint256 dstChainId,\n        bytes32 receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (dstChainId == block.chainid) {\n            revert InterchainApp__SameChainId(dstChainId);\n        }\n        if (receiver == 0) {\n            revert InterchainApp__ReceiverNotSet(dstChainId);\n        }\n        if (address(this).balance \u003c messageFee) {\n            revert InterchainApp__BalanceTooLow({actual: address(this).balance, required: messageFee});\n        }\n        return IInterchainClientV1(client).interchainSend{value: messageFee}(\n            dstChainId, receiver, _getExecutionService(), _getModules(), options, message\n        );\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        virtual;\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee for sending an Interchain message.\n    function _getInterchainFee(\n        uint256 dstChainId,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        return IInterchainClientV1(client).getInterchainFee(\n            dstChainId, _getExecutionService(), _getModules(), options, message\n        );\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view virtual returns (bytes memory);\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view virtual returns (address);\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view virtual returns (address);\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view virtual returns (address[] memory);\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint256 srcChainId, bytes32 sender) internal view virtual returns (bool);\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view virtual returns (bool);\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/AccessControlEnumerable.sol)\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 role =\u003e EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {AccessControl-_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool granted = super._grantRole(role, account);\n        if (granted) {\n            _roleMembers[role].add(account);\n        }\n        return granted;\n    }\n\n    /**\n     * @dev Overload {AccessControl-_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool revoked = super._revokeRole(role, account);\n        if (revoked) {\n            _roleMembers[role].remove(account);\n        }\n        return revoked;\n    }\n}\n\n// contracts/apps/ICAppV1.sol\n\nabstract contract ICAppV1 is AbstractICApp, AccessControlEnumerable, InterchainAppV1Events, IInterchainAppV1 {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Role to manage the Interchain setup of the app.\n    bytes32 public constant IC_GOVERNOR_ROLE = keccak256(\"IC_GOVERNOR_ROLE\");\n\n    /// @dev Address of the latest Interchain Client, used for sending messages.\n    address private _latestClient;\n\n    /// @dev Required responses and optimistic period for the module responses.\n    AppConfigV1 private _appConfigV1;\n    /// @dev Address of the linked app deployed on the remote chain.\n    mapping(uint256 chainId =\u003e bytes32 remoteApp) private _linkedApp;\n    /// @dev Interchain Clients allowed to send messages to this app.\n    EnumerableSet.AddressSet private _interchainClients;\n    /// @dev Trusted Interchain modules.\n    EnumerableSet.AddressSet private _trustedModules;\n    /// @dev Execution Service to use for sending messages.\n    address private _executionService;\n\n    constructor(address admin) {\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addInterchainClient(address client, bool updateLatest) external onlyRole(IC_GOVERNOR_ROLE) {\n        _addClient(client, updateLatest);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _removeClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setLatestInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _setLatestClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteApp(uint256 chainId, bytes32 remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteAppEVM(uint256 chainId, address remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp.addressToBytes32());\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (module == address(0)) {\n            revert InterchainApp__ModuleZeroAddress();\n        }\n        bool added = _trustedModules.add(module);\n        if (!added) {\n            revert InterchainApp__ModuleAlreadyAdded(module);\n        }\n        emit TrustedModuleAdded(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        bool removed = _trustedModules.remove(module);\n        if (!removed) {\n            revert InterchainApp__ModuleNotAdded(module);\n        }\n        emit TrustedModuleRemoved(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setAppConfigV1(AppConfigV1 memory appConfig) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (appConfig.requiredResponses == 0 || appConfig.optimisticPeriod == 0) {\n            revert InterchainApp__InvalidAppConfig(appConfig.requiredResponses, appConfig.optimisticPeriod);\n        }\n        _appConfigV1 = appConfig;\n        emit AppConfigV1Set(appConfig.requiredResponses, appConfig.optimisticPeriod);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setExecutionService(address executionService) external onlyRole(IC_GOVERNOR_ROLE) {\n        _executionService = executionService;\n        emit ExecutionServiceSet(executionService);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainAppV1\n    function getAppConfigV1() external view returns (AppConfigV1 memory) {\n        return _appConfigV1;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getExecutionService() external view returns (address) {\n        return _executionService;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getInterchainClients() external view returns (address[] memory) {\n        return _interchainClients.values();\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLatestInterchainClient() external view returns (address) {\n        return _latestClient;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedApp(uint256 chainId) external view returns (bytes32) {\n        return _linkedApp[chainId];\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedAppEVM(uint256 chainId) external view returns (address linkedAppEVM) {\n        bytes32 linkedApp = _linkedApp[chainId];\n        linkedAppEVM = linkedApp.bytes32ToAddress();\n        if (linkedAppEVM.addressToBytes32() != linkedApp) {\n            revert InterchainApp__NotEVMLinkedApp(linkedApp);\n        }\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getModules() external view returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Links the remote app to the current app.\n    /// Will revert if the chainId is the same as the chainId of the local app.\n    /// Note: Should be guarded with permissions check.\n    function _linkRemoteApp(uint256 chainId, bytes32 remoteApp) internal {\n        if (chainId == block.chainid) {\n            revert InterchainApp__SameChainId(chainId);\n        }\n        if (remoteApp == 0) {\n            revert InterchainApp__AppZeroAddress();\n        }\n        _linkedApp[chainId] = remoteApp;\n        emit AppLinked(chainId, remoteApp);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal override {\n        _latestClient = client;\n    }\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal override {\n        if (allowed) {\n            _interchainClients.add(client);\n        } else {\n            _interchainClients.remove(client);\n        }\n    }\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to send the message to the linked app.\n    function _sendToLinkedApp(\n        uint256 dstChainId,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _sendInterchainMessage(dstChainId, _linkedApp[dstChainId], messageFee, encodedOptions, message);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee to send a message to the linked app on the remote chain.\n    function _getMessageFee(\n        uint256 dstChainId,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _getInterchainFee(dstChainId, encodedOptions, message);\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view override returns (bytes memory) {\n        return _appConfigV1.encodeAppConfigV1();\n    }\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view override returns (address) {\n        return _executionService;\n    }\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view override returns (address) {\n        return _latestClient;\n    }\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view override returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint256 srcChainId, bytes32 sender) internal view override returns (bool) {\n        return _linkedApp[srcChainId] == sender;\n    }\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view override returns (bool) {\n        return _interchainClients.contains(caller);\n    }\n}\n\n// contracts/apps/examples/ExampleAppV1.sol\n\ncontract ExampleAppV1 is ICAppV1 {\n    event MessageReceived(uint256 srcChainId, bytes32 sender, uint256 dbNonce, uint64 entryIndex, bytes message);\n    event MessageSent(uint256 dstChainId, uint256 dbNonce, uint64 entryIndex, bytes32 transactionId);\n\n    constructor(address admin) ICAppV1(admin) {\n        _grantRole(IC_GOVERNOR_ROLE, admin);\n    }\n\n    /// @notice Allows the Admin to withdraw the native asset from the contract.\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        Address.sendValue(payable(msg.sender), address(this).balance);\n    }\n\n    /// @notice Sends a basic message to the destination chain.\n    function sendMessage(\n        uint256 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        InterchainTxDescriptor memory desc = _sendToLinkedApp({\n            dstChainId: dstChainId,\n            messageFee: msg.value,\n            options: OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}),\n            message: message\n        });\n        emit MessageSent(dstChainId, desc.dbNonce, desc.entryIndex, desc.transactionId);\n    }\n\n    /// @notice Returns the fee required to send a message using `sendMessage`.\n    function getMessageFee(\n        uint256 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes memory message\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _getMessageFee(dstChainId, OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}), message);\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        override\n    {\n        emit MessageReceived(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"client","type":"address"}],"name":"InterchainClientAdded","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"client","type":"address"}],"name":"InterchainClientRemoved","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"client","type":"address"}],"name":"LatestClientSet","type":"event"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"}],\"name\":\"InterchainClientAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"}],\"name\":\"InterchainClientRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"}],\"name\":\"LatestClientSet\",\"type\":\"event\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/ExampleAppV1.sol\":\"AbstractICAppEvents\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/ExampleAppV1.sol\":{\"keccak256\":\"0x4c94807e7a2671ad6fcf49fb03cfafa6f51f6b4596f34092fba0bf17b6d482cf\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://4fabc9aa6f6891674b77809808b14ff1f2e8829de650caafa1fb3c3444a07331\",\"dweb:/ipfs/QmVzYNSfkuSkXNaFKuNY3hmkdspssruAhQx4qZuJU3Ceg9\"]}},\"version\":1}"},"hashes":{}},"solidity/ExampleAppV1.sol:AccessControl":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/AbstractICAppEvents.sol\n\nabstract contract AbstractICAppEvents {\n    event InterchainClientAdded(address client);\n    event InterchainClientRemoved(address client);\n    event LatestClientSet(address client);\n}\n\n// contracts/events/InterchainAppV1Events.sol\n\nabstract contract InterchainAppV1Events {\n    event AppConfigV1Set(uint256 requiredResponses, uint256 optimisticPeriod);\n    event AppLinked(uint256 indexed chainId, bytes32 indexed remoteApp);\n    event ExecutionServiceSet(address executionService);\n    event TrustedModuleAdded(address module);\n    event TrustedModuleRemoved(address module);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    /// @notice Allows the Interchain Client to pass the message to the Interchain App.\n    /// @dev App is responsible for keeping track of interchain clients, and must verify the message sender.\n    /// @param srcChainId   Chain ID of the source chain, where the message was sent from.\n    /// @param sender       Sender address on the source chain, as a bytes32 value.\n    /// @param dbNonce      The Interchain DB nonce of the batch containing the message entry.\n    /// @param entryIndex   The index of the message entry within the batch.\n    /// @param message      The message being sent.\n    function appReceive(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /// @notice Returns the verification configuration of the Interchain App.\n    /// @dev This configuration is used by the Interchain Client to verify that message has been confirmed\n    /// by the Interchain Modules on the destination chain.\n    /// Note: V1 version of AppConfig includes the required responses count, and optimistic period after which\n    /// the message is considered confirmed by the module. Following versions may include additional fields.\n    /// @return appConfig    The versioned configuration of the Interchain App, encoded as bytes.\n    /// @return modules      The list of Interchain Modules that app is trusting to confirm the messages.\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    uint8 constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint8 version);\n\n    /// @notice Encodes versioned app config into a bytes format.\n    /// @param version      The version of the app config.\n    /// @param appConfig    The app config to encode.\n    function encodeVersionedAppConfig(uint8 version, bytes memory appConfig) internal pure returns (bytes memory) {\n        return abi.encode(version, appConfig);\n    }\n\n    /// @notice Decodes versioned app config from a bytes format back into a version and app config.\n    /// @param data         The versioned app config data in bytes format.\n    /// @return version     The version of the app config.\n    /// @return appConfig   The app config as bytes.\n    function decodeVersionedAppConfig(bytes memory data)\n        internal\n        pure\n        returns (uint8 version, bytes memory appConfig)\n    {\n        (version, appConfig) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return encodeVersionedAppConfig(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal pure returns (AppConfigV1 memory) {\n        (uint8 version, bytes memory appConfig) = decodeVersionedAppConfig(data);\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(appConfig, (AppConfigV1));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    uint8 constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint8 version);\n\n    /// @notice Encodes versioned options into a bytes format.\n    /// @param version      The version of the options.\n    /// @param options      The options to encode.\n    function encodeVersionedOptions(uint8 version, bytes memory options) internal pure returns (bytes memory) {\n        return abi.encode(version, options);\n    }\n\n    /// @notice Decodes versioned options from a bytes format back into a version and options.\n    /// @param data         The versioned options data in bytes format.\n    /// @return version     The version of the options.\n    /// @return options     The options as bytes.\n    function decodeVersionedOptions(bytes memory data) internal pure returns (uint8 version, bytes memory options) {\n        (version, options) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return encodeVersionedOptions(OPTIONS_V1, abi.encode(options));\n    }\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal pure returns (OptionsV1 memory) {\n        (uint8 version, bytes memory options) = decodeVersionedOptions(data);\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(options, (OptionsV1));\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/IAccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n\n// node_modules/@openzeppelin/contracts/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance \u003c amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance \u003c value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 \u0026\u0026 target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/libs/InterchainTransaction.sol\n\nstruct InterchainTransaction {\n    uint256 srcChainId;\n    bytes32 srcSender;\n    uint256 dstChainId;\n    bytes32 dstReceiver;\n    uint256 dbNonce;\n    uint64 entryIndex;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint256 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    function constructLocalTransaction(\n        address srcSender,\n        uint256 dstChainId,\n        bytes32 dstReceiver,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: block.chainid,\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(transaction);\n    }\n\n    function decodeTransaction(bytes memory encodedTx) internal pure returns (InterchainTransaction memory) {\n        return abi.decode(encodedTx, (InterchainTransaction));\n    }\n\n    function transactionId(InterchainTransaction memory transaction) internal pure returns (bytes32) {\n        return keccak256(abi.encode(transaction));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/IAccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/IAccessControlEnumerable.sol)\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n// contracts/interfaces/IInterchainAppV1.sol\n\ninterface IInterchainAppV1 is IInterchainApp {\n    error InterchainApp__AppZeroAddress();\n    error InterchainApp__InvalidAppConfig(uint256 requiredResponses, uint256 optimisticPeriod);\n    error InterchainApp__ModuleAlreadyAdded(address module);\n    error InterchainApp__ModuleNotAdded(address module);\n    error InterchainApp__ModuleZeroAddress();\n    error InterchainApp__NotEVMLinkedApp(bytes32 linkedApp);\n\n    /// @notice Allows the owner to add the interchain client to the allowed clients set,\n    /// and optionally set the latest client to this one.\n    /// Note: only the allowed clients can send messages to this app.\n    /// Note: the latest client is used for sending messages from this app.\n    /// @param client       The address of the interchain client to add.\n    /// @param updateLatest Whether to set the latest client to this one.\n    function addInterchainClient(address client, bool updateLatest) external;\n\n    /// @notice Allows the owner to remove the interchain client from the allowed clients set.\n    /// If the client is the latest client, the latest client is set to the zero address.\n    /// @param client       The address of the interchain client to remove.\n    function removeInterchainClient(address client) external;\n\n    /// @notice Allows the owner to set the address of the latest interchain client.\n    /// @dev The new latest client must be an allowed client or zero address.\n    /// Setting the client to zero address effectively pauses the app ability to send messages,\n    /// while allowing to receive them.\n    /// @param client       The address of the latest interchain client.\n    function setLatestInterchainClient(address client) external;\n\n    /// @notice Allows the owner to link the remote app for the given chain ID.\n    /// - This address will be used as the receiver for the messages sent from this chain.\n    /// - This address will be the only trusted sender for the messages sent to this chain.\n    /// @param chainId      The remote chain ID.\n    /// @param remoteApp    The address of the remote app to link.\n    function linkRemoteApp(uint256 chainId, bytes32 remoteApp) external;\n\n    /// @notice Thin wrapper for `linkRemoteApp` to accept EVM address as a parameter.\n    function linkRemoteAppEVM(uint256 chainId, address remoteApp) external;\n\n    /// @notice Allows the owner to add the module to the trusted modules set.\n    /// - This set of modules will be used to verify both sent and received messages.\n    function addTrustedModule(address module) external;\n\n    /// @notice Allows the owner to remove the module from the trusted modules set.\n    function removeTrustedModule(address module) external;\n\n    /// @notice Allows the owner to set the app config for the current app. App config includes:\n    /// - requiredResponses: the number of module responses required for accepting the message\n    /// - optimisticPeriod: the minimum time after which the module responses are considered final\n    function setAppConfigV1(AppConfigV1 memory appConfig) external;\n\n    /// @notice Allows the owner to set the address of the Execution Service.\n    /// This address will be used to request execution of the messages sent from this chain,\n    /// by supplying the Service's execution fee.\n    function setExecutionService(address executionService) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Returns the app config for the current app: requiredResponses and optimisticPeriod.\n    function getAppConfigV1() external view returns (AppConfigV1 memory);\n\n    /// @notice Returns the address of the Execution Service used by this app for sending messages.\n    function getExecutionService() external view returns (address);\n\n    /// @notice Returns the list of Interchain Clients allowed to send messages to this app.\n    function getInterchainClients() external view returns (address[] memory);\n\n    /// @notice Returns the address of the latest interchain client.\n    /// This address is used for sending messages from this app.\n    function getLatestInterchainClient() external view returns (address);\n\n    /// @notice Returns the linked app address (as bytes32) for the given chain ID.\n    function getLinkedApp(uint256 chainId) external view returns (bytes32);\n\n    /// @notice Thin wrapper for `getLinkedApp` to return the linked app address as EVM address.\n    /// @dev Will revert if the linked app address is not an EVM address.\n    function getLinkedAppEVM(uint256 chainId) external view returns (address);\n\n    /// @notice Returns the list of Interchain Modules trusted by this app.\n    /// This set of modules will be used to verify both sent and received messages.\n    function getModules() external view returns (address[] memory);\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint256 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__NoLinkedClient(uint256 chainId);\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint256 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint256 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint256 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint256 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint256 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param message              The message being sent.\n    function getInterchainFee(\n        uint256 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint256 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint256 chainId) external view returns (address);\n}\n\n// node_modules/@openzeppelin/contracts/access/AccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account =\u003e bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role =\u003e RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n// contracts/apps/AbstractICApp.sol\n\nabstract contract AbstractICApp is AbstractICAppEvents, IInterchainApp {\n    using TypeCasts for address;\n\n    error InterchainApp__AlreadyLatestClient(address client);\n    error InterchainApp__BalanceTooLow(uint256 actual, uint256 required);\n    error InterchainApp__ClientAlreadyAdded(address client);\n    error InterchainApp__InterchainClientZeroAddress();\n    error InterchainApp__NotInterchainClient(address account);\n    error InterchainApp__ReceiverNotSet(uint256 chainId);\n    error InterchainApp__SameChainId(uint256 chainId);\n    error InterchainApp__SenderNotAllowed(uint256 srcChainId, bytes32 sender);\n\n    /// @inheritdoc IInterchainApp\n    function appReceive(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        if (!_isInterchainClient(msg.sender)) {\n            revert InterchainApp__NotInterchainClient(msg.sender);\n        }\n        if (srcChainId == block.chainid) {\n            revert InterchainApp__SameChainId(srcChainId);\n        }\n        if (!_isAllowedSender(srcChainId, sender)) {\n            revert InterchainApp__SenderNotAllowed(srcChainId, sender);\n        }\n        _receiveMessage(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n\n    /// @inheritdoc IInterchainApp\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules) {\n        appConfig = _getAppConfig();\n        modules = _getModules();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Performs necessary checks and adds an Interchain Client.\n    /// Optionally sets the latest client to this one.\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _addClient(address client, bool updateLatest) internal {\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (_isInterchainClient(client)) {\n            revert InterchainApp__ClientAlreadyAdded(client);\n        }\n        _toggleClientState(client, true);\n        emit InterchainClientAdded(client);\n        if (updateLatest) {\n            _setLatestClient(client);\n        }\n    }\n\n    /// @dev Performs necessary checks and removes an Interchain Client. If this client is the latest one,\n    /// the latest client is set to zero address (effectively pausing the app ability to send messages).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _removeClient(address client) internal {\n        if (!_isInterchainClient(client)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        _toggleClientState(client, false);\n        emit InterchainClientRemoved(client);\n        if (client == _getLatestClient()) {\n            _setLatestClient(address(0));\n        }\n    }\n\n    /// @dev Sets the latest Interchain Client to one of the allowed clients. Setting the client to zero address\n    /// is allowed and effectively pauses the app ability to send messages (but still allows to receive them).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _setLatestClient(address client) internal {\n        // New latest client must be an allowed client or zero address.\n        if (!_isInterchainClient(client) \u0026\u0026 client != address(0)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        if (client == _getLatestClient()) {\n            revert InterchainApp__AlreadyLatestClient(client);\n        }\n        _storeLatestClient(client);\n        emit LatestClientSet(client);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal virtual;\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal virtual;\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to accept EVM address as a parameter.\n    function _sendInterchainMessageEVM(\n        uint256 dstChainId,\n        address receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _sendInterchainMessage(dstChainId, receiver.addressToBytes32(), messageFee, options, message);\n    }\n\n    /// @dev Performs necessary checks and sends an interchain message.\n    function _sendInterchainMessage(\n        uint256 dstChainId,\n        bytes32 receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (dstChainId == block.chainid) {\n            revert InterchainApp__SameChainId(dstChainId);\n        }\n        if (receiver == 0) {\n            revert InterchainApp__ReceiverNotSet(dstChainId);\n        }\n        if (address(this).balance \u003c messageFee) {\n            revert InterchainApp__BalanceTooLow({actual: address(this).balance, required: messageFee});\n        }\n        return IInterchainClientV1(client).interchainSend{value: messageFee}(\n            dstChainId, receiver, _getExecutionService(), _getModules(), options, message\n        );\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        virtual;\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee for sending an Interchain message.\n    function _getInterchainFee(\n        uint256 dstChainId,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        return IInterchainClientV1(client).getInterchainFee(\n            dstChainId, _getExecutionService(), _getModules(), options, message\n        );\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view virtual returns (bytes memory);\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view virtual returns (address);\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view virtual returns (address);\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view virtual returns (address[] memory);\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint256 srcChainId, bytes32 sender) internal view virtual returns (bool);\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view virtual returns (bool);\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/AccessControlEnumerable.sol)\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 role =\u003e EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {AccessControl-_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool granted = super._grantRole(role, account);\n        if (granted) {\n            _roleMembers[role].add(account);\n        }\n        return granted;\n    }\n\n    /**\n     * @dev Overload {AccessControl-_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool revoked = super._revokeRole(role, account);\n        if (revoked) {\n            _roleMembers[role].remove(account);\n        }\n        return revoked;\n    }\n}\n\n// contracts/apps/ICAppV1.sol\n\nabstract contract ICAppV1 is AbstractICApp, AccessControlEnumerable, InterchainAppV1Events, IInterchainAppV1 {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Role to manage the Interchain setup of the app.\n    bytes32 public constant IC_GOVERNOR_ROLE = keccak256(\"IC_GOVERNOR_ROLE\");\n\n    /// @dev Address of the latest Interchain Client, used for sending messages.\n    address private _latestClient;\n\n    /// @dev Required responses and optimistic period for the module responses.\n    AppConfigV1 private _appConfigV1;\n    /// @dev Address of the linked app deployed on the remote chain.\n    mapping(uint256 chainId =\u003e bytes32 remoteApp) private _linkedApp;\n    /// @dev Interchain Clients allowed to send messages to this app.\n    EnumerableSet.AddressSet private _interchainClients;\n    /// @dev Trusted Interchain modules.\n    EnumerableSet.AddressSet private _trustedModules;\n    /// @dev Execution Service to use for sending messages.\n    address private _executionService;\n\n    constructor(address admin) {\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addInterchainClient(address client, bool updateLatest) external onlyRole(IC_GOVERNOR_ROLE) {\n        _addClient(client, updateLatest);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _removeClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setLatestInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _setLatestClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteApp(uint256 chainId, bytes32 remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteAppEVM(uint256 chainId, address remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp.addressToBytes32());\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (module == address(0)) {\n            revert InterchainApp__ModuleZeroAddress();\n        }\n        bool added = _trustedModules.add(module);\n        if (!added) {\n            revert InterchainApp__ModuleAlreadyAdded(module);\n        }\n        emit TrustedModuleAdded(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        bool removed = _trustedModules.remove(module);\n        if (!removed) {\n            revert InterchainApp__ModuleNotAdded(module);\n        }\n        emit TrustedModuleRemoved(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setAppConfigV1(AppConfigV1 memory appConfig) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (appConfig.requiredResponses == 0 || appConfig.optimisticPeriod == 0) {\n            revert InterchainApp__InvalidAppConfig(appConfig.requiredResponses, appConfig.optimisticPeriod);\n        }\n        _appConfigV1 = appConfig;\n        emit AppConfigV1Set(appConfig.requiredResponses, appConfig.optimisticPeriod);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setExecutionService(address executionService) external onlyRole(IC_GOVERNOR_ROLE) {\n        _executionService = executionService;\n        emit ExecutionServiceSet(executionService);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainAppV1\n    function getAppConfigV1() external view returns (AppConfigV1 memory) {\n        return _appConfigV1;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getExecutionService() external view returns (address) {\n        return _executionService;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getInterchainClients() external view returns (address[] memory) {\n        return _interchainClients.values();\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLatestInterchainClient() external view returns (address) {\n        return _latestClient;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedApp(uint256 chainId) external view returns (bytes32) {\n        return _linkedApp[chainId];\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedAppEVM(uint256 chainId) external view returns (address linkedAppEVM) {\n        bytes32 linkedApp = _linkedApp[chainId];\n        linkedAppEVM = linkedApp.bytes32ToAddress();\n        if (linkedAppEVM.addressToBytes32() != linkedApp) {\n            revert InterchainApp__NotEVMLinkedApp(linkedApp);\n        }\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getModules() external view returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Links the remote app to the current app.\n    /// Will revert if the chainId is the same as the chainId of the local app.\n    /// Note: Should be guarded with permissions check.\n    function _linkRemoteApp(uint256 chainId, bytes32 remoteApp) internal {\n        if (chainId == block.chainid) {\n            revert InterchainApp__SameChainId(chainId);\n        }\n        if (remoteApp == 0) {\n            revert InterchainApp__AppZeroAddress();\n        }\n        _linkedApp[chainId] = remoteApp;\n        emit AppLinked(chainId, remoteApp);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal override {\n        _latestClient = client;\n    }\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal override {\n        if (allowed) {\n            _interchainClients.add(client);\n        } else {\n            _interchainClients.remove(client);\n        }\n    }\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to send the message to the linked app.\n    function _sendToLinkedApp(\n        uint256 dstChainId,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _sendInterchainMessage(dstChainId, _linkedApp[dstChainId], messageFee, encodedOptions, message);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee to send a message to the linked app on the remote chain.\n    function _getMessageFee(\n        uint256 dstChainId,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _getInterchainFee(dstChainId, encodedOptions, message);\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view override returns (bytes memory) {\n        return _appConfigV1.encodeAppConfigV1();\n    }\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view override returns (address) {\n        return _executionService;\n    }\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view override returns (address) {\n        return _latestClient;\n    }\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view override returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint256 srcChainId, bytes32 sender) internal view override returns (bool) {\n        return _linkedApp[srcChainId] == sender;\n    }\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view override returns (bool) {\n        return _interchainClients.contains(caller);\n    }\n}\n\n// contracts/apps/examples/ExampleAppV1.sol\n\ncontract ExampleAppV1 is ICAppV1 {\n    event MessageReceived(uint256 srcChainId, bytes32 sender, uint256 dbNonce, uint64 entryIndex, bytes message);\n    event MessageSent(uint256 dstChainId, uint256 dbNonce, uint64 entryIndex, bytes32 transactionId);\n\n    constructor(address admin) ICAppV1(admin) {\n        _grantRole(IC_GOVERNOR_ROLE, admin);\n    }\n\n    /// @notice Allows the Admin to withdraw the native asset from the contract.\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        Address.sendValue(payable(msg.sender), address(this).balance);\n    }\n\n    /// @notice Sends a basic message to the destination chain.\n    function sendMessage(\n        uint256 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        InterchainTxDescriptor memory desc = _sendToLinkedApp({\n            dstChainId: dstChainId,\n            messageFee: msg.value,\n            options: OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}),\n            message: message\n        });\n        emit MessageSent(dstChainId, desc.dbNonce, desc.entryIndex, desc.transactionId);\n    }\n\n    /// @notice Returns the fee required to send a message using `sendMessage`.\n    function getMessageFee(\n        uint256 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes memory message\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _getMessageFee(dstChainId, OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}), message);\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        override\n    {\n        emit MessageReceived(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[],"name":"AccessControlBadConfirmation","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"bytes32","name":"neededRole","type":"bytes32"}],"name":"AccessControlUnauthorizedAccount","type":"error"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"bytes32","name":"previousAdminRole","type":"bytes32"},{"indexed":true,"internalType":"bytes32","name":"newAdminRole","type":"bytes32"}],"name":"RoleAdminChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":true,"internalType":"address","name":"sender","type":"address"}],"name":"RoleGranted","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":true,"internalType":"address","name":"sender","type":"address"}],"name":"RoleRevoked","type":"event"},{"inputs":[],"name":"DEFAULT_ADMIN_ROLE","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"}],"name":"getRoleAdmin","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"grantRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"hasRole","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"callerConfirmation","type":"address"}],"name":"renounceRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"revokeRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes4","name":"interfaceId","type":"bytes4"}],"name":"supportsInterface","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"details":"Contract module that allows children to implement role-based access control mechanisms. This is a lightweight version that doesn't allow enumerating role members except through off-chain means by accessing the contract event logs. Some applications may benefit from on-chain enumerability, for those cases see {AccessControlEnumerable}. Roles are referred to by their `bytes32` identifier. These should be exposed in the external API and be unique. The best way to achieve this is by using `public constant` hash digests: ```solidity bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\"); ``` Roles can be used to represent a set of permissions. To restrict access to a function call, use {hasRole}: ```solidity function foo() public {     require(hasRole(MY_ROLE, msg.sender));     ... } ``` Roles can be granted and revoked dynamically via the {grantRole} and {revokeRole} functions. Each role has an associated admin role, and only accounts that have a role's admin role can call {grantRole} and {revokeRole}. By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means that only accounts with this role will be able to grant or revoke other roles. More complex role relationships can be created by using {_setRoleAdmin}. WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to grant and revoke this role. Extra precautions should be taken to secure accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules} to enforce additional security measures for this role.","errors":{"AccessControlBadConfirmation()":[{"details":"The caller of a function is not the expected one. NOTE: Don't confuse with {AccessControlUnauthorizedAccount}."}],"AccessControlUnauthorizedAccount(address,bytes32)":[{"details":"The `account` is missing a role."}]},"events":{"RoleAdminChanged(bytes32,bytes32,bytes32)":{"details":"Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole` `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite {RoleAdminChanged} not being emitted signaling this."},"RoleGranted(bytes32,address,address)":{"details":"Emitted when `account` is granted `role`. `sender` is the account that originated the contract call, an admin role bearer except when using {AccessControl-_setupRole}."},"RoleRevoked(bytes32,address,address)":{"details":"Emitted when `account` is revoked `role`. `sender` is the account that originated the contract call:   - if using `revokeRole`, it is the admin role bearer   - if using `renounceRole`, it is the role bearer (i.e. `account`)"}},"kind":"dev","methods":{"getRoleAdmin(bytes32)":{"details":"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"grantRole(bytes32,address)":{"details":"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleGranted} event."},"hasRole(bytes32,address)":{"details":"Returns `true` if `account` has been granted `role`."},"renounceRole(bytes32,address)":{"details":"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `callerConfirmation`. May emit a {RoleRevoked} event."},"revokeRole(bytes32,address)":{"details":"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleRevoked} event."},"supportsInterface(bytes4)":{"details":"See {IERC165-supportsInterface}."}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"AccessControlBadConfirmation\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"neededRole\",\"type\":\"bytes32\"}],\"name\":\"AccessControlUnauthorizedAccount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"callerConfirmation\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Contract module that allows children to implement role-based access control mechanisms. This is a lightweight version that doesn't allow enumerating role members except through off-chain means by accessing the contract event logs. Some applications may benefit from on-chain enumerability, for those cases see {AccessControlEnumerable}. Roles are referred to by their `bytes32` identifier. These should be exposed in the external API and be unique. The best way to achieve this is by using `public constant` hash digests: ```solidity bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\"); ``` Roles can be used to represent a set of permissions. To restrict access to a function call, use {hasRole}: ```solidity function foo() public {     require(hasRole(MY_ROLE, msg.sender));     ... } ``` Roles can be granted and revoked dynamically via the {grantRole} and {revokeRole} functions. Each role has an associated admin role, and only accounts that have a role's admin role can call {grantRole} and {revokeRole}. By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means that only accounts with this role will be able to grant or revoke other roles. More complex role relationships can be created by using {_setRoleAdmin}. WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to grant and revoke this role. Extra precautions should be taken to secure accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules} to enforce additional security measures for this role.\",\"errors\":{\"AccessControlBadConfirmation()\":[{\"details\":\"The caller of a function is not the expected one. NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\"}],\"AccessControlUnauthorizedAccount(address,bytes32)\":[{\"details\":\"The `account` is missing a role.\"}]},\"events\":{\"RoleAdminChanged(bytes32,bytes32,bytes32)\":{\"details\":\"Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole` `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite {RoleAdminChanged} not being emitted signaling this.\"},\"RoleGranted(bytes32,address,address)\":{\"details\":\"Emitted when `account` is granted `role`. `sender` is the account that originated the contract call, an admin role bearer except when using {AccessControl-_setupRole}.\"},\"RoleRevoked(bytes32,address,address)\":{\"details\":\"Emitted when `account` is revoked `role`. `sender` is the account that originated the contract call:   - if using `revokeRole`, it is the admin role bearer   - if using `renounceRole`, it is the role bearer (i.e. `account`)\"}},\"kind\":\"dev\",\"methods\":{\"getRoleAdmin(bytes32)\":{\"details\":\"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.\"},\"grantRole(bytes32,address)\":{\"details\":\"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleGranted} event.\"},\"hasRole(bytes32,address)\":{\"details\":\"Returns `true` if `account` has been granted `role`.\"},\"renounceRole(bytes32,address)\":{\"details\":\"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `callerConfirmation`. May emit a {RoleRevoked} event.\"},\"revokeRole(bytes32,address)\":{\"details\":\"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleRevoked} event.\"},\"supportsInterface(bytes4)\":{\"details\":\"See {IERC165-supportsInterface}.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/ExampleAppV1.sol\":\"AccessControl\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/ExampleAppV1.sol\":{\"keccak256\":\"0x4c94807e7a2671ad6fcf49fb03cfafa6f51f6b4596f34092fba0bf17b6d482cf\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://4fabc9aa6f6891674b77809808b14ff1f2e8829de650caafa1fb3c3444a07331\",\"dweb:/ipfs/QmVzYNSfkuSkXNaFKuNY3hmkdspssruAhQx4qZuJU3Ceg9\"]}},\"version\":1}"},"hashes":{"DEFAULT_ADMIN_ROLE()":"a217fddf","getRoleAdmin(bytes32)":"248a9ca3","grantRole(bytes32,address)":"2f2ff15d","hasRole(bytes32,address)":"91d14854","renounceRole(bytes32,address)":"36568abe","revokeRole(bytes32,address)":"d547741f","supportsInterface(bytes4)":"01ffc9a7"}},"solidity/ExampleAppV1.sol:AccessControlEnumerable":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/AbstractICAppEvents.sol\n\nabstract contract AbstractICAppEvents {\n    event InterchainClientAdded(address client);\n    event InterchainClientRemoved(address client);\n    event LatestClientSet(address client);\n}\n\n// contracts/events/InterchainAppV1Events.sol\n\nabstract contract InterchainAppV1Events {\n    event AppConfigV1Set(uint256 requiredResponses, uint256 optimisticPeriod);\n    event AppLinked(uint256 indexed chainId, bytes32 indexed remoteApp);\n    event ExecutionServiceSet(address executionService);\n    event TrustedModuleAdded(address module);\n    event TrustedModuleRemoved(address module);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    /// @notice Allows the Interchain Client to pass the message to the Interchain App.\n    /// @dev App is responsible for keeping track of interchain clients, and must verify the message sender.\n    /// @param srcChainId   Chain ID of the source chain, where the message was sent from.\n    /// @param sender       Sender address on the source chain, as a bytes32 value.\n    /// @param dbNonce      The Interchain DB nonce of the batch containing the message entry.\n    /// @param entryIndex   The index of the message entry within the batch.\n    /// @param message      The message being sent.\n    function appReceive(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /// @notice Returns the verification configuration of the Interchain App.\n    /// @dev This configuration is used by the Interchain Client to verify that message has been confirmed\n    /// by the Interchain Modules on the destination chain.\n    /// Note: V1 version of AppConfig includes the required responses count, and optimistic period after which\n    /// the message is considered confirmed by the module. Following versions may include additional fields.\n    /// @return appConfig    The versioned configuration of the Interchain App, encoded as bytes.\n    /// @return modules      The list of Interchain Modules that app is trusting to confirm the messages.\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    uint8 constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint8 version);\n\n    /// @notice Encodes versioned app config into a bytes format.\n    /// @param version      The version of the app config.\n    /// @param appConfig    The app config to encode.\n    function encodeVersionedAppConfig(uint8 version, bytes memory appConfig) internal pure returns (bytes memory) {\n        return abi.encode(version, appConfig);\n    }\n\n    /// @notice Decodes versioned app config from a bytes format back into a version and app config.\n    /// @param data         The versioned app config data in bytes format.\n    /// @return version     The version of the app config.\n    /// @return appConfig   The app config as bytes.\n    function decodeVersionedAppConfig(bytes memory data)\n        internal\n        pure\n        returns (uint8 version, bytes memory appConfig)\n    {\n        (version, appConfig) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return encodeVersionedAppConfig(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal pure returns (AppConfigV1 memory) {\n        (uint8 version, bytes memory appConfig) = decodeVersionedAppConfig(data);\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(appConfig, (AppConfigV1));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    uint8 constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint8 version);\n\n    /// @notice Encodes versioned options into a bytes format.\n    /// @param version      The version of the options.\n    /// @param options      The options to encode.\n    function encodeVersionedOptions(uint8 version, bytes memory options) internal pure returns (bytes memory) {\n        return abi.encode(version, options);\n    }\n\n    /// @notice Decodes versioned options from a bytes format back into a version and options.\n    /// @param data         The versioned options data in bytes format.\n    /// @return version     The version of the options.\n    /// @return options     The options as bytes.\n    function decodeVersionedOptions(bytes memory data) internal pure returns (uint8 version, bytes memory options) {\n        (version, options) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return encodeVersionedOptions(OPTIONS_V1, abi.encode(options));\n    }\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal pure returns (OptionsV1 memory) {\n        (uint8 version, bytes memory options) = decodeVersionedOptions(data);\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(options, (OptionsV1));\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/IAccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n\n// node_modules/@openzeppelin/contracts/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance \u003c amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance \u003c value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 \u0026\u0026 target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/libs/InterchainTransaction.sol\n\nstruct InterchainTransaction {\n    uint256 srcChainId;\n    bytes32 srcSender;\n    uint256 dstChainId;\n    bytes32 dstReceiver;\n    uint256 dbNonce;\n    uint64 entryIndex;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint256 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    function constructLocalTransaction(\n        address srcSender,\n        uint256 dstChainId,\n        bytes32 dstReceiver,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: block.chainid,\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(transaction);\n    }\n\n    function decodeTransaction(bytes memory encodedTx) internal pure returns (InterchainTransaction memory) {\n        return abi.decode(encodedTx, (InterchainTransaction));\n    }\n\n    function transactionId(InterchainTransaction memory transaction) internal pure returns (bytes32) {\n        return keccak256(abi.encode(transaction));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/IAccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/IAccessControlEnumerable.sol)\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n// contracts/interfaces/IInterchainAppV1.sol\n\ninterface IInterchainAppV1 is IInterchainApp {\n    error InterchainApp__AppZeroAddress();\n    error InterchainApp__InvalidAppConfig(uint256 requiredResponses, uint256 optimisticPeriod);\n    error InterchainApp__ModuleAlreadyAdded(address module);\n    error InterchainApp__ModuleNotAdded(address module);\n    error InterchainApp__ModuleZeroAddress();\n    error InterchainApp__NotEVMLinkedApp(bytes32 linkedApp);\n\n    /// @notice Allows the owner to add the interchain client to the allowed clients set,\n    /// and optionally set the latest client to this one.\n    /// Note: only the allowed clients can send messages to this app.\n    /// Note: the latest client is used for sending messages from this app.\n    /// @param client       The address of the interchain client to add.\n    /// @param updateLatest Whether to set the latest client to this one.\n    function addInterchainClient(address client, bool updateLatest) external;\n\n    /// @notice Allows the owner to remove the interchain client from the allowed clients set.\n    /// If the client is the latest client, the latest client is set to the zero address.\n    /// @param client       The address of the interchain client to remove.\n    function removeInterchainClient(address client) external;\n\n    /// @notice Allows the owner to set the address of the latest interchain client.\n    /// @dev The new latest client must be an allowed client or zero address.\n    /// Setting the client to zero address effectively pauses the app ability to send messages,\n    /// while allowing to receive them.\n    /// @param client       The address of the latest interchain client.\n    function setLatestInterchainClient(address client) external;\n\n    /// @notice Allows the owner to link the remote app for the given chain ID.\n    /// - This address will be used as the receiver for the messages sent from this chain.\n    /// - This address will be the only trusted sender for the messages sent to this chain.\n    /// @param chainId      The remote chain ID.\n    /// @param remoteApp    The address of the remote app to link.\n    function linkRemoteApp(uint256 chainId, bytes32 remoteApp) external;\n\n    /// @notice Thin wrapper for `linkRemoteApp` to accept EVM address as a parameter.\n    function linkRemoteAppEVM(uint256 chainId, address remoteApp) external;\n\n    /// @notice Allows the owner to add the module to the trusted modules set.\n    /// - This set of modules will be used to verify both sent and received messages.\n    function addTrustedModule(address module) external;\n\n    /// @notice Allows the owner to remove the module from the trusted modules set.\n    function removeTrustedModule(address module) external;\n\n    /// @notice Allows the owner to set the app config for the current app. App config includes:\n    /// - requiredResponses: the number of module responses required for accepting the message\n    /// - optimisticPeriod: the minimum time after which the module responses are considered final\n    function setAppConfigV1(AppConfigV1 memory appConfig) external;\n\n    /// @notice Allows the owner to set the address of the Execution Service.\n    /// This address will be used to request execution of the messages sent from this chain,\n    /// by supplying the Service's execution fee.\n    function setExecutionService(address executionService) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Returns the app config for the current app: requiredResponses and optimisticPeriod.\n    function getAppConfigV1() external view returns (AppConfigV1 memory);\n\n    /// @notice Returns the address of the Execution Service used by this app for sending messages.\n    function getExecutionService() external view returns (address);\n\n    /// @notice Returns the list of Interchain Clients allowed to send messages to this app.\n    function getInterchainClients() external view returns (address[] memory);\n\n    /// @notice Returns the address of the latest interchain client.\n    /// This address is used for sending messages from this app.\n    function getLatestInterchainClient() external view returns (address);\n\n    /// @notice Returns the linked app address (as bytes32) for the given chain ID.\n    function getLinkedApp(uint256 chainId) external view returns (bytes32);\n\n    /// @notice Thin wrapper for `getLinkedApp` to return the linked app address as EVM address.\n    /// @dev Will revert if the linked app address is not an EVM address.\n    function getLinkedAppEVM(uint256 chainId) external view returns (address);\n\n    /// @notice Returns the list of Interchain Modules trusted by this app.\n    /// This set of modules will be used to verify both sent and received messages.\n    function getModules() external view returns (address[] memory);\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint256 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__NoLinkedClient(uint256 chainId);\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint256 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint256 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint256 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint256 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint256 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param message              The message being sent.\n    function getInterchainFee(\n        uint256 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint256 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint256 chainId) external view returns (address);\n}\n\n// node_modules/@openzeppelin/contracts/access/AccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account =\u003e bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role =\u003e RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n// contracts/apps/AbstractICApp.sol\n\nabstract contract AbstractICApp is AbstractICAppEvents, IInterchainApp {\n    using TypeCasts for address;\n\n    error InterchainApp__AlreadyLatestClient(address client);\n    error InterchainApp__BalanceTooLow(uint256 actual, uint256 required);\n    error InterchainApp__ClientAlreadyAdded(address client);\n    error InterchainApp__InterchainClientZeroAddress();\n    error InterchainApp__NotInterchainClient(address account);\n    error InterchainApp__ReceiverNotSet(uint256 chainId);\n    error InterchainApp__SameChainId(uint256 chainId);\n    error InterchainApp__SenderNotAllowed(uint256 srcChainId, bytes32 sender);\n\n    /// @inheritdoc IInterchainApp\n    function appReceive(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        if (!_isInterchainClient(msg.sender)) {\n            revert InterchainApp__NotInterchainClient(msg.sender);\n        }\n        if (srcChainId == block.chainid) {\n            revert InterchainApp__SameChainId(srcChainId);\n        }\n        if (!_isAllowedSender(srcChainId, sender)) {\n            revert InterchainApp__SenderNotAllowed(srcChainId, sender);\n        }\n        _receiveMessage(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n\n    /// @inheritdoc IInterchainApp\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules) {\n        appConfig = _getAppConfig();\n        modules = _getModules();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Performs necessary checks and adds an Interchain Client.\n    /// Optionally sets the latest client to this one.\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _addClient(address client, bool updateLatest) internal {\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (_isInterchainClient(client)) {\n            revert InterchainApp__ClientAlreadyAdded(client);\n        }\n        _toggleClientState(client, true);\n        emit InterchainClientAdded(client);\n        if (updateLatest) {\n            _setLatestClient(client);\n        }\n    }\n\n    /// @dev Performs necessary checks and removes an Interchain Client. If this client is the latest one,\n    /// the latest client is set to zero address (effectively pausing the app ability to send messages).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _removeClient(address client) internal {\n        if (!_isInterchainClient(client)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        _toggleClientState(client, false);\n        emit InterchainClientRemoved(client);\n        if (client == _getLatestClient()) {\n            _setLatestClient(address(0));\n        }\n    }\n\n    /// @dev Sets the latest Interchain Client to one of the allowed clients. Setting the client to zero address\n    /// is allowed and effectively pauses the app ability to send messages (but still allows to receive them).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _setLatestClient(address client) internal {\n        // New latest client must be an allowed client or zero address.\n        if (!_isInterchainClient(client) \u0026\u0026 client != address(0)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        if (client == _getLatestClient()) {\n            revert InterchainApp__AlreadyLatestClient(client);\n        }\n        _storeLatestClient(client);\n        emit LatestClientSet(client);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal virtual;\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal virtual;\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to accept EVM address as a parameter.\n    function _sendInterchainMessageEVM(\n        uint256 dstChainId,\n        address receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _sendInterchainMessage(dstChainId, receiver.addressToBytes32(), messageFee, options, message);\n    }\n\n    /// @dev Performs necessary checks and sends an interchain message.\n    function _sendInterchainMessage(\n        uint256 dstChainId,\n        bytes32 receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (dstChainId == block.chainid) {\n            revert InterchainApp__SameChainId(dstChainId);\n        }\n        if (receiver == 0) {\n            revert InterchainApp__ReceiverNotSet(dstChainId);\n        }\n        if (address(this).balance \u003c messageFee) {\n            revert InterchainApp__BalanceTooLow({actual: address(this).balance, required: messageFee});\n        }\n        return IInterchainClientV1(client).interchainSend{value: messageFee}(\n            dstChainId, receiver, _getExecutionService(), _getModules(), options, message\n        );\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        virtual;\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee for sending an Interchain message.\n    function _getInterchainFee(\n        uint256 dstChainId,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        return IInterchainClientV1(client).getInterchainFee(\n            dstChainId, _getExecutionService(), _getModules(), options, message\n        );\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view virtual returns (bytes memory);\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view virtual returns (address);\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view virtual returns (address);\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view virtual returns (address[] memory);\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint256 srcChainId, bytes32 sender) internal view virtual returns (bool);\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view virtual returns (bool);\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/AccessControlEnumerable.sol)\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 role =\u003e EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {AccessControl-_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool granted = super._grantRole(role, account);\n        if (granted) {\n            _roleMembers[role].add(account);\n        }\n        return granted;\n    }\n\n    /**\n     * @dev Overload {AccessControl-_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool revoked = super._revokeRole(role, account);\n        if (revoked) {\n            _roleMembers[role].remove(account);\n        }\n        return revoked;\n    }\n}\n\n// contracts/apps/ICAppV1.sol\n\nabstract contract ICAppV1 is AbstractICApp, AccessControlEnumerable, InterchainAppV1Events, IInterchainAppV1 {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Role to manage the Interchain setup of the app.\n    bytes32 public constant IC_GOVERNOR_ROLE = keccak256(\"IC_GOVERNOR_ROLE\");\n\n    /// @dev Address of the latest Interchain Client, used for sending messages.\n    address private _latestClient;\n\n    /// @dev Required responses and optimistic period for the module responses.\n    AppConfigV1 private _appConfigV1;\n    /// @dev Address of the linked app deployed on the remote chain.\n    mapping(uint256 chainId =\u003e bytes32 remoteApp) private _linkedApp;\n    /// @dev Interchain Clients allowed to send messages to this app.\n    EnumerableSet.AddressSet private _interchainClients;\n    /// @dev Trusted Interchain modules.\n    EnumerableSet.AddressSet private _trustedModules;\n    /// @dev Execution Service to use for sending messages.\n    address private _executionService;\n\n    constructor(address admin) {\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addInterchainClient(address client, bool updateLatest) external onlyRole(IC_GOVERNOR_ROLE) {\n        _addClient(client, updateLatest);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _removeClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setLatestInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _setLatestClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteApp(uint256 chainId, bytes32 remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteAppEVM(uint256 chainId, address remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp.addressToBytes32());\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (module == address(0)) {\n            revert InterchainApp__ModuleZeroAddress();\n        }\n        bool added = _trustedModules.add(module);\n        if (!added) {\n            revert InterchainApp__ModuleAlreadyAdded(module);\n        }\n        emit TrustedModuleAdded(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        bool removed = _trustedModules.remove(module);\n        if (!removed) {\n            revert InterchainApp__ModuleNotAdded(module);\n        }\n        emit TrustedModuleRemoved(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setAppConfigV1(AppConfigV1 memory appConfig) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (appConfig.requiredResponses == 0 || appConfig.optimisticPeriod == 0) {\n            revert InterchainApp__InvalidAppConfig(appConfig.requiredResponses, appConfig.optimisticPeriod);\n        }\n        _appConfigV1 = appConfig;\n        emit AppConfigV1Set(appConfig.requiredResponses, appConfig.optimisticPeriod);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setExecutionService(address executionService) external onlyRole(IC_GOVERNOR_ROLE) {\n        _executionService = executionService;\n        emit ExecutionServiceSet(executionService);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainAppV1\n    function getAppConfigV1() external view returns (AppConfigV1 memory) {\n        return _appConfigV1;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getExecutionService() external view returns (address) {\n        return _executionService;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getInterchainClients() external view returns (address[] memory) {\n        return _interchainClients.values();\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLatestInterchainClient() external view returns (address) {\n        return _latestClient;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedApp(uint256 chainId) external view returns (bytes32) {\n        return _linkedApp[chainId];\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedAppEVM(uint256 chainId) external view returns (address linkedAppEVM) {\n        bytes32 linkedApp = _linkedApp[chainId];\n        linkedAppEVM = linkedApp.bytes32ToAddress();\n        if (linkedAppEVM.addressToBytes32() != linkedApp) {\n            revert InterchainApp__NotEVMLinkedApp(linkedApp);\n        }\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getModules() external view returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Links the remote app to the current app.\n    /// Will revert if the chainId is the same as the chainId of the local app.\n    /// Note: Should be guarded with permissions check.\n    function _linkRemoteApp(uint256 chainId, bytes32 remoteApp) internal {\n        if (chainId == block.chainid) {\n            revert InterchainApp__SameChainId(chainId);\n        }\n        if (remoteApp == 0) {\n            revert InterchainApp__AppZeroAddress();\n        }\n        _linkedApp[chainId] = remoteApp;\n        emit AppLinked(chainId, remoteApp);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal override {\n        _latestClient = client;\n    }\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal override {\n        if (allowed) {\n            _interchainClients.add(client);\n        } else {\n            _interchainClients.remove(client);\n        }\n    }\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to send the message to the linked app.\n    function _sendToLinkedApp(\n        uint256 dstChainId,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _sendInterchainMessage(dstChainId, _linkedApp[dstChainId], messageFee, encodedOptions, message);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee to send a message to the linked app on the remote chain.\n    function _getMessageFee(\n        uint256 dstChainId,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _getInterchainFee(dstChainId, encodedOptions, message);\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view override returns (bytes memory) {\n        return _appConfigV1.encodeAppConfigV1();\n    }\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view override returns (address) {\n        return _executionService;\n    }\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view override returns (address) {\n        return _latestClient;\n    }\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view override returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint256 srcChainId, bytes32 sender) internal view override returns (bool) {\n        return _linkedApp[srcChainId] == sender;\n    }\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view override returns (bool) {\n        return _interchainClients.contains(caller);\n    }\n}\n\n// contracts/apps/examples/ExampleAppV1.sol\n\ncontract ExampleAppV1 is ICAppV1 {\n    event MessageReceived(uint256 srcChainId, bytes32 sender, uint256 dbNonce, uint64 entryIndex, bytes message);\n    event MessageSent(uint256 dstChainId, uint256 dbNonce, uint64 entryIndex, bytes32 transactionId);\n\n    constructor(address admin) ICAppV1(admin) {\n        _grantRole(IC_GOVERNOR_ROLE, admin);\n    }\n\n    /// @notice Allows the Admin to withdraw the native asset from the contract.\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        Address.sendValue(payable(msg.sender), address(this).balance);\n    }\n\n    /// @notice Sends a basic message to the destination chain.\n    function sendMessage(\n        uint256 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        InterchainTxDescriptor memory desc = _sendToLinkedApp({\n            dstChainId: dstChainId,\n            messageFee: msg.value,\n            options: OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}),\n            message: message\n        });\n        emit MessageSent(dstChainId, desc.dbNonce, desc.entryIndex, desc.transactionId);\n    }\n\n    /// @notice Returns the fee required to send a message using `sendMessage`.\n    function getMessageFee(\n        uint256 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes memory message\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _getMessageFee(dstChainId, OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}), message);\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        override\n    {\n        emit MessageReceived(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[],"name":"AccessControlBadConfirmation","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"bytes32","name":"neededRole","type":"bytes32"}],"name":"AccessControlUnauthorizedAccount","type":"error"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"bytes32","name":"previousAdminRole","type":"bytes32"},{"indexed":true,"internalType":"bytes32","name":"newAdminRole","type":"bytes32"}],"name":"RoleAdminChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":true,"internalType":"address","name":"sender","type":"address"}],"name":"RoleGranted","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":true,"internalType":"address","name":"sender","type":"address"}],"name":"RoleRevoked","type":"event"},{"inputs":[],"name":"DEFAULT_ADMIN_ROLE","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"}],"name":"getRoleAdmin","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"uint256","name":"index","type":"uint256"}],"name":"getRoleMember","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"}],"name":"getRoleMemberCount","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"grantRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"hasRole","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"callerConfirmation","type":"address"}],"name":"renounceRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"revokeRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes4","name":"interfaceId","type":"bytes4"}],"name":"supportsInterface","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"details":"Extension of {AccessControl} that allows enumerating the members of each role.","errors":{"AccessControlBadConfirmation()":[{"details":"The caller of a function is not the expected one. NOTE: Don't confuse with {AccessControlUnauthorizedAccount}."}],"AccessControlUnauthorizedAccount(address,bytes32)":[{"details":"The `account` is missing a role."}]},"events":{"RoleAdminChanged(bytes32,bytes32,bytes32)":{"details":"Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole` `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite {RoleAdminChanged} not being emitted signaling this."},"RoleGranted(bytes32,address,address)":{"details":"Emitted when `account` is granted `role`. `sender` is the account that originated the contract call, an admin role bearer except when using {AccessControl-_setupRole}."},"RoleRevoked(bytes32,address,address)":{"details":"Emitted when `account` is revoked `role`. `sender` is the account that originated the contract call:   - if using `revokeRole`, it is the admin role bearer   - if using `renounceRole`, it is the role bearer (i.e. `account`)"}},"kind":"dev","methods":{"getRoleAdmin(bytes32)":{"details":"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"getRoleMember(bytes32,uint256)":{"details":"Returns one of the accounts that have `role`. `index` must be a value between 0 and {getRoleMemberCount}, non-inclusive. Role bearers are not sorted in any particular way, and their ordering may change at any point. WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure you perform all queries on the same block. See the following https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post] for more information."},"getRoleMemberCount(bytes32)":{"details":"Returns the number of accounts that have `role`. Can be used together with {getRoleMember} to enumerate all bearers of a role."},"grantRole(bytes32,address)":{"details":"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleGranted} event."},"hasRole(bytes32,address)":{"details":"Returns `true` if `account` has been granted `role`."},"renounceRole(bytes32,address)":{"details":"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `callerConfirmation`. May emit a {RoleRevoked} event."},"revokeRole(bytes32,address)":{"details":"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleRevoked} event."},"supportsInterface(bytes4)":{"details":"See {IERC165-supportsInterface}."}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"AccessControlBadConfirmation\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"neededRole\",\"type\":\"bytes32\"}],\"name\":\"AccessControlUnauthorizedAccount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getRoleMember\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleMemberCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"callerConfirmation\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Extension of {AccessControl} that allows enumerating the members of each role.\",\"errors\":{\"AccessControlBadConfirmation()\":[{\"details\":\"The caller of a function is not the expected one. NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\"}],\"AccessControlUnauthorizedAccount(address,bytes32)\":[{\"details\":\"The `account` is missing a role.\"}]},\"events\":{\"RoleAdminChanged(bytes32,bytes32,bytes32)\":{\"details\":\"Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole` `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite {RoleAdminChanged} not being emitted signaling this.\"},\"RoleGranted(bytes32,address,address)\":{\"details\":\"Emitted when `account` is granted `role`. `sender` is the account that originated the contract call, an admin role bearer except when using {AccessControl-_setupRole}.\"},\"RoleRevoked(bytes32,address,address)\":{\"details\":\"Emitted when `account` is revoked `role`. `sender` is the account that originated the contract call:   - if using `revokeRole`, it is the admin role bearer   - if using `renounceRole`, it is the role bearer (i.e. `account`)\"}},\"kind\":\"dev\",\"methods\":{\"getRoleAdmin(bytes32)\":{\"details\":\"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.\"},\"getRoleMember(bytes32,uint256)\":{\"details\":\"Returns one of the accounts that have `role`. `index` must be a value between 0 and {getRoleMemberCount}, non-inclusive. Role bearers are not sorted in any particular way, and their ordering may change at any point. WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure you perform all queries on the same block. See the following https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post] for more information.\"},\"getRoleMemberCount(bytes32)\":{\"details\":\"Returns the number of accounts that have `role`. Can be used together with {getRoleMember} to enumerate all bearers of a role.\"},\"grantRole(bytes32,address)\":{\"details\":\"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleGranted} event.\"},\"hasRole(bytes32,address)\":{\"details\":\"Returns `true` if `account` has been granted `role`.\"},\"renounceRole(bytes32,address)\":{\"details\":\"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `callerConfirmation`. May emit a {RoleRevoked} event.\"},\"revokeRole(bytes32,address)\":{\"details\":\"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleRevoked} event.\"},\"supportsInterface(bytes4)\":{\"details\":\"See {IERC165-supportsInterface}.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/ExampleAppV1.sol\":\"AccessControlEnumerable\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/ExampleAppV1.sol\":{\"keccak256\":\"0x4c94807e7a2671ad6fcf49fb03cfafa6f51f6b4596f34092fba0bf17b6d482cf\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://4fabc9aa6f6891674b77809808b14ff1f2e8829de650caafa1fb3c3444a07331\",\"dweb:/ipfs/QmVzYNSfkuSkXNaFKuNY3hmkdspssruAhQx4qZuJU3Ceg9\"]}},\"version\":1}"},"hashes":{"DEFAULT_ADMIN_ROLE()":"a217fddf","getRoleAdmin(bytes32)":"248a9ca3","getRoleMember(bytes32,uint256)":"9010d07c","getRoleMemberCount(bytes32)":"ca15c873","grantRole(bytes32,address)":"2f2ff15d","hasRole(bytes32,address)":"91d14854","renounceRole(bytes32,address)":"36568abe","revokeRole(bytes32,address)":"d547741f","supportsInterface(bytes4)":"01ffc9a7"}},"solidity/ExampleAppV1.sol:Address":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122071b366c86611bb1ac69bdf4f60915ed393f9a940400980397231210dcc5472ed64736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122071b366c86611bb1ac69bdf4f60915ed393f9a940400980397231210dcc5472ed64736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/AbstractICAppEvents.sol\n\nabstract contract AbstractICAppEvents {\n    event InterchainClientAdded(address client);\n    event InterchainClientRemoved(address client);\n    event LatestClientSet(address client);\n}\n\n// contracts/events/InterchainAppV1Events.sol\n\nabstract contract InterchainAppV1Events {\n    event AppConfigV1Set(uint256 requiredResponses, uint256 optimisticPeriod);\n    event AppLinked(uint256 indexed chainId, bytes32 indexed remoteApp);\n    event ExecutionServiceSet(address executionService);\n    event TrustedModuleAdded(address module);\n    event TrustedModuleRemoved(address module);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    /// @notice Allows the Interchain Client to pass the message to the Interchain App.\n    /// @dev App is responsible for keeping track of interchain clients, and must verify the message sender.\n    /// @param srcChainId   Chain ID of the source chain, where the message was sent from.\n    /// @param sender       Sender address on the source chain, as a bytes32 value.\n    /// @param dbNonce      The Interchain DB nonce of the batch containing the message entry.\n    /// @param entryIndex   The index of the message entry within the batch.\n    /// @param message      The message being sent.\n    function appReceive(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /// @notice Returns the verification configuration of the Interchain App.\n    /// @dev This configuration is used by the Interchain Client to verify that message has been confirmed\n    /// by the Interchain Modules on the destination chain.\n    /// Note: V1 version of AppConfig includes the required responses count, and optimistic period after which\n    /// the message is considered confirmed by the module. Following versions may include additional fields.\n    /// @return appConfig    The versioned configuration of the Interchain App, encoded as bytes.\n    /// @return modules      The list of Interchain Modules that app is trusting to confirm the messages.\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    uint8 constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint8 version);\n\n    /// @notice Encodes versioned app config into a bytes format.\n    /// @param version      The version of the app config.\n    /// @param appConfig    The app config to encode.\n    function encodeVersionedAppConfig(uint8 version, bytes memory appConfig) internal pure returns (bytes memory) {\n        return abi.encode(version, appConfig);\n    }\n\n    /// @notice Decodes versioned app config from a bytes format back into a version and app config.\n    /// @param data         The versioned app config data in bytes format.\n    /// @return version     The version of the app config.\n    /// @return appConfig   The app config as bytes.\n    function decodeVersionedAppConfig(bytes memory data)\n        internal\n        pure\n        returns (uint8 version, bytes memory appConfig)\n    {\n        (version, appConfig) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return encodeVersionedAppConfig(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal pure returns (AppConfigV1 memory) {\n        (uint8 version, bytes memory appConfig) = decodeVersionedAppConfig(data);\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(appConfig, (AppConfigV1));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    uint8 constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint8 version);\n\n    /// @notice Encodes versioned options into a bytes format.\n    /// @param version      The version of the options.\n    /// @param options      The options to encode.\n    function encodeVersionedOptions(uint8 version, bytes memory options) internal pure returns (bytes memory) {\n        return abi.encode(version, options);\n    }\n\n    /// @notice Decodes versioned options from a bytes format back into a version and options.\n    /// @param data         The versioned options data in bytes format.\n    /// @return version     The version of the options.\n    /// @return options     The options as bytes.\n    function decodeVersionedOptions(bytes memory data) internal pure returns (uint8 version, bytes memory options) {\n        (version, options) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return encodeVersionedOptions(OPTIONS_V1, abi.encode(options));\n    }\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal pure returns (OptionsV1 memory) {\n        (uint8 version, bytes memory options) = decodeVersionedOptions(data);\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(options, (OptionsV1));\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/IAccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n\n// node_modules/@openzeppelin/contracts/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance \u003c amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance \u003c value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 \u0026\u0026 target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/libs/InterchainTransaction.sol\n\nstruct InterchainTransaction {\n    uint256 srcChainId;\n    bytes32 srcSender;\n    uint256 dstChainId;\n    bytes32 dstReceiver;\n    uint256 dbNonce;\n    uint64 entryIndex;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint256 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    function constructLocalTransaction(\n        address srcSender,\n        uint256 dstChainId,\n        bytes32 dstReceiver,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: block.chainid,\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(transaction);\n    }\n\n    function decodeTransaction(bytes memory encodedTx) internal pure returns (InterchainTransaction memory) {\n        return abi.decode(encodedTx, (InterchainTransaction));\n    }\n\n    function transactionId(InterchainTransaction memory transaction) internal pure returns (bytes32) {\n        return keccak256(abi.encode(transaction));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/IAccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/IAccessControlEnumerable.sol)\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n// contracts/interfaces/IInterchainAppV1.sol\n\ninterface IInterchainAppV1 is IInterchainApp {\n    error InterchainApp__AppZeroAddress();\n    error InterchainApp__InvalidAppConfig(uint256 requiredResponses, uint256 optimisticPeriod);\n    error InterchainApp__ModuleAlreadyAdded(address module);\n    error InterchainApp__ModuleNotAdded(address module);\n    error InterchainApp__ModuleZeroAddress();\n    error InterchainApp__NotEVMLinkedApp(bytes32 linkedApp);\n\n    /// @notice Allows the owner to add the interchain client to the allowed clients set,\n    /// and optionally set the latest client to this one.\n    /// Note: only the allowed clients can send messages to this app.\n    /// Note: the latest client is used for sending messages from this app.\n    /// @param client       The address of the interchain client to add.\n    /// @param updateLatest Whether to set the latest client to this one.\n    function addInterchainClient(address client, bool updateLatest) external;\n\n    /// @notice Allows the owner to remove the interchain client from the allowed clients set.\n    /// If the client is the latest client, the latest client is set to the zero address.\n    /// @param client       The address of the interchain client to remove.\n    function removeInterchainClient(address client) external;\n\n    /// @notice Allows the owner to set the address of the latest interchain client.\n    /// @dev The new latest client must be an allowed client or zero address.\n    /// Setting the client to zero address effectively pauses the app ability to send messages,\n    /// while allowing to receive them.\n    /// @param client       The address of the latest interchain client.\n    function setLatestInterchainClient(address client) external;\n\n    /// @notice Allows the owner to link the remote app for the given chain ID.\n    /// - This address will be used as the receiver for the messages sent from this chain.\n    /// - This address will be the only trusted sender for the messages sent to this chain.\n    /// @param chainId      The remote chain ID.\n    /// @param remoteApp    The address of the remote app to link.\n    function linkRemoteApp(uint256 chainId, bytes32 remoteApp) external;\n\n    /// @notice Thin wrapper for `linkRemoteApp` to accept EVM address as a parameter.\n    function linkRemoteAppEVM(uint256 chainId, address remoteApp) external;\n\n    /// @notice Allows the owner to add the module to the trusted modules set.\n    /// - This set of modules will be used to verify both sent and received messages.\n    function addTrustedModule(address module) external;\n\n    /// @notice Allows the owner to remove the module from the trusted modules set.\n    function removeTrustedModule(address module) external;\n\n    /// @notice Allows the owner to set the app config for the current app. App config includes:\n    /// - requiredResponses: the number of module responses required for accepting the message\n    /// - optimisticPeriod: the minimum time after which the module responses are considered final\n    function setAppConfigV1(AppConfigV1 memory appConfig) external;\n\n    /// @notice Allows the owner to set the address of the Execution Service.\n    /// This address will be used to request execution of the messages sent from this chain,\n    /// by supplying the Service's execution fee.\n    function setExecutionService(address executionService) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Returns the app config for the current app: requiredResponses and optimisticPeriod.\n    function getAppConfigV1() external view returns (AppConfigV1 memory);\n\n    /// @notice Returns the address of the Execution Service used by this app for sending messages.\n    function getExecutionService() external view returns (address);\n\n    /// @notice Returns the list of Interchain Clients allowed to send messages to this app.\n    function getInterchainClients() external view returns (address[] memory);\n\n    /// @notice Returns the address of the latest interchain client.\n    /// This address is used for sending messages from this app.\n    function getLatestInterchainClient() external view returns (address);\n\n    /// @notice Returns the linked app address (as bytes32) for the given chain ID.\n    function getLinkedApp(uint256 chainId) external view returns (bytes32);\n\n    /// @notice Thin wrapper for `getLinkedApp` to return the linked app address as EVM address.\n    /// @dev Will revert if the linked app address is not an EVM address.\n    function getLinkedAppEVM(uint256 chainId) external view returns (address);\n\n    /// @notice Returns the list of Interchain Modules trusted by this app.\n    /// This set of modules will be used to verify both sent and received messages.\n    function getModules() external view returns (address[] memory);\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint256 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__NoLinkedClient(uint256 chainId);\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint256 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint256 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint256 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint256 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint256 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param message              The message being sent.\n    function getInterchainFee(\n        uint256 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint256 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint256 chainId) external view returns (address);\n}\n\n// node_modules/@openzeppelin/contracts/access/AccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account =\u003e bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role =\u003e RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n// contracts/apps/AbstractICApp.sol\n\nabstract contract AbstractICApp is AbstractICAppEvents, IInterchainApp {\n    using TypeCasts for address;\n\n    error InterchainApp__AlreadyLatestClient(address client);\n    error InterchainApp__BalanceTooLow(uint256 actual, uint256 required);\n    error InterchainApp__ClientAlreadyAdded(address client);\n    error InterchainApp__InterchainClientZeroAddress();\n    error InterchainApp__NotInterchainClient(address account);\n    error InterchainApp__ReceiverNotSet(uint256 chainId);\n    error InterchainApp__SameChainId(uint256 chainId);\n    error InterchainApp__SenderNotAllowed(uint256 srcChainId, bytes32 sender);\n\n    /// @inheritdoc IInterchainApp\n    function appReceive(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        if (!_isInterchainClient(msg.sender)) {\n            revert InterchainApp__NotInterchainClient(msg.sender);\n        }\n        if (srcChainId == block.chainid) {\n            revert InterchainApp__SameChainId(srcChainId);\n        }\n        if (!_isAllowedSender(srcChainId, sender)) {\n            revert InterchainApp__SenderNotAllowed(srcChainId, sender);\n        }\n        _receiveMessage(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n\n    /// @inheritdoc IInterchainApp\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules) {\n        appConfig = _getAppConfig();\n        modules = _getModules();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Performs necessary checks and adds an Interchain Client.\n    /// Optionally sets the latest client to this one.\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _addClient(address client, bool updateLatest) internal {\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (_isInterchainClient(client)) {\n            revert InterchainApp__ClientAlreadyAdded(client);\n        }\n        _toggleClientState(client, true);\n        emit InterchainClientAdded(client);\n        if (updateLatest) {\n            _setLatestClient(client);\n        }\n    }\n\n    /// @dev Performs necessary checks and removes an Interchain Client. If this client is the latest one,\n    /// the latest client is set to zero address (effectively pausing the app ability to send messages).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _removeClient(address client) internal {\n        if (!_isInterchainClient(client)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        _toggleClientState(client, false);\n        emit InterchainClientRemoved(client);\n        if (client == _getLatestClient()) {\n            _setLatestClient(address(0));\n        }\n    }\n\n    /// @dev Sets the latest Interchain Client to one of the allowed clients. Setting the client to zero address\n    /// is allowed and effectively pauses the app ability to send messages (but still allows to receive them).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _setLatestClient(address client) internal {\n        // New latest client must be an allowed client or zero address.\n        if (!_isInterchainClient(client) \u0026\u0026 client != address(0)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        if (client == _getLatestClient()) {\n            revert InterchainApp__AlreadyLatestClient(client);\n        }\n        _storeLatestClient(client);\n        emit LatestClientSet(client);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal virtual;\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal virtual;\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to accept EVM address as a parameter.\n    function _sendInterchainMessageEVM(\n        uint256 dstChainId,\n        address receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _sendInterchainMessage(dstChainId, receiver.addressToBytes32(), messageFee, options, message);\n    }\n\n    /// @dev Performs necessary checks and sends an interchain message.\n    function _sendInterchainMessage(\n        uint256 dstChainId,\n        bytes32 receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (dstChainId == block.chainid) {\n            revert InterchainApp__SameChainId(dstChainId);\n        }\n        if (receiver == 0) {\n            revert InterchainApp__ReceiverNotSet(dstChainId);\n        }\n        if (address(this).balance \u003c messageFee) {\n            revert InterchainApp__BalanceTooLow({actual: address(this).balance, required: messageFee});\n        }\n        return IInterchainClientV1(client).interchainSend{value: messageFee}(\n            dstChainId, receiver, _getExecutionService(), _getModules(), options, message\n        );\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        virtual;\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee for sending an Interchain message.\n    function _getInterchainFee(\n        uint256 dstChainId,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        return IInterchainClientV1(client).getInterchainFee(\n            dstChainId, _getExecutionService(), _getModules(), options, message\n        );\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view virtual returns (bytes memory);\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view virtual returns (address);\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view virtual returns (address);\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view virtual returns (address[] memory);\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint256 srcChainId, bytes32 sender) internal view virtual returns (bool);\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view virtual returns (bool);\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/AccessControlEnumerable.sol)\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 role =\u003e EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {AccessControl-_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool granted = super._grantRole(role, account);\n        if (granted) {\n            _roleMembers[role].add(account);\n        }\n        return granted;\n    }\n\n    /**\n     * @dev Overload {AccessControl-_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool revoked = super._revokeRole(role, account);\n        if (revoked) {\n            _roleMembers[role].remove(account);\n        }\n        return revoked;\n    }\n}\n\n// contracts/apps/ICAppV1.sol\n\nabstract contract ICAppV1 is AbstractICApp, AccessControlEnumerable, InterchainAppV1Events, IInterchainAppV1 {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Role to manage the Interchain setup of the app.\n    bytes32 public constant IC_GOVERNOR_ROLE = keccak256(\"IC_GOVERNOR_ROLE\");\n\n    /// @dev Address of the latest Interchain Client, used for sending messages.\n    address private _latestClient;\n\n    /// @dev Required responses and optimistic period for the module responses.\n    AppConfigV1 private _appConfigV1;\n    /// @dev Address of the linked app deployed on the remote chain.\n    mapping(uint256 chainId =\u003e bytes32 remoteApp) private _linkedApp;\n    /// @dev Interchain Clients allowed to send messages to this app.\n    EnumerableSet.AddressSet private _interchainClients;\n    /// @dev Trusted Interchain modules.\n    EnumerableSet.AddressSet private _trustedModules;\n    /// @dev Execution Service to use for sending messages.\n    address private _executionService;\n\n    constructor(address admin) {\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addInterchainClient(address client, bool updateLatest) external onlyRole(IC_GOVERNOR_ROLE) {\n        _addClient(client, updateLatest);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _removeClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setLatestInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _setLatestClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteApp(uint256 chainId, bytes32 remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteAppEVM(uint256 chainId, address remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp.addressToBytes32());\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (module == address(0)) {\n            revert InterchainApp__ModuleZeroAddress();\n        }\n        bool added = _trustedModules.add(module);\n        if (!added) {\n            revert InterchainApp__ModuleAlreadyAdded(module);\n        }\n        emit TrustedModuleAdded(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        bool removed = _trustedModules.remove(module);\n        if (!removed) {\n            revert InterchainApp__ModuleNotAdded(module);\n        }\n        emit TrustedModuleRemoved(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setAppConfigV1(AppConfigV1 memory appConfig) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (appConfig.requiredResponses == 0 || appConfig.optimisticPeriod == 0) {\n            revert InterchainApp__InvalidAppConfig(appConfig.requiredResponses, appConfig.optimisticPeriod);\n        }\n        _appConfigV1 = appConfig;\n        emit AppConfigV1Set(appConfig.requiredResponses, appConfig.optimisticPeriod);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setExecutionService(address executionService) external onlyRole(IC_GOVERNOR_ROLE) {\n        _executionService = executionService;\n        emit ExecutionServiceSet(executionService);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainAppV1\n    function getAppConfigV1() external view returns (AppConfigV1 memory) {\n        return _appConfigV1;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getExecutionService() external view returns (address) {\n        return _executionService;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getInterchainClients() external view returns (address[] memory) {\n        return _interchainClients.values();\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLatestInterchainClient() external view returns (address) {\n        return _latestClient;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedApp(uint256 chainId) external view returns (bytes32) {\n        return _linkedApp[chainId];\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedAppEVM(uint256 chainId) external view returns (address linkedAppEVM) {\n        bytes32 linkedApp = _linkedApp[chainId];\n        linkedAppEVM = linkedApp.bytes32ToAddress();\n        if (linkedAppEVM.addressToBytes32() != linkedApp) {\n            revert InterchainApp__NotEVMLinkedApp(linkedApp);\n        }\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getModules() external view returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Links the remote app to the current app.\n    /// Will revert if the chainId is the same as the chainId of the local app.\n    /// Note: Should be guarded with permissions check.\n    function _linkRemoteApp(uint256 chainId, bytes32 remoteApp) internal {\n        if (chainId == block.chainid) {\n            revert InterchainApp__SameChainId(chainId);\n        }\n        if (remoteApp == 0) {\n            revert InterchainApp__AppZeroAddress();\n        }\n        _linkedApp[chainId] = remoteApp;\n        emit AppLinked(chainId, remoteApp);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal override {\n        _latestClient = client;\n    }\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal override {\n        if (allowed) {\n            _interchainClients.add(client);\n        } else {\n            _interchainClients.remove(client);\n        }\n    }\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to send the message to the linked app.\n    function _sendToLinkedApp(\n        uint256 dstChainId,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _sendInterchainMessage(dstChainId, _linkedApp[dstChainId], messageFee, encodedOptions, message);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee to send a message to the linked app on the remote chain.\n    function _getMessageFee(\n        uint256 dstChainId,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _getInterchainFee(dstChainId, encodedOptions, message);\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view override returns (bytes memory) {\n        return _appConfigV1.encodeAppConfigV1();\n    }\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view override returns (address) {\n        return _executionService;\n    }\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view override returns (address) {\n        return _latestClient;\n    }\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view override returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint256 srcChainId, bytes32 sender) internal view override returns (bool) {\n        return _linkedApp[srcChainId] == sender;\n    }\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view override returns (bool) {\n        return _interchainClients.contains(caller);\n    }\n}\n\n// contracts/apps/examples/ExampleAppV1.sol\n\ncontract ExampleAppV1 is ICAppV1 {\n    event MessageReceived(uint256 srcChainId, bytes32 sender, uint256 dbNonce, uint64 entryIndex, bytes message);\n    event MessageSent(uint256 dstChainId, uint256 dbNonce, uint64 entryIndex, bytes32 transactionId);\n\n    constructor(address admin) ICAppV1(admin) {\n        _grantRole(IC_GOVERNOR_ROLE, admin);\n    }\n\n    /// @notice Allows the Admin to withdraw the native asset from the contract.\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        Address.sendValue(payable(msg.sender), address(this).balance);\n    }\n\n    /// @notice Sends a basic message to the destination chain.\n    function sendMessage(\n        uint256 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        InterchainTxDescriptor memory desc = _sendToLinkedApp({\n            dstChainId: dstChainId,\n            messageFee: msg.value,\n            options: OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}),\n            message: message\n        });\n        emit MessageSent(dstChainId, desc.dbNonce, desc.entryIndex, desc.transactionId);\n    }\n\n    /// @notice Returns the fee required to send a message using `sendMessage`.\n    function getMessageFee(\n        uint256 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes memory message\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _getMessageFee(dstChainId, OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}), message);\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        override\n    {\n        emit MessageReceived(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"10937:6066:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;10937:6066:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"10937:6066:0:-:0;;;;;;;;","abiDefinition":[{"inputs":[{"internalType":"address","name":"target","type":"address"}],"name":"AddressEmptyCode","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"AddressInsufficientBalance","type":"error"},{"inputs":[],"name":"FailedInnerCall","type":"error"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"details":"Collection of functions related to the address type","errors":{"AddressEmptyCode(address)":[{"details":"There's no code at `target` (it is not a contract)."}],"AddressInsufficientBalance(address)":[{"details":"The ETH balance of the account is not enough to perform the operation."}],"FailedInnerCall()":[{"details":"A call to an address target failed. The target may have reverted."}]},"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"AddressEmptyCode\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AddressInsufficientBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FailedInnerCall\",\"type\":\"error\"}],\"devdoc\":{\"details\":\"Collection of functions related to the address type\",\"errors\":{\"AddressEmptyCode(address)\":[{\"details\":\"There's no code at `target` (it is not a contract).\"}],\"AddressInsufficientBalance(address)\":[{\"details\":\"The ETH balance of the account is not enough to perform the operation.\"}],\"FailedInnerCall()\":[{\"details\":\"A call to an address target failed. The target may have reverted.\"}]},\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/ExampleAppV1.sol\":\"Address\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/ExampleAppV1.sol\":{\"keccak256\":\"0x4c94807e7a2671ad6fcf49fb03cfafa6f51f6b4596f34092fba0bf17b6d482cf\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://4fabc9aa6f6891674b77809808b14ff1f2e8829de650caafa1fb3c3444a07331\",\"dweb:/ipfs/QmVzYNSfkuSkXNaFKuNY3hmkdspssruAhQx4qZuJU3Ceg9\"]}},\"version\":1}"},"hashes":{}},"solidity/ExampleAppV1.sol:AppConfigLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122039e9c8ac1f0fed471c30a37e5111fe29054fba2ad81e1fafc68dd5549470454564736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122039e9c8ac1f0fed471c30a37e5111fe29054fba2ad81e1fafc68dd5549470454564736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/AbstractICAppEvents.sol\n\nabstract contract AbstractICAppEvents {\n    event InterchainClientAdded(address client);\n    event InterchainClientRemoved(address client);\n    event LatestClientSet(address client);\n}\n\n// contracts/events/InterchainAppV1Events.sol\n\nabstract contract InterchainAppV1Events {\n    event AppConfigV1Set(uint256 requiredResponses, uint256 optimisticPeriod);\n    event AppLinked(uint256 indexed chainId, bytes32 indexed remoteApp);\n    event ExecutionServiceSet(address executionService);\n    event TrustedModuleAdded(address module);\n    event TrustedModuleRemoved(address module);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    /// @notice Allows the Interchain Client to pass the message to the Interchain App.\n    /// @dev App is responsible for keeping track of interchain clients, and must verify the message sender.\n    /// @param srcChainId   Chain ID of the source chain, where the message was sent from.\n    /// @param sender       Sender address on the source chain, as a bytes32 value.\n    /// @param dbNonce      The Interchain DB nonce of the batch containing the message entry.\n    /// @param entryIndex   The index of the message entry within the batch.\n    /// @param message      The message being sent.\n    function appReceive(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /// @notice Returns the verification configuration of the Interchain App.\n    /// @dev This configuration is used by the Interchain Client to verify that message has been confirmed\n    /// by the Interchain Modules on the destination chain.\n    /// Note: V1 version of AppConfig includes the required responses count, and optimistic period after which\n    /// the message is considered confirmed by the module. Following versions may include additional fields.\n    /// @return appConfig    The versioned configuration of the Interchain App, encoded as bytes.\n    /// @return modules      The list of Interchain Modules that app is trusting to confirm the messages.\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    uint8 constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint8 version);\n\n    /// @notice Encodes versioned app config into a bytes format.\n    /// @param version      The version of the app config.\n    /// @param appConfig    The app config to encode.\n    function encodeVersionedAppConfig(uint8 version, bytes memory appConfig) internal pure returns (bytes memory) {\n        return abi.encode(version, appConfig);\n    }\n\n    /// @notice Decodes versioned app config from a bytes format back into a version and app config.\n    /// @param data         The versioned app config data in bytes format.\n    /// @return version     The version of the app config.\n    /// @return appConfig   The app config as bytes.\n    function decodeVersionedAppConfig(bytes memory data)\n        internal\n        pure\n        returns (uint8 version, bytes memory appConfig)\n    {\n        (version, appConfig) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return encodeVersionedAppConfig(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal pure returns (AppConfigV1 memory) {\n        (uint8 version, bytes memory appConfig) = decodeVersionedAppConfig(data);\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(appConfig, (AppConfigV1));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    uint8 constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint8 version);\n\n    /// @notice Encodes versioned options into a bytes format.\n    /// @param version      The version of the options.\n    /// @param options      The options to encode.\n    function encodeVersionedOptions(uint8 version, bytes memory options) internal pure returns (bytes memory) {\n        return abi.encode(version, options);\n    }\n\n    /// @notice Decodes versioned options from a bytes format back into a version and options.\n    /// @param data         The versioned options data in bytes format.\n    /// @return version     The version of the options.\n    /// @return options     The options as bytes.\n    function decodeVersionedOptions(bytes memory data) internal pure returns (uint8 version, bytes memory options) {\n        (version, options) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return encodeVersionedOptions(OPTIONS_V1, abi.encode(options));\n    }\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal pure returns (OptionsV1 memory) {\n        (uint8 version, bytes memory options) = decodeVersionedOptions(data);\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(options, (OptionsV1));\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/IAccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n\n// node_modules/@openzeppelin/contracts/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance \u003c amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance \u003c value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 \u0026\u0026 target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/libs/InterchainTransaction.sol\n\nstruct InterchainTransaction {\n    uint256 srcChainId;\n    bytes32 srcSender;\n    uint256 dstChainId;\n    bytes32 dstReceiver;\n    uint256 dbNonce;\n    uint64 entryIndex;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint256 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    function constructLocalTransaction(\n        address srcSender,\n        uint256 dstChainId,\n        bytes32 dstReceiver,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: block.chainid,\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(transaction);\n    }\n\n    function decodeTransaction(bytes memory encodedTx) internal pure returns (InterchainTransaction memory) {\n        return abi.decode(encodedTx, (InterchainTransaction));\n    }\n\n    function transactionId(InterchainTransaction memory transaction) internal pure returns (bytes32) {\n        return keccak256(abi.encode(transaction));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/IAccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/IAccessControlEnumerable.sol)\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n// contracts/interfaces/IInterchainAppV1.sol\n\ninterface IInterchainAppV1 is IInterchainApp {\n    error InterchainApp__AppZeroAddress();\n    error InterchainApp__InvalidAppConfig(uint256 requiredResponses, uint256 optimisticPeriod);\n    error InterchainApp__ModuleAlreadyAdded(address module);\n    error InterchainApp__ModuleNotAdded(address module);\n    error InterchainApp__ModuleZeroAddress();\n    error InterchainApp__NotEVMLinkedApp(bytes32 linkedApp);\n\n    /// @notice Allows the owner to add the interchain client to the allowed clients set,\n    /// and optionally set the latest client to this one.\n    /// Note: only the allowed clients can send messages to this app.\n    /// Note: the latest client is used for sending messages from this app.\n    /// @param client       The address of the interchain client to add.\n    /// @param updateLatest Whether to set the latest client to this one.\n    function addInterchainClient(address client, bool updateLatest) external;\n\n    /// @notice Allows the owner to remove the interchain client from the allowed clients set.\n    /// If the client is the latest client, the latest client is set to the zero address.\n    /// @param client       The address of the interchain client to remove.\n    function removeInterchainClient(address client) external;\n\n    /// @notice Allows the owner to set the address of the latest interchain client.\n    /// @dev The new latest client must be an allowed client or zero address.\n    /// Setting the client to zero address effectively pauses the app ability to send messages,\n    /// while allowing to receive them.\n    /// @param client       The address of the latest interchain client.\n    function setLatestInterchainClient(address client) external;\n\n    /// @notice Allows the owner to link the remote app for the given chain ID.\n    /// - This address will be used as the receiver for the messages sent from this chain.\n    /// - This address will be the only trusted sender for the messages sent to this chain.\n    /// @param chainId      The remote chain ID.\n    /// @param remoteApp    The address of the remote app to link.\n    function linkRemoteApp(uint256 chainId, bytes32 remoteApp) external;\n\n    /// @notice Thin wrapper for `linkRemoteApp` to accept EVM address as a parameter.\n    function linkRemoteAppEVM(uint256 chainId, address remoteApp) external;\n\n    /// @notice Allows the owner to add the module to the trusted modules set.\n    /// - This set of modules will be used to verify both sent and received messages.\n    function addTrustedModule(address module) external;\n\n    /// @notice Allows the owner to remove the module from the trusted modules set.\n    function removeTrustedModule(address module) external;\n\n    /// @notice Allows the owner to set the app config for the current app. App config includes:\n    /// - requiredResponses: the number of module responses required for accepting the message\n    /// - optimisticPeriod: the minimum time after which the module responses are considered final\n    function setAppConfigV1(AppConfigV1 memory appConfig) external;\n\n    /// @notice Allows the owner to set the address of the Execution Service.\n    /// This address will be used to request execution of the messages sent from this chain,\n    /// by supplying the Service's execution fee.\n    function setExecutionService(address executionService) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Returns the app config for the current app: requiredResponses and optimisticPeriod.\n    function getAppConfigV1() external view returns (AppConfigV1 memory);\n\n    /// @notice Returns the address of the Execution Service used by this app for sending messages.\n    function getExecutionService() external view returns (address);\n\n    /// @notice Returns the list of Interchain Clients allowed to send messages to this app.\n    function getInterchainClients() external view returns (address[] memory);\n\n    /// @notice Returns the address of the latest interchain client.\n    /// This address is used for sending messages from this app.\n    function getLatestInterchainClient() external view returns (address);\n\n    /// @notice Returns the linked app address (as bytes32) for the given chain ID.\n    function getLinkedApp(uint256 chainId) external view returns (bytes32);\n\n    /// @notice Thin wrapper for `getLinkedApp` to return the linked app address as EVM address.\n    /// @dev Will revert if the linked app address is not an EVM address.\n    function getLinkedAppEVM(uint256 chainId) external view returns (address);\n\n    /// @notice Returns the list of Interchain Modules trusted by this app.\n    /// This set of modules will be used to verify both sent and received messages.\n    function getModules() external view returns (address[] memory);\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint256 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__NoLinkedClient(uint256 chainId);\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint256 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint256 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint256 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint256 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint256 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param message              The message being sent.\n    function getInterchainFee(\n        uint256 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint256 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint256 chainId) external view returns (address);\n}\n\n// node_modules/@openzeppelin/contracts/access/AccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account =\u003e bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role =\u003e RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n// contracts/apps/AbstractICApp.sol\n\nabstract contract AbstractICApp is AbstractICAppEvents, IInterchainApp {\n    using TypeCasts for address;\n\n    error InterchainApp__AlreadyLatestClient(address client);\n    error InterchainApp__BalanceTooLow(uint256 actual, uint256 required);\n    error InterchainApp__ClientAlreadyAdded(address client);\n    error InterchainApp__InterchainClientZeroAddress();\n    error InterchainApp__NotInterchainClient(address account);\n    error InterchainApp__ReceiverNotSet(uint256 chainId);\n    error InterchainApp__SameChainId(uint256 chainId);\n    error InterchainApp__SenderNotAllowed(uint256 srcChainId, bytes32 sender);\n\n    /// @inheritdoc IInterchainApp\n    function appReceive(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        if (!_isInterchainClient(msg.sender)) {\n            revert InterchainApp__NotInterchainClient(msg.sender);\n        }\n        if (srcChainId == block.chainid) {\n            revert InterchainApp__SameChainId(srcChainId);\n        }\n        if (!_isAllowedSender(srcChainId, sender)) {\n            revert InterchainApp__SenderNotAllowed(srcChainId, sender);\n        }\n        _receiveMessage(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n\n    /// @inheritdoc IInterchainApp\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules) {\n        appConfig = _getAppConfig();\n        modules = _getModules();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Performs necessary checks and adds an Interchain Client.\n    /// Optionally sets the latest client to this one.\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _addClient(address client, bool updateLatest) internal {\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (_isInterchainClient(client)) {\n            revert InterchainApp__ClientAlreadyAdded(client);\n        }\n        _toggleClientState(client, true);\n        emit InterchainClientAdded(client);\n        if (updateLatest) {\n            _setLatestClient(client);\n        }\n    }\n\n    /// @dev Performs necessary checks and removes an Interchain Client. If this client is the latest one,\n    /// the latest client is set to zero address (effectively pausing the app ability to send messages).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _removeClient(address client) internal {\n        if (!_isInterchainClient(client)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        _toggleClientState(client, false);\n        emit InterchainClientRemoved(client);\n        if (client == _getLatestClient()) {\n            _setLatestClient(address(0));\n        }\n    }\n\n    /// @dev Sets the latest Interchain Client to one of the allowed clients. Setting the client to zero address\n    /// is allowed and effectively pauses the app ability to send messages (but still allows to receive them).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _setLatestClient(address client) internal {\n        // New latest client must be an allowed client or zero address.\n        if (!_isInterchainClient(client) \u0026\u0026 client != address(0)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        if (client == _getLatestClient()) {\n            revert InterchainApp__AlreadyLatestClient(client);\n        }\n        _storeLatestClient(client);\n        emit LatestClientSet(client);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal virtual;\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal virtual;\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to accept EVM address as a parameter.\n    function _sendInterchainMessageEVM(\n        uint256 dstChainId,\n        address receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _sendInterchainMessage(dstChainId, receiver.addressToBytes32(), messageFee, options, message);\n    }\n\n    /// @dev Performs necessary checks and sends an interchain message.\n    function _sendInterchainMessage(\n        uint256 dstChainId,\n        bytes32 receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (dstChainId == block.chainid) {\n            revert InterchainApp__SameChainId(dstChainId);\n        }\n        if (receiver == 0) {\n            revert InterchainApp__ReceiverNotSet(dstChainId);\n        }\n        if (address(this).balance \u003c messageFee) {\n            revert InterchainApp__BalanceTooLow({actual: address(this).balance, required: messageFee});\n        }\n        return IInterchainClientV1(client).interchainSend{value: messageFee}(\n            dstChainId, receiver, _getExecutionService(), _getModules(), options, message\n        );\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        virtual;\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee for sending an Interchain message.\n    function _getInterchainFee(\n        uint256 dstChainId,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        return IInterchainClientV1(client).getInterchainFee(\n            dstChainId, _getExecutionService(), _getModules(), options, message\n        );\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view virtual returns (bytes memory);\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view virtual returns (address);\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view virtual returns (address);\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view virtual returns (address[] memory);\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint256 srcChainId, bytes32 sender) internal view virtual returns (bool);\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view virtual returns (bool);\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/AccessControlEnumerable.sol)\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 role =\u003e EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {AccessControl-_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool granted = super._grantRole(role, account);\n        if (granted) {\n            _roleMembers[role].add(account);\n        }\n        return granted;\n    }\n\n    /**\n     * @dev Overload {AccessControl-_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool revoked = super._revokeRole(role, account);\n        if (revoked) {\n            _roleMembers[role].remove(account);\n        }\n        return revoked;\n    }\n}\n\n// contracts/apps/ICAppV1.sol\n\nabstract contract ICAppV1 is AbstractICApp, AccessControlEnumerable, InterchainAppV1Events, IInterchainAppV1 {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Role to manage the Interchain setup of the app.\n    bytes32 public constant IC_GOVERNOR_ROLE = keccak256(\"IC_GOVERNOR_ROLE\");\n\n    /// @dev Address of the latest Interchain Client, used for sending messages.\n    address private _latestClient;\n\n    /// @dev Required responses and optimistic period for the module responses.\n    AppConfigV1 private _appConfigV1;\n    /// @dev Address of the linked app deployed on the remote chain.\n    mapping(uint256 chainId =\u003e bytes32 remoteApp) private _linkedApp;\n    /// @dev Interchain Clients allowed to send messages to this app.\n    EnumerableSet.AddressSet private _interchainClients;\n    /// @dev Trusted Interchain modules.\n    EnumerableSet.AddressSet private _trustedModules;\n    /// @dev Execution Service to use for sending messages.\n    address private _executionService;\n\n    constructor(address admin) {\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addInterchainClient(address client, bool updateLatest) external onlyRole(IC_GOVERNOR_ROLE) {\n        _addClient(client, updateLatest);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _removeClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setLatestInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _setLatestClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteApp(uint256 chainId, bytes32 remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteAppEVM(uint256 chainId, address remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp.addressToBytes32());\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (module == address(0)) {\n            revert InterchainApp__ModuleZeroAddress();\n        }\n        bool added = _trustedModules.add(module);\n        if (!added) {\n            revert InterchainApp__ModuleAlreadyAdded(module);\n        }\n        emit TrustedModuleAdded(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        bool removed = _trustedModules.remove(module);\n        if (!removed) {\n            revert InterchainApp__ModuleNotAdded(module);\n        }\n        emit TrustedModuleRemoved(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setAppConfigV1(AppConfigV1 memory appConfig) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (appConfig.requiredResponses == 0 || appConfig.optimisticPeriod == 0) {\n            revert InterchainApp__InvalidAppConfig(appConfig.requiredResponses, appConfig.optimisticPeriod);\n        }\n        _appConfigV1 = appConfig;\n        emit AppConfigV1Set(appConfig.requiredResponses, appConfig.optimisticPeriod);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setExecutionService(address executionService) external onlyRole(IC_GOVERNOR_ROLE) {\n        _executionService = executionService;\n        emit ExecutionServiceSet(executionService);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainAppV1\n    function getAppConfigV1() external view returns (AppConfigV1 memory) {\n        return _appConfigV1;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getExecutionService() external view returns (address) {\n        return _executionService;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getInterchainClients() external view returns (address[] memory) {\n        return _interchainClients.values();\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLatestInterchainClient() external view returns (address) {\n        return _latestClient;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedApp(uint256 chainId) external view returns (bytes32) {\n        return _linkedApp[chainId];\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedAppEVM(uint256 chainId) external view returns (address linkedAppEVM) {\n        bytes32 linkedApp = _linkedApp[chainId];\n        linkedAppEVM = linkedApp.bytes32ToAddress();\n        if (linkedAppEVM.addressToBytes32() != linkedApp) {\n            revert InterchainApp__NotEVMLinkedApp(linkedApp);\n        }\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getModules() external view returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Links the remote app to the current app.\n    /// Will revert if the chainId is the same as the chainId of the local app.\n    /// Note: Should be guarded with permissions check.\n    function _linkRemoteApp(uint256 chainId, bytes32 remoteApp) internal {\n        if (chainId == block.chainid) {\n            revert InterchainApp__SameChainId(chainId);\n        }\n        if (remoteApp == 0) {\n            revert InterchainApp__AppZeroAddress();\n        }\n        _linkedApp[chainId] = remoteApp;\n        emit AppLinked(chainId, remoteApp);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal override {\n        _latestClient = client;\n    }\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal override {\n        if (allowed) {\n            _interchainClients.add(client);\n        } else {\n            _interchainClients.remove(client);\n        }\n    }\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to send the message to the linked app.\n    function _sendToLinkedApp(\n        uint256 dstChainId,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _sendInterchainMessage(dstChainId, _linkedApp[dstChainId], messageFee, encodedOptions, message);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee to send a message to the linked app on the remote chain.\n    function _getMessageFee(\n        uint256 dstChainId,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _getInterchainFee(dstChainId, encodedOptions, message);\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view override returns (bytes memory) {\n        return _appConfigV1.encodeAppConfigV1();\n    }\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view override returns (address) {\n        return _executionService;\n    }\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view override returns (address) {\n        return _latestClient;\n    }\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view override returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint256 srcChainId, bytes32 sender) internal view override returns (bool) {\n        return _linkedApp[srcChainId] == sender;\n    }\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view override returns (bool) {\n        return _interchainClients.contains(caller);\n    }\n}\n\n// contracts/apps/examples/ExampleAppV1.sol\n\ncontract ExampleAppV1 is ICAppV1 {\n    event MessageReceived(uint256 srcChainId, bytes32 sender, uint256 dbNonce, uint64 entryIndex, bytes message);\n    event MessageSent(uint256 dstChainId, uint256 dbNonce, uint64 entryIndex, bytes32 transactionId);\n\n    constructor(address admin) ICAppV1(admin) {\n        _grantRole(IC_GOVERNOR_ROLE, admin);\n    }\n\n    /// @notice Allows the Admin to withdraw the native asset from the contract.\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        Address.sendValue(payable(msg.sender), address(this).balance);\n    }\n\n    /// @notice Sends a basic message to the destination chain.\n    function sendMessage(\n        uint256 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        InterchainTxDescriptor memory desc = _sendToLinkedApp({\n            dstChainId: dstChainId,\n            messageFee: msg.value,\n            options: OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}),\n            message: message\n        });\n        emit MessageSent(dstChainId, desc.dbNonce, desc.entryIndex, desc.transactionId);\n    }\n\n    /// @notice Returns the fee required to send a message using `sendMessage`.\n    function getMessageFee(\n        uint256 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes memory message\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _getMessageFee(dstChainId, OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}), message);\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        override\n    {\n        emit MessageReceived(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"2606:2072:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;2606:2072:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"2606:2072:0:-:0;;;;;;;;","abiDefinition":[{"inputs":[{"internalType":"uint8","name":"version","type":"uint8"}],"name":"AppConfigLib__IncorrectVersion","type":"error"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"AppConfigLib__IncorrectVersion\",\"type\":\"error\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/ExampleAppV1.sol\":\"AppConfigLib\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/ExampleAppV1.sol\":{\"keccak256\":\"0x4c94807e7a2671ad6fcf49fb03cfafa6f51f6b4596f34092fba0bf17b6d482cf\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://4fabc9aa6f6891674b77809808b14ff1f2e8829de650caafa1fb3c3444a07331\",\"dweb:/ipfs/QmVzYNSfkuSkXNaFKuNY3hmkdspssruAhQx4qZuJU3Ceg9\"]}},\"version\":1}"},"hashes":{}},"solidity/ExampleAppV1.sol:Context":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/AbstractICAppEvents.sol\n\nabstract contract AbstractICAppEvents {\n    event InterchainClientAdded(address client);\n    event InterchainClientRemoved(address client);\n    event LatestClientSet(address client);\n}\n\n// contracts/events/InterchainAppV1Events.sol\n\nabstract contract InterchainAppV1Events {\n    event AppConfigV1Set(uint256 requiredResponses, uint256 optimisticPeriod);\n    event AppLinked(uint256 indexed chainId, bytes32 indexed remoteApp);\n    event ExecutionServiceSet(address executionService);\n    event TrustedModuleAdded(address module);\n    event TrustedModuleRemoved(address module);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    /// @notice Allows the Interchain Client to pass the message to the Interchain App.\n    /// @dev App is responsible for keeping track of interchain clients, and must verify the message sender.\n    /// @param srcChainId   Chain ID of the source chain, where the message was sent from.\n    /// @param sender       Sender address on the source chain, as a bytes32 value.\n    /// @param dbNonce      The Interchain DB nonce of the batch containing the message entry.\n    /// @param entryIndex   The index of the message entry within the batch.\n    /// @param message      The message being sent.\n    function appReceive(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /// @notice Returns the verification configuration of the Interchain App.\n    /// @dev This configuration is used by the Interchain Client to verify that message has been confirmed\n    /// by the Interchain Modules on the destination chain.\n    /// Note: V1 version of AppConfig includes the required responses count, and optimistic period after which\n    /// the message is considered confirmed by the module. Following versions may include additional fields.\n    /// @return appConfig    The versioned configuration of the Interchain App, encoded as bytes.\n    /// @return modules      The list of Interchain Modules that app is trusting to confirm the messages.\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    uint8 constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint8 version);\n\n    /// @notice Encodes versioned app config into a bytes format.\n    /// @param version      The version of the app config.\n    /// @param appConfig    The app config to encode.\n    function encodeVersionedAppConfig(uint8 version, bytes memory appConfig) internal pure returns (bytes memory) {\n        return abi.encode(version, appConfig);\n    }\n\n    /// @notice Decodes versioned app config from a bytes format back into a version and app config.\n    /// @param data         The versioned app config data in bytes format.\n    /// @return version     The version of the app config.\n    /// @return appConfig   The app config as bytes.\n    function decodeVersionedAppConfig(bytes memory data)\n        internal\n        pure\n        returns (uint8 version, bytes memory appConfig)\n    {\n        (version, appConfig) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return encodeVersionedAppConfig(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal pure returns (AppConfigV1 memory) {\n        (uint8 version, bytes memory appConfig) = decodeVersionedAppConfig(data);\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(appConfig, (AppConfigV1));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    uint8 constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint8 version);\n\n    /// @notice Encodes versioned options into a bytes format.\n    /// @param version      The version of the options.\n    /// @param options      The options to encode.\n    function encodeVersionedOptions(uint8 version, bytes memory options) internal pure returns (bytes memory) {\n        return abi.encode(version, options);\n    }\n\n    /// @notice Decodes versioned options from a bytes format back into a version and options.\n    /// @param data         The versioned options data in bytes format.\n    /// @return version     The version of the options.\n    /// @return options     The options as bytes.\n    function decodeVersionedOptions(bytes memory data) internal pure returns (uint8 version, bytes memory options) {\n        (version, options) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return encodeVersionedOptions(OPTIONS_V1, abi.encode(options));\n    }\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal pure returns (OptionsV1 memory) {\n        (uint8 version, bytes memory options) = decodeVersionedOptions(data);\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(options, (OptionsV1));\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/IAccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n\n// node_modules/@openzeppelin/contracts/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance \u003c amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance \u003c value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 \u0026\u0026 target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/libs/InterchainTransaction.sol\n\nstruct InterchainTransaction {\n    uint256 srcChainId;\n    bytes32 srcSender;\n    uint256 dstChainId;\n    bytes32 dstReceiver;\n    uint256 dbNonce;\n    uint64 entryIndex;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint256 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    function constructLocalTransaction(\n        address srcSender,\n        uint256 dstChainId,\n        bytes32 dstReceiver,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: block.chainid,\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(transaction);\n    }\n\n    function decodeTransaction(bytes memory encodedTx) internal pure returns (InterchainTransaction memory) {\n        return abi.decode(encodedTx, (InterchainTransaction));\n    }\n\n    function transactionId(InterchainTransaction memory transaction) internal pure returns (bytes32) {\n        return keccak256(abi.encode(transaction));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/IAccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/IAccessControlEnumerable.sol)\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n// contracts/interfaces/IInterchainAppV1.sol\n\ninterface IInterchainAppV1 is IInterchainApp {\n    error InterchainApp__AppZeroAddress();\n    error InterchainApp__InvalidAppConfig(uint256 requiredResponses, uint256 optimisticPeriod);\n    error InterchainApp__ModuleAlreadyAdded(address module);\n    error InterchainApp__ModuleNotAdded(address module);\n    error InterchainApp__ModuleZeroAddress();\n    error InterchainApp__NotEVMLinkedApp(bytes32 linkedApp);\n\n    /// @notice Allows the owner to add the interchain client to the allowed clients set,\n    /// and optionally set the latest client to this one.\n    /// Note: only the allowed clients can send messages to this app.\n    /// Note: the latest client is used for sending messages from this app.\n    /// @param client       The address of the interchain client to add.\n    /// @param updateLatest Whether to set the latest client to this one.\n    function addInterchainClient(address client, bool updateLatest) external;\n\n    /// @notice Allows the owner to remove the interchain client from the allowed clients set.\n    /// If the client is the latest client, the latest client is set to the zero address.\n    /// @param client       The address of the interchain client to remove.\n    function removeInterchainClient(address client) external;\n\n    /// @notice Allows the owner to set the address of the latest interchain client.\n    /// @dev The new latest client must be an allowed client or zero address.\n    /// Setting the client to zero address effectively pauses the app ability to send messages,\n    /// while allowing to receive them.\n    /// @param client       The address of the latest interchain client.\n    function setLatestInterchainClient(address client) external;\n\n    /// @notice Allows the owner to link the remote app for the given chain ID.\n    /// - This address will be used as the receiver for the messages sent from this chain.\n    /// - This address will be the only trusted sender for the messages sent to this chain.\n    /// @param chainId      The remote chain ID.\n    /// @param remoteApp    The address of the remote app to link.\n    function linkRemoteApp(uint256 chainId, bytes32 remoteApp) external;\n\n    /// @notice Thin wrapper for `linkRemoteApp` to accept EVM address as a parameter.\n    function linkRemoteAppEVM(uint256 chainId, address remoteApp) external;\n\n    /// @notice Allows the owner to add the module to the trusted modules set.\n    /// - This set of modules will be used to verify both sent and received messages.\n    function addTrustedModule(address module) external;\n\n    /// @notice Allows the owner to remove the module from the trusted modules set.\n    function removeTrustedModule(address module) external;\n\n    /// @notice Allows the owner to set the app config for the current app. App config includes:\n    /// - requiredResponses: the number of module responses required for accepting the message\n    /// - optimisticPeriod: the minimum time after which the module responses are considered final\n    function setAppConfigV1(AppConfigV1 memory appConfig) external;\n\n    /// @notice Allows the owner to set the address of the Execution Service.\n    /// This address will be used to request execution of the messages sent from this chain,\n    /// by supplying the Service's execution fee.\n    function setExecutionService(address executionService) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Returns the app config for the current app: requiredResponses and optimisticPeriod.\n    function getAppConfigV1() external view returns (AppConfigV1 memory);\n\n    /// @notice Returns the address of the Execution Service used by this app for sending messages.\n    function getExecutionService() external view returns (address);\n\n    /// @notice Returns the list of Interchain Clients allowed to send messages to this app.\n    function getInterchainClients() external view returns (address[] memory);\n\n    /// @notice Returns the address of the latest interchain client.\n    /// This address is used for sending messages from this app.\n    function getLatestInterchainClient() external view returns (address);\n\n    /// @notice Returns the linked app address (as bytes32) for the given chain ID.\n    function getLinkedApp(uint256 chainId) external view returns (bytes32);\n\n    /// @notice Thin wrapper for `getLinkedApp` to return the linked app address as EVM address.\n    /// @dev Will revert if the linked app address is not an EVM address.\n    function getLinkedAppEVM(uint256 chainId) external view returns (address);\n\n    /// @notice Returns the list of Interchain Modules trusted by this app.\n    /// This set of modules will be used to verify both sent and received messages.\n    function getModules() external view returns (address[] memory);\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint256 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__NoLinkedClient(uint256 chainId);\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint256 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint256 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint256 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint256 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint256 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param message              The message being sent.\n    function getInterchainFee(\n        uint256 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint256 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint256 chainId) external view returns (address);\n}\n\n// node_modules/@openzeppelin/contracts/access/AccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account =\u003e bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role =\u003e RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n// contracts/apps/AbstractICApp.sol\n\nabstract contract AbstractICApp is AbstractICAppEvents, IInterchainApp {\n    using TypeCasts for address;\n\n    error InterchainApp__AlreadyLatestClient(address client);\n    error InterchainApp__BalanceTooLow(uint256 actual, uint256 required);\n    error InterchainApp__ClientAlreadyAdded(address client);\n    error InterchainApp__InterchainClientZeroAddress();\n    error InterchainApp__NotInterchainClient(address account);\n    error InterchainApp__ReceiverNotSet(uint256 chainId);\n    error InterchainApp__SameChainId(uint256 chainId);\n    error InterchainApp__SenderNotAllowed(uint256 srcChainId, bytes32 sender);\n\n    /// @inheritdoc IInterchainApp\n    function appReceive(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        if (!_isInterchainClient(msg.sender)) {\n            revert InterchainApp__NotInterchainClient(msg.sender);\n        }\n        if (srcChainId == block.chainid) {\n            revert InterchainApp__SameChainId(srcChainId);\n        }\n        if (!_isAllowedSender(srcChainId, sender)) {\n            revert InterchainApp__SenderNotAllowed(srcChainId, sender);\n        }\n        _receiveMessage(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n\n    /// @inheritdoc IInterchainApp\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules) {\n        appConfig = _getAppConfig();\n        modules = _getModules();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Performs necessary checks and adds an Interchain Client.\n    /// Optionally sets the latest client to this one.\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _addClient(address client, bool updateLatest) internal {\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (_isInterchainClient(client)) {\n            revert InterchainApp__ClientAlreadyAdded(client);\n        }\n        _toggleClientState(client, true);\n        emit InterchainClientAdded(client);\n        if (updateLatest) {\n            _setLatestClient(client);\n        }\n    }\n\n    /// @dev Performs necessary checks and removes an Interchain Client. If this client is the latest one,\n    /// the latest client is set to zero address (effectively pausing the app ability to send messages).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _removeClient(address client) internal {\n        if (!_isInterchainClient(client)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        _toggleClientState(client, false);\n        emit InterchainClientRemoved(client);\n        if (client == _getLatestClient()) {\n            _setLatestClient(address(0));\n        }\n    }\n\n    /// @dev Sets the latest Interchain Client to one of the allowed clients. Setting the client to zero address\n    /// is allowed and effectively pauses the app ability to send messages (but still allows to receive them).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _setLatestClient(address client) internal {\n        // New latest client must be an allowed client or zero address.\n        if (!_isInterchainClient(client) \u0026\u0026 client != address(0)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        if (client == _getLatestClient()) {\n            revert InterchainApp__AlreadyLatestClient(client);\n        }\n        _storeLatestClient(client);\n        emit LatestClientSet(client);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal virtual;\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal virtual;\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to accept EVM address as a parameter.\n    function _sendInterchainMessageEVM(\n        uint256 dstChainId,\n        address receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _sendInterchainMessage(dstChainId, receiver.addressToBytes32(), messageFee, options, message);\n    }\n\n    /// @dev Performs necessary checks and sends an interchain message.\n    function _sendInterchainMessage(\n        uint256 dstChainId,\n        bytes32 receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (dstChainId == block.chainid) {\n            revert InterchainApp__SameChainId(dstChainId);\n        }\n        if (receiver == 0) {\n            revert InterchainApp__ReceiverNotSet(dstChainId);\n        }\n        if (address(this).balance \u003c messageFee) {\n            revert InterchainApp__BalanceTooLow({actual: address(this).balance, required: messageFee});\n        }\n        return IInterchainClientV1(client).interchainSend{value: messageFee}(\n            dstChainId, receiver, _getExecutionService(), _getModules(), options, message\n        );\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        virtual;\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee for sending an Interchain message.\n    function _getInterchainFee(\n        uint256 dstChainId,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        return IInterchainClientV1(client).getInterchainFee(\n            dstChainId, _getExecutionService(), _getModules(), options, message\n        );\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view virtual returns (bytes memory);\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view virtual returns (address);\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view virtual returns (address);\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view virtual returns (address[] memory);\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint256 srcChainId, bytes32 sender) internal view virtual returns (bool);\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view virtual returns (bool);\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/AccessControlEnumerable.sol)\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 role =\u003e EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {AccessControl-_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool granted = super._grantRole(role, account);\n        if (granted) {\n            _roleMembers[role].add(account);\n        }\n        return granted;\n    }\n\n    /**\n     * @dev Overload {AccessControl-_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool revoked = super._revokeRole(role, account);\n        if (revoked) {\n            _roleMembers[role].remove(account);\n        }\n        return revoked;\n    }\n}\n\n// contracts/apps/ICAppV1.sol\n\nabstract contract ICAppV1 is AbstractICApp, AccessControlEnumerable, InterchainAppV1Events, IInterchainAppV1 {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Role to manage the Interchain setup of the app.\n    bytes32 public constant IC_GOVERNOR_ROLE = keccak256(\"IC_GOVERNOR_ROLE\");\n\n    /// @dev Address of the latest Interchain Client, used for sending messages.\n    address private _latestClient;\n\n    /// @dev Required responses and optimistic period for the module responses.\n    AppConfigV1 private _appConfigV1;\n    /// @dev Address of the linked app deployed on the remote chain.\n    mapping(uint256 chainId =\u003e bytes32 remoteApp) private _linkedApp;\n    /// @dev Interchain Clients allowed to send messages to this app.\n    EnumerableSet.AddressSet private _interchainClients;\n    /// @dev Trusted Interchain modules.\n    EnumerableSet.AddressSet private _trustedModules;\n    /// @dev Execution Service to use for sending messages.\n    address private _executionService;\n\n    constructor(address admin) {\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addInterchainClient(address client, bool updateLatest) external onlyRole(IC_GOVERNOR_ROLE) {\n        _addClient(client, updateLatest);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _removeClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setLatestInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _setLatestClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteApp(uint256 chainId, bytes32 remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteAppEVM(uint256 chainId, address remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp.addressToBytes32());\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (module == address(0)) {\n            revert InterchainApp__ModuleZeroAddress();\n        }\n        bool added = _trustedModules.add(module);\n        if (!added) {\n            revert InterchainApp__ModuleAlreadyAdded(module);\n        }\n        emit TrustedModuleAdded(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        bool removed = _trustedModules.remove(module);\n        if (!removed) {\n            revert InterchainApp__ModuleNotAdded(module);\n        }\n        emit TrustedModuleRemoved(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setAppConfigV1(AppConfigV1 memory appConfig) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (appConfig.requiredResponses == 0 || appConfig.optimisticPeriod == 0) {\n            revert InterchainApp__InvalidAppConfig(appConfig.requiredResponses, appConfig.optimisticPeriod);\n        }\n        _appConfigV1 = appConfig;\n        emit AppConfigV1Set(appConfig.requiredResponses, appConfig.optimisticPeriod);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setExecutionService(address executionService) external onlyRole(IC_GOVERNOR_ROLE) {\n        _executionService = executionService;\n        emit ExecutionServiceSet(executionService);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainAppV1\n    function getAppConfigV1() external view returns (AppConfigV1 memory) {\n        return _appConfigV1;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getExecutionService() external view returns (address) {\n        return _executionService;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getInterchainClients() external view returns (address[] memory) {\n        return _interchainClients.values();\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLatestInterchainClient() external view returns (address) {\n        return _latestClient;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedApp(uint256 chainId) external view returns (bytes32) {\n        return _linkedApp[chainId];\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedAppEVM(uint256 chainId) external view returns (address linkedAppEVM) {\n        bytes32 linkedApp = _linkedApp[chainId];\n        linkedAppEVM = linkedApp.bytes32ToAddress();\n        if (linkedAppEVM.addressToBytes32() != linkedApp) {\n            revert InterchainApp__NotEVMLinkedApp(linkedApp);\n        }\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getModules() external view returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Links the remote app to the current app.\n    /// Will revert if the chainId is the same as the chainId of the local app.\n    /// Note: Should be guarded with permissions check.\n    function _linkRemoteApp(uint256 chainId, bytes32 remoteApp) internal {\n        if (chainId == block.chainid) {\n            revert InterchainApp__SameChainId(chainId);\n        }\n        if (remoteApp == 0) {\n            revert InterchainApp__AppZeroAddress();\n        }\n        _linkedApp[chainId] = remoteApp;\n        emit AppLinked(chainId, remoteApp);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal override {\n        _latestClient = client;\n    }\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal override {\n        if (allowed) {\n            _interchainClients.add(client);\n        } else {\n            _interchainClients.remove(client);\n        }\n    }\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to send the message to the linked app.\n    function _sendToLinkedApp(\n        uint256 dstChainId,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _sendInterchainMessage(dstChainId, _linkedApp[dstChainId], messageFee, encodedOptions, message);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee to send a message to the linked app on the remote chain.\n    function _getMessageFee(\n        uint256 dstChainId,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _getInterchainFee(dstChainId, encodedOptions, message);\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view override returns (bytes memory) {\n        return _appConfigV1.encodeAppConfigV1();\n    }\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view override returns (address) {\n        return _executionService;\n    }\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view override returns (address) {\n        return _latestClient;\n    }\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view override returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint256 srcChainId, bytes32 sender) internal view override returns (bool) {\n        return _linkedApp[srcChainId] == sender;\n    }\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view override returns (bool) {\n        return _interchainClients.contains(caller);\n    }\n}\n\n// contracts/apps/examples/ExampleAppV1.sol\n\ncontract ExampleAppV1 is ICAppV1 {\n    event MessageReceived(uint256 srcChainId, bytes32 sender, uint256 dbNonce, uint64 entryIndex, bytes message);\n    event MessageSent(uint256 dstChainId, uint256 dbNonce, uint64 entryIndex, bytes32 transactionId);\n\n    constructor(address admin) ICAppV1(admin) {\n        _grantRole(IC_GOVERNOR_ROLE, admin);\n    }\n\n    /// @notice Allows the Admin to withdraw the native asset from the contract.\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        Address.sendValue(payable(msg.sender), address(this).balance);\n    }\n\n    /// @notice Sends a basic message to the destination chain.\n    function sendMessage(\n        uint256 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        InterchainTxDescriptor memory desc = _sendToLinkedApp({\n            dstChainId: dstChainId,\n            messageFee: msg.value,\n            options: OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}),\n            message: message\n        });\n        emit MessageSent(dstChainId, desc.dbNonce, desc.entryIndex, desc.transactionId);\n    }\n\n    /// @notice Returns the fee required to send a message using `sendMessage`.\n    function getMessageFee(\n        uint256 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes memory message\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _getMessageFee(dstChainId, OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}), message);\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        override\n    {\n        emit MessageReceived(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"details":"Provides information about the current execution context, including the sender of the transaction and its data. While these are generally available via msg.sender and msg.data, they should not be accessed in such a direct manner, since when dealing with meta-transactions the account sending and paying for execution may not be the actual sender (as far as an application is concerned). This contract is only required for intermediate, library-like contracts.","kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"details\":\"Provides information about the current execution context, including the sender of the transaction and its data. While these are generally available via msg.sender and msg.data, they should not be accessed in such a direct manner, since when dealing with meta-transactions the account sending and paying for execution may not be the actual sender (as far as an application is concerned). This contract is only required for intermediate, library-like contracts.\",\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/ExampleAppV1.sol\":\"Context\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/ExampleAppV1.sol\":{\"keccak256\":\"0x4c94807e7a2671ad6fcf49fb03cfafa6f51f6b4596f34092fba0bf17b6d482cf\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://4fabc9aa6f6891674b77809808b14ff1f2e8829de650caafa1fb3c3444a07331\",\"dweb:/ipfs/QmVzYNSfkuSkXNaFKuNY3hmkdspssruAhQx4qZuJU3Ceg9\"]}},\"version\":1}"},"hashes":{}},"solidity/ExampleAppV1.sol:ERC165":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/AbstractICAppEvents.sol\n\nabstract contract AbstractICAppEvents {\n    event InterchainClientAdded(address client);\n    event InterchainClientRemoved(address client);\n    event LatestClientSet(address client);\n}\n\n// contracts/events/InterchainAppV1Events.sol\n\nabstract contract InterchainAppV1Events {\n    event AppConfigV1Set(uint256 requiredResponses, uint256 optimisticPeriod);\n    event AppLinked(uint256 indexed chainId, bytes32 indexed remoteApp);\n    event ExecutionServiceSet(address executionService);\n    event TrustedModuleAdded(address module);\n    event TrustedModuleRemoved(address module);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    /// @notice Allows the Interchain Client to pass the message to the Interchain App.\n    /// @dev App is responsible for keeping track of interchain clients, and must verify the message sender.\n    /// @param srcChainId   Chain ID of the source chain, where the message was sent from.\n    /// @param sender       Sender address on the source chain, as a bytes32 value.\n    /// @param dbNonce      The Interchain DB nonce of the batch containing the message entry.\n    /// @param entryIndex   The index of the message entry within the batch.\n    /// @param message      The message being sent.\n    function appReceive(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /// @notice Returns the verification configuration of the Interchain App.\n    /// @dev This configuration is used by the Interchain Client to verify that message has been confirmed\n    /// by the Interchain Modules on the destination chain.\n    /// Note: V1 version of AppConfig includes the required responses count, and optimistic period after which\n    /// the message is considered confirmed by the module. Following versions may include additional fields.\n    /// @return appConfig    The versioned configuration of the Interchain App, encoded as bytes.\n    /// @return modules      The list of Interchain Modules that app is trusting to confirm the messages.\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    uint8 constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint8 version);\n\n    /// @notice Encodes versioned app config into a bytes format.\n    /// @param version      The version of the app config.\n    /// @param appConfig    The app config to encode.\n    function encodeVersionedAppConfig(uint8 version, bytes memory appConfig) internal pure returns (bytes memory) {\n        return abi.encode(version, appConfig);\n    }\n\n    /// @notice Decodes versioned app config from a bytes format back into a version and app config.\n    /// @param data         The versioned app config data in bytes format.\n    /// @return version     The version of the app config.\n    /// @return appConfig   The app config as bytes.\n    function decodeVersionedAppConfig(bytes memory data)\n        internal\n        pure\n        returns (uint8 version, bytes memory appConfig)\n    {\n        (version, appConfig) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return encodeVersionedAppConfig(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal pure returns (AppConfigV1 memory) {\n        (uint8 version, bytes memory appConfig) = decodeVersionedAppConfig(data);\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(appConfig, (AppConfigV1));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    uint8 constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint8 version);\n\n    /// @notice Encodes versioned options into a bytes format.\n    /// @param version      The version of the options.\n    /// @param options      The options to encode.\n    function encodeVersionedOptions(uint8 version, bytes memory options) internal pure returns (bytes memory) {\n        return abi.encode(version, options);\n    }\n\n    /// @notice Decodes versioned options from a bytes format back into a version and options.\n    /// @param data         The versioned options data in bytes format.\n    /// @return version     The version of the options.\n    /// @return options     The options as bytes.\n    function decodeVersionedOptions(bytes memory data) internal pure returns (uint8 version, bytes memory options) {\n        (version, options) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return encodeVersionedOptions(OPTIONS_V1, abi.encode(options));\n    }\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal pure returns (OptionsV1 memory) {\n        (uint8 version, bytes memory options) = decodeVersionedOptions(data);\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(options, (OptionsV1));\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/IAccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n\n// node_modules/@openzeppelin/contracts/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance \u003c amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance \u003c value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 \u0026\u0026 target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/libs/InterchainTransaction.sol\n\nstruct InterchainTransaction {\n    uint256 srcChainId;\n    bytes32 srcSender;\n    uint256 dstChainId;\n    bytes32 dstReceiver;\n    uint256 dbNonce;\n    uint64 entryIndex;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint256 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    function constructLocalTransaction(\n        address srcSender,\n        uint256 dstChainId,\n        bytes32 dstReceiver,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: block.chainid,\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(transaction);\n    }\n\n    function decodeTransaction(bytes memory encodedTx) internal pure returns (InterchainTransaction memory) {\n        return abi.decode(encodedTx, (InterchainTransaction));\n    }\n\n    function transactionId(InterchainTransaction memory transaction) internal pure returns (bytes32) {\n        return keccak256(abi.encode(transaction));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/IAccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/IAccessControlEnumerable.sol)\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n// contracts/interfaces/IInterchainAppV1.sol\n\ninterface IInterchainAppV1 is IInterchainApp {\n    error InterchainApp__AppZeroAddress();\n    error InterchainApp__InvalidAppConfig(uint256 requiredResponses, uint256 optimisticPeriod);\n    error InterchainApp__ModuleAlreadyAdded(address module);\n    error InterchainApp__ModuleNotAdded(address module);\n    error InterchainApp__ModuleZeroAddress();\n    error InterchainApp__NotEVMLinkedApp(bytes32 linkedApp);\n\n    /// @notice Allows the owner to add the interchain client to the allowed clients set,\n    /// and optionally set the latest client to this one.\n    /// Note: only the allowed clients can send messages to this app.\n    /// Note: the latest client is used for sending messages from this app.\n    /// @param client       The address of the interchain client to add.\n    /// @param updateLatest Whether to set the latest client to this one.\n    function addInterchainClient(address client, bool updateLatest) external;\n\n    /// @notice Allows the owner to remove the interchain client from the allowed clients set.\n    /// If the client is the latest client, the latest client is set to the zero address.\n    /// @param client       The address of the interchain client to remove.\n    function removeInterchainClient(address client) external;\n\n    /// @notice Allows the owner to set the address of the latest interchain client.\n    /// @dev The new latest client must be an allowed client or zero address.\n    /// Setting the client to zero address effectively pauses the app ability to send messages,\n    /// while allowing to receive them.\n    /// @param client       The address of the latest interchain client.\n    function setLatestInterchainClient(address client) external;\n\n    /// @notice Allows the owner to link the remote app for the given chain ID.\n    /// - This address will be used as the receiver for the messages sent from this chain.\n    /// - This address will be the only trusted sender for the messages sent to this chain.\n    /// @param chainId      The remote chain ID.\n    /// @param remoteApp    The address of the remote app to link.\n    function linkRemoteApp(uint256 chainId, bytes32 remoteApp) external;\n\n    /// @notice Thin wrapper for `linkRemoteApp` to accept EVM address as a parameter.\n    function linkRemoteAppEVM(uint256 chainId, address remoteApp) external;\n\n    /// @notice Allows the owner to add the module to the trusted modules set.\n    /// - This set of modules will be used to verify both sent and received messages.\n    function addTrustedModule(address module) external;\n\n    /// @notice Allows the owner to remove the module from the trusted modules set.\n    function removeTrustedModule(address module) external;\n\n    /// @notice Allows the owner to set the app config for the current app. App config includes:\n    /// - requiredResponses: the number of module responses required for accepting the message\n    /// - optimisticPeriod: the minimum time after which the module responses are considered final\n    function setAppConfigV1(AppConfigV1 memory appConfig) external;\n\n    /// @notice Allows the owner to set the address of the Execution Service.\n    /// This address will be used to request execution of the messages sent from this chain,\n    /// by supplying the Service's execution fee.\n    function setExecutionService(address executionService) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Returns the app config for the current app: requiredResponses and optimisticPeriod.\n    function getAppConfigV1() external view returns (AppConfigV1 memory);\n\n    /// @notice Returns the address of the Execution Service used by this app for sending messages.\n    function getExecutionService() external view returns (address);\n\n    /// @notice Returns the list of Interchain Clients allowed to send messages to this app.\n    function getInterchainClients() external view returns (address[] memory);\n\n    /// @notice Returns the address of the latest interchain client.\n    /// This address is used for sending messages from this app.\n    function getLatestInterchainClient() external view returns (address);\n\n    /// @notice Returns the linked app address (as bytes32) for the given chain ID.\n    function getLinkedApp(uint256 chainId) external view returns (bytes32);\n\n    /// @notice Thin wrapper for `getLinkedApp` to return the linked app address as EVM address.\n    /// @dev Will revert if the linked app address is not an EVM address.\n    function getLinkedAppEVM(uint256 chainId) external view returns (address);\n\n    /// @notice Returns the list of Interchain Modules trusted by this app.\n    /// This set of modules will be used to verify both sent and received messages.\n    function getModules() external view returns (address[] memory);\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint256 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__NoLinkedClient(uint256 chainId);\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint256 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint256 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint256 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint256 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint256 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param message              The message being sent.\n    function getInterchainFee(\n        uint256 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint256 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint256 chainId) external view returns (address);\n}\n\n// node_modules/@openzeppelin/contracts/access/AccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account =\u003e bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role =\u003e RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n// contracts/apps/AbstractICApp.sol\n\nabstract contract AbstractICApp is AbstractICAppEvents, IInterchainApp {\n    using TypeCasts for address;\n\n    error InterchainApp__AlreadyLatestClient(address client);\n    error InterchainApp__BalanceTooLow(uint256 actual, uint256 required);\n    error InterchainApp__ClientAlreadyAdded(address client);\n    error InterchainApp__InterchainClientZeroAddress();\n    error InterchainApp__NotInterchainClient(address account);\n    error InterchainApp__ReceiverNotSet(uint256 chainId);\n    error InterchainApp__SameChainId(uint256 chainId);\n    error InterchainApp__SenderNotAllowed(uint256 srcChainId, bytes32 sender);\n\n    /// @inheritdoc IInterchainApp\n    function appReceive(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        if (!_isInterchainClient(msg.sender)) {\n            revert InterchainApp__NotInterchainClient(msg.sender);\n        }\n        if (srcChainId == block.chainid) {\n            revert InterchainApp__SameChainId(srcChainId);\n        }\n        if (!_isAllowedSender(srcChainId, sender)) {\n            revert InterchainApp__SenderNotAllowed(srcChainId, sender);\n        }\n        _receiveMessage(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n\n    /// @inheritdoc IInterchainApp\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules) {\n        appConfig = _getAppConfig();\n        modules = _getModules();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Performs necessary checks and adds an Interchain Client.\n    /// Optionally sets the latest client to this one.\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _addClient(address client, bool updateLatest) internal {\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (_isInterchainClient(client)) {\n            revert InterchainApp__ClientAlreadyAdded(client);\n        }\n        _toggleClientState(client, true);\n        emit InterchainClientAdded(client);\n        if (updateLatest) {\n            _setLatestClient(client);\n        }\n    }\n\n    /// @dev Performs necessary checks and removes an Interchain Client. If this client is the latest one,\n    /// the latest client is set to zero address (effectively pausing the app ability to send messages).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _removeClient(address client) internal {\n        if (!_isInterchainClient(client)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        _toggleClientState(client, false);\n        emit InterchainClientRemoved(client);\n        if (client == _getLatestClient()) {\n            _setLatestClient(address(0));\n        }\n    }\n\n    /// @dev Sets the latest Interchain Client to one of the allowed clients. Setting the client to zero address\n    /// is allowed and effectively pauses the app ability to send messages (but still allows to receive them).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _setLatestClient(address client) internal {\n        // New latest client must be an allowed client or zero address.\n        if (!_isInterchainClient(client) \u0026\u0026 client != address(0)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        if (client == _getLatestClient()) {\n            revert InterchainApp__AlreadyLatestClient(client);\n        }\n        _storeLatestClient(client);\n        emit LatestClientSet(client);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal virtual;\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal virtual;\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to accept EVM address as a parameter.\n    function _sendInterchainMessageEVM(\n        uint256 dstChainId,\n        address receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _sendInterchainMessage(dstChainId, receiver.addressToBytes32(), messageFee, options, message);\n    }\n\n    /// @dev Performs necessary checks and sends an interchain message.\n    function _sendInterchainMessage(\n        uint256 dstChainId,\n        bytes32 receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (dstChainId == block.chainid) {\n            revert InterchainApp__SameChainId(dstChainId);\n        }\n        if (receiver == 0) {\n            revert InterchainApp__ReceiverNotSet(dstChainId);\n        }\n        if (address(this).balance \u003c messageFee) {\n            revert InterchainApp__BalanceTooLow({actual: address(this).balance, required: messageFee});\n        }\n        return IInterchainClientV1(client).interchainSend{value: messageFee}(\n            dstChainId, receiver, _getExecutionService(), _getModules(), options, message\n        );\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        virtual;\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee for sending an Interchain message.\n    function _getInterchainFee(\n        uint256 dstChainId,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        return IInterchainClientV1(client).getInterchainFee(\n            dstChainId, _getExecutionService(), _getModules(), options, message\n        );\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view virtual returns (bytes memory);\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view virtual returns (address);\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view virtual returns (address);\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view virtual returns (address[] memory);\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint256 srcChainId, bytes32 sender) internal view virtual returns (bool);\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view virtual returns (bool);\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/AccessControlEnumerable.sol)\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 role =\u003e EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {AccessControl-_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool granted = super._grantRole(role, account);\n        if (granted) {\n            _roleMembers[role].add(account);\n        }\n        return granted;\n    }\n\n    /**\n     * @dev Overload {AccessControl-_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool revoked = super._revokeRole(role, account);\n        if (revoked) {\n            _roleMembers[role].remove(account);\n        }\n        return revoked;\n    }\n}\n\n// contracts/apps/ICAppV1.sol\n\nabstract contract ICAppV1 is AbstractICApp, AccessControlEnumerable, InterchainAppV1Events, IInterchainAppV1 {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Role to manage the Interchain setup of the app.\n    bytes32 public constant IC_GOVERNOR_ROLE = keccak256(\"IC_GOVERNOR_ROLE\");\n\n    /// @dev Address of the latest Interchain Client, used for sending messages.\n    address private _latestClient;\n\n    /// @dev Required responses and optimistic period for the module responses.\n    AppConfigV1 private _appConfigV1;\n    /// @dev Address of the linked app deployed on the remote chain.\n    mapping(uint256 chainId =\u003e bytes32 remoteApp) private _linkedApp;\n    /// @dev Interchain Clients allowed to send messages to this app.\n    EnumerableSet.AddressSet private _interchainClients;\n    /// @dev Trusted Interchain modules.\n    EnumerableSet.AddressSet private _trustedModules;\n    /// @dev Execution Service to use for sending messages.\n    address private _executionService;\n\n    constructor(address admin) {\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addInterchainClient(address client, bool updateLatest) external onlyRole(IC_GOVERNOR_ROLE) {\n        _addClient(client, updateLatest);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _removeClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setLatestInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _setLatestClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteApp(uint256 chainId, bytes32 remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteAppEVM(uint256 chainId, address remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp.addressToBytes32());\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (module == address(0)) {\n            revert InterchainApp__ModuleZeroAddress();\n        }\n        bool added = _trustedModules.add(module);\n        if (!added) {\n            revert InterchainApp__ModuleAlreadyAdded(module);\n        }\n        emit TrustedModuleAdded(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        bool removed = _trustedModules.remove(module);\n        if (!removed) {\n            revert InterchainApp__ModuleNotAdded(module);\n        }\n        emit TrustedModuleRemoved(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setAppConfigV1(AppConfigV1 memory appConfig) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (appConfig.requiredResponses == 0 || appConfig.optimisticPeriod == 0) {\n            revert InterchainApp__InvalidAppConfig(appConfig.requiredResponses, appConfig.optimisticPeriod);\n        }\n        _appConfigV1 = appConfig;\n        emit AppConfigV1Set(appConfig.requiredResponses, appConfig.optimisticPeriod);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setExecutionService(address executionService) external onlyRole(IC_GOVERNOR_ROLE) {\n        _executionService = executionService;\n        emit ExecutionServiceSet(executionService);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainAppV1\n    function getAppConfigV1() external view returns (AppConfigV1 memory) {\n        return _appConfigV1;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getExecutionService() external view returns (address) {\n        return _executionService;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getInterchainClients() external view returns (address[] memory) {\n        return _interchainClients.values();\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLatestInterchainClient() external view returns (address) {\n        return _latestClient;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedApp(uint256 chainId) external view returns (bytes32) {\n        return _linkedApp[chainId];\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedAppEVM(uint256 chainId) external view returns (address linkedAppEVM) {\n        bytes32 linkedApp = _linkedApp[chainId];\n        linkedAppEVM = linkedApp.bytes32ToAddress();\n        if (linkedAppEVM.addressToBytes32() != linkedApp) {\n            revert InterchainApp__NotEVMLinkedApp(linkedApp);\n        }\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getModules() external view returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Links the remote app to the current app.\n    /// Will revert if the chainId is the same as the chainId of the local app.\n    /// Note: Should be guarded with permissions check.\n    function _linkRemoteApp(uint256 chainId, bytes32 remoteApp) internal {\n        if (chainId == block.chainid) {\n            revert InterchainApp__SameChainId(chainId);\n        }\n        if (remoteApp == 0) {\n            revert InterchainApp__AppZeroAddress();\n        }\n        _linkedApp[chainId] = remoteApp;\n        emit AppLinked(chainId, remoteApp);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal override {\n        _latestClient = client;\n    }\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal override {\n        if (allowed) {\n            _interchainClients.add(client);\n        } else {\n            _interchainClients.remove(client);\n        }\n    }\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to send the message to the linked app.\n    function _sendToLinkedApp(\n        uint256 dstChainId,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _sendInterchainMessage(dstChainId, _linkedApp[dstChainId], messageFee, encodedOptions, message);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee to send a message to the linked app on the remote chain.\n    function _getMessageFee(\n        uint256 dstChainId,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _getInterchainFee(dstChainId, encodedOptions, message);\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view override returns (bytes memory) {\n        return _appConfigV1.encodeAppConfigV1();\n    }\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view override returns (address) {\n        return _executionService;\n    }\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view override returns (address) {\n        return _latestClient;\n    }\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view override returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint256 srcChainId, bytes32 sender) internal view override returns (bool) {\n        return _linkedApp[srcChainId] == sender;\n    }\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view override returns (bool) {\n        return _interchainClients.contains(caller);\n    }\n}\n\n// contracts/apps/examples/ExampleAppV1.sol\n\ncontract ExampleAppV1 is ICAppV1 {\n    event MessageReceived(uint256 srcChainId, bytes32 sender, uint256 dbNonce, uint64 entryIndex, bytes message);\n    event MessageSent(uint256 dstChainId, uint256 dbNonce, uint64 entryIndex, bytes32 transactionId);\n\n    constructor(address admin) ICAppV1(admin) {\n        _grantRole(IC_GOVERNOR_ROLE, admin);\n    }\n\n    /// @notice Allows the Admin to withdraw the native asset from the contract.\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        Address.sendValue(payable(msg.sender), address(this).balance);\n    }\n\n    /// @notice Sends a basic message to the destination chain.\n    function sendMessage(\n        uint256 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        InterchainTxDescriptor memory desc = _sendToLinkedApp({\n            dstChainId: dstChainId,\n            messageFee: msg.value,\n            options: OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}),\n            message: message\n        });\n        emit MessageSent(dstChainId, desc.dbNonce, desc.entryIndex, desc.transactionId);\n    }\n\n    /// @notice Returns the fee required to send a message using `sendMessage`.\n    function getMessageFee(\n        uint256 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes memory message\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _getMessageFee(dstChainId, OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}), message);\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        override\n    {\n        emit MessageReceived(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"bytes4","name":"interfaceId","type":"bytes4"}],"name":"supportsInterface","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"details":"Implementation of the {IERC165} interface. Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check for the additional interface id that will be supported. For example: ```solidity function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId); } ```","kind":"dev","methods":{"supportsInterface(bytes4)":{"details":"See {IERC165-supportsInterface}."}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Implementation of the {IERC165} interface. Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check for the additional interface id that will be supported. For example: ```solidity function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId); } ```\",\"kind\":\"dev\",\"methods\":{\"supportsInterface(bytes4)\":{\"details\":\"See {IERC165-supportsInterface}.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/ExampleAppV1.sol\":\"ERC165\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/ExampleAppV1.sol\":{\"keccak256\":\"0x4c94807e7a2671ad6fcf49fb03cfafa6f51f6b4596f34092fba0bf17b6d482cf\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://4fabc9aa6f6891674b77809808b14ff1f2e8829de650caafa1fb3c3444a07331\",\"dweb:/ipfs/QmVzYNSfkuSkXNaFKuNY3hmkdspssruAhQx4qZuJU3Ceg9\"]}},\"version\":1}"},"hashes":{"supportsInterface(bytes4)":"01ffc9a7"}},"solidity/ExampleAppV1.sol:EnumerableSet":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212207e2c5ba71758553dc5e10715fb7c8fa98de678459543a8f43cced53020d8574764736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212207e2c5ba71758553dc5e10715fb7c8fa98de678459543a8f43cced53020d8574764736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/AbstractICAppEvents.sol\n\nabstract contract AbstractICAppEvents {\n    event InterchainClientAdded(address client);\n    event InterchainClientRemoved(address client);\n    event LatestClientSet(address client);\n}\n\n// contracts/events/InterchainAppV1Events.sol\n\nabstract contract InterchainAppV1Events {\n    event AppConfigV1Set(uint256 requiredResponses, uint256 optimisticPeriod);\n    event AppLinked(uint256 indexed chainId, bytes32 indexed remoteApp);\n    event ExecutionServiceSet(address executionService);\n    event TrustedModuleAdded(address module);\n    event TrustedModuleRemoved(address module);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    /// @notice Allows the Interchain Client to pass the message to the Interchain App.\n    /// @dev App is responsible for keeping track of interchain clients, and must verify the message sender.\n    /// @param srcChainId   Chain ID of the source chain, where the message was sent from.\n    /// @param sender       Sender address on the source chain, as a bytes32 value.\n    /// @param dbNonce      The Interchain DB nonce of the batch containing the message entry.\n    /// @param entryIndex   The index of the message entry within the batch.\n    /// @param message      The message being sent.\n    function appReceive(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /// @notice Returns the verification configuration of the Interchain App.\n    /// @dev This configuration is used by the Interchain Client to verify that message has been confirmed\n    /// by the Interchain Modules on the destination chain.\n    /// Note: V1 version of AppConfig includes the required responses count, and optimistic period after which\n    /// the message is considered confirmed by the module. Following versions may include additional fields.\n    /// @return appConfig    The versioned configuration of the Interchain App, encoded as bytes.\n    /// @return modules      The list of Interchain Modules that app is trusting to confirm the messages.\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    uint8 constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint8 version);\n\n    /// @notice Encodes versioned app config into a bytes format.\n    /// @param version      The version of the app config.\n    /// @param appConfig    The app config to encode.\n    function encodeVersionedAppConfig(uint8 version, bytes memory appConfig) internal pure returns (bytes memory) {\n        return abi.encode(version, appConfig);\n    }\n\n    /// @notice Decodes versioned app config from a bytes format back into a version and app config.\n    /// @param data         The versioned app config data in bytes format.\n    /// @return version     The version of the app config.\n    /// @return appConfig   The app config as bytes.\n    function decodeVersionedAppConfig(bytes memory data)\n        internal\n        pure\n        returns (uint8 version, bytes memory appConfig)\n    {\n        (version, appConfig) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return encodeVersionedAppConfig(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal pure returns (AppConfigV1 memory) {\n        (uint8 version, bytes memory appConfig) = decodeVersionedAppConfig(data);\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(appConfig, (AppConfigV1));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    uint8 constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint8 version);\n\n    /// @notice Encodes versioned options into a bytes format.\n    /// @param version      The version of the options.\n    /// @param options      The options to encode.\n    function encodeVersionedOptions(uint8 version, bytes memory options) internal pure returns (bytes memory) {\n        return abi.encode(version, options);\n    }\n\n    /// @notice Decodes versioned options from a bytes format back into a version and options.\n    /// @param data         The versioned options data in bytes format.\n    /// @return version     The version of the options.\n    /// @return options     The options as bytes.\n    function decodeVersionedOptions(bytes memory data) internal pure returns (uint8 version, bytes memory options) {\n        (version, options) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return encodeVersionedOptions(OPTIONS_V1, abi.encode(options));\n    }\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal pure returns (OptionsV1 memory) {\n        (uint8 version, bytes memory options) = decodeVersionedOptions(data);\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(options, (OptionsV1));\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/IAccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n\n// node_modules/@openzeppelin/contracts/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance \u003c amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance \u003c value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 \u0026\u0026 target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/libs/InterchainTransaction.sol\n\nstruct InterchainTransaction {\n    uint256 srcChainId;\n    bytes32 srcSender;\n    uint256 dstChainId;\n    bytes32 dstReceiver;\n    uint256 dbNonce;\n    uint64 entryIndex;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint256 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    function constructLocalTransaction(\n        address srcSender,\n        uint256 dstChainId,\n        bytes32 dstReceiver,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: block.chainid,\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(transaction);\n    }\n\n    function decodeTransaction(bytes memory encodedTx) internal pure returns (InterchainTransaction memory) {\n        return abi.decode(encodedTx, (InterchainTransaction));\n    }\n\n    function transactionId(InterchainTransaction memory transaction) internal pure returns (bytes32) {\n        return keccak256(abi.encode(transaction));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/IAccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/IAccessControlEnumerable.sol)\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n// contracts/interfaces/IInterchainAppV1.sol\n\ninterface IInterchainAppV1 is IInterchainApp {\n    error InterchainApp__AppZeroAddress();\n    error InterchainApp__InvalidAppConfig(uint256 requiredResponses, uint256 optimisticPeriod);\n    error InterchainApp__ModuleAlreadyAdded(address module);\n    error InterchainApp__ModuleNotAdded(address module);\n    error InterchainApp__ModuleZeroAddress();\n    error InterchainApp__NotEVMLinkedApp(bytes32 linkedApp);\n\n    /// @notice Allows the owner to add the interchain client to the allowed clients set,\n    /// and optionally set the latest client to this one.\n    /// Note: only the allowed clients can send messages to this app.\n    /// Note: the latest client is used for sending messages from this app.\n    /// @param client       The address of the interchain client to add.\n    /// @param updateLatest Whether to set the latest client to this one.\n    function addInterchainClient(address client, bool updateLatest) external;\n\n    /// @notice Allows the owner to remove the interchain client from the allowed clients set.\n    /// If the client is the latest client, the latest client is set to the zero address.\n    /// @param client       The address of the interchain client to remove.\n    function removeInterchainClient(address client) external;\n\n    /// @notice Allows the owner to set the address of the latest interchain client.\n    /// @dev The new latest client must be an allowed client or zero address.\n    /// Setting the client to zero address effectively pauses the app ability to send messages,\n    /// while allowing to receive them.\n    /// @param client       The address of the latest interchain client.\n    function setLatestInterchainClient(address client) external;\n\n    /// @notice Allows the owner to link the remote app for the given chain ID.\n    /// - This address will be used as the receiver for the messages sent from this chain.\n    /// - This address will be the only trusted sender for the messages sent to this chain.\n    /// @param chainId      The remote chain ID.\n    /// @param remoteApp    The address of the remote app to link.\n    function linkRemoteApp(uint256 chainId, bytes32 remoteApp) external;\n\n    /// @notice Thin wrapper for `linkRemoteApp` to accept EVM address as a parameter.\n    function linkRemoteAppEVM(uint256 chainId, address remoteApp) external;\n\n    /// @notice Allows the owner to add the module to the trusted modules set.\n    /// - This set of modules will be used to verify both sent and received messages.\n    function addTrustedModule(address module) external;\n\n    /// @notice Allows the owner to remove the module from the trusted modules set.\n    function removeTrustedModule(address module) external;\n\n    /// @notice Allows the owner to set the app config for the current app. App config includes:\n    /// - requiredResponses: the number of module responses required for accepting the message\n    /// - optimisticPeriod: the minimum time after which the module responses are considered final\n    function setAppConfigV1(AppConfigV1 memory appConfig) external;\n\n    /// @notice Allows the owner to set the address of the Execution Service.\n    /// This address will be used to request execution of the messages sent from this chain,\n    /// by supplying the Service's execution fee.\n    function setExecutionService(address executionService) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Returns the app config for the current app: requiredResponses and optimisticPeriod.\n    function getAppConfigV1() external view returns (AppConfigV1 memory);\n\n    /// @notice Returns the address of the Execution Service used by this app for sending messages.\n    function getExecutionService() external view returns (address);\n\n    /// @notice Returns the list of Interchain Clients allowed to send messages to this app.\n    function getInterchainClients() external view returns (address[] memory);\n\n    /// @notice Returns the address of the latest interchain client.\n    /// This address is used for sending messages from this app.\n    function getLatestInterchainClient() external view returns (address);\n\n    /// @notice Returns the linked app address (as bytes32) for the given chain ID.\n    function getLinkedApp(uint256 chainId) external view returns (bytes32);\n\n    /// @notice Thin wrapper for `getLinkedApp` to return the linked app address as EVM address.\n    /// @dev Will revert if the linked app address is not an EVM address.\n    function getLinkedAppEVM(uint256 chainId) external view returns (address);\n\n    /// @notice Returns the list of Interchain Modules trusted by this app.\n    /// This set of modules will be used to verify both sent and received messages.\n    function getModules() external view returns (address[] memory);\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint256 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__NoLinkedClient(uint256 chainId);\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint256 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint256 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint256 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint256 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint256 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param message              The message being sent.\n    function getInterchainFee(\n        uint256 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint256 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint256 chainId) external view returns (address);\n}\n\n// node_modules/@openzeppelin/contracts/access/AccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account =\u003e bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role =\u003e RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n// contracts/apps/AbstractICApp.sol\n\nabstract contract AbstractICApp is AbstractICAppEvents, IInterchainApp {\n    using TypeCasts for address;\n\n    error InterchainApp__AlreadyLatestClient(address client);\n    error InterchainApp__BalanceTooLow(uint256 actual, uint256 required);\n    error InterchainApp__ClientAlreadyAdded(address client);\n    error InterchainApp__InterchainClientZeroAddress();\n    error InterchainApp__NotInterchainClient(address account);\n    error InterchainApp__ReceiverNotSet(uint256 chainId);\n    error InterchainApp__SameChainId(uint256 chainId);\n    error InterchainApp__SenderNotAllowed(uint256 srcChainId, bytes32 sender);\n\n    /// @inheritdoc IInterchainApp\n    function appReceive(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        if (!_isInterchainClient(msg.sender)) {\n            revert InterchainApp__NotInterchainClient(msg.sender);\n        }\n        if (srcChainId == block.chainid) {\n            revert InterchainApp__SameChainId(srcChainId);\n        }\n        if (!_isAllowedSender(srcChainId, sender)) {\n            revert InterchainApp__SenderNotAllowed(srcChainId, sender);\n        }\n        _receiveMessage(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n\n    /// @inheritdoc IInterchainApp\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules) {\n        appConfig = _getAppConfig();\n        modules = _getModules();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Performs necessary checks and adds an Interchain Client.\n    /// Optionally sets the latest client to this one.\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _addClient(address client, bool updateLatest) internal {\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (_isInterchainClient(client)) {\n            revert InterchainApp__ClientAlreadyAdded(client);\n        }\n        _toggleClientState(client, true);\n        emit InterchainClientAdded(client);\n        if (updateLatest) {\n            _setLatestClient(client);\n        }\n    }\n\n    /// @dev Performs necessary checks and removes an Interchain Client. If this client is the latest one,\n    /// the latest client is set to zero address (effectively pausing the app ability to send messages).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _removeClient(address client) internal {\n        if (!_isInterchainClient(client)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        _toggleClientState(client, false);\n        emit InterchainClientRemoved(client);\n        if (client == _getLatestClient()) {\n            _setLatestClient(address(0));\n        }\n    }\n\n    /// @dev Sets the latest Interchain Client to one of the allowed clients. Setting the client to zero address\n    /// is allowed and effectively pauses the app ability to send messages (but still allows to receive them).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _setLatestClient(address client) internal {\n        // New latest client must be an allowed client or zero address.\n        if (!_isInterchainClient(client) \u0026\u0026 client != address(0)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        if (client == _getLatestClient()) {\n            revert InterchainApp__AlreadyLatestClient(client);\n        }\n        _storeLatestClient(client);\n        emit LatestClientSet(client);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal virtual;\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal virtual;\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to accept EVM address as a parameter.\n    function _sendInterchainMessageEVM(\n        uint256 dstChainId,\n        address receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _sendInterchainMessage(dstChainId, receiver.addressToBytes32(), messageFee, options, message);\n    }\n\n    /// @dev Performs necessary checks and sends an interchain message.\n    function _sendInterchainMessage(\n        uint256 dstChainId,\n        bytes32 receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (dstChainId == block.chainid) {\n            revert InterchainApp__SameChainId(dstChainId);\n        }\n        if (receiver == 0) {\n            revert InterchainApp__ReceiverNotSet(dstChainId);\n        }\n        if (address(this).balance \u003c messageFee) {\n            revert InterchainApp__BalanceTooLow({actual: address(this).balance, required: messageFee});\n        }\n        return IInterchainClientV1(client).interchainSend{value: messageFee}(\n            dstChainId, receiver, _getExecutionService(), _getModules(), options, message\n        );\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        virtual;\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee for sending an Interchain message.\n    function _getInterchainFee(\n        uint256 dstChainId,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        return IInterchainClientV1(client).getInterchainFee(\n            dstChainId, _getExecutionService(), _getModules(), options, message\n        );\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view virtual returns (bytes memory);\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view virtual returns (address);\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view virtual returns (address);\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view virtual returns (address[] memory);\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint256 srcChainId, bytes32 sender) internal view virtual returns (bool);\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view virtual returns (bool);\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/AccessControlEnumerable.sol)\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 role =\u003e EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {AccessControl-_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool granted = super._grantRole(role, account);\n        if (granted) {\n            _roleMembers[role].add(account);\n        }\n        return granted;\n    }\n\n    /**\n     * @dev Overload {AccessControl-_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool revoked = super._revokeRole(role, account);\n        if (revoked) {\n            _roleMembers[role].remove(account);\n        }\n        return revoked;\n    }\n}\n\n// contracts/apps/ICAppV1.sol\n\nabstract contract ICAppV1 is AbstractICApp, AccessControlEnumerable, InterchainAppV1Events, IInterchainAppV1 {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Role to manage the Interchain setup of the app.\n    bytes32 public constant IC_GOVERNOR_ROLE = keccak256(\"IC_GOVERNOR_ROLE\");\n\n    /// @dev Address of the latest Interchain Client, used for sending messages.\n    address private _latestClient;\n\n    /// @dev Required responses and optimistic period for the module responses.\n    AppConfigV1 private _appConfigV1;\n    /// @dev Address of the linked app deployed on the remote chain.\n    mapping(uint256 chainId =\u003e bytes32 remoteApp) private _linkedApp;\n    /// @dev Interchain Clients allowed to send messages to this app.\n    EnumerableSet.AddressSet private _interchainClients;\n    /// @dev Trusted Interchain modules.\n    EnumerableSet.AddressSet private _trustedModules;\n    /// @dev Execution Service to use for sending messages.\n    address private _executionService;\n\n    constructor(address admin) {\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addInterchainClient(address client, bool updateLatest) external onlyRole(IC_GOVERNOR_ROLE) {\n        _addClient(client, updateLatest);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _removeClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setLatestInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _setLatestClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteApp(uint256 chainId, bytes32 remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteAppEVM(uint256 chainId, address remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp.addressToBytes32());\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (module == address(0)) {\n            revert InterchainApp__ModuleZeroAddress();\n        }\n        bool added = _trustedModules.add(module);\n        if (!added) {\n            revert InterchainApp__ModuleAlreadyAdded(module);\n        }\n        emit TrustedModuleAdded(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        bool removed = _trustedModules.remove(module);\n        if (!removed) {\n            revert InterchainApp__ModuleNotAdded(module);\n        }\n        emit TrustedModuleRemoved(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setAppConfigV1(AppConfigV1 memory appConfig) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (appConfig.requiredResponses == 0 || appConfig.optimisticPeriod == 0) {\n            revert InterchainApp__InvalidAppConfig(appConfig.requiredResponses, appConfig.optimisticPeriod);\n        }\n        _appConfigV1 = appConfig;\n        emit AppConfigV1Set(appConfig.requiredResponses, appConfig.optimisticPeriod);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setExecutionService(address executionService) external onlyRole(IC_GOVERNOR_ROLE) {\n        _executionService = executionService;\n        emit ExecutionServiceSet(executionService);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainAppV1\n    function getAppConfigV1() external view returns (AppConfigV1 memory) {\n        return _appConfigV1;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getExecutionService() external view returns (address) {\n        return _executionService;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getInterchainClients() external view returns (address[] memory) {\n        return _interchainClients.values();\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLatestInterchainClient() external view returns (address) {\n        return _latestClient;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedApp(uint256 chainId) external view returns (bytes32) {\n        return _linkedApp[chainId];\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedAppEVM(uint256 chainId) external view returns (address linkedAppEVM) {\n        bytes32 linkedApp = _linkedApp[chainId];\n        linkedAppEVM = linkedApp.bytes32ToAddress();\n        if (linkedAppEVM.addressToBytes32() != linkedApp) {\n            revert InterchainApp__NotEVMLinkedApp(linkedApp);\n        }\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getModules() external view returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Links the remote app to the current app.\n    /// Will revert if the chainId is the same as the chainId of the local app.\n    /// Note: Should be guarded with permissions check.\n    function _linkRemoteApp(uint256 chainId, bytes32 remoteApp) internal {\n        if (chainId == block.chainid) {\n            revert InterchainApp__SameChainId(chainId);\n        }\n        if (remoteApp == 0) {\n            revert InterchainApp__AppZeroAddress();\n        }\n        _linkedApp[chainId] = remoteApp;\n        emit AppLinked(chainId, remoteApp);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal override {\n        _latestClient = client;\n    }\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal override {\n        if (allowed) {\n            _interchainClients.add(client);\n        } else {\n            _interchainClients.remove(client);\n        }\n    }\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to send the message to the linked app.\n    function _sendToLinkedApp(\n        uint256 dstChainId,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _sendInterchainMessage(dstChainId, _linkedApp[dstChainId], messageFee, encodedOptions, message);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee to send a message to the linked app on the remote chain.\n    function _getMessageFee(\n        uint256 dstChainId,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _getInterchainFee(dstChainId, encodedOptions, message);\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view override returns (bytes memory) {\n        return _appConfigV1.encodeAppConfigV1();\n    }\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view override returns (address) {\n        return _executionService;\n    }\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view override returns (address) {\n        return _latestClient;\n    }\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view override returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint256 srcChainId, bytes32 sender) internal view override returns (bool) {\n        return _linkedApp[srcChainId] == sender;\n    }\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view override returns (bool) {\n        return _interchainClients.contains(caller);\n    }\n}\n\n// contracts/apps/examples/ExampleAppV1.sol\n\ncontract ExampleAppV1 is ICAppV1 {\n    event MessageReceived(uint256 srcChainId, bytes32 sender, uint256 dbNonce, uint64 entryIndex, bytes message);\n    event MessageSent(uint256 dstChainId, uint256 dbNonce, uint64 entryIndex, bytes32 transactionId);\n\n    constructor(address admin) ICAppV1(admin) {\n        _grantRole(IC_GOVERNOR_ROLE, admin);\n    }\n\n    /// @notice Allows the Admin to withdraw the native asset from the contract.\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        Address.sendValue(payable(msg.sender), address(this).balance);\n    }\n\n    /// @notice Sends a basic message to the destination chain.\n    function sendMessage(\n        uint256 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        InterchainTxDescriptor memory desc = _sendToLinkedApp({\n            dstChainId: dstChainId,\n            messageFee: msg.value,\n            options: OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}),\n            message: message\n        });\n        emit MessageSent(dstChainId, desc.dbNonce, desc.entryIndex, desc.transactionId);\n    }\n\n    /// @notice Returns the fee required to send a message using `sendMessage`.\n    function getMessageFee(\n        uint256 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes memory message\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _getMessageFee(dstChainId, OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}), message);\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        override\n    {\n        emit MessageReceived(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"20200:11640:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;20200:11640:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"20200:11640:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"details":"Library for managing https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive types. Sets have the following properties: - Elements are added, removed, and checked for existence in constant time (O(1)). - Elements are enumerated in O(n). No guarantees are made on the ordering. ```solidity contract Example {     // Add the library methods     using EnumerableSet for EnumerableSet.AddressSet;     // Declare a set state variable     EnumerableSet.AddressSet private mySet; } ``` As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`) and `uint256` (`UintSet`) are supported. [WARNING] ==== Trying to delete such a structure from storage will likely result in data corruption, rendering the structure unusable. See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info. In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an array of EnumerableSet. ====","kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"details\":\"Library for managing https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive types. Sets have the following properties: - Elements are added, removed, and checked for existence in constant time (O(1)). - Elements are enumerated in O(n). No guarantees are made on the ordering. ```solidity contract Example {     // Add the library methods     using EnumerableSet for EnumerableSet.AddressSet;     // Declare a set state variable     EnumerableSet.AddressSet private mySet; } ``` As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`) and `uint256` (`UintSet`) are supported. [WARNING] ==== Trying to delete such a structure from storage will likely result in data corruption, rendering the structure unusable. See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info. In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an array of EnumerableSet. ====\",\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/ExampleAppV1.sol\":\"EnumerableSet\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/ExampleAppV1.sol\":{\"keccak256\":\"0x4c94807e7a2671ad6fcf49fb03cfafa6f51f6b4596f34092fba0bf17b6d482cf\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://4fabc9aa6f6891674b77809808b14ff1f2e8829de650caafa1fb3c3444a07331\",\"dweb:/ipfs/QmVzYNSfkuSkXNaFKuNY3hmkdspssruAhQx4qZuJU3Ceg9\"]}},\"version\":1}"},"hashes":{}},"solidity/ExampleAppV1.sol:ExampleAppV1":{"code":"0x60806040523480156200001157600080fd5b50604051620024cb380380620024cb8339810160408190526200003491620001be565b806200004260008262000079565b506200007190507f67458b9c8206fd7556afadce1bc8e28c7a8942ecb92d9d9fad69bb6c8cf75c848262000079565b5050620001e9565b600080620000888484620000b6565b90508015620000ad576000848152600160205260409020620000ab908462000164565b505b90505b92915050565b6000828152602081815260408083206001600160a01b038516845290915281205460ff166200015b576000838152602081815260408083206001600160a01b03861684529091529020805460ff19166001179055620001123390565b6001600160a01b0316826001600160a01b0316847f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d60405160405180910390a4506001620000b0565b506000620000b0565b6000620000ad836001600160a01b03841660008181526001830160205260408120546200015b57508154600181810184556000848152602080822090930184905584548482528286019093526040902091909155620000b0565b600060208284031215620001d157600080fd5b81516001600160a01b0381168114620000ad57600080fd5b6122d280620001f96000396000f3fe6080604052600436106101d85760003560e01c80639010d07c11610102578063b9b74b1811610095578063cb5038fb11610064578063cb5038fb146105b7578063d547741f146105d7578063eb53b44e146105f7578063f22ba23d1461061757600080fd5b8063b9b74b181461052e578063bc0d912c1461055b578063c313c80714610579578063ca15c8731461059757600080fd5b8063a9ac04b6116100d1578063a9ac04b6146104b9578063af8fcc8e146104d9578063b2494df3146104f9578063b70c40b31461050e57600080fd5b80639010d07c1461040657806391d148541461043e578063a1aa5d6814610482578063a217fddf146104a457600080fd5b80632f2ff15d1161017a57806351a308021161014957806351a308021461037157806368a6984714610391578063764ca1e8146103a45780637717a647146103c457600080fd5b80632f2ff15d146102fc57806336568abe1461031c5780633ccfd60b1461033c578063496774b11461035157600080fd5b80631c489e4f116101b65780631c489e4f14610254578063248a9ca314610296578063282be0e9146102c6578063287bc057146102d957600080fd5b806301ffc9a7146101dd5780630d32b505146102125780630fb5915614610234575b600080fd5b3480156101e957600080fd5b506101fd6101f8366004611b54565b610637565b60405190151581526020015b60405180910390f35b34801561021e57600080fd5b5061023261022d366004611c14565b610693565b005b34801561024057600080fd5b5061023261024f366004611c7f565b610766565b34801561026057600080fd5b506102887f67458b9c8206fd7556afadce1bc8e28c7a8942ecb92d9d9fad69bb6c8cf75c8481565b604051908152602001610209565b3480156102a257600080fd5b506102886102b1366004611c9a565b60009081526020819052604090206001015490565b6102326102d4366004611cfc565b61079d565b3480156102e557600080fd5b506102ee61085b565b604051610209929190611e05565b34801561030857600080fd5b50610232610317366004611e2a565b610876565b34801561032857600080fd5b50610232610337366004611e2a565b6108a1565b34801561034857600080fd5b506102326108f2565b34801561035d57600080fd5b5061023261036c366004611c7f565b61090a565b34801561037d57600080fd5b5061023261038c366004611e56565b61099a565b61023261039f366004611e8e565b6109ce565b3480156103b057600080fd5b506102886103bf366004611f01565b610ab2565b3480156103d057600080fd5b50604080518082018252600080825260209182015281518083019092526003548252600454908201526040516102099190611fd1565b34801561041257600080fd5b50610426610421366004611e56565b610adc565b6040516001600160a01b039091168152602001610209565b34801561044a57600080fd5b506101fd610459366004611e2a565b6000918252602082815260408084206001600160a01b0393909316845291905290205460ff1690565b34801561048e57600080fd5b50610497610afb565b6040516102099190611fe8565b3480156104b057600080fd5b50610288600081565b3480156104c557600080fd5b506104266104d4366004611c9a565b610b0c565b3480156104e557600080fd5b506102326104f4366004611e2a565b610b67565b34801561050557600080fd5b50610497610ba4565b34801561051a57600080fd5b50610232610529366004611c7f565b610bb0565b34801561053a57600080fd5b50610288610549366004611c9a565b60009081526005602052604090205490565b34801561056757600080fd5b506002546001600160a01b0316610426565b34801561058557600080fd5b50600a546001600160a01b0316610426565b3480156105a357600080fd5b506102886105b2366004611c9a565b610c6d565b3480156105c357600080fd5b506102326105d2366004611c7f565b610c84565b3480156105e357600080fd5b506102326105f2366004611e2a565b610d78565b34801561060357600080fd5b50610232610612366004611c7f565b610d9d565b34801561062357600080fd5b50610232610632366004611ffb565b610dd0565b60007fffffffff0000000000000000000000000000000000000000000000000000000082167f5a05180f00000000000000000000000000000000000000000000000000000000148061068d575061068d82610e04565b92915050565b7f67458b9c8206fd7556afadce1bc8e28c7a8942ecb92d9d9fad69bb6c8cf75c846106bd81610e9b565b815115806106cd57506020820151155b1561071957815160208301516040517f8bdc31dd000000000000000000000000000000000000000000000000000000008152600481019290925260248201526044015b60405180910390fd5b81516003819055602080840151600481905560408051938452918301527f156e53f21add5e964d33e39e015675e24d4568202b47744bd8cc6080f76deabf91015b60405180910390a15050565b7f67458b9c8206fd7556afadce1bc8e28c7a8942ecb92d9d9fad69bb6c8cf75c8461079081610e9b565b61079982610ea5565b5050565b60006107f5863460405180604001604052808981526020018881525086868080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250610f6492505050565b602080820151604080840151845182518c81529485019390935267ffffffffffffffff169083015260608201529091507f2ef16db2691a32543ce5591798c4992f4cfbbcd446874f1437d99da53d600e7c906080015b60405180910390a1505050505050565b606080610866610fb4565b9150610870610ba4565b90509091565b60008281526020819052604090206001015461089181610e9b565b61089b8383610fd7565b50505050565b6001600160a01b03811633146108e3576040517f6697b23200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6108ed828261100c565b505050565b60006108fd81610e9b565b6109073347611039565b50565b7f67458b9c8206fd7556afadce1bc8e28c7a8942ecb92d9d9fad69bb6c8cf75c8461093481610e9b565b600a80547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b0384169081179091556040519081527f56f2046f579030345e1c12cfd7e2d297e4059c24d30ac1a5cb27a8ee1d53526e9060200161075a565b7f67458b9c8206fd7556afadce1bc8e28c7a8942ecb92d9d9fad69bb6c8cf75c846109c481610e9b565b6108ed8383611102565b6109d7336111b8565b610a0f576040517f0578f695000000000000000000000000000000000000000000000000000000008152336004820152602401610710565b468603610a4b576040517fbfae2eb700000000000000000000000000000000000000000000000000000000815260048101879052602401610710565b6000868152600560205260409020548514610a9c576040517f327f41230000000000000000000000000000000000000000000000000000000081526004810187905260248101869052604401610710565b610aaa8686868686866111c5565b505050505050565b6000610ad385604051806040016040528087815260200186815250846111fe565b95945050505050565b6000828152600160205260408120610af49083611217565b9392505050565b6060610b076006611223565b905090565b600081815260056020526040902054806001600160a01b0381168114610b61576040517ff04c4a4500000000000000000000000000000000000000000000000000000000815260048101829052602401610710565b50919050565b7f67458b9c8206fd7556afadce1bc8e28c7a8942ecb92d9d9fad69bb6c8cf75c84610b9181610e9b565b6108ed836001600160a01b038416611102565b6060610b076008611223565b7f67458b9c8206fd7556afadce1bc8e28c7a8942ecb92d9d9fad69bb6c8cf75c84610bda81610e9b565b6000610be7600884611230565b905080610c2b576040517fb12a48e60000000000000000000000000000000000000000000000000000000081526001600160a01b0384166004820152602401610710565b6040516001600160a01b03841681527f91071153b5721fdadecd5ab74cedca9c0faa62c94f02ef659df2241602698385906020015b60405180910390a1505050565b600081815260016020526040812061068d90611245565b7f67458b9c8206fd7556afadce1bc8e28c7a8942ecb92d9d9fad69bb6c8cf75c84610cae81610e9b565b6001600160a01b038216610cee576040517fa8ce0c2e00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6000610cfb60088461124f565b905080610d3f576040517f856e38ac0000000000000000000000000000000000000000000000000000000081526001600160a01b0384166004820152602401610710565b6040516001600160a01b03841681527f0f92a0308a1fb283891a96a4cf077b8499cca0159d8e6ccc8d12096a5011750990602001610c60565b600082815260208190526040902060010154610d9381610e9b565b61089b838361100c565b7f67458b9c8206fd7556afadce1bc8e28c7a8942ecb92d9d9fad69bb6c8cf75c84610dc781610e9b565b61079982611264565b7f67458b9c8206fd7556afadce1bc8e28c7a8942ecb92d9d9fad69bb6c8cf75c84610dfa81610e9b565b6108ed8383611397565b60007fffffffff0000000000000000000000000000000000000000000000000000000082167f7965db0b00000000000000000000000000000000000000000000000000000000148061068d57507f01ffc9a7000000000000000000000000000000000000000000000000000000007fffffffff0000000000000000000000000000000000000000000000000000000083161461068d565b6109078133611478565b610eae816111b8565b610eef576040517f0578f6950000000000000000000000000000000000000000000000000000000081526001600160a01b0382166004820152602401610710565b610efa8160006114e4565b6040516001600160a01b03821681527fc0d64f9e088893f1e4aea6d42c0e815f158ca62962029260f3c2b079d97feccc9060200160405180910390a16002546001600160a01b03166001600160a01b0316816001600160a01b031603610907576109076000611264565b6040805160608101825260008082526020820181905291810182905290610f8a84611500565b600087815260056020526040902054909150610faa90879087848761152c565b9695505050505050565b6040805180820190915260035481526004546020820152606090610b0790611500565b600080610fe484846116f9565b90508015610af4576000848152600160205260409020611004908461124f565b509392505050565b60008061101984846117c1565b90508015610af45760008481526001602052604090206110049084611230565b80471015611075576040517fcd786059000000000000000000000000000000000000000000000000000000008152306004820152602401610710565b6000826001600160a01b03168260405160006040518083038185875af1925050503d80600081146110c2576040519150601f19603f3d011682016040523d82523d6000602084013e6110c7565b606091505b50509050806108ed576040517f1425ea4200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b46820361113e576040517fbfae2eb700000000000000000000000000000000000000000000000000000000815260048101839052602401610710565b6000819003611179576040517fe04fb69600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60008281526005602052604080822083905551829184917f622d488f4fb24881af2fe5b552b249253a21e4a6fa77d12e69f61ee0fdfb9a319190a35050565b600061068d600683611862565b7fc5b07cf0d424748241636d3a67366b44ac88118c42bef024abcb7fd138df79a686868686868660405161084b96959493929190612037565b60008061120a84611500565b9050610ad3858285611884565b6000610af48383611968565b60606000610af483611992565b6000610af4836001600160a01b0384166119ee565b600061068d825490565b6000610af4836001600160a01b038416611ae1565b61126d816111b8565b15801561128257506001600160a01b03811615155b156112c4576040517f0578f6950000000000000000000000000000000000000000000000000000000081526001600160a01b0382166004820152602401610710565b6002546001600160a01b03166001600160a01b0316816001600160a01b031603611325576040517f56c309440000000000000000000000000000000000000000000000000000000081526001600160a01b0382166004820152602401610710565b600280547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b0383161790556040516001600160a01b03821681527fd6c4ff3ce819d1fe47a30bb776376d847d8085a73ebf92dbf4058c36fdd5c1699060200160405180910390a150565b6001600160a01b0382166113d7576040517f6be4ac5200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6113e0826111b8565b15611422576040517f4ea647680000000000000000000000000000000000000000000000000000000081526001600160a01b0383166004820152602401610710565b61142d8260016114e4565b6040516001600160a01b03831681527f9963c5d146abd18838e0638ea82ec86b9a726e15fd852cab94aeebcd8bf438d19060200160405180910390a180156107995761079982611264565b6000828152602081815260408083206001600160a01b038516845290915290205460ff16610799576040517fe2517d3f0000000000000000000000000000000000000000000000000000000081526001600160a01b038216600482015260248101839052604401610710565b80156114f5576108ed60068361124f565b6108ed600683611230565b606061068d6001836040516020016115189190611fd1565b604051602081830303815290604052611b28565b6040805160608101825260008082526020820181905291810191909152600061155d6002546001600160a01b031690565b90506001600160a01b03811661159f576040517f6be4ac5200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b4687036115db576040517fbfae2eb700000000000000000000000000000000000000000000000000000000815260048101889052602401610710565b6000869003611619576040517f9a3e6bd400000000000000000000000000000000000000000000000000000000815260048101889052602401610710565b8447101561165c576040517f5b59cdf200000000000000000000000000000000000000000000000000000000815247600482015260248101869052604401610710565b806001600160a01b03166398939d28868989611680600a546001600160a01b031690565b611688610ba4565b8a8a6040518863ffffffff1660e01b81526004016116ab969594939291906120aa565b60606040518083038185885af11580156116c9573d6000803e3d6000fd5b50505050506040513d601f19601f820116820180604052508101906116ee919061210b565b979650505050505050565b6000828152602081815260408083206001600160a01b038516845290915281205460ff166117b9576000838152602081815260408083206001600160a01b0386168452909152902080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff001660011790556117713390565b6001600160a01b0316826001600160a01b0316847f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d60405160405180910390a450600161068d565b50600061068d565b6000828152602081815260408083206001600160a01b038516845290915281205460ff16156117b9576000838152602081815260408083206001600160a01b038616808552925280832080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0016905551339286917ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b9190a450600161068d565b6001600160a01b03811660009081526001830160205260408120541515610af4565b6000806118996002546001600160a01b031690565b90506001600160a01b0381166118db576040517f6be4ac5200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b806001600160a01b0316633c383e7b866118fd600a546001600160a01b031690565b611905610ba4565b88886040518663ffffffff1660e01b815260040161192795949392919061216d565b602060405180830381865afa158015611944573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ad391906121c7565b600082600001828154811061197f5761197f6121e0565b9060005260206000200154905092915050565b6060816000018054806020026020016040519081016040528092919081815260200182805480156119e257602002820191906000526020600020905b8154815260200190600101908083116119ce575b50505050509050919050565b60008181526001830160205260408120548015611ad7576000611a1260018361220f565b8554909150600090611a269060019061220f565b9050808214611a8b576000866000018281548110611a4657611a466121e0565b9060005260206000200154905080876000018481548110611a6957611a696121e0565b6000918252602080832090910192909255918252600188019052604090208390555b8554869080611a9c57611a9c612249565b60019003818190600052602060002001600090559055856001016000868152602001908152602001600020600090556001935050505061068d565b600091505061068d565b60008181526001830160205260408120546117b95750815460018181018455600084815260208082209093018490558454848252828601909352604090209190915561068d565b60608282604051602001611b3d929190612278565b604051602081830303815290604052905092915050565b600060208284031215611b6657600080fd5b81357fffffffff0000000000000000000000000000000000000000000000000000000081168114610af457600080fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff81118282101715611c0c57611c0c611b96565b604052919050565b600060408284031215611c2657600080fd5b6040516040810181811067ffffffffffffffff82111715611c4957611c49611b96565b604052823581526020928301359281019290925250919050565b80356001600160a01b0381168114611c7a57600080fd5b919050565b600060208284031215611c9157600080fd5b610af482611c63565b600060208284031215611cac57600080fd5b5035919050565b60008083601f840112611cc557600080fd5b50813567ffffffffffffffff811115611cdd57600080fd5b602083019150836020828501011115611cf557600080fd5b9250929050565b600080600080600060808688031215611d1457600080fd5b853594506020860135935060408601359250606086013567ffffffffffffffff811115611d4057600080fd5b611d4c88828901611cb3565b969995985093965092949392505050565b6000815180845260005b81811015611d8357602081850181015186830182015201611d67565b5060006020828601015260207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f83011685010191505092915050565b600081518084526020808501945080840160005b83811015611dfa5781516001600160a01b031687529582019590820190600101611dd5565b509495945050505050565b604081526000611e186040830185611d5d565b8281036020840152610ad38185611dc1565b60008060408385031215611e3d57600080fd5b82359150611e4d60208401611c63565b90509250929050565b60008060408385031215611e6957600080fd5b50508035926020909101359150565b67ffffffffffffffff8116811461090757600080fd5b60008060008060008060a08789031215611ea757600080fd5b8635955060208701359450604087013593506060870135611ec781611e78565b9250608087013567ffffffffffffffff811115611ee357600080fd5b611eef89828a01611cb3565b979a9699509497509295939492505050565b60008060008060808587031215611f1757600080fd5b84359350602080860135935060408601359250606086013567ffffffffffffffff80821115611f4557600080fd5b818801915088601f830112611f5957600080fd5b813581811115611f6b57611f6b611b96565b611f9b847fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f84011601611bc5565b91508082528984828501011115611fb157600080fd5b808484018584013760008482840101525080935050505092959194509250565b81518152602080830151908201526040810161068d565b602081526000610af46020830184611dc1565b6000806040838503121561200e57600080fd5b61201783611c63565b91506020830135801515811461202c57600080fd5b809150509250929050565b86815285602082015284604082015267ffffffffffffffff8416606082015260a060808201528160a0820152818360c0830137600081830160c090810191909152601f9092017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016010195945050505050565b8681528560208201526001600160a01b038516604082015260c0606082015260006120d860c0830186611dc1565b82810360808401526120ea8186611d5d565b905082810360a08401526120fe8185611d5d565b9998505050505050505050565b60006060828403121561211d57600080fd5b6040516060810181811067ffffffffffffffff8211171561214057612140611b96565b80604052508251815260208301516020820152604083015161216181611e78565b60408201529392505050565b8581526001600160a01b038516602082015260a06040820152600061219560a0830186611dc1565b82810360608401526121a78186611d5d565b905082810360808401526121bb8185611d5d565b98975050505050505050565b6000602082840312156121d957600080fd5b5051919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b8181038181111561068d577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603160045260246000fd5b60ff831681526040602082015260006122946040830184611d5d565b94935050505056fea2646970667358221220854c346e357af8e31946cfd4e6252f3cf1c58f741ccbe71b54df75bb3bd5d80664736f6c63430008140033","runtime-code":"0x6080604052600436106101d85760003560e01c80639010d07c11610102578063b9b74b1811610095578063cb5038fb11610064578063cb5038fb146105b7578063d547741f146105d7578063eb53b44e146105f7578063f22ba23d1461061757600080fd5b8063b9b74b181461052e578063bc0d912c1461055b578063c313c80714610579578063ca15c8731461059757600080fd5b8063a9ac04b6116100d1578063a9ac04b6146104b9578063af8fcc8e146104d9578063b2494df3146104f9578063b70c40b31461050e57600080fd5b80639010d07c1461040657806391d148541461043e578063a1aa5d6814610482578063a217fddf146104a457600080fd5b80632f2ff15d1161017a57806351a308021161014957806351a308021461037157806368a6984714610391578063764ca1e8146103a45780637717a647146103c457600080fd5b80632f2ff15d146102fc57806336568abe1461031c5780633ccfd60b1461033c578063496774b11461035157600080fd5b80631c489e4f116101b65780631c489e4f14610254578063248a9ca314610296578063282be0e9146102c6578063287bc057146102d957600080fd5b806301ffc9a7146101dd5780630d32b505146102125780630fb5915614610234575b600080fd5b3480156101e957600080fd5b506101fd6101f8366004611b54565b610637565b60405190151581526020015b60405180910390f35b34801561021e57600080fd5b5061023261022d366004611c14565b610693565b005b34801561024057600080fd5b5061023261024f366004611c7f565b610766565b34801561026057600080fd5b506102887f67458b9c8206fd7556afadce1bc8e28c7a8942ecb92d9d9fad69bb6c8cf75c8481565b604051908152602001610209565b3480156102a257600080fd5b506102886102b1366004611c9a565b60009081526020819052604090206001015490565b6102326102d4366004611cfc565b61079d565b3480156102e557600080fd5b506102ee61085b565b604051610209929190611e05565b34801561030857600080fd5b50610232610317366004611e2a565b610876565b34801561032857600080fd5b50610232610337366004611e2a565b6108a1565b34801561034857600080fd5b506102326108f2565b34801561035d57600080fd5b5061023261036c366004611c7f565b61090a565b34801561037d57600080fd5b5061023261038c366004611e56565b61099a565b61023261039f366004611e8e565b6109ce565b3480156103b057600080fd5b506102886103bf366004611f01565b610ab2565b3480156103d057600080fd5b50604080518082018252600080825260209182015281518083019092526003548252600454908201526040516102099190611fd1565b34801561041257600080fd5b50610426610421366004611e56565b610adc565b6040516001600160a01b039091168152602001610209565b34801561044a57600080fd5b506101fd610459366004611e2a565b6000918252602082815260408084206001600160a01b0393909316845291905290205460ff1690565b34801561048e57600080fd5b50610497610afb565b6040516102099190611fe8565b3480156104b057600080fd5b50610288600081565b3480156104c557600080fd5b506104266104d4366004611c9a565b610b0c565b3480156104e557600080fd5b506102326104f4366004611e2a565b610b67565b34801561050557600080fd5b50610497610ba4565b34801561051a57600080fd5b50610232610529366004611c7f565b610bb0565b34801561053a57600080fd5b50610288610549366004611c9a565b60009081526005602052604090205490565b34801561056757600080fd5b506002546001600160a01b0316610426565b34801561058557600080fd5b50600a546001600160a01b0316610426565b3480156105a357600080fd5b506102886105b2366004611c9a565b610c6d565b3480156105c357600080fd5b506102326105d2366004611c7f565b610c84565b3480156105e357600080fd5b506102326105f2366004611e2a565b610d78565b34801561060357600080fd5b50610232610612366004611c7f565b610d9d565b34801561062357600080fd5b50610232610632366004611ffb565b610dd0565b60007fffffffff0000000000000000000000000000000000000000000000000000000082167f5a05180f00000000000000000000000000000000000000000000000000000000148061068d575061068d82610e04565b92915050565b7f67458b9c8206fd7556afadce1bc8e28c7a8942ecb92d9d9fad69bb6c8cf75c846106bd81610e9b565b815115806106cd57506020820151155b1561071957815160208301516040517f8bdc31dd000000000000000000000000000000000000000000000000000000008152600481019290925260248201526044015b60405180910390fd5b81516003819055602080840151600481905560408051938452918301527f156e53f21add5e964d33e39e015675e24d4568202b47744bd8cc6080f76deabf91015b60405180910390a15050565b7f67458b9c8206fd7556afadce1bc8e28c7a8942ecb92d9d9fad69bb6c8cf75c8461079081610e9b565b61079982610ea5565b5050565b60006107f5863460405180604001604052808981526020018881525086868080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250610f6492505050565b602080820151604080840151845182518c81529485019390935267ffffffffffffffff169083015260608201529091507f2ef16db2691a32543ce5591798c4992f4cfbbcd446874f1437d99da53d600e7c906080015b60405180910390a1505050505050565b606080610866610fb4565b9150610870610ba4565b90509091565b60008281526020819052604090206001015461089181610e9b565b61089b8383610fd7565b50505050565b6001600160a01b03811633146108e3576040517f6697b23200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6108ed828261100c565b505050565b60006108fd81610e9b565b6109073347611039565b50565b7f67458b9c8206fd7556afadce1bc8e28c7a8942ecb92d9d9fad69bb6c8cf75c8461093481610e9b565b600a80547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b0384169081179091556040519081527f56f2046f579030345e1c12cfd7e2d297e4059c24d30ac1a5cb27a8ee1d53526e9060200161075a565b7f67458b9c8206fd7556afadce1bc8e28c7a8942ecb92d9d9fad69bb6c8cf75c846109c481610e9b565b6108ed8383611102565b6109d7336111b8565b610a0f576040517f0578f695000000000000000000000000000000000000000000000000000000008152336004820152602401610710565b468603610a4b576040517fbfae2eb700000000000000000000000000000000000000000000000000000000815260048101879052602401610710565b6000868152600560205260409020548514610a9c576040517f327f41230000000000000000000000000000000000000000000000000000000081526004810187905260248101869052604401610710565b610aaa8686868686866111c5565b505050505050565b6000610ad385604051806040016040528087815260200186815250846111fe565b95945050505050565b6000828152600160205260408120610af49083611217565b9392505050565b6060610b076006611223565b905090565b600081815260056020526040902054806001600160a01b0381168114610b61576040517ff04c4a4500000000000000000000000000000000000000000000000000000000815260048101829052602401610710565b50919050565b7f67458b9c8206fd7556afadce1bc8e28c7a8942ecb92d9d9fad69bb6c8cf75c84610b9181610e9b565b6108ed836001600160a01b038416611102565b6060610b076008611223565b7f67458b9c8206fd7556afadce1bc8e28c7a8942ecb92d9d9fad69bb6c8cf75c84610bda81610e9b565b6000610be7600884611230565b905080610c2b576040517fb12a48e60000000000000000000000000000000000000000000000000000000081526001600160a01b0384166004820152602401610710565b6040516001600160a01b03841681527f91071153b5721fdadecd5ab74cedca9c0faa62c94f02ef659df2241602698385906020015b60405180910390a1505050565b600081815260016020526040812061068d90611245565b7f67458b9c8206fd7556afadce1bc8e28c7a8942ecb92d9d9fad69bb6c8cf75c84610cae81610e9b565b6001600160a01b038216610cee576040517fa8ce0c2e00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6000610cfb60088461124f565b905080610d3f576040517f856e38ac0000000000000000000000000000000000000000000000000000000081526001600160a01b0384166004820152602401610710565b6040516001600160a01b03841681527f0f92a0308a1fb283891a96a4cf077b8499cca0159d8e6ccc8d12096a5011750990602001610c60565b600082815260208190526040902060010154610d9381610e9b565b61089b838361100c565b7f67458b9c8206fd7556afadce1bc8e28c7a8942ecb92d9d9fad69bb6c8cf75c84610dc781610e9b565b61079982611264565b7f67458b9c8206fd7556afadce1bc8e28c7a8942ecb92d9d9fad69bb6c8cf75c84610dfa81610e9b565b6108ed8383611397565b60007fffffffff0000000000000000000000000000000000000000000000000000000082167f7965db0b00000000000000000000000000000000000000000000000000000000148061068d57507f01ffc9a7000000000000000000000000000000000000000000000000000000007fffffffff0000000000000000000000000000000000000000000000000000000083161461068d565b6109078133611478565b610eae816111b8565b610eef576040517f0578f6950000000000000000000000000000000000000000000000000000000081526001600160a01b0382166004820152602401610710565b610efa8160006114e4565b6040516001600160a01b03821681527fc0d64f9e088893f1e4aea6d42c0e815f158ca62962029260f3c2b079d97feccc9060200160405180910390a16002546001600160a01b03166001600160a01b0316816001600160a01b031603610907576109076000611264565b6040805160608101825260008082526020820181905291810182905290610f8a84611500565b600087815260056020526040902054909150610faa90879087848761152c565b9695505050505050565b6040805180820190915260035481526004546020820152606090610b0790611500565b600080610fe484846116f9565b90508015610af4576000848152600160205260409020611004908461124f565b509392505050565b60008061101984846117c1565b90508015610af45760008481526001602052604090206110049084611230565b80471015611075576040517fcd786059000000000000000000000000000000000000000000000000000000008152306004820152602401610710565b6000826001600160a01b03168260405160006040518083038185875af1925050503d80600081146110c2576040519150601f19603f3d011682016040523d82523d6000602084013e6110c7565b606091505b50509050806108ed576040517f1425ea4200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b46820361113e576040517fbfae2eb700000000000000000000000000000000000000000000000000000000815260048101839052602401610710565b6000819003611179576040517fe04fb69600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60008281526005602052604080822083905551829184917f622d488f4fb24881af2fe5b552b249253a21e4a6fa77d12e69f61ee0fdfb9a319190a35050565b600061068d600683611862565b7fc5b07cf0d424748241636d3a67366b44ac88118c42bef024abcb7fd138df79a686868686868660405161084b96959493929190612037565b60008061120a84611500565b9050610ad3858285611884565b6000610af48383611968565b60606000610af483611992565b6000610af4836001600160a01b0384166119ee565b600061068d825490565b6000610af4836001600160a01b038416611ae1565b61126d816111b8565b15801561128257506001600160a01b03811615155b156112c4576040517f0578f6950000000000000000000000000000000000000000000000000000000081526001600160a01b0382166004820152602401610710565b6002546001600160a01b03166001600160a01b0316816001600160a01b031603611325576040517f56c309440000000000000000000000000000000000000000000000000000000081526001600160a01b0382166004820152602401610710565b600280547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b0383161790556040516001600160a01b03821681527fd6c4ff3ce819d1fe47a30bb776376d847d8085a73ebf92dbf4058c36fdd5c1699060200160405180910390a150565b6001600160a01b0382166113d7576040517f6be4ac5200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6113e0826111b8565b15611422576040517f4ea647680000000000000000000000000000000000000000000000000000000081526001600160a01b0383166004820152602401610710565b61142d8260016114e4565b6040516001600160a01b03831681527f9963c5d146abd18838e0638ea82ec86b9a726e15fd852cab94aeebcd8bf438d19060200160405180910390a180156107995761079982611264565b6000828152602081815260408083206001600160a01b038516845290915290205460ff16610799576040517fe2517d3f0000000000000000000000000000000000000000000000000000000081526001600160a01b038216600482015260248101839052604401610710565b80156114f5576108ed60068361124f565b6108ed600683611230565b606061068d6001836040516020016115189190611fd1565b604051602081830303815290604052611b28565b6040805160608101825260008082526020820181905291810191909152600061155d6002546001600160a01b031690565b90506001600160a01b03811661159f576040517f6be4ac5200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b4687036115db576040517fbfae2eb700000000000000000000000000000000000000000000000000000000815260048101889052602401610710565b6000869003611619576040517f9a3e6bd400000000000000000000000000000000000000000000000000000000815260048101889052602401610710565b8447101561165c576040517f5b59cdf200000000000000000000000000000000000000000000000000000000815247600482015260248101869052604401610710565b806001600160a01b03166398939d28868989611680600a546001600160a01b031690565b611688610ba4565b8a8a6040518863ffffffff1660e01b81526004016116ab969594939291906120aa565b60606040518083038185885af11580156116c9573d6000803e3d6000fd5b50505050506040513d601f19601f820116820180604052508101906116ee919061210b565b979650505050505050565b6000828152602081815260408083206001600160a01b038516845290915281205460ff166117b9576000838152602081815260408083206001600160a01b0386168452909152902080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff001660011790556117713390565b6001600160a01b0316826001600160a01b0316847f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d60405160405180910390a450600161068d565b50600061068d565b6000828152602081815260408083206001600160a01b038516845290915281205460ff16156117b9576000838152602081815260408083206001600160a01b038616808552925280832080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0016905551339286917ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b9190a450600161068d565b6001600160a01b03811660009081526001830160205260408120541515610af4565b6000806118996002546001600160a01b031690565b90506001600160a01b0381166118db576040517f6be4ac5200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b806001600160a01b0316633c383e7b866118fd600a546001600160a01b031690565b611905610ba4565b88886040518663ffffffff1660e01b815260040161192795949392919061216d565b602060405180830381865afa158015611944573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ad391906121c7565b600082600001828154811061197f5761197f6121e0565b9060005260206000200154905092915050565b6060816000018054806020026020016040519081016040528092919081815260200182805480156119e257602002820191906000526020600020905b8154815260200190600101908083116119ce575b50505050509050919050565b60008181526001830160205260408120548015611ad7576000611a1260018361220f565b8554909150600090611a269060019061220f565b9050808214611a8b576000866000018281548110611a4657611a466121e0565b9060005260206000200154905080876000018481548110611a6957611a696121e0565b6000918252602080832090910192909255918252600188019052604090208390555b8554869080611a9c57611a9c612249565b60019003818190600052602060002001600090559055856001016000868152602001908152602001600020600090556001935050505061068d565b600091505061068d565b60008181526001830160205260408120546117b95750815460018181018455600084815260208082209093018490558454848252828601909352604090209190915561068d565b60608282604051602001611b3d929190612278565b604051602081830303815290604052905092915050565b600060208284031215611b6657600080fd5b81357fffffffff0000000000000000000000000000000000000000000000000000000081168114610af457600080fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff81118282101715611c0c57611c0c611b96565b604052919050565b600060408284031215611c2657600080fd5b6040516040810181811067ffffffffffffffff82111715611c4957611c49611b96565b604052823581526020928301359281019290925250919050565b80356001600160a01b0381168114611c7a57600080fd5b919050565b600060208284031215611c9157600080fd5b610af482611c63565b600060208284031215611cac57600080fd5b5035919050565b60008083601f840112611cc557600080fd5b50813567ffffffffffffffff811115611cdd57600080fd5b602083019150836020828501011115611cf557600080fd5b9250929050565b600080600080600060808688031215611d1457600080fd5b853594506020860135935060408601359250606086013567ffffffffffffffff811115611d4057600080fd5b611d4c88828901611cb3565b969995985093965092949392505050565b6000815180845260005b81811015611d8357602081850181015186830182015201611d67565b5060006020828601015260207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f83011685010191505092915050565b600081518084526020808501945080840160005b83811015611dfa5781516001600160a01b031687529582019590820190600101611dd5565b509495945050505050565b604081526000611e186040830185611d5d565b8281036020840152610ad38185611dc1565b60008060408385031215611e3d57600080fd5b82359150611e4d60208401611c63565b90509250929050565b60008060408385031215611e6957600080fd5b50508035926020909101359150565b67ffffffffffffffff8116811461090757600080fd5b60008060008060008060a08789031215611ea757600080fd5b8635955060208701359450604087013593506060870135611ec781611e78565b9250608087013567ffffffffffffffff811115611ee357600080fd5b611eef89828a01611cb3565b979a9699509497509295939492505050565b60008060008060808587031215611f1757600080fd5b84359350602080860135935060408601359250606086013567ffffffffffffffff80821115611f4557600080fd5b818801915088601f830112611f5957600080fd5b813581811115611f6b57611f6b611b96565b611f9b847fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f84011601611bc5565b91508082528984828501011115611fb157600080fd5b808484018584013760008482840101525080935050505092959194509250565b81518152602080830151908201526040810161068d565b602081526000610af46020830184611dc1565b6000806040838503121561200e57600080fd5b61201783611c63565b91506020830135801515811461202c57600080fd5b809150509250929050565b86815285602082015284604082015267ffffffffffffffff8416606082015260a060808201528160a0820152818360c0830137600081830160c090810191909152601f9092017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016010195945050505050565b8681528560208201526001600160a01b038516604082015260c0606082015260006120d860c0830186611dc1565b82810360808401526120ea8186611d5d565b905082810360a08401526120fe8185611d5d565b9998505050505050505050565b60006060828403121561211d57600080fd5b6040516060810181811067ffffffffffffffff8211171561214057612140611b96565b80604052508251815260208301516020820152604083015161216181611e78565b60408201529392505050565b8581526001600160a01b038516602082015260a06040820152600061219560a0830186611dc1565b82810360608401526121a78186611d5d565b905082810360808401526121bb8185611d5d565b98975050505050505050565b6000602082840312156121d957600080fd5b5051919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b8181038181111561068d577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603160045260246000fd5b60ff831681526040602082015260006122946040830184611d5d565b94935050505056fea2646970667358221220854c346e357af8e31946cfd4e6252f3cf1c58f741ccbe71b54df75bb3bd5d80664736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/AbstractICAppEvents.sol\n\nabstract contract AbstractICAppEvents {\n    event InterchainClientAdded(address client);\n    event InterchainClientRemoved(address client);\n    event LatestClientSet(address client);\n}\n\n// contracts/events/InterchainAppV1Events.sol\n\nabstract contract InterchainAppV1Events {\n    event AppConfigV1Set(uint256 requiredResponses, uint256 optimisticPeriod);\n    event AppLinked(uint256 indexed chainId, bytes32 indexed remoteApp);\n    event ExecutionServiceSet(address executionService);\n    event TrustedModuleAdded(address module);\n    event TrustedModuleRemoved(address module);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    /// @notice Allows the Interchain Client to pass the message to the Interchain App.\n    /// @dev App is responsible for keeping track of interchain clients, and must verify the message sender.\n    /// @param srcChainId   Chain ID of the source chain, where the message was sent from.\n    /// @param sender       Sender address on the source chain, as a bytes32 value.\n    /// @param dbNonce      The Interchain DB nonce of the batch containing the message entry.\n    /// @param entryIndex   The index of the message entry within the batch.\n    /// @param message      The message being sent.\n    function appReceive(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /// @notice Returns the verification configuration of the Interchain App.\n    /// @dev This configuration is used by the Interchain Client to verify that message has been confirmed\n    /// by the Interchain Modules on the destination chain.\n    /// Note: V1 version of AppConfig includes the required responses count, and optimistic period after which\n    /// the message is considered confirmed by the module. Following versions may include additional fields.\n    /// @return appConfig    The versioned configuration of the Interchain App, encoded as bytes.\n    /// @return modules      The list of Interchain Modules that app is trusting to confirm the messages.\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    uint8 constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint8 version);\n\n    /// @notice Encodes versioned app config into a bytes format.\n    /// @param version      The version of the app config.\n    /// @param appConfig    The app config to encode.\n    function encodeVersionedAppConfig(uint8 version, bytes memory appConfig) internal pure returns (bytes memory) {\n        return abi.encode(version, appConfig);\n    }\n\n    /// @notice Decodes versioned app config from a bytes format back into a version and app config.\n    /// @param data         The versioned app config data in bytes format.\n    /// @return version     The version of the app config.\n    /// @return appConfig   The app config as bytes.\n    function decodeVersionedAppConfig(bytes memory data)\n        internal\n        pure\n        returns (uint8 version, bytes memory appConfig)\n    {\n        (version, appConfig) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return encodeVersionedAppConfig(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal pure returns (AppConfigV1 memory) {\n        (uint8 version, bytes memory appConfig) = decodeVersionedAppConfig(data);\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(appConfig, (AppConfigV1));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    uint8 constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint8 version);\n\n    /// @notice Encodes versioned options into a bytes format.\n    /// @param version      The version of the options.\n    /// @param options      The options to encode.\n    function encodeVersionedOptions(uint8 version, bytes memory options) internal pure returns (bytes memory) {\n        return abi.encode(version, options);\n    }\n\n    /// @notice Decodes versioned options from a bytes format back into a version and options.\n    /// @param data         The versioned options data in bytes format.\n    /// @return version     The version of the options.\n    /// @return options     The options as bytes.\n    function decodeVersionedOptions(bytes memory data) internal pure returns (uint8 version, bytes memory options) {\n        (version, options) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return encodeVersionedOptions(OPTIONS_V1, abi.encode(options));\n    }\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal pure returns (OptionsV1 memory) {\n        (uint8 version, bytes memory options) = decodeVersionedOptions(data);\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(options, (OptionsV1));\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/IAccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n\n// node_modules/@openzeppelin/contracts/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance \u003c amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance \u003c value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 \u0026\u0026 target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/libs/InterchainTransaction.sol\n\nstruct InterchainTransaction {\n    uint256 srcChainId;\n    bytes32 srcSender;\n    uint256 dstChainId;\n    bytes32 dstReceiver;\n    uint256 dbNonce;\n    uint64 entryIndex;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint256 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    function constructLocalTransaction(\n        address srcSender,\n        uint256 dstChainId,\n        bytes32 dstReceiver,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: block.chainid,\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(transaction);\n    }\n\n    function decodeTransaction(bytes memory encodedTx) internal pure returns (InterchainTransaction memory) {\n        return abi.decode(encodedTx, (InterchainTransaction));\n    }\n\n    function transactionId(InterchainTransaction memory transaction) internal pure returns (bytes32) {\n        return keccak256(abi.encode(transaction));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/IAccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/IAccessControlEnumerable.sol)\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n// contracts/interfaces/IInterchainAppV1.sol\n\ninterface IInterchainAppV1 is IInterchainApp {\n    error InterchainApp__AppZeroAddress();\n    error InterchainApp__InvalidAppConfig(uint256 requiredResponses, uint256 optimisticPeriod);\n    error InterchainApp__ModuleAlreadyAdded(address module);\n    error InterchainApp__ModuleNotAdded(address module);\n    error InterchainApp__ModuleZeroAddress();\n    error InterchainApp__NotEVMLinkedApp(bytes32 linkedApp);\n\n    /// @notice Allows the owner to add the interchain client to the allowed clients set,\n    /// and optionally set the latest client to this one.\n    /// Note: only the allowed clients can send messages to this app.\n    /// Note: the latest client is used for sending messages from this app.\n    /// @param client       The address of the interchain client to add.\n    /// @param updateLatest Whether to set the latest client to this one.\n    function addInterchainClient(address client, bool updateLatest) external;\n\n    /// @notice Allows the owner to remove the interchain client from the allowed clients set.\n    /// If the client is the latest client, the latest client is set to the zero address.\n    /// @param client       The address of the interchain client to remove.\n    function removeInterchainClient(address client) external;\n\n    /// @notice Allows the owner to set the address of the latest interchain client.\n    /// @dev The new latest client must be an allowed client or zero address.\n    /// Setting the client to zero address effectively pauses the app ability to send messages,\n    /// while allowing to receive them.\n    /// @param client       The address of the latest interchain client.\n    function setLatestInterchainClient(address client) external;\n\n    /// @notice Allows the owner to link the remote app for the given chain ID.\n    /// - This address will be used as the receiver for the messages sent from this chain.\n    /// - This address will be the only trusted sender for the messages sent to this chain.\n    /// @param chainId      The remote chain ID.\n    /// @param remoteApp    The address of the remote app to link.\n    function linkRemoteApp(uint256 chainId, bytes32 remoteApp) external;\n\n    /// @notice Thin wrapper for `linkRemoteApp` to accept EVM address as a parameter.\n    function linkRemoteAppEVM(uint256 chainId, address remoteApp) external;\n\n    /// @notice Allows the owner to add the module to the trusted modules set.\n    /// - This set of modules will be used to verify both sent and received messages.\n    function addTrustedModule(address module) external;\n\n    /// @notice Allows the owner to remove the module from the trusted modules set.\n    function removeTrustedModule(address module) external;\n\n    /// @notice Allows the owner to set the app config for the current app. App config includes:\n    /// - requiredResponses: the number of module responses required for accepting the message\n    /// - optimisticPeriod: the minimum time after which the module responses are considered final\n    function setAppConfigV1(AppConfigV1 memory appConfig) external;\n\n    /// @notice Allows the owner to set the address of the Execution Service.\n    /// This address will be used to request execution of the messages sent from this chain,\n    /// by supplying the Service's execution fee.\n    function setExecutionService(address executionService) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Returns the app config for the current app: requiredResponses and optimisticPeriod.\n    function getAppConfigV1() external view returns (AppConfigV1 memory);\n\n    /// @notice Returns the address of the Execution Service used by this app for sending messages.\n    function getExecutionService() external view returns (address);\n\n    /// @notice Returns the list of Interchain Clients allowed to send messages to this app.\n    function getInterchainClients() external view returns (address[] memory);\n\n    /// @notice Returns the address of the latest interchain client.\n    /// This address is used for sending messages from this app.\n    function getLatestInterchainClient() external view returns (address);\n\n    /// @notice Returns the linked app address (as bytes32) for the given chain ID.\n    function getLinkedApp(uint256 chainId) external view returns (bytes32);\n\n    /// @notice Thin wrapper for `getLinkedApp` to return the linked app address as EVM address.\n    /// @dev Will revert if the linked app address is not an EVM address.\n    function getLinkedAppEVM(uint256 chainId) external view returns (address);\n\n    /// @notice Returns the list of Interchain Modules trusted by this app.\n    /// This set of modules will be used to verify both sent and received messages.\n    function getModules() external view returns (address[] memory);\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint256 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__NoLinkedClient(uint256 chainId);\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint256 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint256 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint256 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint256 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint256 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param message              The message being sent.\n    function getInterchainFee(\n        uint256 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint256 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint256 chainId) external view returns (address);\n}\n\n// node_modules/@openzeppelin/contracts/access/AccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account =\u003e bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role =\u003e RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n// contracts/apps/AbstractICApp.sol\n\nabstract contract AbstractICApp is AbstractICAppEvents, IInterchainApp {\n    using TypeCasts for address;\n\n    error InterchainApp__AlreadyLatestClient(address client);\n    error InterchainApp__BalanceTooLow(uint256 actual, uint256 required);\n    error InterchainApp__ClientAlreadyAdded(address client);\n    error InterchainApp__InterchainClientZeroAddress();\n    error InterchainApp__NotInterchainClient(address account);\n    error InterchainApp__ReceiverNotSet(uint256 chainId);\n    error InterchainApp__SameChainId(uint256 chainId);\n    error InterchainApp__SenderNotAllowed(uint256 srcChainId, bytes32 sender);\n\n    /// @inheritdoc IInterchainApp\n    function appReceive(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        if (!_isInterchainClient(msg.sender)) {\n            revert InterchainApp__NotInterchainClient(msg.sender);\n        }\n        if (srcChainId == block.chainid) {\n            revert InterchainApp__SameChainId(srcChainId);\n        }\n        if (!_isAllowedSender(srcChainId, sender)) {\n            revert InterchainApp__SenderNotAllowed(srcChainId, sender);\n        }\n        _receiveMessage(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n\n    /// @inheritdoc IInterchainApp\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules) {\n        appConfig = _getAppConfig();\n        modules = _getModules();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Performs necessary checks and adds an Interchain Client.\n    /// Optionally sets the latest client to this one.\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _addClient(address client, bool updateLatest) internal {\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (_isInterchainClient(client)) {\n            revert InterchainApp__ClientAlreadyAdded(client);\n        }\n        _toggleClientState(client, true);\n        emit InterchainClientAdded(client);\n        if (updateLatest) {\n            _setLatestClient(client);\n        }\n    }\n\n    /// @dev Performs necessary checks and removes an Interchain Client. If this client is the latest one,\n    /// the latest client is set to zero address (effectively pausing the app ability to send messages).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _removeClient(address client) internal {\n        if (!_isInterchainClient(client)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        _toggleClientState(client, false);\n        emit InterchainClientRemoved(client);\n        if (client == _getLatestClient()) {\n            _setLatestClient(address(0));\n        }\n    }\n\n    /// @dev Sets the latest Interchain Client to one of the allowed clients. Setting the client to zero address\n    /// is allowed and effectively pauses the app ability to send messages (but still allows to receive them).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _setLatestClient(address client) internal {\n        // New latest client must be an allowed client or zero address.\n        if (!_isInterchainClient(client) \u0026\u0026 client != address(0)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        if (client == _getLatestClient()) {\n            revert InterchainApp__AlreadyLatestClient(client);\n        }\n        _storeLatestClient(client);\n        emit LatestClientSet(client);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal virtual;\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal virtual;\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to accept EVM address as a parameter.\n    function _sendInterchainMessageEVM(\n        uint256 dstChainId,\n        address receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _sendInterchainMessage(dstChainId, receiver.addressToBytes32(), messageFee, options, message);\n    }\n\n    /// @dev Performs necessary checks and sends an interchain message.\n    function _sendInterchainMessage(\n        uint256 dstChainId,\n        bytes32 receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (dstChainId == block.chainid) {\n            revert InterchainApp__SameChainId(dstChainId);\n        }\n        if (receiver == 0) {\n            revert InterchainApp__ReceiverNotSet(dstChainId);\n        }\n        if (address(this).balance \u003c messageFee) {\n            revert InterchainApp__BalanceTooLow({actual: address(this).balance, required: messageFee});\n        }\n        return IInterchainClientV1(client).interchainSend{value: messageFee}(\n            dstChainId, receiver, _getExecutionService(), _getModules(), options, message\n        );\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        virtual;\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee for sending an Interchain message.\n    function _getInterchainFee(\n        uint256 dstChainId,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        return IInterchainClientV1(client).getInterchainFee(\n            dstChainId, _getExecutionService(), _getModules(), options, message\n        );\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view virtual returns (bytes memory);\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view virtual returns (address);\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view virtual returns (address);\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view virtual returns (address[] memory);\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint256 srcChainId, bytes32 sender) internal view virtual returns (bool);\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view virtual returns (bool);\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/AccessControlEnumerable.sol)\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 role =\u003e EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {AccessControl-_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool granted = super._grantRole(role, account);\n        if (granted) {\n            _roleMembers[role].add(account);\n        }\n        return granted;\n    }\n\n    /**\n     * @dev Overload {AccessControl-_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool revoked = super._revokeRole(role, account);\n        if (revoked) {\n            _roleMembers[role].remove(account);\n        }\n        return revoked;\n    }\n}\n\n// contracts/apps/ICAppV1.sol\n\nabstract contract ICAppV1 is AbstractICApp, AccessControlEnumerable, InterchainAppV1Events, IInterchainAppV1 {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Role to manage the Interchain setup of the app.\n    bytes32 public constant IC_GOVERNOR_ROLE = keccak256(\"IC_GOVERNOR_ROLE\");\n\n    /// @dev Address of the latest Interchain Client, used for sending messages.\n    address private _latestClient;\n\n    /// @dev Required responses and optimistic period for the module responses.\n    AppConfigV1 private _appConfigV1;\n    /// @dev Address of the linked app deployed on the remote chain.\n    mapping(uint256 chainId =\u003e bytes32 remoteApp) private _linkedApp;\n    /// @dev Interchain Clients allowed to send messages to this app.\n    EnumerableSet.AddressSet private _interchainClients;\n    /// @dev Trusted Interchain modules.\n    EnumerableSet.AddressSet private _trustedModules;\n    /// @dev Execution Service to use for sending messages.\n    address private _executionService;\n\n    constructor(address admin) {\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addInterchainClient(address client, bool updateLatest) external onlyRole(IC_GOVERNOR_ROLE) {\n        _addClient(client, updateLatest);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _removeClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setLatestInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _setLatestClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteApp(uint256 chainId, bytes32 remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteAppEVM(uint256 chainId, address remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp.addressToBytes32());\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (module == address(0)) {\n            revert InterchainApp__ModuleZeroAddress();\n        }\n        bool added = _trustedModules.add(module);\n        if (!added) {\n            revert InterchainApp__ModuleAlreadyAdded(module);\n        }\n        emit TrustedModuleAdded(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        bool removed = _trustedModules.remove(module);\n        if (!removed) {\n            revert InterchainApp__ModuleNotAdded(module);\n        }\n        emit TrustedModuleRemoved(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setAppConfigV1(AppConfigV1 memory appConfig) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (appConfig.requiredResponses == 0 || appConfig.optimisticPeriod == 0) {\n            revert InterchainApp__InvalidAppConfig(appConfig.requiredResponses, appConfig.optimisticPeriod);\n        }\n        _appConfigV1 = appConfig;\n        emit AppConfigV1Set(appConfig.requiredResponses, appConfig.optimisticPeriod);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setExecutionService(address executionService) external onlyRole(IC_GOVERNOR_ROLE) {\n        _executionService = executionService;\n        emit ExecutionServiceSet(executionService);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainAppV1\n    function getAppConfigV1() external view returns (AppConfigV1 memory) {\n        return _appConfigV1;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getExecutionService() external view returns (address) {\n        return _executionService;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getInterchainClients() external view returns (address[] memory) {\n        return _interchainClients.values();\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLatestInterchainClient() external view returns (address) {\n        return _latestClient;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedApp(uint256 chainId) external view returns (bytes32) {\n        return _linkedApp[chainId];\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedAppEVM(uint256 chainId) external view returns (address linkedAppEVM) {\n        bytes32 linkedApp = _linkedApp[chainId];\n        linkedAppEVM = linkedApp.bytes32ToAddress();\n        if (linkedAppEVM.addressToBytes32() != linkedApp) {\n            revert InterchainApp__NotEVMLinkedApp(linkedApp);\n        }\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getModules() external view returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Links the remote app to the current app.\n    /// Will revert if the chainId is the same as the chainId of the local app.\n    /// Note: Should be guarded with permissions check.\n    function _linkRemoteApp(uint256 chainId, bytes32 remoteApp) internal {\n        if (chainId == block.chainid) {\n            revert InterchainApp__SameChainId(chainId);\n        }\n        if (remoteApp == 0) {\n            revert InterchainApp__AppZeroAddress();\n        }\n        _linkedApp[chainId] = remoteApp;\n        emit AppLinked(chainId, remoteApp);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal override {\n        _latestClient = client;\n    }\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal override {\n        if (allowed) {\n            _interchainClients.add(client);\n        } else {\n            _interchainClients.remove(client);\n        }\n    }\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to send the message to the linked app.\n    function _sendToLinkedApp(\n        uint256 dstChainId,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _sendInterchainMessage(dstChainId, _linkedApp[dstChainId], messageFee, encodedOptions, message);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee to send a message to the linked app on the remote chain.\n    function _getMessageFee(\n        uint256 dstChainId,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _getInterchainFee(dstChainId, encodedOptions, message);\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view override returns (bytes memory) {\n        return _appConfigV1.encodeAppConfigV1();\n    }\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view override returns (address) {\n        return _executionService;\n    }\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view override returns (address) {\n        return _latestClient;\n    }\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view override returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint256 srcChainId, bytes32 sender) internal view override returns (bool) {\n        return _linkedApp[srcChainId] == sender;\n    }\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view override returns (bool) {\n        return _interchainClients.contains(caller);\n    }\n}\n\n// contracts/apps/examples/ExampleAppV1.sol\n\ncontract ExampleAppV1 is ICAppV1 {\n    event MessageReceived(uint256 srcChainId, bytes32 sender, uint256 dbNonce, uint64 entryIndex, bytes message);\n    event MessageSent(uint256 dstChainId, uint256 dbNonce, uint64 entryIndex, bytes32 transactionId);\n\n    constructor(address admin) ICAppV1(admin) {\n        _grantRole(IC_GOVERNOR_ROLE, admin);\n    }\n\n    /// @notice Allows the Admin to withdraw the native asset from the contract.\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        Address.sendValue(payable(msg.sender), address(this).balance);\n    }\n\n    /// @notice Sends a basic message to the destination chain.\n    function sendMessage(\n        uint256 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        InterchainTxDescriptor memory desc = _sendToLinkedApp({\n            dstChainId: dstChainId,\n            messageFee: msg.value,\n            options: OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}),\n            message: message\n        });\n        emit MessageSent(dstChainId, desc.dbNonce, desc.entryIndex, desc.transactionId);\n    }\n\n    /// @notice Returns the fee required to send a message using `sendMessage`.\n    function getMessageFee(\n        uint256 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes memory message\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _getMessageFee(dstChainId, OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}), message);\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        override\n    {\n        emit MessageReceived(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"76529:1988:0:-:0;;;76785:94;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;76820:5;67598:37;50149:4;76820:5;67598:10;:37::i;:::-;-1:-1:-1;76837:35:0::1;::::0;-1:-1:-1;66829:29:0::1;76866:5:::0;76837:10:::1;:35::i;:::-;;76785:94:::0;76529:1988;;65829:257;65915:4;;65946:31;65963:4;65969:7;65946:16;:31::i;:::-;65931:46;;65991:7;65987:69;;;66014:18;;;;:12;:18;;;;;:31;;66037:7;66014:22;:31::i;:::-;;65987:69;66072:7;-1:-1:-1;65829:257:0;;;;;:::o;54096:316::-;54173:4;50871:12;;;;;;;;;;;-1:-1:-1;;;;;50871:29:0;;;;;;;;;;;;54189:217;;54232:6;:12;;;;;;;;;;;-1:-1:-1;;;;;54232:29:0;;;;;;;;;:36;;-1:-1:-1;;54232:36:0;54264:4;54232:36;;;54314:12;17741:10;;17662:96;54314:12;-1:-1:-1;;;;;54287:40:0;54305:7;-1:-1:-1;;;;;54287:40:0;54299:4;54287:40;;;;;;;;;;-1:-1:-1;54348:4:0;54341:11;;54189:217;-1:-1:-1;54390:5:0;54383:12;;27186:150;27256:4;27279:50;27284:3;-1:-1:-1;;;;;27304:23:0;;21174:4;23230:21;;;:14;;;:21;;;;;;21190:321;;-1:-1:-1;21232:23:0;;;;;;;;:11;:23;;;;;;;;;;;;;21414:18;;21390:21;;;:14;;;:21;;;;;;:42;;;;21446:11;;14:290:1;84:6;137:2;125:9;116:7;112:23;108:32;105:52;;;153:1;150;143:12;105:52;179:16;;-1:-1:-1;;;;;224:31:1;;214:42;;204:70;;270:1;267;260:12;14:290;76529:1988:0;;;;;;","srcMapRuntime":"76529:1988:0:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;64489:212;;;;;;;;;;-1:-1:-1;64489:212:0;;;;;:::i;:::-;;:::i;:::-;;;516:14:1;;509:22;491:41;;479:2;464:18;64489:212:0;;;;;;;;69348:419;;;;;;;;;;-1:-1:-1;69348:419:0;;;;;:::i;:::-;;:::i;:::-;;67877:122;;;;;;;;;;-1:-1:-1;67877:122:0;;;;;:::i;:::-;;:::i;66786:72::-;;;;;;;;;;;;66829:29;66786:72;;;;;2120:25:1;;;2108:2;2093:18;66786:72:0;1974:177:1;51727:120:0;;;;;;;;;;-1:-1:-1;51727:120:0;;;;;:::i;:::-;51792:7;51818:12;;;;;;;;;;:22;;;;51727:120;77172:528;;;;;;:::i;:::-;;:::i;56354:180::-;;;;;;;;;;;;;:::i;:::-;;;;;;;;:::i;52143:136::-;;;;;;;;;;-1:-1:-1;52143:136:0;;;;;:::i;:::-;;:::i;53245:245::-;;;;;;;;;;-1:-1:-1;53245:245:0;;;;;:::i;:::-;;:::i;76966:136::-;;;;;;;;;;;;;:::i;69810:196::-;;;;;;;;;;-1:-1:-1;69810:196:0;;;;;:::i;:::-;;:::i;68213:146::-;;;;;;;;;;-1:-1:-1;68213:146:0;;;;;:::i;:::-;;:::i;55660:653::-;;;;;;:::i;:::-;;:::i;77786:317::-;;;;;;;;;;-1:-1:-1;77786:317:0;;;;;:::i;:::-;;:::i;70383:105::-;;;;;;;;;;-1:-1:-1;;;;;;;;;;;;;;;;;;70462:19:0;;;;;;;;70469:12;70462:19;;;;;;;;;70383:105;;;;;;:::i;65286:142::-;;;;;;;;;;-1:-1:-1;65286:142:0;;;;;:::i;:::-;;:::i;:::-;;;-1:-1:-1;;;;;8159:55:1;;;8141:74;;8129:2;8114:18;65286:142:0;7995:226:1;50771:136:0;;;;;;;;;;-1:-1:-1;50771:136:0;;;;;:::i;:::-;50848:4;50871:12;;;;;;;;;;;-1:-1:-1;;;;;50871:29:0;;;;;;;;;;;;;;;50771:136;70678:124;;;;;;;;;;;;;:::i;:::-;;;;;;;:::i;50104:49::-;;;;;;;;;;-1:-1:-1;50104:49:0;50149:4;50104:49;;71151:328;;;;;;;;;;-1:-1:-1;71151:328:0;;;;;:::i;:::-;;:::i;68402:168::-;;;;;;;;;;-1:-1:-1;68402:168:0;;;;;:::i;:::-;;:::i;71522:111::-;;;;;;;;;;;;;:::i;69027:278::-;;;;;;;;;;-1:-1:-1;69027:278:0;;;;;:::i;:::-;;:::i;70994:114::-;;;;;;;;;;-1:-1:-1;70994:114:0;;;;;:::i;:::-;71056:7;71082:19;;;:10;:19;;;;;;;70994:114;70845:106;;;;;;;;;;-1:-1:-1;70931:13:0;;-1:-1:-1;;;;;70931:13:0;70845:106;;70531:104;;;;;;;;;;-1:-1:-1;70611:17:0;;-1:-1:-1;;;;;70611:17:0;70531:104;;65596:131;;;;;;;;;;-1:-1:-1;65596:131:0;;;;;:::i;:::-;;:::i;68613:371::-;;;;;;;;;;-1:-1:-1;68613:371:0;;;;;:::i;:::-;;:::i;52559:138::-;;;;;;;;;;-1:-1:-1;52559:138:0;;;;;:::i;:::-;;:::i;68042:128::-;;;;;;;;;;-1:-1:-1;68042:128:0;;;;;:::i;:::-;;:::i;67685:149::-;;;;;;;;;;-1:-1:-1;67685:149:0;;;;;:::i;:::-;;:::i;64489:212::-;64574:4;64597:57;;;64612:42;64597:57;;:97;;;64658:36;64682:11;64658:23;:36::i;:::-;64590:104;64489:212;-1:-1:-1;;64489:212:0:o;69348:419::-;66829:29;50381:16;50392:4;50381:10;:16::i;:::-;69452:27;;:32;;:67:::1;;-1:-1:-1::0;69488:26:0::1;::::0;::::1;::::0;:31;69452:67:::1;69448:193;;;69574:27:::0;;69603:26:::1;::::0;::::1;::::0;69542:88:::1;::::0;::::1;::::0;;::::1;::::0;::::1;9462:25:1::0;;;;9503:18;;;9496:34;9435:18;;69542:88:0::1;;;;;;;;69448:193;69650:24:::0;;:12:::1;:24:::0;;;::::1;::::0;;::::1;::::0;;;;;69689:71:::1;::::0;;9462:25:1;;;9503:18;;;9496:34;69689:71:0::1;::::0;9435:18:1;69689:71:0::1;;;;;;;;69348:419:::0;;:::o;67877:122::-;66829:29;50381:16;50392:4;50381:10;:16::i;:::-;67971:21:::1;67985:6;67971:13;:21::i;:::-;67877:122:::0;;:::o;77172:528::-;77360:34;77397:207;77440:10;77476:9;77508:55;;;;;;;;77529:8;77508:55;;;;77551:10;77508:55;;;77586:7;;77397:207;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;77397:16:0;;-1:-1:-1;;;77397:207:0:i;:::-;77643:12;;;;;77657:15;;;;;77674:18;;77619:74;;9770:25:1;;;9811:18;;;9804:34;;;;9886:18;9874:31;9854:18;;;9847:59;9937:2;9922:18;;9915:34;77360:244:0;;-1:-1:-1;77619:74:0;;9757:3:1;9742:19;77619:74:0;;;;;;;;77350:350;77172:528;;;;;:::o;56354:180::-;56407:22;56431:24;56479:15;:13;:15::i;:::-;56467:27;;56514:13;:11;:13::i;:::-;56504:23;;56354:180;;:::o;52143:136::-;51792:7;51818:12;;;;;;;;;;:22;;;50381:16;50392:4;50381:10;:16::i;:::-;52247:25:::1;52258:4;52264:7;52247:10;:25::i;:::-;;52143:136:::0;;;:::o;53245:245::-;-1:-1:-1;;;;;53338:34:0;;17741:10;53338:34;53334:102;;53395:30;;;;;;;;;;;;;;53334:102;53446:37;53458:4;53464:18;53446:11;:37::i;:::-;;53245:245;;:::o;76966:136::-;50149:4;50381:16;50149:4;50381:10;:16::i;:::-;77034:61:::1;77060:10;77073:21;77034:17;:61::i;:::-;76966:136:::0;:::o;69810:196::-;66829:29;50381:16;50392:4;50381:10;:16::i;:::-;69911:17:::1;:36:::0;;;::::1;-1:-1:-1::0;;;;;69911:36:0;::::1;::::0;;::::1;::::0;;;69962:37:::1;::::0;8141:74:1;;;69962:37:0::1;::::0;8129:2:1;8114:18;69962:37:0::1;7995:226:1::0;68213:146:0;66829:29;50381:16;50392:4;50381:10;:16::i;:::-;68318:34:::1;68333:7;68342:9;68318:14;:34::i;55660:653::-:0;55874:31;55894:10;55874:19;:31::i;:::-;55869:116;;55928:46;;;;;55963:10;55928:46;;;8141:74:1;8114:18;;55928:46:0;7995:226:1;55869:116:0;56012:13;55998:10;:27;55994:103;;56048:38;;;;;;;;2120:25:1;;;2093:18;;56048:38:0;1974:177:1;55994:103:0;76127:4;76150:22;;;:10;:22;;;;;;:32;;56106:126;;56170:51;;;;;;;;9462:25:1;;;9503:18;;;9496:34;;;9435:18;;56170:51:0;9288:248:1;56106:126:0;56241:65;56257:10;56269:6;56277:7;56286:10;56298:7;;56241:15;:65::i;:::-;55660:653;;;;;;:::o;77786:317::-;77974:7;78004:92;78019:10;78031:55;;;;;;;;78052:8;78031:55;;;;78074:10;78031:55;;;78088:7;78004:14;:92::i;:::-;77997:99;77786:317;-1:-1:-1;;;;;77786:317:0:o;65286:142::-;65367:7;65393:18;;;:12;:18;;;;;:28;;65415:5;65393:21;:28::i;:::-;65386:35;65286:142;-1:-1:-1;;;65286:142:0:o;70678:124::-;70733:16;70768:27;:18;:25;:27::i;:::-;70761:34;;70678:124;:::o;71151:328::-;71216:20;71268:19;;;:10;:19;;;;;;;-1:-1:-1;;;;;71354:29:0;;:44;;71350:123;;71421:41;;;;;;;;2120:25:1;;;2093:18;;71421:41:0;1974:177:1;71350:123:0;71238:241;71151:328;;;:::o;68402:168::-;66829:29;50381:16;50392:4;50381:10;:16::i;:::-;68510:53:::1;68525:7:::0;-1:-1:-1;;;;;68534:26:0;::::1;68510:14;:53::i;71522:111::-:0;71567:16;71602:24;:15;:22;:24::i;69027:278::-;66829:29;50381:16;50392:4;50381:10;:16::i;:::-;69118:12:::1;69133:30;:15;69156:6:::0;69133:22:::1;:30::i;:::-;69118:45;;69178:7;69173:83;;69208:37;::::0;::::1;::::0;;-1:-1:-1;;;;;8159:55:1;;69208:37:0::1;::::0;::::1;8141:74:1::0;8114:18;;69208:37:0::1;7995:226:1::0;69173:83:0::1;69270:28;::::0;-1:-1:-1;;;;;8159:55:1;;8141:74;;69270:28:0::1;::::0;8129:2:1;8114:18;69270:28:0::1;;;;;;;;69108:197;69027:278:::0;;:::o;65596:131::-;65667:7;65693:18;;;:12;:18;;;;;:27;;:25;:27::i;68613:371::-;66829:29;50381:16;50392:4;50381:10;:16::i;:::-;-1:-1:-1;;;;;68705:20:0;::::1;68701:92;;68748:34;;;;;;;;;;;;;;68701:92;68802:10;68815:27;:15;68835:6:::0;68815:19:::1;:27::i;:::-;68802:40;;68857:5;68852:85;;68885:41;::::0;::::1;::::0;;-1:-1:-1;;;;;8159:55:1;;68885:41:0::1;::::0;::::1;8141:74:1::0;8114:18;;68885:41:0::1;7995:226:1::0;68852:85:0::1;68951:26;::::0;-1:-1:-1;;;;;8159:55:1;;8141:74;;68951:26:0::1;::::0;8129:2:1;8114:18;68951:26:0::1;7995:226:1::0;52559:138:0;51792:7;51818:12;;;;;;;;;;:22;;;50381:16;50392:4;50381:10;:16::i;:::-;52664:26:::1;52676:4;52682:7;52664:11;:26::i;68042:128::-:0;66829:29;50381:16;50392:4;50381:10;:16::i;:::-;68139:24:::1;68156:6;68139:16;:24::i;67685:149::-:0;66829:29;50381:16;50392:4;50381:10;:16::i;:::-;67795:32:::1;67806:6;67814:12;67795:10;:32::i;50482:202::-:0;50567:4;50590:47;;;50605:32;50590:47;;:87;;-1:-1:-1;35606:25:0;35591:40;;;;50641:36;35492:146;51116:103;51182:30;51193:4;17741:10;51182;:30::i;57808:357::-;57871:27;57891:6;57871:19;:27::i;:::-;57866:108;;57921:42;;;;;-1:-1:-1;;;;;8159:55:1;;57921:42:0;;;8141:74:1;8114:18;;57921:42:0;7995:226:1;57866:108:0;57983:33;58002:6;58010:5;57983:18;:33::i;:::-;58031:31;;-1:-1:-1;;;;;8159:55:1;;8141:74;;58031:31:0;;8129:2:1;8114:18;58031:31:0;;;;;;;70931:13;;-1:-1:-1;;;;;70931:13:0;-1:-1:-1;;;;;58076:28:0;:6;-1:-1:-1;;;;;58076:28:0;;58072:87;;58120:28;58145:1;58120:16;:28::i;73927:405::-;-1:-1:-1;;;;;;;;;;;;;;;;;;;;;;;;;74188:25:0;:7;:23;:25::i;:::-;74265:22;;;;:10;:22;;;;;;74158:55;;-1:-1:-1;74230:95:0;;74253:10;;74289;74158:55;74317:7;74230:22;:95::i;:::-;74223:102;73927:405;-1:-1:-1;;;;;;73927:405:0:o;75159:127::-;75247:30;;;;;;;;;:12;:30;;;;;;;;;75216:12;;75247:32;;:30;:32::i;65829:257::-;65915:4;65931:12;65946:31;65963:4;65969:7;65946:16;:31::i;:::-;65931:46;;65991:7;65987:69;;;66014:18;;;;:12;:18;;;;;:31;;66037:7;66014:22;:31::i;:::-;;66072:7;65829:257;-1:-1:-1;;;65829:257:0:o;66189:262::-;66276:4;66292:12;66307:32;66325:4;66331:7;66307:17;:32::i;:::-;66292:47;;66353:7;66349:72;;;66376:18;;;;:12;:18;;;;;:34;;66402:7;66376:25;:34::i;12273:331::-;12382:6;12358:21;:30;12354:109;;;12411:41;;;;;12446:4;12411:41;;;8141:74:1;8114:18;;12411:41:0;7995:226:1;12354:109:0;12474:12;12492:9;-1:-1:-1;;;;;12492:14:0;12514:6;12492:33;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;12473:52;;;12540:7;12535:63;;12570:17;;;;;;;;;;;;;;72133:359;72227:13;72216:7;:24;72212:97;;72263:35;;;;;;;;2120:25:1;;;2093:18;;72263:35:0;1974:177:1;72212:97:0;72335:1;72322:14;;;72318:83;;72359:31;;;;;;;;;;;;;;72318:83;72410:19;;;;:10;:19;;;;;;:31;;;72456:29;72432:9;;72421:7;;72456:29;;72410:19;72456:29;72133:359;;:::o;76338:142::-;76415:4;76438:35;:18;76466:6;76438:27;:35::i;78223:292::-;78443:65;78459:10;78471:6;78479:7;78488:10;78500:7;;78443:65;;;;;;;;;;;:::i;74740:325::-;74909:7;74932:27;74962:25;:7;:23;:25::i;:::-;74932:55;;75004:54;75022:10;75034:14;75050:7;75004:17;:54::i;28444:156::-;28518:7;28568:22;28572:3;28584:5;28568:3;:22::i;29140:300::-;29203:16;29231:22;29256:19;29264:3;29256:7;:19::i;27504:156::-;27577:4;27600:53;27608:3;-1:-1:-1;;;;;27628:23:0;;27600:7;:53::i;27987:115::-;28050:7;28076:19;28084:3;23426:18;;23344:107;27186:150;27256:4;27279:50;27284:3;-1:-1:-1;;;;;27304:23:0;;27279:4;:50::i;58476:462::-;58614:27;58634:6;58614:19;:27::i;:::-;58613:28;:52;;;;-1:-1:-1;;;;;;58645:20:0;;;;58613:52;58609:132;;;58688:42;;;;;-1:-1:-1;;;;;8159:55:1;;58688:42:0;;;8141:74:1;8114:18;;58688:42:0;7995:226:1;58609:132:0;70931:13;;-1:-1:-1;;;;;70931:13:0;-1:-1:-1;;;;;58754:28:0;:6;-1:-1:-1;;;;;58754:28:0;;58750:108;;58805:42;;;;;-1:-1:-1;;;;;8159:55:1;;58805:42:0;;;8141:74:1;8114:18;;58805:42:0;7995:226:1;58750:108:0;72848:13;:22;;;;-1:-1:-1;;;;;72848:22:0;;;;;58908:23;;-1:-1:-1;;;;;8159:55:1;;8141:74;;58908:23:0;;8129:2:1;8114:18;58908:23:0;;;;;;;58476:462;:::o;57050:459::-;-1:-1:-1;;;;;57128:20:0;;57124:102;;57171:44;;;;;;;;;;;;;;57124:102;57239:27;57259:6;57239:19;:27::i;:::-;57235:106;;;57289:41;;;;;-1:-1:-1;;;;;8159:55:1;;57289:41:0;;;8141:74:1;8114:18;;57289:41:0;7995:226:1;57235:106:0;57350:32;57369:6;57377:4;57350:18;:32::i;:::-;57397:29;;-1:-1:-1;;;;;8159:55:1;;8141:74;;57397:29:0;;8129:2:1;8114:18;57397:29:0;;;;;;;57440:12;57436:67;;;57468:24;57485:6;57468:16;:24::i;51349:197::-;50848:4;50871:12;;;;;;;;;;;-1:-1:-1;;;;;50871:29:0;;;;;;;;;;;;51432:108;;51482:47;;;;;-1:-1:-1;;;;;11380:55:1;;51482:47:0;;;11362:74:1;11452:18;;;11445:34;;;11335:18;;51482:47:0;11188:297:1;73296:224:0;73386:7;73382:132;;;73409:30;:18;73432:6;73409:22;:30::i;73382:132::-;73470:33;:18;73496:6;73470:25;:33::i;6217:167::-;6291:12;6322:55;5250:1;6368:7;6357:19;;;;;;;;:::i;:::-;;;;;;;;;;;;;6322:22;:55::i;60635:973::-;-1:-1:-1;;;;;;;;;;;;;;;;;;;;;;;;;60899:14:0;60916:18;70931:13;;-1:-1:-1;;;;;70931:13:0;;70845:106;60916:18;60899:35;-1:-1:-1;;;;;;60948:20:0;;60944:102;;60991:44;;;;;;;;;;;;;;60944:102;61073:13;61059:10;:27;61055:103;;61109:38;;;;;;;;2120:25:1;;;2093:18;;61109:38:0;1974:177:1;61055:103:0;61183:1;61171:13;;;61167:92;;61207:41;;;;;;;;2120:25:1;;;2093:18;;61207:41:0;1974:177:1;61167:92:0;61296:10;61272:21;:34;61268:155;;;61329:83;;;;;61367:21;61329:83;;;9462:25:1;9503:18;;;9496:34;;;9435:18;;61329:83:0;9288:248:1;61268:155:0;61459:6;-1:-1:-1;;;;;61439:42:0;;61489:10;61514;61526:8;61536:22;70611:17;;-1:-1:-1;;;;;70611:17:0;;70531:104;61536:22;61560:13;:11;:13::i;:::-;61575:7;61584;61439:162;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;61432:169;60635:973;-1:-1:-1;;;;;;;60635:973:0:o;54096:316::-;54173:4;50871:12;;;;;;;;;;;-1:-1:-1;;;;;50871:29:0;;;;;;;;;;;;54189:217;;54232:6;:12;;;;;;;;;;;-1:-1:-1;;;;;54232:29:0;;;;;;;;;:36;;;;54264:4;54232:36;;;54314:12;17741:10;;17662:96;54314:12;-1:-1:-1;;;;;54287:40:0;54305:7;-1:-1:-1;;;;;54287:40:0;54299:4;54287:40;;;;;;;;;;-1:-1:-1;54348:4:0;54341:11;;54189:217;-1:-1:-1;54390:5:0;54383:12;;54647:317;54725:4;50871:12;;;;;;;;;;;-1:-1:-1;;;;;50871:29:0;;;;;;;;;;;;54741:217;;;54815:5;54783:12;;;;;;;;;;;-1:-1:-1;;;;;54783:29:0;;;;;;;;;;:37;;;;;;54839:40;17741:10;;54783:12;;54839:40;;54815:5;54839:40;-1:-1:-1;54900:4:0;54893:11;;27741:165;-1:-1:-1;;;;;27874:23:0;;27821:4;23230:21;;;:14;;;:21;;;;;;:26;;27844:55;23134:129;62314:496;62482:7;62505:14;62522:18;70931:13;;-1:-1:-1;;;;;70931:13:0;;70845:106;62522:18;62505:35;-1:-1:-1;;;;;;62554:20:0;;62550:102;;62597:44;;;;;;;;;;;;;;62550:102;62688:6;-1:-1:-1;;;;;62668:44:0;;62726:10;62738:22;70611:17;;-1:-1:-1;;;;;70611:17:0;;70531:104;62738:22;62762:13;:11;:13::i;:::-;62777:7;62786;62668:135;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;23793:118::-;23860:7;23886:3;:11;;23898:5;23886:18;;;;;;;;:::i;:::-;;;;;;;;;23879:25;;23793:118;;;;:::o;24451:109::-;24507:16;24542:3;:11;;24535:18;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;24451:109;;;:::o;21685:1368::-;21751:4;21880:21;;;:14;;;:21;;;;;;21916:13;;21912:1135;;22283:18;22304:12;22315:1;22304:8;:12;:::i;:::-;22350:18;;22283:33;;-1:-1:-1;22330:17:0;;22350:22;;22371:1;;22350:22;:::i;:::-;22330:42;;22405:9;22391:10;:23;22387:378;;22434:17;22454:3;:11;;22466:9;22454:22;;;;;;;;:::i;:::-;;;;;;;;;22434:42;;22601:9;22575:3;:11;;22587:10;22575:23;;;;;;;;:::i;:::-;;;;;;;;;;;;:35;;;;22714:25;;;:14;;;:25;;;;;:36;;;22387:378;22843:17;;:3;;:17;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;22946:3;:14;;:21;22961:5;22946:21;;;;;;;;;;;22939:28;;;22989:4;22982:11;;;;;;;21912:1135;23031:5;23024:12;;;;;21111:406;21174:4;23230:21;;;:14;;;:21;;;;;;21190:321;;-1:-1:-1;21232:23:0;;;;;;;;:11;:23;;;;;;;;;;;;;21414:18;;21390:21;;;:14;;;:21;;;;;;:42;;;;21446:11;;5484:158;5576:12;5618:7;5627;5607:28;;;;;;;;;:::i;:::-;;;;;;;;;;;;;5600:35;;5484:158;;;;:::o;14:332:1:-;72:6;125:2;113:9;104:7;100:23;96:32;93:52;;;141:1;138;131:12;93:52;180:9;167:23;230:66;223:5;219:78;212:5;209:89;199:117;;312:1;309;302:12;543:184;595:77;592:1;585:88;692:4;689:1;682:15;716:4;713:1;706:15;732:334;803:2;797:9;859:2;849:13;;864:66;845:86;833:99;;962:18;947:34;;983:22;;;944:62;941:88;;;1009:18;;:::i;:::-;1045:2;1038:22;732:334;;-1:-1:-1;732:334:1:o;1071:506::-;1157:6;1210:2;1198:9;1189:7;1185:23;1181:32;1178:52;;;1226:1;1223;1216:12;1178:52;1259:2;1253:9;1301:2;1293:6;1289:15;1370:6;1358:10;1355:22;1334:18;1322:10;1319:34;1316:62;1313:88;;;1381:18;;:::i;:::-;1417:2;1410:22;1456:23;;1441:39;;1541:2;1526:18;;;1513:32;1496:15;;;1489:57;;;;-1:-1:-1;1448:6:1;1071:506;-1:-1:-1;1071:506:1:o;1582:196::-;1650:20;;-1:-1:-1;;;;;1699:54:1;;1689:65;;1679:93;;1768:1;1765;1758:12;1679:93;1582:196;;;:::o;1783:186::-;1842:6;1895:2;1883:9;1874:7;1870:23;1866:32;1863:52;;;1911:1;1908;1901:12;1863:52;1934:29;1953:9;1934:29;:::i;2156:180::-;2215:6;2268:2;2256:9;2247:7;2243:23;2239:32;2236:52;;;2284:1;2281;2274:12;2236:52;-1:-1:-1;2307:23:1;;2156:180;-1:-1:-1;2156:180:1:o;2341:347::-;2392:8;2402:6;2456:3;2449:4;2441:6;2437:17;2433:27;2423:55;;2474:1;2471;2464:12;2423:55;-1:-1:-1;2497:20:1;;2540:18;2529:30;;2526:50;;;2572:1;2569;2562:12;2526:50;2609:4;2601:6;2597:17;2585:29;;2661:3;2654:4;2645:6;2637;2633:19;2629:30;2626:39;2623:59;;;2678:1;2675;2668:12;2623:59;2341:347;;;;;:::o;2693:614::-;2790:6;2798;2806;2814;2822;2875:3;2863:9;2854:7;2850:23;2846:33;2843:53;;;2892:1;2889;2882:12;2843:53;2928:9;2915:23;2905:33;;2985:2;2974:9;2970:18;2957:32;2947:42;;3036:2;3025:9;3021:18;3008:32;2998:42;;3091:2;3080:9;3076:18;3063:32;3118:18;3110:6;3107:30;3104:50;;;3150:1;3147;3140:12;3104:50;3189:58;3239:7;3230:6;3219:9;3215:22;3189:58;:::i;:::-;2693:614;;;;-1:-1:-1;2693:614:1;;-1:-1:-1;3266:8:1;;3163:84;2693:614;-1:-1:-1;;;2693:614:1:o;3312:481::-;3353:3;3391:5;3385:12;3418:6;3413:3;3406:19;3443:1;3453:162;3467:6;3464:1;3461:13;3453:162;;;3529:4;3585:13;;;3581:22;;3575:29;3557:11;;;3553:20;;3546:59;3482:12;3453:162;;;3457:3;3660:1;3653:4;3644:6;3639:3;3635:16;3631:27;3624:38;3782:4;3712:66;3707:2;3699:6;3695:15;3691:88;3686:3;3682:98;3678:109;3671:116;;;3312:481;;;;:::o;3798:484::-;3851:3;3889:5;3883:12;3916:6;3911:3;3904:19;3942:4;3971:2;3966:3;3962:12;3955:19;;4008:2;4001:5;3997:14;4029:1;4039:218;4053:6;4050:1;4047:13;4039:218;;;4118:13;;-1:-1:-1;;;;;4114:62:1;4102:75;;4197:12;;;;4232:15;;;;4075:1;4068:9;4039:218;;;-1:-1:-1;4273:3:1;;3798:484;-1:-1:-1;;;;;3798:484:1:o;4287:421::-;4512:2;4501:9;4494:21;4475:4;4538:44;4578:2;4567:9;4563:18;4555:6;4538:44;:::i;:::-;4630:9;4622:6;4618:22;4613:2;4602:9;4598:18;4591:50;4658:44;4695:6;4687;4658:44;:::i;4713:254::-;4781:6;4789;4842:2;4830:9;4821:7;4817:23;4813:32;4810:52;;;4858:1;4855;4848:12;4810:52;4894:9;4881:23;4871:33;;4923:38;4957:2;4946:9;4942:18;4923:38;:::i;:::-;4913:48;;4713:254;;;;;:::o;4972:248::-;5040:6;5048;5101:2;5089:9;5080:7;5076:23;5072:32;5069:52;;;5117:1;5114;5107:12;5069:52;-1:-1:-1;;5140:23:1;;;5210:2;5195:18;;;5182:32;;-1:-1:-1;4972:248:1:o;5225:129::-;5310:18;5303:5;5299:30;5292:5;5289:41;5279:69;;5344:1;5341;5334:12;5359:748;5464:6;5472;5480;5488;5496;5504;5557:3;5545:9;5536:7;5532:23;5528:33;5525:53;;;5574:1;5571;5564:12;5525:53;5610:9;5597:23;5587:33;;5667:2;5656:9;5652:18;5639:32;5629:42;;5718:2;5707:9;5703:18;5690:32;5680:42;;5772:2;5761:9;5757:18;5744:32;5785:30;5809:5;5785:30;:::i;:::-;5834:5;-1:-1:-1;5890:3:1;5875:19;;5862:33;5918:18;5907:30;;5904:50;;;5950:1;5947;5940:12;5904:50;5989:58;6039:7;6030:6;6019:9;6015:22;5989:58;:::i;:::-;5359:748;;;;-1:-1:-1;5359:748:1;;-1:-1:-1;5359:748:1;;6066:8;;5359:748;-1:-1:-1;;;5359:748:1:o;6112:1027::-;6207:6;6215;6223;6231;6284:3;6272:9;6263:7;6259:23;6255:33;6252:53;;;6301:1;6298;6291:12;6252:53;6337:9;6324:23;6314:33;;6366:2;6415;6404:9;6400:18;6387:32;6377:42;;6466:2;6455:9;6451:18;6438:32;6428:42;;6521:2;6510:9;6506:18;6493:32;6544:18;6585:2;6577:6;6574:14;6571:34;;;6601:1;6598;6591:12;6571:34;6639:6;6628:9;6624:22;6614:32;;6684:7;6677:4;6673:2;6669:13;6665:27;6655:55;;6706:1;6703;6696:12;6655:55;6742:2;6729:16;6764:2;6760;6757:10;6754:36;;;6770:18;;:::i;:::-;6812:112;6920:2;6851:66;6844:4;6840:2;6836:13;6832:86;6828:95;6812:112;:::i;:::-;6799:125;;6947:2;6940:5;6933:17;6987:7;6982:2;6977;6973;6969:11;6965:20;6962:33;6959:53;;;7008:1;7005;6998:12;6959:53;7063:2;7058;7054;7050:11;7045:2;7038:5;7034:14;7021:45;7107:1;7102:2;7097;7090:5;7086:14;7082:23;7075:34;;7128:5;7118:15;;;;;6112:1027;;;;;;;:::o;7483:254::-;7403:12;;7391:25;;7465:4;7454:16;;;7448:23;7432:14;;;7425:47;7671:2;7656:18;;7683:48;7326:152;8226:261;8405:2;8394:9;8387:21;8368:4;8425:56;8477:2;8466:9;8462:18;8454:6;8425:56;:::i;8936:347::-;9001:6;9009;9062:2;9050:9;9041:7;9037:23;9033:32;9030:52;;;9078:1;9075;9068:12;9030:52;9101:29;9120:9;9101:29;:::i;:::-;9091:39;;9180:2;9169:9;9165:18;9152:32;9227:5;9220:13;9213:21;9206:5;9203:32;9193:60;;9249:1;9246;9239:12;9193:60;9272:5;9262:15;;;8936:347;;;;;:::o;10423:760::-;10690:6;10679:9;10672:25;10733:6;10728:2;10717:9;10713:18;10706:34;10776:6;10771:2;10760:9;10756:18;10749:34;10831:18;10823:6;10819:31;10814:2;10803:9;10799:18;10792:59;10888:3;10882;10871:9;10867:19;10860:32;10929:6;10923:3;10912:9;10908:19;10901:35;10987:6;10979;10973:3;10962:9;10958:19;10945:49;11044:1;11014:22;;;11038:3;11010:32;;;11003:43;;;;11098:2;11086:15;;;11103:66;11082:88;11067:104;11063:114;;10423:760;-1:-1:-1;;;;;10423:760:1:o;11747:847::-;12102:6;12091:9;12084:25;12145:6;12140:2;12129:9;12125:18;12118:34;-1:-1:-1;;;;;12192:6:1;12188:55;12183:2;12172:9;12168:18;12161:83;12280:3;12275:2;12264:9;12260:18;12253:31;12065:4;12307:57;12359:3;12348:9;12344:19;12336:6;12307:57;:::i;:::-;12413:9;12405:6;12401:22;12395:3;12384:9;12380:19;12373:51;12447:32;12472:6;12464;12447:32;:::i;:::-;12433:46;;12528:9;12520:6;12516:22;12510:3;12499:9;12495:19;12488:51;12556:32;12581:6;12573;12556:32;:::i;:::-;12548:40;11747:847;-1:-1:-1;;;;;;;;;11747:847:1:o;12599:641::-;12709:6;12762:2;12750:9;12741:7;12737:23;12733:32;12730:52;;;12778:1;12775;12768:12;12730:52;12811:2;12805:9;12853:2;12845:6;12841:15;12922:6;12910:10;12907:22;12886:18;12874:10;12871:34;12868:62;12865:88;;;12933:18;;:::i;:::-;12973:10;12969:2;12962:22;;13014:9;13008:16;13000:6;12993:32;13079:2;13068:9;13064:18;13058:25;13053:2;13045:6;13041:15;13034:50;13127:2;13116:9;13112:18;13106:25;13140:30;13164:5;13140:30;:::i;:::-;13198:2;13186:15;;13179:30;13190:6;12599:641;-1:-1:-1;;;12599:641:1:o;13245:775::-;13572:6;13561:9;13554:25;-1:-1:-1;;;;;13619:6:1;13615:55;13610:2;13599:9;13595:18;13588:83;13707:3;13702:2;13691:9;13687:18;13680:31;13535:4;13734:57;13786:3;13775:9;13771:19;13763:6;13734:57;:::i;:::-;13839:9;13831:6;13827:22;13822:2;13811:9;13807:18;13800:50;13873:32;13898:6;13890;13873:32;:::i;:::-;13859:46;;13954:9;13946:6;13942:22;13936:3;13925:9;13921:19;13914:51;13982:32;14007:6;13999;13982:32;:::i;:::-;13974:40;13245:775;-1:-1:-1;;;;;;;;13245:775:1:o;14025:184::-;14095:6;14148:2;14136:9;14127:7;14123:23;14119:32;14116:52;;;14164:1;14161;14154:12;14116:52;-1:-1:-1;14187:16:1;;14025:184;-1:-1:-1;14025:184:1:o;14214:::-;14266:77;14263:1;14256:88;14363:4;14360:1;14353:15;14387:4;14384:1;14377:15;14403:282;14470:9;;;14491:11;;;14488:191;;;14535:77;14532:1;14525:88;14636:4;14633:1;14626:15;14664:4;14661:1;14654:15;14690:184;14742:77;14739:1;14732:88;14839:4;14836:1;14829:15;14863:4;14860:1;14853:15;14879:295;15062:4;15054:6;15050:17;15039:9;15032:36;15104:2;15099;15088:9;15084:18;15077:30;15013:4;15124:44;15164:2;15153:9;15149:18;15141:6;15124:44;:::i;:::-;15116:52;14879:295;-1:-1:-1;;;;14879:295:1:o","abiDefinition":[{"inputs":[{"internalType":"address","name":"admin","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"inputs":[],"name":"AccessControlBadConfirmation","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"bytes32","name":"neededRole","type":"bytes32"}],"name":"AccessControlUnauthorizedAccount","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"AddressInsufficientBalance","type":"error"},{"inputs":[],"name":"FailedInnerCall","type":"error"},{"inputs":[{"internalType":"address","name":"client","type":"address"}],"name":"InterchainApp__AlreadyLatestClient","type":"error"},{"inputs":[],"name":"InterchainApp__AppZeroAddress","type":"error"},{"inputs":[{"internalType":"uint256","name":"actual","type":"uint256"},{"internalType":"uint256","name":"required","type":"uint256"}],"name":"InterchainApp__BalanceTooLow","type":"error"},{"inputs":[{"internalType":"address","name":"client","type":"address"}],"name":"InterchainApp__ClientAlreadyAdded","type":"error"},{"inputs":[],"name":"InterchainApp__InterchainClientZeroAddress","type":"error"},{"inputs":[{"internalType":"uint256","name":"requiredResponses","type":"uint256"},{"internalType":"uint256","name":"optimisticPeriod","type":"uint256"}],"name":"InterchainApp__InvalidAppConfig","type":"error"},{"inputs":[{"internalType":"address","name":"module","type":"address"}],"name":"InterchainApp__ModuleAlreadyAdded","type":"error"},{"inputs":[{"internalType":"address","name":"module","type":"address"}],"name":"InterchainApp__ModuleNotAdded","type":"error"},{"inputs":[],"name":"InterchainApp__ModuleZeroAddress","type":"error"},{"inputs":[{"internalType":"bytes32","name":"linkedApp","type":"bytes32"}],"name":"InterchainApp__NotEVMLinkedApp","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"InterchainApp__NotInterchainClient","type":"error"},{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"}],"name":"InterchainApp__ReceiverNotSet","type":"error"},{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"}],"name":"InterchainApp__SameChainId","type":"error"},{"inputs":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"bytes32","name":"sender","type":"bytes32"}],"name":"InterchainApp__SenderNotAllowed","type":"error"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"requiredResponses","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"optimisticPeriod","type":"uint256"}],"name":"AppConfigV1Set","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"chainId","type":"uint256"},{"indexed":true,"internalType":"bytes32","name":"remoteApp","type":"bytes32"}],"name":"AppLinked","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"executionService","type":"address"}],"name":"ExecutionServiceSet","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"client","type":"address"}],"name":"InterchainClientAdded","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"client","type":"address"}],"name":"InterchainClientRemoved","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"client","type":"address"}],"name":"LatestClientSet","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"srcChainId","type":"uint256"},{"indexed":false,"internalType":"bytes32","name":"sender","type":"bytes32"},{"indexed":false,"internalType":"uint256","name":"dbNonce","type":"uint256"},{"indexed":false,"internalType":"uint64","name":"entryIndex","type":"uint64"},{"indexed":false,"internalType":"bytes","name":"message","type":"bytes"}],"name":"MessageReceived","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"dstChainId","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"dbNonce","type":"uint256"},{"indexed":false,"internalType":"uint64","name":"entryIndex","type":"uint64"},{"indexed":false,"internalType":"bytes32","name":"transactionId","type":"bytes32"}],"name":"MessageSent","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"bytes32","name":"previousAdminRole","type":"bytes32"},{"indexed":true,"internalType":"bytes32","name":"newAdminRole","type":"bytes32"}],"name":"RoleAdminChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":true,"internalType":"address","name":"sender","type":"address"}],"name":"RoleGranted","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":true,"internalType":"address","name":"sender","type":"address"}],"name":"RoleRevoked","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"module","type":"address"}],"name":"TrustedModuleAdded","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"module","type":"address"}],"name":"TrustedModuleRemoved","type":"event"},{"inputs":[],"name":"DEFAULT_ADMIN_ROLE","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"IC_GOVERNOR_ROLE","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"client","type":"address"},{"internalType":"bool","name":"updateLatest","type":"bool"}],"name":"addInterchainClient","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"module","type":"address"}],"name":"addTrustedModule","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"bytes32","name":"sender","type":"bytes32"},{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"uint64","name":"entryIndex","type":"uint64"},{"internalType":"bytes","name":"message","type":"bytes"}],"name":"appReceive","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"getAppConfigV1","outputs":[{"components":[{"internalType":"uint256","name":"requiredResponses","type":"uint256"},{"internalType":"uint256","name":"optimisticPeriod","type":"uint256"}],"internalType":"struct AppConfigV1","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getExecutionService","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getInterchainClients","outputs":[{"internalType":"address[]","name":"","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getLatestInterchainClient","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"}],"name":"getLinkedApp","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"}],"name":"getLinkedAppEVM","outputs":[{"internalType":"address","name":"linkedAppEVM","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"dstChainId","type":"uint256"},{"internalType":"uint256","name":"gasLimit","type":"uint256"},{"internalType":"uint256","name":"gasAirdrop","type":"uint256"},{"internalType":"bytes","name":"message","type":"bytes"}],"name":"getMessageFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getModules","outputs":[{"internalType":"address[]","name":"","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getReceivingConfig","outputs":[{"internalType":"bytes","name":"appConfig","type":"bytes"},{"internalType":"address[]","name":"modules","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"}],"name":"getRoleAdmin","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"uint256","name":"index","type":"uint256"}],"name":"getRoleMember","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"}],"name":"getRoleMemberCount","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"grantRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"hasRole","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"},{"internalType":"bytes32","name":"remoteApp","type":"bytes32"}],"name":"linkRemoteApp","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"},{"internalType":"address","name":"remoteApp","type":"address"}],"name":"linkRemoteAppEVM","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"client","type":"address"}],"name":"removeInterchainClient","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"module","type":"address"}],"name":"removeTrustedModule","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"callerConfirmation","type":"address"}],"name":"renounceRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"revokeRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"dstChainId","type":"uint256"},{"internalType":"uint256","name":"gasLimit","type":"uint256"},{"internalType":"uint256","name":"gasAirdrop","type":"uint256"},{"internalType":"bytes","name":"message","type":"bytes"}],"name":"sendMessage","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"components":[{"internalType":"uint256","name":"requiredResponses","type":"uint256"},{"internalType":"uint256","name":"optimisticPeriod","type":"uint256"}],"internalType":"struct AppConfigV1","name":"appConfig","type":"tuple"}],"name":"setAppConfigV1","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"executionService","type":"address"}],"name":"setExecutionService","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"client","type":"address"}],"name":"setLatestInterchainClient","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes4","name":"interfaceId","type":"bytes4"}],"name":"supportsInterface","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"withdraw","outputs":[],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{"IC_GOVERNOR_ROLE()":{"notice":"Role to manage the Interchain setup of the app."},"addInterchainClient(address,bool)":{"notice":"Allows the owner to add the interchain client to the allowed clients set, and optionally set the latest client to this one. Note: only the allowed clients can send messages to this app. Note: the latest client is used for sending messages from this app."},"addTrustedModule(address)":{"notice":"Allows the owner to add the module to the trusted modules set. - This set of modules will be used to verify both sent and received messages."},"appReceive(uint256,bytes32,uint256,uint64,bytes)":{"notice":"Allows the Interchain Client to pass the message to the Interchain App."},"getAppConfigV1()":{"notice":"Returns the app config for the current app: requiredResponses and optimisticPeriod."},"getExecutionService()":{"notice":"Returns the address of the Execution Service used by this app for sending messages."},"getInterchainClients()":{"notice":"Returns the list of Interchain Clients allowed to send messages to this app."},"getLatestInterchainClient()":{"notice":"Returns the address of the latest interchain client. This address is used for sending messages from this app."},"getLinkedApp(uint256)":{"notice":"Returns the linked app address (as bytes32) for the given chain ID."},"getLinkedAppEVM(uint256)":{"notice":"Thin wrapper for `getLinkedApp` to return the linked app address as EVM address."},"getMessageFee(uint256,uint256,uint256,bytes)":{"notice":"Returns the fee required to send a message using `sendMessage`."},"getModules()":{"notice":"Returns the list of Interchain Modules trusted by this app. This set of modules will be used to verify both sent and received messages."},"getReceivingConfig()":{"notice":"Returns the verification configuration of the Interchain App."},"linkRemoteApp(uint256,bytes32)":{"notice":"Allows the owner to link the remote app for the given chain ID. - This address will be used as the receiver for the messages sent from this chain. - This address will be the only trusted sender for the messages sent to this chain."},"linkRemoteAppEVM(uint256,address)":{"notice":"Thin wrapper for `linkRemoteApp` to accept EVM address as a parameter."},"removeInterchainClient(address)":{"notice":"Allows the owner to remove the interchain client from the allowed clients set. If the client is the latest client, the latest client is set to the zero address."},"removeTrustedModule(address)":{"notice":"Allows the owner to remove the module from the trusted modules set."},"sendMessage(uint256,uint256,uint256,bytes)":{"notice":"Sends a basic message to the destination chain."},"setAppConfigV1((uint256,uint256))":{"notice":"Allows the owner to set the app config for the current app. App config includes: - requiredResponses: the number of module responses required for accepting the message - optimisticPeriod: the minimum time after which the module responses are considered final"},"setExecutionService(address)":{"notice":"Allows the owner to set the address of the Execution Service. This address will be used to request execution of the messages sent from this chain, by supplying the Service's execution fee."},"setLatestInterchainClient(address)":{"notice":"Allows the owner to set the address of the latest interchain client."},"withdraw()":{"notice":"Allows the Admin to withdraw the native asset from the contract."}},"version":1},"developerDoc":{"errors":{"AccessControlBadConfirmation()":[{"details":"The caller of a function is not the expected one. NOTE: Don't confuse with {AccessControlUnauthorizedAccount}."}],"AccessControlUnauthorizedAccount(address,bytes32)":[{"details":"The `account` is missing a role."}],"AddressInsufficientBalance(address)":[{"details":"The ETH balance of the account is not enough to perform the operation."}],"FailedInnerCall()":[{"details":"A call to an address target failed. The target may have reverted."}]},"events":{"RoleAdminChanged(bytes32,bytes32,bytes32)":{"details":"Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole` `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite {RoleAdminChanged} not being emitted signaling this."},"RoleGranted(bytes32,address,address)":{"details":"Emitted when `account` is granted `role`. `sender` is the account that originated the contract call, an admin role bearer except when using {AccessControl-_setupRole}."},"RoleRevoked(bytes32,address,address)":{"details":"Emitted when `account` is revoked `role`. `sender` is the account that originated the contract call:   - if using `revokeRole`, it is the admin role bearer   - if using `renounceRole`, it is the role bearer (i.e. `account`)"}},"kind":"dev","methods":{"addInterchainClient(address,bool)":{"params":{"client":"The address of the interchain client to add.","updateLatest":"Whether to set the latest client to this one."}},"appReceive(uint256,bytes32,uint256,uint64,bytes)":{"details":"App is responsible for keeping track of interchain clients, and must verify the message sender.","params":{"dbNonce":"The Interchain DB nonce of the batch containing the message entry.","entryIndex":"The index of the message entry within the batch.","message":"The message being sent.","sender":"Sender address on the source chain, as a bytes32 value.","srcChainId":"Chain ID of the source chain, where the message was sent from."}},"getLinkedAppEVM(uint256)":{"details":"Will revert if the linked app address is not an EVM address."},"getReceivingConfig()":{"details":"This configuration is used by the Interchain Client to verify that message has been confirmed by the Interchain Modules on the destination chain. Note: V1 version of AppConfig includes the required responses count, and optimistic period after which the message is considered confirmed by the module. Following versions may include additional fields.","returns":{"appConfig":"   The versioned configuration of the Interchain App, encoded as bytes.","modules":"     The list of Interchain Modules that app is trusting to confirm the messages."}},"getRoleAdmin(bytes32)":{"details":"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"getRoleMember(bytes32,uint256)":{"details":"Returns one of the accounts that have `role`. `index` must be a value between 0 and {getRoleMemberCount}, non-inclusive. Role bearers are not sorted in any particular way, and their ordering may change at any point. WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure you perform all queries on the same block. See the following https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post] for more information."},"getRoleMemberCount(bytes32)":{"details":"Returns the number of accounts that have `role`. Can be used together with {getRoleMember} to enumerate all bearers of a role."},"grantRole(bytes32,address)":{"details":"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleGranted} event."},"hasRole(bytes32,address)":{"details":"Returns `true` if `account` has been granted `role`."},"linkRemoteApp(uint256,bytes32)":{"params":{"chainId":"The remote chain ID.","remoteApp":"The address of the remote app to link."}},"removeInterchainClient(address)":{"params":{"client":"The address of the interchain client to remove."}},"renounceRole(bytes32,address)":{"details":"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `callerConfirmation`. May emit a {RoleRevoked} event."},"revokeRole(bytes32,address)":{"details":"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleRevoked} event."},"setLatestInterchainClient(address)":{"details":"The new latest client must be an allowed client or zero address. Setting the client to zero address effectively pauses the app ability to send messages, while allowing to receive them.","params":{"client":"The address of the latest interchain client."}},"supportsInterface(bytes4)":{"details":"See {IERC165-supportsInterface}."}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AccessControlBadConfirmation\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"neededRole\",\"type\":\"bytes32\"}],\"name\":\"AccessControlUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AddressInsufficientBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FailedInnerCall\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"}],\"name\":\"InterchainApp__AlreadyLatestClient\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InterchainApp__AppZeroAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"required\",\"type\":\"uint256\"}],\"name\":\"InterchainApp__BalanceTooLow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"}],\"name\":\"InterchainApp__ClientAlreadyAdded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InterchainApp__InterchainClientZeroAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requiredResponses\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"optimisticPeriod\",\"type\":\"uint256\"}],\"name\":\"InterchainApp__InvalidAppConfig\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"InterchainApp__ModuleAlreadyAdded\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"InterchainApp__ModuleNotAdded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InterchainApp__ModuleZeroAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"linkedApp\",\"type\":\"bytes32\"}],\"name\":\"InterchainApp__NotEVMLinkedApp\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"InterchainApp__NotInterchainClient\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"InterchainApp__ReceiverNotSet\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"InterchainApp__SameChainId\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"}],\"name\":\"InterchainApp__SenderNotAllowed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requiredResponses\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"optimisticPeriod\",\"type\":\"uint256\"}],\"name\":\"AppConfigV1Set\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"remoteApp\",\"type\":\"bytes32\"}],\"name\":\"AppLinked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"executionService\",\"type\":\"address\"}],\"name\":\"ExecutionServiceSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"}],\"name\":\"InterchainClientAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"}],\"name\":\"InterchainClientRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"}],\"name\":\"LatestClientSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"MessageReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dstChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"}],\"name\":\"MessageSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"TrustedModuleAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"TrustedModuleRemoved\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"IC_GOVERNOR_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"updateLatest\",\"type\":\"bool\"}],\"name\":\"addInterchainClient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"addTrustedModule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"appReceive\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAppConfigV1\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"requiredResponses\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"optimisticPeriod\",\"type\":\"uint256\"}],\"internalType\":\"struct AppConfigV1\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getExecutionService\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getInterchainClients\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLatestInterchainClient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"getLinkedApp\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"getLinkedAppEVM\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"linkedAppEVM\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dstChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasAirdrop\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"getMessageFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getModules\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReceivingConfig\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"appConfig\",\"type\":\"bytes\"},{\"internalType\":\"address[]\",\"name\":\"modules\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getRoleMember\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleMemberCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"remoteApp\",\"type\":\"bytes32\"}],\"name\":\"linkRemoteApp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"remoteApp\",\"type\":\"address\"}],\"name\":\"linkRemoteAppEVM\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"}],\"name\":\"removeInterchainClient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"removeTrustedModule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"callerConfirmation\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dstChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasAirdrop\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"sendMessage\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"requiredResponses\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"optimisticPeriod\",\"type\":\"uint256\"}],\"internalType\":\"struct AppConfigV1\",\"name\":\"appConfig\",\"type\":\"tuple\"}],\"name\":\"setAppConfigV1\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"executionService\",\"type\":\"address\"}],\"name\":\"setExecutionService\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"}],\"name\":\"setLatestInterchainClient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"errors\":{\"AccessControlBadConfirmation()\":[{\"details\":\"The caller of a function is not the expected one. NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\"}],\"AccessControlUnauthorizedAccount(address,bytes32)\":[{\"details\":\"The `account` is missing a role.\"}],\"AddressInsufficientBalance(address)\":[{\"details\":\"The ETH balance of the account is not enough to perform the operation.\"}],\"FailedInnerCall()\":[{\"details\":\"A call to an address target failed. The target may have reverted.\"}]},\"events\":{\"RoleAdminChanged(bytes32,bytes32,bytes32)\":{\"details\":\"Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole` `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite {RoleAdminChanged} not being emitted signaling this.\"},\"RoleGranted(bytes32,address,address)\":{\"details\":\"Emitted when `account` is granted `role`. `sender` is the account that originated the contract call, an admin role bearer except when using {AccessControl-_setupRole}.\"},\"RoleRevoked(bytes32,address,address)\":{\"details\":\"Emitted when `account` is revoked `role`. `sender` is the account that originated the contract call:   - if using `revokeRole`, it is the admin role bearer   - if using `renounceRole`, it is the role bearer (i.e. `account`)\"}},\"kind\":\"dev\",\"methods\":{\"addInterchainClient(address,bool)\":{\"params\":{\"client\":\"The address of the interchain client to add.\",\"updateLatest\":\"Whether to set the latest client to this one.\"}},\"appReceive(uint256,bytes32,uint256,uint64,bytes)\":{\"details\":\"App is responsible for keeping track of interchain clients, and must verify the message sender.\",\"params\":{\"dbNonce\":\"The Interchain DB nonce of the batch containing the message entry.\",\"entryIndex\":\"The index of the message entry within the batch.\",\"message\":\"The message being sent.\",\"sender\":\"Sender address on the source chain, as a bytes32 value.\",\"srcChainId\":\"Chain ID of the source chain, where the message was sent from.\"}},\"getLinkedAppEVM(uint256)\":{\"details\":\"Will revert if the linked app address is not an EVM address.\"},\"getReceivingConfig()\":{\"details\":\"This configuration is used by the Interchain Client to verify that message has been confirmed by the Interchain Modules on the destination chain. Note: V1 version of AppConfig includes the required responses count, and optimistic period after which the message is considered confirmed by the module. Following versions may include additional fields.\",\"returns\":{\"appConfig\":\"   The versioned configuration of the Interchain App, encoded as bytes.\",\"modules\":\"     The list of Interchain Modules that app is trusting to confirm the messages.\"}},\"getRoleAdmin(bytes32)\":{\"details\":\"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.\"},\"getRoleMember(bytes32,uint256)\":{\"details\":\"Returns one of the accounts that have `role`. `index` must be a value between 0 and {getRoleMemberCount}, non-inclusive. Role bearers are not sorted in any particular way, and their ordering may change at any point. WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure you perform all queries on the same block. See the following https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post] for more information.\"},\"getRoleMemberCount(bytes32)\":{\"details\":\"Returns the number of accounts that have `role`. Can be used together with {getRoleMember} to enumerate all bearers of a role.\"},\"grantRole(bytes32,address)\":{\"details\":\"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleGranted} event.\"},\"hasRole(bytes32,address)\":{\"details\":\"Returns `true` if `account` has been granted `role`.\"},\"linkRemoteApp(uint256,bytes32)\":{\"params\":{\"chainId\":\"The remote chain ID.\",\"remoteApp\":\"The address of the remote app to link.\"}},\"removeInterchainClient(address)\":{\"params\":{\"client\":\"The address of the interchain client to remove.\"}},\"renounceRole(bytes32,address)\":{\"details\":\"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `callerConfirmation`. May emit a {RoleRevoked} event.\"},\"revokeRole(bytes32,address)\":{\"details\":\"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleRevoked} event.\"},\"setLatestInterchainClient(address)\":{\"details\":\"The new latest client must be an allowed client or zero address. Setting the client to zero address effectively pauses the app ability to send messages, while allowing to receive them.\",\"params\":{\"client\":\"The address of the latest interchain client.\"}},\"supportsInterface(bytes4)\":{\"details\":\"See {IERC165-supportsInterface}.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"IC_GOVERNOR_ROLE()\":{\"notice\":\"Role to manage the Interchain setup of the app.\"},\"addInterchainClient(address,bool)\":{\"notice\":\"Allows the owner to add the interchain client to the allowed clients set, and optionally set the latest client to this one. Note: only the allowed clients can send messages to this app. Note: the latest client is used for sending messages from this app.\"},\"addTrustedModule(address)\":{\"notice\":\"Allows the owner to add the module to the trusted modules set. - This set of modules will be used to verify both sent and received messages.\"},\"appReceive(uint256,bytes32,uint256,uint64,bytes)\":{\"notice\":\"Allows the Interchain Client to pass the message to the Interchain App.\"},\"getAppConfigV1()\":{\"notice\":\"Returns the app config for the current app: requiredResponses and optimisticPeriod.\"},\"getExecutionService()\":{\"notice\":\"Returns the address of the Execution Service used by this app for sending messages.\"},\"getInterchainClients()\":{\"notice\":\"Returns the list of Interchain Clients allowed to send messages to this app.\"},\"getLatestInterchainClient()\":{\"notice\":\"Returns the address of the latest interchain client. This address is used for sending messages from this app.\"},\"getLinkedApp(uint256)\":{\"notice\":\"Returns the linked app address (as bytes32) for the given chain ID.\"},\"getLinkedAppEVM(uint256)\":{\"notice\":\"Thin wrapper for `getLinkedApp` to return the linked app address as EVM address.\"},\"getMessageFee(uint256,uint256,uint256,bytes)\":{\"notice\":\"Returns the fee required to send a message using `sendMessage`.\"},\"getModules()\":{\"notice\":\"Returns the list of Interchain Modules trusted by this app. This set of modules will be used to verify both sent and received messages.\"},\"getReceivingConfig()\":{\"notice\":\"Returns the verification configuration of the Interchain App.\"},\"linkRemoteApp(uint256,bytes32)\":{\"notice\":\"Allows the owner to link the remote app for the given chain ID. - This address will be used as the receiver for the messages sent from this chain. - This address will be the only trusted sender for the messages sent to this chain.\"},\"linkRemoteAppEVM(uint256,address)\":{\"notice\":\"Thin wrapper for `linkRemoteApp` to accept EVM address as a parameter.\"},\"removeInterchainClient(address)\":{\"notice\":\"Allows the owner to remove the interchain client from the allowed clients set. If the client is the latest client, the latest client is set to the zero address.\"},\"removeTrustedModule(address)\":{\"notice\":\"Allows the owner to remove the module from the trusted modules set.\"},\"sendMessage(uint256,uint256,uint256,bytes)\":{\"notice\":\"Sends a basic message to the destination chain.\"},\"setAppConfigV1((uint256,uint256))\":{\"notice\":\"Allows the owner to set the app config for the current app. App config includes: - requiredResponses: the number of module responses required for accepting the message - optimisticPeriod: the minimum time after which the module responses are considered final\"},\"setExecutionService(address)\":{\"notice\":\"Allows the owner to set the address of the Execution Service. This address will be used to request execution of the messages sent from this chain, by supplying the Service's execution fee.\"},\"setLatestInterchainClient(address)\":{\"notice\":\"Allows the owner to set the address of the latest interchain client.\"},\"withdraw()\":{\"notice\":\"Allows the Admin to withdraw the native asset from the contract.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/ExampleAppV1.sol\":\"ExampleAppV1\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/ExampleAppV1.sol\":{\"keccak256\":\"0x4c94807e7a2671ad6fcf49fb03cfafa6f51f6b4596f34092fba0bf17b6d482cf\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://4fabc9aa6f6891674b77809808b14ff1f2e8829de650caafa1fb3c3444a07331\",\"dweb:/ipfs/QmVzYNSfkuSkXNaFKuNY3hmkdspssruAhQx4qZuJU3Ceg9\"]}},\"version\":1}"},"hashes":{"DEFAULT_ADMIN_ROLE()":"a217fddf","IC_GOVERNOR_ROLE()":"1c489e4f","addInterchainClient(address,bool)":"f22ba23d","addTrustedModule(address)":"cb5038fb","appReceive(uint256,bytes32,uint256,uint64,bytes)":"68a69847","getAppConfigV1()":"7717a647","getExecutionService()":"c313c807","getInterchainClients()":"a1aa5d68","getLatestInterchainClient()":"bc0d912c","getLinkedApp(uint256)":"b9b74b18","getLinkedAppEVM(uint256)":"a9ac04b6","getMessageFee(uint256,uint256,uint256,bytes)":"764ca1e8","getModules()":"b2494df3","getReceivingConfig()":"287bc057","getRoleAdmin(bytes32)":"248a9ca3","getRoleMember(bytes32,uint256)":"9010d07c","getRoleMemberCount(bytes32)":"ca15c873","grantRole(bytes32,address)":"2f2ff15d","hasRole(bytes32,address)":"91d14854","linkRemoteApp(uint256,bytes32)":"51a30802","linkRemoteAppEVM(uint256,address)":"af8fcc8e","removeInterchainClient(address)":"0fb59156","removeTrustedModule(address)":"b70c40b3","renounceRole(bytes32,address)":"36568abe","revokeRole(bytes32,address)":"d547741f","sendMessage(uint256,uint256,uint256,bytes)":"282be0e9","setAppConfigV1((uint256,uint256))":"0d32b505","setExecutionService(address)":"496774b1","setLatestInterchainClient(address)":"eb53b44e","supportsInterface(bytes4)":"01ffc9a7","withdraw()":"3ccfd60b"}},"solidity/ExampleAppV1.sol:IAccessControl":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/AbstractICAppEvents.sol\n\nabstract contract AbstractICAppEvents {\n    event InterchainClientAdded(address client);\n    event InterchainClientRemoved(address client);\n    event LatestClientSet(address client);\n}\n\n// contracts/events/InterchainAppV1Events.sol\n\nabstract contract InterchainAppV1Events {\n    event AppConfigV1Set(uint256 requiredResponses, uint256 optimisticPeriod);\n    event AppLinked(uint256 indexed chainId, bytes32 indexed remoteApp);\n    event ExecutionServiceSet(address executionService);\n    event TrustedModuleAdded(address module);\n    event TrustedModuleRemoved(address module);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    /// @notice Allows the Interchain Client to pass the message to the Interchain App.\n    /// @dev App is responsible for keeping track of interchain clients, and must verify the message sender.\n    /// @param srcChainId   Chain ID of the source chain, where the message was sent from.\n    /// @param sender       Sender address on the source chain, as a bytes32 value.\n    /// @param dbNonce      The Interchain DB nonce of the batch containing the message entry.\n    /// @param entryIndex   The index of the message entry within the batch.\n    /// @param message      The message being sent.\n    function appReceive(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /// @notice Returns the verification configuration of the Interchain App.\n    /// @dev This configuration is used by the Interchain Client to verify that message has been confirmed\n    /// by the Interchain Modules on the destination chain.\n    /// Note: V1 version of AppConfig includes the required responses count, and optimistic period after which\n    /// the message is considered confirmed by the module. Following versions may include additional fields.\n    /// @return appConfig    The versioned configuration of the Interchain App, encoded as bytes.\n    /// @return modules      The list of Interchain Modules that app is trusting to confirm the messages.\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    uint8 constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint8 version);\n\n    /// @notice Encodes versioned app config into a bytes format.\n    /// @param version      The version of the app config.\n    /// @param appConfig    The app config to encode.\n    function encodeVersionedAppConfig(uint8 version, bytes memory appConfig) internal pure returns (bytes memory) {\n        return abi.encode(version, appConfig);\n    }\n\n    /// @notice Decodes versioned app config from a bytes format back into a version and app config.\n    /// @param data         The versioned app config data in bytes format.\n    /// @return version     The version of the app config.\n    /// @return appConfig   The app config as bytes.\n    function decodeVersionedAppConfig(bytes memory data)\n        internal\n        pure\n        returns (uint8 version, bytes memory appConfig)\n    {\n        (version, appConfig) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return encodeVersionedAppConfig(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal pure returns (AppConfigV1 memory) {\n        (uint8 version, bytes memory appConfig) = decodeVersionedAppConfig(data);\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(appConfig, (AppConfigV1));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    uint8 constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint8 version);\n\n    /// @notice Encodes versioned options into a bytes format.\n    /// @param version      The version of the options.\n    /// @param options      The options to encode.\n    function encodeVersionedOptions(uint8 version, bytes memory options) internal pure returns (bytes memory) {\n        return abi.encode(version, options);\n    }\n\n    /// @notice Decodes versioned options from a bytes format back into a version and options.\n    /// @param data         The versioned options data in bytes format.\n    /// @return version     The version of the options.\n    /// @return options     The options as bytes.\n    function decodeVersionedOptions(bytes memory data) internal pure returns (uint8 version, bytes memory options) {\n        (version, options) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return encodeVersionedOptions(OPTIONS_V1, abi.encode(options));\n    }\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal pure returns (OptionsV1 memory) {\n        (uint8 version, bytes memory options) = decodeVersionedOptions(data);\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(options, (OptionsV1));\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/IAccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n\n// node_modules/@openzeppelin/contracts/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance \u003c amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance \u003c value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 \u0026\u0026 target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/libs/InterchainTransaction.sol\n\nstruct InterchainTransaction {\n    uint256 srcChainId;\n    bytes32 srcSender;\n    uint256 dstChainId;\n    bytes32 dstReceiver;\n    uint256 dbNonce;\n    uint64 entryIndex;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint256 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    function constructLocalTransaction(\n        address srcSender,\n        uint256 dstChainId,\n        bytes32 dstReceiver,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: block.chainid,\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(transaction);\n    }\n\n    function decodeTransaction(bytes memory encodedTx) internal pure returns (InterchainTransaction memory) {\n        return abi.decode(encodedTx, (InterchainTransaction));\n    }\n\n    function transactionId(InterchainTransaction memory transaction) internal pure returns (bytes32) {\n        return keccak256(abi.encode(transaction));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/IAccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/IAccessControlEnumerable.sol)\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n// contracts/interfaces/IInterchainAppV1.sol\n\ninterface IInterchainAppV1 is IInterchainApp {\n    error InterchainApp__AppZeroAddress();\n    error InterchainApp__InvalidAppConfig(uint256 requiredResponses, uint256 optimisticPeriod);\n    error InterchainApp__ModuleAlreadyAdded(address module);\n    error InterchainApp__ModuleNotAdded(address module);\n    error InterchainApp__ModuleZeroAddress();\n    error InterchainApp__NotEVMLinkedApp(bytes32 linkedApp);\n\n    /// @notice Allows the owner to add the interchain client to the allowed clients set,\n    /// and optionally set the latest client to this one.\n    /// Note: only the allowed clients can send messages to this app.\n    /// Note: the latest client is used for sending messages from this app.\n    /// @param client       The address of the interchain client to add.\n    /// @param updateLatest Whether to set the latest client to this one.\n    function addInterchainClient(address client, bool updateLatest) external;\n\n    /// @notice Allows the owner to remove the interchain client from the allowed clients set.\n    /// If the client is the latest client, the latest client is set to the zero address.\n    /// @param client       The address of the interchain client to remove.\n    function removeInterchainClient(address client) external;\n\n    /// @notice Allows the owner to set the address of the latest interchain client.\n    /// @dev The new latest client must be an allowed client or zero address.\n    /// Setting the client to zero address effectively pauses the app ability to send messages,\n    /// while allowing to receive them.\n    /// @param client       The address of the latest interchain client.\n    function setLatestInterchainClient(address client) external;\n\n    /// @notice Allows the owner to link the remote app for the given chain ID.\n    /// - This address will be used as the receiver for the messages sent from this chain.\n    /// - This address will be the only trusted sender for the messages sent to this chain.\n    /// @param chainId      The remote chain ID.\n    /// @param remoteApp    The address of the remote app to link.\n    function linkRemoteApp(uint256 chainId, bytes32 remoteApp) external;\n\n    /// @notice Thin wrapper for `linkRemoteApp` to accept EVM address as a parameter.\n    function linkRemoteAppEVM(uint256 chainId, address remoteApp) external;\n\n    /// @notice Allows the owner to add the module to the trusted modules set.\n    /// - This set of modules will be used to verify both sent and received messages.\n    function addTrustedModule(address module) external;\n\n    /// @notice Allows the owner to remove the module from the trusted modules set.\n    function removeTrustedModule(address module) external;\n\n    /// @notice Allows the owner to set the app config for the current app. App config includes:\n    /// - requiredResponses: the number of module responses required for accepting the message\n    /// - optimisticPeriod: the minimum time after which the module responses are considered final\n    function setAppConfigV1(AppConfigV1 memory appConfig) external;\n\n    /// @notice Allows the owner to set the address of the Execution Service.\n    /// This address will be used to request execution of the messages sent from this chain,\n    /// by supplying the Service's execution fee.\n    function setExecutionService(address executionService) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Returns the app config for the current app: requiredResponses and optimisticPeriod.\n    function getAppConfigV1() external view returns (AppConfigV1 memory);\n\n    /// @notice Returns the address of the Execution Service used by this app for sending messages.\n    function getExecutionService() external view returns (address);\n\n    /// @notice Returns the list of Interchain Clients allowed to send messages to this app.\n    function getInterchainClients() external view returns (address[] memory);\n\n    /// @notice Returns the address of the latest interchain client.\n    /// This address is used for sending messages from this app.\n    function getLatestInterchainClient() external view returns (address);\n\n    /// @notice Returns the linked app address (as bytes32) for the given chain ID.\n    function getLinkedApp(uint256 chainId) external view returns (bytes32);\n\n    /// @notice Thin wrapper for `getLinkedApp` to return the linked app address as EVM address.\n    /// @dev Will revert if the linked app address is not an EVM address.\n    function getLinkedAppEVM(uint256 chainId) external view returns (address);\n\n    /// @notice Returns the list of Interchain Modules trusted by this app.\n    /// This set of modules will be used to verify both sent and received messages.\n    function getModules() external view returns (address[] memory);\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint256 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__NoLinkedClient(uint256 chainId);\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint256 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint256 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint256 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint256 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint256 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param message              The message being sent.\n    function getInterchainFee(\n        uint256 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint256 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint256 chainId) external view returns (address);\n}\n\n// node_modules/@openzeppelin/contracts/access/AccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account =\u003e bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role =\u003e RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n// contracts/apps/AbstractICApp.sol\n\nabstract contract AbstractICApp is AbstractICAppEvents, IInterchainApp {\n    using TypeCasts for address;\n\n    error InterchainApp__AlreadyLatestClient(address client);\n    error InterchainApp__BalanceTooLow(uint256 actual, uint256 required);\n    error InterchainApp__ClientAlreadyAdded(address client);\n    error InterchainApp__InterchainClientZeroAddress();\n    error InterchainApp__NotInterchainClient(address account);\n    error InterchainApp__ReceiverNotSet(uint256 chainId);\n    error InterchainApp__SameChainId(uint256 chainId);\n    error InterchainApp__SenderNotAllowed(uint256 srcChainId, bytes32 sender);\n\n    /// @inheritdoc IInterchainApp\n    function appReceive(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        if (!_isInterchainClient(msg.sender)) {\n            revert InterchainApp__NotInterchainClient(msg.sender);\n        }\n        if (srcChainId == block.chainid) {\n            revert InterchainApp__SameChainId(srcChainId);\n        }\n        if (!_isAllowedSender(srcChainId, sender)) {\n            revert InterchainApp__SenderNotAllowed(srcChainId, sender);\n        }\n        _receiveMessage(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n\n    /// @inheritdoc IInterchainApp\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules) {\n        appConfig = _getAppConfig();\n        modules = _getModules();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Performs necessary checks and adds an Interchain Client.\n    /// Optionally sets the latest client to this one.\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _addClient(address client, bool updateLatest) internal {\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (_isInterchainClient(client)) {\n            revert InterchainApp__ClientAlreadyAdded(client);\n        }\n        _toggleClientState(client, true);\n        emit InterchainClientAdded(client);\n        if (updateLatest) {\n            _setLatestClient(client);\n        }\n    }\n\n    /// @dev Performs necessary checks and removes an Interchain Client. If this client is the latest one,\n    /// the latest client is set to zero address (effectively pausing the app ability to send messages).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _removeClient(address client) internal {\n        if (!_isInterchainClient(client)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        _toggleClientState(client, false);\n        emit InterchainClientRemoved(client);\n        if (client == _getLatestClient()) {\n            _setLatestClient(address(0));\n        }\n    }\n\n    /// @dev Sets the latest Interchain Client to one of the allowed clients. Setting the client to zero address\n    /// is allowed and effectively pauses the app ability to send messages (but still allows to receive them).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _setLatestClient(address client) internal {\n        // New latest client must be an allowed client or zero address.\n        if (!_isInterchainClient(client) \u0026\u0026 client != address(0)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        if (client == _getLatestClient()) {\n            revert InterchainApp__AlreadyLatestClient(client);\n        }\n        _storeLatestClient(client);\n        emit LatestClientSet(client);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal virtual;\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal virtual;\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to accept EVM address as a parameter.\n    function _sendInterchainMessageEVM(\n        uint256 dstChainId,\n        address receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _sendInterchainMessage(dstChainId, receiver.addressToBytes32(), messageFee, options, message);\n    }\n\n    /// @dev Performs necessary checks and sends an interchain message.\n    function _sendInterchainMessage(\n        uint256 dstChainId,\n        bytes32 receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (dstChainId == block.chainid) {\n            revert InterchainApp__SameChainId(dstChainId);\n        }\n        if (receiver == 0) {\n            revert InterchainApp__ReceiverNotSet(dstChainId);\n        }\n        if (address(this).balance \u003c messageFee) {\n            revert InterchainApp__BalanceTooLow({actual: address(this).balance, required: messageFee});\n        }\n        return IInterchainClientV1(client).interchainSend{value: messageFee}(\n            dstChainId, receiver, _getExecutionService(), _getModules(), options, message\n        );\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        virtual;\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee for sending an Interchain message.\n    function _getInterchainFee(\n        uint256 dstChainId,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        return IInterchainClientV1(client).getInterchainFee(\n            dstChainId, _getExecutionService(), _getModules(), options, message\n        );\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view virtual returns (bytes memory);\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view virtual returns (address);\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view virtual returns (address);\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view virtual returns (address[] memory);\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint256 srcChainId, bytes32 sender) internal view virtual returns (bool);\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view virtual returns (bool);\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/AccessControlEnumerable.sol)\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 role =\u003e EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {AccessControl-_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool granted = super._grantRole(role, account);\n        if (granted) {\n            _roleMembers[role].add(account);\n        }\n        return granted;\n    }\n\n    /**\n     * @dev Overload {AccessControl-_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool revoked = super._revokeRole(role, account);\n        if (revoked) {\n            _roleMembers[role].remove(account);\n        }\n        return revoked;\n    }\n}\n\n// contracts/apps/ICAppV1.sol\n\nabstract contract ICAppV1 is AbstractICApp, AccessControlEnumerable, InterchainAppV1Events, IInterchainAppV1 {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Role to manage the Interchain setup of the app.\n    bytes32 public constant IC_GOVERNOR_ROLE = keccak256(\"IC_GOVERNOR_ROLE\");\n\n    /// @dev Address of the latest Interchain Client, used for sending messages.\n    address private _latestClient;\n\n    /// @dev Required responses and optimistic period for the module responses.\n    AppConfigV1 private _appConfigV1;\n    /// @dev Address of the linked app deployed on the remote chain.\n    mapping(uint256 chainId =\u003e bytes32 remoteApp) private _linkedApp;\n    /// @dev Interchain Clients allowed to send messages to this app.\n    EnumerableSet.AddressSet private _interchainClients;\n    /// @dev Trusted Interchain modules.\n    EnumerableSet.AddressSet private _trustedModules;\n    /// @dev Execution Service to use for sending messages.\n    address private _executionService;\n\n    constructor(address admin) {\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addInterchainClient(address client, bool updateLatest) external onlyRole(IC_GOVERNOR_ROLE) {\n        _addClient(client, updateLatest);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _removeClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setLatestInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _setLatestClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteApp(uint256 chainId, bytes32 remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteAppEVM(uint256 chainId, address remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp.addressToBytes32());\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (module == address(0)) {\n            revert InterchainApp__ModuleZeroAddress();\n        }\n        bool added = _trustedModules.add(module);\n        if (!added) {\n            revert InterchainApp__ModuleAlreadyAdded(module);\n        }\n        emit TrustedModuleAdded(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        bool removed = _trustedModules.remove(module);\n        if (!removed) {\n            revert InterchainApp__ModuleNotAdded(module);\n        }\n        emit TrustedModuleRemoved(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setAppConfigV1(AppConfigV1 memory appConfig) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (appConfig.requiredResponses == 0 || appConfig.optimisticPeriod == 0) {\n            revert InterchainApp__InvalidAppConfig(appConfig.requiredResponses, appConfig.optimisticPeriod);\n        }\n        _appConfigV1 = appConfig;\n        emit AppConfigV1Set(appConfig.requiredResponses, appConfig.optimisticPeriod);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setExecutionService(address executionService) external onlyRole(IC_GOVERNOR_ROLE) {\n        _executionService = executionService;\n        emit ExecutionServiceSet(executionService);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainAppV1\n    function getAppConfigV1() external view returns (AppConfigV1 memory) {\n        return _appConfigV1;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getExecutionService() external view returns (address) {\n        return _executionService;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getInterchainClients() external view returns (address[] memory) {\n        return _interchainClients.values();\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLatestInterchainClient() external view returns (address) {\n        return _latestClient;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedApp(uint256 chainId) external view returns (bytes32) {\n        return _linkedApp[chainId];\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedAppEVM(uint256 chainId) external view returns (address linkedAppEVM) {\n        bytes32 linkedApp = _linkedApp[chainId];\n        linkedAppEVM = linkedApp.bytes32ToAddress();\n        if (linkedAppEVM.addressToBytes32() != linkedApp) {\n            revert InterchainApp__NotEVMLinkedApp(linkedApp);\n        }\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getModules() external view returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Links the remote app to the current app.\n    /// Will revert if the chainId is the same as the chainId of the local app.\n    /// Note: Should be guarded with permissions check.\n    function _linkRemoteApp(uint256 chainId, bytes32 remoteApp) internal {\n        if (chainId == block.chainid) {\n            revert InterchainApp__SameChainId(chainId);\n        }\n        if (remoteApp == 0) {\n            revert InterchainApp__AppZeroAddress();\n        }\n        _linkedApp[chainId] = remoteApp;\n        emit AppLinked(chainId, remoteApp);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal override {\n        _latestClient = client;\n    }\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal override {\n        if (allowed) {\n            _interchainClients.add(client);\n        } else {\n            _interchainClients.remove(client);\n        }\n    }\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to send the message to the linked app.\n    function _sendToLinkedApp(\n        uint256 dstChainId,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _sendInterchainMessage(dstChainId, _linkedApp[dstChainId], messageFee, encodedOptions, message);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee to send a message to the linked app on the remote chain.\n    function _getMessageFee(\n        uint256 dstChainId,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _getInterchainFee(dstChainId, encodedOptions, message);\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view override returns (bytes memory) {\n        return _appConfigV1.encodeAppConfigV1();\n    }\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view override returns (address) {\n        return _executionService;\n    }\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view override returns (address) {\n        return _latestClient;\n    }\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view override returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint256 srcChainId, bytes32 sender) internal view override returns (bool) {\n        return _linkedApp[srcChainId] == sender;\n    }\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view override returns (bool) {\n        return _interchainClients.contains(caller);\n    }\n}\n\n// contracts/apps/examples/ExampleAppV1.sol\n\ncontract ExampleAppV1 is ICAppV1 {\n    event MessageReceived(uint256 srcChainId, bytes32 sender, uint256 dbNonce, uint64 entryIndex, bytes message);\n    event MessageSent(uint256 dstChainId, uint256 dbNonce, uint64 entryIndex, bytes32 transactionId);\n\n    constructor(address admin) ICAppV1(admin) {\n        _grantRole(IC_GOVERNOR_ROLE, admin);\n    }\n\n    /// @notice Allows the Admin to withdraw the native asset from the contract.\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        Address.sendValue(payable(msg.sender), address(this).balance);\n    }\n\n    /// @notice Sends a basic message to the destination chain.\n    function sendMessage(\n        uint256 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        InterchainTxDescriptor memory desc = _sendToLinkedApp({\n            dstChainId: dstChainId,\n            messageFee: msg.value,\n            options: OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}),\n            message: message\n        });\n        emit MessageSent(dstChainId, desc.dbNonce, desc.entryIndex, desc.transactionId);\n    }\n\n    /// @notice Returns the fee required to send a message using `sendMessage`.\n    function getMessageFee(\n        uint256 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes memory message\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _getMessageFee(dstChainId, OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}), message);\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        override\n    {\n        emit MessageReceived(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[],"name":"AccessControlBadConfirmation","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"bytes32","name":"neededRole","type":"bytes32"}],"name":"AccessControlUnauthorizedAccount","type":"error"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"bytes32","name":"previousAdminRole","type":"bytes32"},{"indexed":true,"internalType":"bytes32","name":"newAdminRole","type":"bytes32"}],"name":"RoleAdminChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":true,"internalType":"address","name":"sender","type":"address"}],"name":"RoleGranted","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":true,"internalType":"address","name":"sender","type":"address"}],"name":"RoleRevoked","type":"event"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"}],"name":"getRoleAdmin","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"grantRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"hasRole","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"callerConfirmation","type":"address"}],"name":"renounceRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"revokeRole","outputs":[],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"details":"External interface of AccessControl declared to support ERC165 detection.","errors":{"AccessControlBadConfirmation()":[{"details":"The caller of a function is not the expected one. NOTE: Don't confuse with {AccessControlUnauthorizedAccount}."}],"AccessControlUnauthorizedAccount(address,bytes32)":[{"details":"The `account` is missing a role."}]},"events":{"RoleAdminChanged(bytes32,bytes32,bytes32)":{"details":"Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole` `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite {RoleAdminChanged} not being emitted signaling this."},"RoleGranted(bytes32,address,address)":{"details":"Emitted when `account` is granted `role`. `sender` is the account that originated the contract call, an admin role bearer except when using {AccessControl-_setupRole}."},"RoleRevoked(bytes32,address,address)":{"details":"Emitted when `account` is revoked `role`. `sender` is the account that originated the contract call:   - if using `revokeRole`, it is the admin role bearer   - if using `renounceRole`, it is the role bearer (i.e. `account`)"}},"kind":"dev","methods":{"getRoleAdmin(bytes32)":{"details":"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {AccessControl-_setRoleAdmin}."},"grantRole(bytes32,address)":{"details":"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role."},"hasRole(bytes32,address)":{"details":"Returns `true` if `account` has been granted `role`."},"renounceRole(bytes32,address)":{"details":"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `callerConfirmation`."},"revokeRole(bytes32,address)":{"details":"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role."}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"AccessControlBadConfirmation\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"neededRole\",\"type\":\"bytes32\"}],\"name\":\"AccessControlUnauthorizedAccount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"callerConfirmation\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"External interface of AccessControl declared to support ERC165 detection.\",\"errors\":{\"AccessControlBadConfirmation()\":[{\"details\":\"The caller of a function is not the expected one. NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\"}],\"AccessControlUnauthorizedAccount(address,bytes32)\":[{\"details\":\"The `account` is missing a role.\"}]},\"events\":{\"RoleAdminChanged(bytes32,bytes32,bytes32)\":{\"details\":\"Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole` `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite {RoleAdminChanged} not being emitted signaling this.\"},\"RoleGranted(bytes32,address,address)\":{\"details\":\"Emitted when `account` is granted `role`. `sender` is the account that originated the contract call, an admin role bearer except when using {AccessControl-_setupRole}.\"},\"RoleRevoked(bytes32,address,address)\":{\"details\":\"Emitted when `account` is revoked `role`. `sender` is the account that originated the contract call:   - if using `revokeRole`, it is the admin role bearer   - if using `renounceRole`, it is the role bearer (i.e. `account`)\"}},\"kind\":\"dev\",\"methods\":{\"getRoleAdmin(bytes32)\":{\"details\":\"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {AccessControl-_setRoleAdmin}.\"},\"grantRole(bytes32,address)\":{\"details\":\"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.\"},\"hasRole(bytes32,address)\":{\"details\":\"Returns `true` if `account` has been granted `role`.\"},\"renounceRole(bytes32,address)\":{\"details\":\"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `callerConfirmation`.\"},\"revokeRole(bytes32,address)\":{\"details\":\"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/ExampleAppV1.sol\":\"IAccessControl\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/ExampleAppV1.sol\":{\"keccak256\":\"0x4c94807e7a2671ad6fcf49fb03cfafa6f51f6b4596f34092fba0bf17b6d482cf\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://4fabc9aa6f6891674b77809808b14ff1f2e8829de650caafa1fb3c3444a07331\",\"dweb:/ipfs/QmVzYNSfkuSkXNaFKuNY3hmkdspssruAhQx4qZuJU3Ceg9\"]}},\"version\":1}"},"hashes":{"getRoleAdmin(bytes32)":"248a9ca3","grantRole(bytes32,address)":"2f2ff15d","hasRole(bytes32,address)":"91d14854","renounceRole(bytes32,address)":"36568abe","revokeRole(bytes32,address)":"d547741f"}},"solidity/ExampleAppV1.sol:IAccessControlEnumerable":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/AbstractICAppEvents.sol\n\nabstract contract AbstractICAppEvents {\n    event InterchainClientAdded(address client);\n    event InterchainClientRemoved(address client);\n    event LatestClientSet(address client);\n}\n\n// contracts/events/InterchainAppV1Events.sol\n\nabstract contract InterchainAppV1Events {\n    event AppConfigV1Set(uint256 requiredResponses, uint256 optimisticPeriod);\n    event AppLinked(uint256 indexed chainId, bytes32 indexed remoteApp);\n    event ExecutionServiceSet(address executionService);\n    event TrustedModuleAdded(address module);\n    event TrustedModuleRemoved(address module);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    /// @notice Allows the Interchain Client to pass the message to the Interchain App.\n    /// @dev App is responsible for keeping track of interchain clients, and must verify the message sender.\n    /// @param srcChainId   Chain ID of the source chain, where the message was sent from.\n    /// @param sender       Sender address on the source chain, as a bytes32 value.\n    /// @param dbNonce      The Interchain DB nonce of the batch containing the message entry.\n    /// @param entryIndex   The index of the message entry within the batch.\n    /// @param message      The message being sent.\n    function appReceive(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /// @notice Returns the verification configuration of the Interchain App.\n    /// @dev This configuration is used by the Interchain Client to verify that message has been confirmed\n    /// by the Interchain Modules on the destination chain.\n    /// Note: V1 version of AppConfig includes the required responses count, and optimistic period after which\n    /// the message is considered confirmed by the module. Following versions may include additional fields.\n    /// @return appConfig    The versioned configuration of the Interchain App, encoded as bytes.\n    /// @return modules      The list of Interchain Modules that app is trusting to confirm the messages.\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    uint8 constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint8 version);\n\n    /// @notice Encodes versioned app config into a bytes format.\n    /// @param version      The version of the app config.\n    /// @param appConfig    The app config to encode.\n    function encodeVersionedAppConfig(uint8 version, bytes memory appConfig) internal pure returns (bytes memory) {\n        return abi.encode(version, appConfig);\n    }\n\n    /// @notice Decodes versioned app config from a bytes format back into a version and app config.\n    /// @param data         The versioned app config data in bytes format.\n    /// @return version     The version of the app config.\n    /// @return appConfig   The app config as bytes.\n    function decodeVersionedAppConfig(bytes memory data)\n        internal\n        pure\n        returns (uint8 version, bytes memory appConfig)\n    {\n        (version, appConfig) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return encodeVersionedAppConfig(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal pure returns (AppConfigV1 memory) {\n        (uint8 version, bytes memory appConfig) = decodeVersionedAppConfig(data);\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(appConfig, (AppConfigV1));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    uint8 constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint8 version);\n\n    /// @notice Encodes versioned options into a bytes format.\n    /// @param version      The version of the options.\n    /// @param options      The options to encode.\n    function encodeVersionedOptions(uint8 version, bytes memory options) internal pure returns (bytes memory) {\n        return abi.encode(version, options);\n    }\n\n    /// @notice Decodes versioned options from a bytes format back into a version and options.\n    /// @param data         The versioned options data in bytes format.\n    /// @return version     The version of the options.\n    /// @return options     The options as bytes.\n    function decodeVersionedOptions(bytes memory data) internal pure returns (uint8 version, bytes memory options) {\n        (version, options) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return encodeVersionedOptions(OPTIONS_V1, abi.encode(options));\n    }\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal pure returns (OptionsV1 memory) {\n        (uint8 version, bytes memory options) = decodeVersionedOptions(data);\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(options, (OptionsV1));\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/IAccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n\n// node_modules/@openzeppelin/contracts/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance \u003c amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance \u003c value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 \u0026\u0026 target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/libs/InterchainTransaction.sol\n\nstruct InterchainTransaction {\n    uint256 srcChainId;\n    bytes32 srcSender;\n    uint256 dstChainId;\n    bytes32 dstReceiver;\n    uint256 dbNonce;\n    uint64 entryIndex;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint256 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    function constructLocalTransaction(\n        address srcSender,\n        uint256 dstChainId,\n        bytes32 dstReceiver,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: block.chainid,\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(transaction);\n    }\n\n    function decodeTransaction(bytes memory encodedTx) internal pure returns (InterchainTransaction memory) {\n        return abi.decode(encodedTx, (InterchainTransaction));\n    }\n\n    function transactionId(InterchainTransaction memory transaction) internal pure returns (bytes32) {\n        return keccak256(abi.encode(transaction));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/IAccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/IAccessControlEnumerable.sol)\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n// contracts/interfaces/IInterchainAppV1.sol\n\ninterface IInterchainAppV1 is IInterchainApp {\n    error InterchainApp__AppZeroAddress();\n    error InterchainApp__InvalidAppConfig(uint256 requiredResponses, uint256 optimisticPeriod);\n    error InterchainApp__ModuleAlreadyAdded(address module);\n    error InterchainApp__ModuleNotAdded(address module);\n    error InterchainApp__ModuleZeroAddress();\n    error InterchainApp__NotEVMLinkedApp(bytes32 linkedApp);\n\n    /// @notice Allows the owner to add the interchain client to the allowed clients set,\n    /// and optionally set the latest client to this one.\n    /// Note: only the allowed clients can send messages to this app.\n    /// Note: the latest client is used for sending messages from this app.\n    /// @param client       The address of the interchain client to add.\n    /// @param updateLatest Whether to set the latest client to this one.\n    function addInterchainClient(address client, bool updateLatest) external;\n\n    /// @notice Allows the owner to remove the interchain client from the allowed clients set.\n    /// If the client is the latest client, the latest client is set to the zero address.\n    /// @param client       The address of the interchain client to remove.\n    function removeInterchainClient(address client) external;\n\n    /// @notice Allows the owner to set the address of the latest interchain client.\n    /// @dev The new latest client must be an allowed client or zero address.\n    /// Setting the client to zero address effectively pauses the app ability to send messages,\n    /// while allowing to receive them.\n    /// @param client       The address of the latest interchain client.\n    function setLatestInterchainClient(address client) external;\n\n    /// @notice Allows the owner to link the remote app for the given chain ID.\n    /// - This address will be used as the receiver for the messages sent from this chain.\n    /// - This address will be the only trusted sender for the messages sent to this chain.\n    /// @param chainId      The remote chain ID.\n    /// @param remoteApp    The address of the remote app to link.\n    function linkRemoteApp(uint256 chainId, bytes32 remoteApp) external;\n\n    /// @notice Thin wrapper for `linkRemoteApp` to accept EVM address as a parameter.\n    function linkRemoteAppEVM(uint256 chainId, address remoteApp) external;\n\n    /// @notice Allows the owner to add the module to the trusted modules set.\n    /// - This set of modules will be used to verify both sent and received messages.\n    function addTrustedModule(address module) external;\n\n    /// @notice Allows the owner to remove the module from the trusted modules set.\n    function removeTrustedModule(address module) external;\n\n    /// @notice Allows the owner to set the app config for the current app. App config includes:\n    /// - requiredResponses: the number of module responses required for accepting the message\n    /// - optimisticPeriod: the minimum time after which the module responses are considered final\n    function setAppConfigV1(AppConfigV1 memory appConfig) external;\n\n    /// @notice Allows the owner to set the address of the Execution Service.\n    /// This address will be used to request execution of the messages sent from this chain,\n    /// by supplying the Service's execution fee.\n    function setExecutionService(address executionService) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Returns the app config for the current app: requiredResponses and optimisticPeriod.\n    function getAppConfigV1() external view returns (AppConfigV1 memory);\n\n    /// @notice Returns the address of the Execution Service used by this app for sending messages.\n    function getExecutionService() external view returns (address);\n\n    /// @notice Returns the list of Interchain Clients allowed to send messages to this app.\n    function getInterchainClients() external view returns (address[] memory);\n\n    /// @notice Returns the address of the latest interchain client.\n    /// This address is used for sending messages from this app.\n    function getLatestInterchainClient() external view returns (address);\n\n    /// @notice Returns the linked app address (as bytes32) for the given chain ID.\n    function getLinkedApp(uint256 chainId) external view returns (bytes32);\n\n    /// @notice Thin wrapper for `getLinkedApp` to return the linked app address as EVM address.\n    /// @dev Will revert if the linked app address is not an EVM address.\n    function getLinkedAppEVM(uint256 chainId) external view returns (address);\n\n    /// @notice Returns the list of Interchain Modules trusted by this app.\n    /// This set of modules will be used to verify both sent and received messages.\n    function getModules() external view returns (address[] memory);\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint256 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__NoLinkedClient(uint256 chainId);\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint256 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint256 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint256 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint256 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint256 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param message              The message being sent.\n    function getInterchainFee(\n        uint256 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint256 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint256 chainId) external view returns (address);\n}\n\n// node_modules/@openzeppelin/contracts/access/AccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account =\u003e bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role =\u003e RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n// contracts/apps/AbstractICApp.sol\n\nabstract contract AbstractICApp is AbstractICAppEvents, IInterchainApp {\n    using TypeCasts for address;\n\n    error InterchainApp__AlreadyLatestClient(address client);\n    error InterchainApp__BalanceTooLow(uint256 actual, uint256 required);\n    error InterchainApp__ClientAlreadyAdded(address client);\n    error InterchainApp__InterchainClientZeroAddress();\n    error InterchainApp__NotInterchainClient(address account);\n    error InterchainApp__ReceiverNotSet(uint256 chainId);\n    error InterchainApp__SameChainId(uint256 chainId);\n    error InterchainApp__SenderNotAllowed(uint256 srcChainId, bytes32 sender);\n\n    /// @inheritdoc IInterchainApp\n    function appReceive(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        if (!_isInterchainClient(msg.sender)) {\n            revert InterchainApp__NotInterchainClient(msg.sender);\n        }\n        if (srcChainId == block.chainid) {\n            revert InterchainApp__SameChainId(srcChainId);\n        }\n        if (!_isAllowedSender(srcChainId, sender)) {\n            revert InterchainApp__SenderNotAllowed(srcChainId, sender);\n        }\n        _receiveMessage(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n\n    /// @inheritdoc IInterchainApp\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules) {\n        appConfig = _getAppConfig();\n        modules = _getModules();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Performs necessary checks and adds an Interchain Client.\n    /// Optionally sets the latest client to this one.\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _addClient(address client, bool updateLatest) internal {\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (_isInterchainClient(client)) {\n            revert InterchainApp__ClientAlreadyAdded(client);\n        }\n        _toggleClientState(client, true);\n        emit InterchainClientAdded(client);\n        if (updateLatest) {\n            _setLatestClient(client);\n        }\n    }\n\n    /// @dev Performs necessary checks and removes an Interchain Client. If this client is the latest one,\n    /// the latest client is set to zero address (effectively pausing the app ability to send messages).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _removeClient(address client) internal {\n        if (!_isInterchainClient(client)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        _toggleClientState(client, false);\n        emit InterchainClientRemoved(client);\n        if (client == _getLatestClient()) {\n            _setLatestClient(address(0));\n        }\n    }\n\n    /// @dev Sets the latest Interchain Client to one of the allowed clients. Setting the client to zero address\n    /// is allowed and effectively pauses the app ability to send messages (but still allows to receive them).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _setLatestClient(address client) internal {\n        // New latest client must be an allowed client or zero address.\n        if (!_isInterchainClient(client) \u0026\u0026 client != address(0)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        if (client == _getLatestClient()) {\n            revert InterchainApp__AlreadyLatestClient(client);\n        }\n        _storeLatestClient(client);\n        emit LatestClientSet(client);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal virtual;\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal virtual;\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to accept EVM address as a parameter.\n    function _sendInterchainMessageEVM(\n        uint256 dstChainId,\n        address receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _sendInterchainMessage(dstChainId, receiver.addressToBytes32(), messageFee, options, message);\n    }\n\n    /// @dev Performs necessary checks and sends an interchain message.\n    function _sendInterchainMessage(\n        uint256 dstChainId,\n        bytes32 receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (dstChainId == block.chainid) {\n            revert InterchainApp__SameChainId(dstChainId);\n        }\n        if (receiver == 0) {\n            revert InterchainApp__ReceiverNotSet(dstChainId);\n        }\n        if (address(this).balance \u003c messageFee) {\n            revert InterchainApp__BalanceTooLow({actual: address(this).balance, required: messageFee});\n        }\n        return IInterchainClientV1(client).interchainSend{value: messageFee}(\n            dstChainId, receiver, _getExecutionService(), _getModules(), options, message\n        );\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        virtual;\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee for sending an Interchain message.\n    function _getInterchainFee(\n        uint256 dstChainId,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        return IInterchainClientV1(client).getInterchainFee(\n            dstChainId, _getExecutionService(), _getModules(), options, message\n        );\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view virtual returns (bytes memory);\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view virtual returns (address);\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view virtual returns (address);\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view virtual returns (address[] memory);\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint256 srcChainId, bytes32 sender) internal view virtual returns (bool);\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view virtual returns (bool);\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/AccessControlEnumerable.sol)\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 role =\u003e EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {AccessControl-_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool granted = super._grantRole(role, account);\n        if (granted) {\n            _roleMembers[role].add(account);\n        }\n        return granted;\n    }\n\n    /**\n     * @dev Overload {AccessControl-_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool revoked = super._revokeRole(role, account);\n        if (revoked) {\n            _roleMembers[role].remove(account);\n        }\n        return revoked;\n    }\n}\n\n// contracts/apps/ICAppV1.sol\n\nabstract contract ICAppV1 is AbstractICApp, AccessControlEnumerable, InterchainAppV1Events, IInterchainAppV1 {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Role to manage the Interchain setup of the app.\n    bytes32 public constant IC_GOVERNOR_ROLE = keccak256(\"IC_GOVERNOR_ROLE\");\n\n    /// @dev Address of the latest Interchain Client, used for sending messages.\n    address private _latestClient;\n\n    /// @dev Required responses and optimistic period for the module responses.\n    AppConfigV1 private _appConfigV1;\n    /// @dev Address of the linked app deployed on the remote chain.\n    mapping(uint256 chainId =\u003e bytes32 remoteApp) private _linkedApp;\n    /// @dev Interchain Clients allowed to send messages to this app.\n    EnumerableSet.AddressSet private _interchainClients;\n    /// @dev Trusted Interchain modules.\n    EnumerableSet.AddressSet private _trustedModules;\n    /// @dev Execution Service to use for sending messages.\n    address private _executionService;\n\n    constructor(address admin) {\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addInterchainClient(address client, bool updateLatest) external onlyRole(IC_GOVERNOR_ROLE) {\n        _addClient(client, updateLatest);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _removeClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setLatestInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _setLatestClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteApp(uint256 chainId, bytes32 remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteAppEVM(uint256 chainId, address remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp.addressToBytes32());\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (module == address(0)) {\n            revert InterchainApp__ModuleZeroAddress();\n        }\n        bool added = _trustedModules.add(module);\n        if (!added) {\n            revert InterchainApp__ModuleAlreadyAdded(module);\n        }\n        emit TrustedModuleAdded(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        bool removed = _trustedModules.remove(module);\n        if (!removed) {\n            revert InterchainApp__ModuleNotAdded(module);\n        }\n        emit TrustedModuleRemoved(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setAppConfigV1(AppConfigV1 memory appConfig) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (appConfig.requiredResponses == 0 || appConfig.optimisticPeriod == 0) {\n            revert InterchainApp__InvalidAppConfig(appConfig.requiredResponses, appConfig.optimisticPeriod);\n        }\n        _appConfigV1 = appConfig;\n        emit AppConfigV1Set(appConfig.requiredResponses, appConfig.optimisticPeriod);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setExecutionService(address executionService) external onlyRole(IC_GOVERNOR_ROLE) {\n        _executionService = executionService;\n        emit ExecutionServiceSet(executionService);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainAppV1\n    function getAppConfigV1() external view returns (AppConfigV1 memory) {\n        return _appConfigV1;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getExecutionService() external view returns (address) {\n        return _executionService;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getInterchainClients() external view returns (address[] memory) {\n        return _interchainClients.values();\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLatestInterchainClient() external view returns (address) {\n        return _latestClient;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedApp(uint256 chainId) external view returns (bytes32) {\n        return _linkedApp[chainId];\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedAppEVM(uint256 chainId) external view returns (address linkedAppEVM) {\n        bytes32 linkedApp = _linkedApp[chainId];\n        linkedAppEVM = linkedApp.bytes32ToAddress();\n        if (linkedAppEVM.addressToBytes32() != linkedApp) {\n            revert InterchainApp__NotEVMLinkedApp(linkedApp);\n        }\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getModules() external view returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Links the remote app to the current app.\n    /// Will revert if the chainId is the same as the chainId of the local app.\n    /// Note: Should be guarded with permissions check.\n    function _linkRemoteApp(uint256 chainId, bytes32 remoteApp) internal {\n        if (chainId == block.chainid) {\n            revert InterchainApp__SameChainId(chainId);\n        }\n        if (remoteApp == 0) {\n            revert InterchainApp__AppZeroAddress();\n        }\n        _linkedApp[chainId] = remoteApp;\n        emit AppLinked(chainId, remoteApp);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal override {\n        _latestClient = client;\n    }\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal override {\n        if (allowed) {\n            _interchainClients.add(client);\n        } else {\n            _interchainClients.remove(client);\n        }\n    }\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to send the message to the linked app.\n    function _sendToLinkedApp(\n        uint256 dstChainId,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _sendInterchainMessage(dstChainId, _linkedApp[dstChainId], messageFee, encodedOptions, message);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee to send a message to the linked app on the remote chain.\n    function _getMessageFee(\n        uint256 dstChainId,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _getInterchainFee(dstChainId, encodedOptions, message);\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view override returns (bytes memory) {\n        return _appConfigV1.encodeAppConfigV1();\n    }\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view override returns (address) {\n        return _executionService;\n    }\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view override returns (address) {\n        return _latestClient;\n    }\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view override returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint256 srcChainId, bytes32 sender) internal view override returns (bool) {\n        return _linkedApp[srcChainId] == sender;\n    }\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view override returns (bool) {\n        return _interchainClients.contains(caller);\n    }\n}\n\n// contracts/apps/examples/ExampleAppV1.sol\n\ncontract ExampleAppV1 is ICAppV1 {\n    event MessageReceived(uint256 srcChainId, bytes32 sender, uint256 dbNonce, uint64 entryIndex, bytes message);\n    event MessageSent(uint256 dstChainId, uint256 dbNonce, uint64 entryIndex, bytes32 transactionId);\n\n    constructor(address admin) ICAppV1(admin) {\n        _grantRole(IC_GOVERNOR_ROLE, admin);\n    }\n\n    /// @notice Allows the Admin to withdraw the native asset from the contract.\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        Address.sendValue(payable(msg.sender), address(this).balance);\n    }\n\n    /// @notice Sends a basic message to the destination chain.\n    function sendMessage(\n        uint256 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        InterchainTxDescriptor memory desc = _sendToLinkedApp({\n            dstChainId: dstChainId,\n            messageFee: msg.value,\n            options: OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}),\n            message: message\n        });\n        emit MessageSent(dstChainId, desc.dbNonce, desc.entryIndex, desc.transactionId);\n    }\n\n    /// @notice Returns the fee required to send a message using `sendMessage`.\n    function getMessageFee(\n        uint256 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes memory message\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _getMessageFee(dstChainId, OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}), message);\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        override\n    {\n        emit MessageReceived(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[],"name":"AccessControlBadConfirmation","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"bytes32","name":"neededRole","type":"bytes32"}],"name":"AccessControlUnauthorizedAccount","type":"error"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"bytes32","name":"previousAdminRole","type":"bytes32"},{"indexed":true,"internalType":"bytes32","name":"newAdminRole","type":"bytes32"}],"name":"RoleAdminChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":true,"internalType":"address","name":"sender","type":"address"}],"name":"RoleGranted","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":true,"internalType":"address","name":"sender","type":"address"}],"name":"RoleRevoked","type":"event"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"}],"name":"getRoleAdmin","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"uint256","name":"index","type":"uint256"}],"name":"getRoleMember","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"}],"name":"getRoleMemberCount","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"grantRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"hasRole","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"callerConfirmation","type":"address"}],"name":"renounceRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"revokeRole","outputs":[],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"details":"External interface of AccessControlEnumerable declared to support ERC165 detection.","errors":{"AccessControlBadConfirmation()":[{"details":"The caller of a function is not the expected one. NOTE: Don't confuse with {AccessControlUnauthorizedAccount}."}],"AccessControlUnauthorizedAccount(address,bytes32)":[{"details":"The `account` is missing a role."}]},"events":{"RoleAdminChanged(bytes32,bytes32,bytes32)":{"details":"Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole` `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite {RoleAdminChanged} not being emitted signaling this."},"RoleGranted(bytes32,address,address)":{"details":"Emitted when `account` is granted `role`. `sender` is the account that originated the contract call, an admin role bearer except when using {AccessControl-_setupRole}."},"RoleRevoked(bytes32,address,address)":{"details":"Emitted when `account` is revoked `role`. `sender` is the account that originated the contract call:   - if using `revokeRole`, it is the admin role bearer   - if using `renounceRole`, it is the role bearer (i.e. `account`)"}},"kind":"dev","methods":{"getRoleAdmin(bytes32)":{"details":"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {AccessControl-_setRoleAdmin}."},"getRoleMember(bytes32,uint256)":{"details":"Returns one of the accounts that have `role`. `index` must be a value between 0 and {getRoleMemberCount}, non-inclusive. Role bearers are not sorted in any particular way, and their ordering may change at any point. WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure you perform all queries on the same block. See the following https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post] for more information."},"getRoleMemberCount(bytes32)":{"details":"Returns the number of accounts that have `role`. Can be used together with {getRoleMember} to enumerate all bearers of a role."},"grantRole(bytes32,address)":{"details":"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role."},"hasRole(bytes32,address)":{"details":"Returns `true` if `account` has been granted `role`."},"renounceRole(bytes32,address)":{"details":"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `callerConfirmation`."},"revokeRole(bytes32,address)":{"details":"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role."}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"AccessControlBadConfirmation\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"neededRole\",\"type\":\"bytes32\"}],\"name\":\"AccessControlUnauthorizedAccount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getRoleMember\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleMemberCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"callerConfirmation\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"External interface of AccessControlEnumerable declared to support ERC165 detection.\",\"errors\":{\"AccessControlBadConfirmation()\":[{\"details\":\"The caller of a function is not the expected one. NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\"}],\"AccessControlUnauthorizedAccount(address,bytes32)\":[{\"details\":\"The `account` is missing a role.\"}]},\"events\":{\"RoleAdminChanged(bytes32,bytes32,bytes32)\":{\"details\":\"Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole` `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite {RoleAdminChanged} not being emitted signaling this.\"},\"RoleGranted(bytes32,address,address)\":{\"details\":\"Emitted when `account` is granted `role`. `sender` is the account that originated the contract call, an admin role bearer except when using {AccessControl-_setupRole}.\"},\"RoleRevoked(bytes32,address,address)\":{\"details\":\"Emitted when `account` is revoked `role`. `sender` is the account that originated the contract call:   - if using `revokeRole`, it is the admin role bearer   - if using `renounceRole`, it is the role bearer (i.e. `account`)\"}},\"kind\":\"dev\",\"methods\":{\"getRoleAdmin(bytes32)\":{\"details\":\"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {AccessControl-_setRoleAdmin}.\"},\"getRoleMember(bytes32,uint256)\":{\"details\":\"Returns one of the accounts that have `role`. `index` must be a value between 0 and {getRoleMemberCount}, non-inclusive. Role bearers are not sorted in any particular way, and their ordering may change at any point. WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure you perform all queries on the same block. See the following https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post] for more information.\"},\"getRoleMemberCount(bytes32)\":{\"details\":\"Returns the number of accounts that have `role`. Can be used together with {getRoleMember} to enumerate all bearers of a role.\"},\"grantRole(bytes32,address)\":{\"details\":\"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.\"},\"hasRole(bytes32,address)\":{\"details\":\"Returns `true` if `account` has been granted `role`.\"},\"renounceRole(bytes32,address)\":{\"details\":\"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `callerConfirmation`.\"},\"revokeRole(bytes32,address)\":{\"details\":\"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/ExampleAppV1.sol\":\"IAccessControlEnumerable\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/ExampleAppV1.sol\":{\"keccak256\":\"0x4c94807e7a2671ad6fcf49fb03cfafa6f51f6b4596f34092fba0bf17b6d482cf\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://4fabc9aa6f6891674b77809808b14ff1f2e8829de650caafa1fb3c3444a07331\",\"dweb:/ipfs/QmVzYNSfkuSkXNaFKuNY3hmkdspssruAhQx4qZuJU3Ceg9\"]}},\"version\":1}"},"hashes":{"getRoleAdmin(bytes32)":"248a9ca3","getRoleMember(bytes32,uint256)":"9010d07c","getRoleMemberCount(bytes32)":"ca15c873","grantRole(bytes32,address)":"2f2ff15d","hasRole(bytes32,address)":"91d14854","renounceRole(bytes32,address)":"36568abe","revokeRole(bytes32,address)":"d547741f"}},"solidity/ExampleAppV1.sol:ICAppV1":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/AbstractICAppEvents.sol\n\nabstract contract AbstractICAppEvents {\n    event InterchainClientAdded(address client);\n    event InterchainClientRemoved(address client);\n    event LatestClientSet(address client);\n}\n\n// contracts/events/InterchainAppV1Events.sol\n\nabstract contract InterchainAppV1Events {\n    event AppConfigV1Set(uint256 requiredResponses, uint256 optimisticPeriod);\n    event AppLinked(uint256 indexed chainId, bytes32 indexed remoteApp);\n    event ExecutionServiceSet(address executionService);\n    event TrustedModuleAdded(address module);\n    event TrustedModuleRemoved(address module);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    /// @notice Allows the Interchain Client to pass the message to the Interchain App.\n    /// @dev App is responsible for keeping track of interchain clients, and must verify the message sender.\n    /// @param srcChainId   Chain ID of the source chain, where the message was sent from.\n    /// @param sender       Sender address on the source chain, as a bytes32 value.\n    /// @param dbNonce      The Interchain DB nonce of the batch containing the message entry.\n    /// @param entryIndex   The index of the message entry within the batch.\n    /// @param message      The message being sent.\n    function appReceive(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /// @notice Returns the verification configuration of the Interchain App.\n    /// @dev This configuration is used by the Interchain Client to verify that message has been confirmed\n    /// by the Interchain Modules on the destination chain.\n    /// Note: V1 version of AppConfig includes the required responses count, and optimistic period after which\n    /// the message is considered confirmed by the module. Following versions may include additional fields.\n    /// @return appConfig    The versioned configuration of the Interchain App, encoded as bytes.\n    /// @return modules      The list of Interchain Modules that app is trusting to confirm the messages.\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    uint8 constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint8 version);\n\n    /// @notice Encodes versioned app config into a bytes format.\n    /// @param version      The version of the app config.\n    /// @param appConfig    The app config to encode.\n    function encodeVersionedAppConfig(uint8 version, bytes memory appConfig) internal pure returns (bytes memory) {\n        return abi.encode(version, appConfig);\n    }\n\n    /// @notice Decodes versioned app config from a bytes format back into a version and app config.\n    /// @param data         The versioned app config data in bytes format.\n    /// @return version     The version of the app config.\n    /// @return appConfig   The app config as bytes.\n    function decodeVersionedAppConfig(bytes memory data)\n        internal\n        pure\n        returns (uint8 version, bytes memory appConfig)\n    {\n        (version, appConfig) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return encodeVersionedAppConfig(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal pure returns (AppConfigV1 memory) {\n        (uint8 version, bytes memory appConfig) = decodeVersionedAppConfig(data);\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(appConfig, (AppConfigV1));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    uint8 constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint8 version);\n\n    /// @notice Encodes versioned options into a bytes format.\n    /// @param version      The version of the options.\n    /// @param options      The options to encode.\n    function encodeVersionedOptions(uint8 version, bytes memory options) internal pure returns (bytes memory) {\n        return abi.encode(version, options);\n    }\n\n    /// @notice Decodes versioned options from a bytes format back into a version and options.\n    /// @param data         The versioned options data in bytes format.\n    /// @return version     The version of the options.\n    /// @return options     The options as bytes.\n    function decodeVersionedOptions(bytes memory data) internal pure returns (uint8 version, bytes memory options) {\n        (version, options) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return encodeVersionedOptions(OPTIONS_V1, abi.encode(options));\n    }\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal pure returns (OptionsV1 memory) {\n        (uint8 version, bytes memory options) = decodeVersionedOptions(data);\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(options, (OptionsV1));\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/IAccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n\n// node_modules/@openzeppelin/contracts/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance \u003c amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance \u003c value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 \u0026\u0026 target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/libs/InterchainTransaction.sol\n\nstruct InterchainTransaction {\n    uint256 srcChainId;\n    bytes32 srcSender;\n    uint256 dstChainId;\n    bytes32 dstReceiver;\n    uint256 dbNonce;\n    uint64 entryIndex;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint256 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    function constructLocalTransaction(\n        address srcSender,\n        uint256 dstChainId,\n        bytes32 dstReceiver,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: block.chainid,\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(transaction);\n    }\n\n    function decodeTransaction(bytes memory encodedTx) internal pure returns (InterchainTransaction memory) {\n        return abi.decode(encodedTx, (InterchainTransaction));\n    }\n\n    function transactionId(InterchainTransaction memory transaction) internal pure returns (bytes32) {\n        return keccak256(abi.encode(transaction));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/IAccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/IAccessControlEnumerable.sol)\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n// contracts/interfaces/IInterchainAppV1.sol\n\ninterface IInterchainAppV1 is IInterchainApp {\n    error InterchainApp__AppZeroAddress();\n    error InterchainApp__InvalidAppConfig(uint256 requiredResponses, uint256 optimisticPeriod);\n    error InterchainApp__ModuleAlreadyAdded(address module);\n    error InterchainApp__ModuleNotAdded(address module);\n    error InterchainApp__ModuleZeroAddress();\n    error InterchainApp__NotEVMLinkedApp(bytes32 linkedApp);\n\n    /// @notice Allows the owner to add the interchain client to the allowed clients set,\n    /// and optionally set the latest client to this one.\n    /// Note: only the allowed clients can send messages to this app.\n    /// Note: the latest client is used for sending messages from this app.\n    /// @param client       The address of the interchain client to add.\n    /// @param updateLatest Whether to set the latest client to this one.\n    function addInterchainClient(address client, bool updateLatest) external;\n\n    /// @notice Allows the owner to remove the interchain client from the allowed clients set.\n    /// If the client is the latest client, the latest client is set to the zero address.\n    /// @param client       The address of the interchain client to remove.\n    function removeInterchainClient(address client) external;\n\n    /// @notice Allows the owner to set the address of the latest interchain client.\n    /// @dev The new latest client must be an allowed client or zero address.\n    /// Setting the client to zero address effectively pauses the app ability to send messages,\n    /// while allowing to receive them.\n    /// @param client       The address of the latest interchain client.\n    function setLatestInterchainClient(address client) external;\n\n    /// @notice Allows the owner to link the remote app for the given chain ID.\n    /// - This address will be used as the receiver for the messages sent from this chain.\n    /// - This address will be the only trusted sender for the messages sent to this chain.\n    /// @param chainId      The remote chain ID.\n    /// @param remoteApp    The address of the remote app to link.\n    function linkRemoteApp(uint256 chainId, bytes32 remoteApp) external;\n\n    /// @notice Thin wrapper for `linkRemoteApp` to accept EVM address as a parameter.\n    function linkRemoteAppEVM(uint256 chainId, address remoteApp) external;\n\n    /// @notice Allows the owner to add the module to the trusted modules set.\n    /// - This set of modules will be used to verify both sent and received messages.\n    function addTrustedModule(address module) external;\n\n    /// @notice Allows the owner to remove the module from the trusted modules set.\n    function removeTrustedModule(address module) external;\n\n    /// @notice Allows the owner to set the app config for the current app. App config includes:\n    /// - requiredResponses: the number of module responses required for accepting the message\n    /// - optimisticPeriod: the minimum time after which the module responses are considered final\n    function setAppConfigV1(AppConfigV1 memory appConfig) external;\n\n    /// @notice Allows the owner to set the address of the Execution Service.\n    /// This address will be used to request execution of the messages sent from this chain,\n    /// by supplying the Service's execution fee.\n    function setExecutionService(address executionService) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Returns the app config for the current app: requiredResponses and optimisticPeriod.\n    function getAppConfigV1() external view returns (AppConfigV1 memory);\n\n    /// @notice Returns the address of the Execution Service used by this app for sending messages.\n    function getExecutionService() external view returns (address);\n\n    /// @notice Returns the list of Interchain Clients allowed to send messages to this app.\n    function getInterchainClients() external view returns (address[] memory);\n\n    /// @notice Returns the address of the latest interchain client.\n    /// This address is used for sending messages from this app.\n    function getLatestInterchainClient() external view returns (address);\n\n    /// @notice Returns the linked app address (as bytes32) for the given chain ID.\n    function getLinkedApp(uint256 chainId) external view returns (bytes32);\n\n    /// @notice Thin wrapper for `getLinkedApp` to return the linked app address as EVM address.\n    /// @dev Will revert if the linked app address is not an EVM address.\n    function getLinkedAppEVM(uint256 chainId) external view returns (address);\n\n    /// @notice Returns the list of Interchain Modules trusted by this app.\n    /// This set of modules will be used to verify both sent and received messages.\n    function getModules() external view returns (address[] memory);\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint256 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__NoLinkedClient(uint256 chainId);\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint256 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint256 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint256 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint256 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint256 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param message              The message being sent.\n    function getInterchainFee(\n        uint256 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint256 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint256 chainId) external view returns (address);\n}\n\n// node_modules/@openzeppelin/contracts/access/AccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account =\u003e bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role =\u003e RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n// contracts/apps/AbstractICApp.sol\n\nabstract contract AbstractICApp is AbstractICAppEvents, IInterchainApp {\n    using TypeCasts for address;\n\n    error InterchainApp__AlreadyLatestClient(address client);\n    error InterchainApp__BalanceTooLow(uint256 actual, uint256 required);\n    error InterchainApp__ClientAlreadyAdded(address client);\n    error InterchainApp__InterchainClientZeroAddress();\n    error InterchainApp__NotInterchainClient(address account);\n    error InterchainApp__ReceiverNotSet(uint256 chainId);\n    error InterchainApp__SameChainId(uint256 chainId);\n    error InterchainApp__SenderNotAllowed(uint256 srcChainId, bytes32 sender);\n\n    /// @inheritdoc IInterchainApp\n    function appReceive(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        if (!_isInterchainClient(msg.sender)) {\n            revert InterchainApp__NotInterchainClient(msg.sender);\n        }\n        if (srcChainId == block.chainid) {\n            revert InterchainApp__SameChainId(srcChainId);\n        }\n        if (!_isAllowedSender(srcChainId, sender)) {\n            revert InterchainApp__SenderNotAllowed(srcChainId, sender);\n        }\n        _receiveMessage(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n\n    /// @inheritdoc IInterchainApp\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules) {\n        appConfig = _getAppConfig();\n        modules = _getModules();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Performs necessary checks and adds an Interchain Client.\n    /// Optionally sets the latest client to this one.\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _addClient(address client, bool updateLatest) internal {\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (_isInterchainClient(client)) {\n            revert InterchainApp__ClientAlreadyAdded(client);\n        }\n        _toggleClientState(client, true);\n        emit InterchainClientAdded(client);\n        if (updateLatest) {\n            _setLatestClient(client);\n        }\n    }\n\n    /// @dev Performs necessary checks and removes an Interchain Client. If this client is the latest one,\n    /// the latest client is set to zero address (effectively pausing the app ability to send messages).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _removeClient(address client) internal {\n        if (!_isInterchainClient(client)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        _toggleClientState(client, false);\n        emit InterchainClientRemoved(client);\n        if (client == _getLatestClient()) {\n            _setLatestClient(address(0));\n        }\n    }\n\n    /// @dev Sets the latest Interchain Client to one of the allowed clients. Setting the client to zero address\n    /// is allowed and effectively pauses the app ability to send messages (but still allows to receive them).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _setLatestClient(address client) internal {\n        // New latest client must be an allowed client or zero address.\n        if (!_isInterchainClient(client) \u0026\u0026 client != address(0)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        if (client == _getLatestClient()) {\n            revert InterchainApp__AlreadyLatestClient(client);\n        }\n        _storeLatestClient(client);\n        emit LatestClientSet(client);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal virtual;\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal virtual;\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to accept EVM address as a parameter.\n    function _sendInterchainMessageEVM(\n        uint256 dstChainId,\n        address receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _sendInterchainMessage(dstChainId, receiver.addressToBytes32(), messageFee, options, message);\n    }\n\n    /// @dev Performs necessary checks and sends an interchain message.\n    function _sendInterchainMessage(\n        uint256 dstChainId,\n        bytes32 receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (dstChainId == block.chainid) {\n            revert InterchainApp__SameChainId(dstChainId);\n        }\n        if (receiver == 0) {\n            revert InterchainApp__ReceiverNotSet(dstChainId);\n        }\n        if (address(this).balance \u003c messageFee) {\n            revert InterchainApp__BalanceTooLow({actual: address(this).balance, required: messageFee});\n        }\n        return IInterchainClientV1(client).interchainSend{value: messageFee}(\n            dstChainId, receiver, _getExecutionService(), _getModules(), options, message\n        );\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        virtual;\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee for sending an Interchain message.\n    function _getInterchainFee(\n        uint256 dstChainId,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        return IInterchainClientV1(client).getInterchainFee(\n            dstChainId, _getExecutionService(), _getModules(), options, message\n        );\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view virtual returns (bytes memory);\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view virtual returns (address);\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view virtual returns (address);\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view virtual returns (address[] memory);\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint256 srcChainId, bytes32 sender) internal view virtual returns (bool);\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view virtual returns (bool);\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/AccessControlEnumerable.sol)\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 role =\u003e EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {AccessControl-_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool granted = super._grantRole(role, account);\n        if (granted) {\n            _roleMembers[role].add(account);\n        }\n        return granted;\n    }\n\n    /**\n     * @dev Overload {AccessControl-_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool revoked = super._revokeRole(role, account);\n        if (revoked) {\n            _roleMembers[role].remove(account);\n        }\n        return revoked;\n    }\n}\n\n// contracts/apps/ICAppV1.sol\n\nabstract contract ICAppV1 is AbstractICApp, AccessControlEnumerable, InterchainAppV1Events, IInterchainAppV1 {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Role to manage the Interchain setup of the app.\n    bytes32 public constant IC_GOVERNOR_ROLE = keccak256(\"IC_GOVERNOR_ROLE\");\n\n    /// @dev Address of the latest Interchain Client, used for sending messages.\n    address private _latestClient;\n\n    /// @dev Required responses and optimistic period for the module responses.\n    AppConfigV1 private _appConfigV1;\n    /// @dev Address of the linked app deployed on the remote chain.\n    mapping(uint256 chainId =\u003e bytes32 remoteApp) private _linkedApp;\n    /// @dev Interchain Clients allowed to send messages to this app.\n    EnumerableSet.AddressSet private _interchainClients;\n    /// @dev Trusted Interchain modules.\n    EnumerableSet.AddressSet private _trustedModules;\n    /// @dev Execution Service to use for sending messages.\n    address private _executionService;\n\n    constructor(address admin) {\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addInterchainClient(address client, bool updateLatest) external onlyRole(IC_GOVERNOR_ROLE) {\n        _addClient(client, updateLatest);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _removeClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setLatestInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _setLatestClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteApp(uint256 chainId, bytes32 remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteAppEVM(uint256 chainId, address remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp.addressToBytes32());\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (module == address(0)) {\n            revert InterchainApp__ModuleZeroAddress();\n        }\n        bool added = _trustedModules.add(module);\n        if (!added) {\n            revert InterchainApp__ModuleAlreadyAdded(module);\n        }\n        emit TrustedModuleAdded(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        bool removed = _trustedModules.remove(module);\n        if (!removed) {\n            revert InterchainApp__ModuleNotAdded(module);\n        }\n        emit TrustedModuleRemoved(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setAppConfigV1(AppConfigV1 memory appConfig) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (appConfig.requiredResponses == 0 || appConfig.optimisticPeriod == 0) {\n            revert InterchainApp__InvalidAppConfig(appConfig.requiredResponses, appConfig.optimisticPeriod);\n        }\n        _appConfigV1 = appConfig;\n        emit AppConfigV1Set(appConfig.requiredResponses, appConfig.optimisticPeriod);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setExecutionService(address executionService) external onlyRole(IC_GOVERNOR_ROLE) {\n        _executionService = executionService;\n        emit ExecutionServiceSet(executionService);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainAppV1\n    function getAppConfigV1() external view returns (AppConfigV1 memory) {\n        return _appConfigV1;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getExecutionService() external view returns (address) {\n        return _executionService;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getInterchainClients() external view returns (address[] memory) {\n        return _interchainClients.values();\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLatestInterchainClient() external view returns (address) {\n        return _latestClient;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedApp(uint256 chainId) external view returns (bytes32) {\n        return _linkedApp[chainId];\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedAppEVM(uint256 chainId) external view returns (address linkedAppEVM) {\n        bytes32 linkedApp = _linkedApp[chainId];\n        linkedAppEVM = linkedApp.bytes32ToAddress();\n        if (linkedAppEVM.addressToBytes32() != linkedApp) {\n            revert InterchainApp__NotEVMLinkedApp(linkedApp);\n        }\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getModules() external view returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Links the remote app to the current app.\n    /// Will revert if the chainId is the same as the chainId of the local app.\n    /// Note: Should be guarded with permissions check.\n    function _linkRemoteApp(uint256 chainId, bytes32 remoteApp) internal {\n        if (chainId == block.chainid) {\n            revert InterchainApp__SameChainId(chainId);\n        }\n        if (remoteApp == 0) {\n            revert InterchainApp__AppZeroAddress();\n        }\n        _linkedApp[chainId] = remoteApp;\n        emit AppLinked(chainId, remoteApp);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal override {\n        _latestClient = client;\n    }\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal override {\n        if (allowed) {\n            _interchainClients.add(client);\n        } else {\n            _interchainClients.remove(client);\n        }\n    }\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to send the message to the linked app.\n    function _sendToLinkedApp(\n        uint256 dstChainId,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _sendInterchainMessage(dstChainId, _linkedApp[dstChainId], messageFee, encodedOptions, message);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee to send a message to the linked app on the remote chain.\n    function _getMessageFee(\n        uint256 dstChainId,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _getInterchainFee(dstChainId, encodedOptions, message);\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view override returns (bytes memory) {\n        return _appConfigV1.encodeAppConfigV1();\n    }\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view override returns (address) {\n        return _executionService;\n    }\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view override returns (address) {\n        return _latestClient;\n    }\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view override returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint256 srcChainId, bytes32 sender) internal view override returns (bool) {\n        return _linkedApp[srcChainId] == sender;\n    }\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view override returns (bool) {\n        return _interchainClients.contains(caller);\n    }\n}\n\n// contracts/apps/examples/ExampleAppV1.sol\n\ncontract ExampleAppV1 is ICAppV1 {\n    event MessageReceived(uint256 srcChainId, bytes32 sender, uint256 dbNonce, uint64 entryIndex, bytes message);\n    event MessageSent(uint256 dstChainId, uint256 dbNonce, uint64 entryIndex, bytes32 transactionId);\n\n    constructor(address admin) ICAppV1(admin) {\n        _grantRole(IC_GOVERNOR_ROLE, admin);\n    }\n\n    /// @notice Allows the Admin to withdraw the native asset from the contract.\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        Address.sendValue(payable(msg.sender), address(this).balance);\n    }\n\n    /// @notice Sends a basic message to the destination chain.\n    function sendMessage(\n        uint256 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        InterchainTxDescriptor memory desc = _sendToLinkedApp({\n            dstChainId: dstChainId,\n            messageFee: msg.value,\n            options: OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}),\n            message: message\n        });\n        emit MessageSent(dstChainId, desc.dbNonce, desc.entryIndex, desc.transactionId);\n    }\n\n    /// @notice Returns the fee required to send a message using `sendMessage`.\n    function getMessageFee(\n        uint256 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes memory message\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _getMessageFee(dstChainId, OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}), message);\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        override\n    {\n        emit MessageReceived(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[],"name":"AccessControlBadConfirmation","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"bytes32","name":"neededRole","type":"bytes32"}],"name":"AccessControlUnauthorizedAccount","type":"error"},{"inputs":[{"internalType":"address","name":"client","type":"address"}],"name":"InterchainApp__AlreadyLatestClient","type":"error"},{"inputs":[],"name":"InterchainApp__AppZeroAddress","type":"error"},{"inputs":[{"internalType":"uint256","name":"actual","type":"uint256"},{"internalType":"uint256","name":"required","type":"uint256"}],"name":"InterchainApp__BalanceTooLow","type":"error"},{"inputs":[{"internalType":"address","name":"client","type":"address"}],"name":"InterchainApp__ClientAlreadyAdded","type":"error"},{"inputs":[],"name":"InterchainApp__InterchainClientZeroAddress","type":"error"},{"inputs":[{"internalType":"uint256","name":"requiredResponses","type":"uint256"},{"internalType":"uint256","name":"optimisticPeriod","type":"uint256"}],"name":"InterchainApp__InvalidAppConfig","type":"error"},{"inputs":[{"internalType":"address","name":"module","type":"address"}],"name":"InterchainApp__ModuleAlreadyAdded","type":"error"},{"inputs":[{"internalType":"address","name":"module","type":"address"}],"name":"InterchainApp__ModuleNotAdded","type":"error"},{"inputs":[],"name":"InterchainApp__ModuleZeroAddress","type":"error"},{"inputs":[{"internalType":"bytes32","name":"linkedApp","type":"bytes32"}],"name":"InterchainApp__NotEVMLinkedApp","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"InterchainApp__NotInterchainClient","type":"error"},{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"}],"name":"InterchainApp__ReceiverNotSet","type":"error"},{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"}],"name":"InterchainApp__SameChainId","type":"error"},{"inputs":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"bytes32","name":"sender","type":"bytes32"}],"name":"InterchainApp__SenderNotAllowed","type":"error"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"requiredResponses","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"optimisticPeriod","type":"uint256"}],"name":"AppConfigV1Set","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"chainId","type":"uint256"},{"indexed":true,"internalType":"bytes32","name":"remoteApp","type":"bytes32"}],"name":"AppLinked","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"executionService","type":"address"}],"name":"ExecutionServiceSet","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"client","type":"address"}],"name":"InterchainClientAdded","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"client","type":"address"}],"name":"InterchainClientRemoved","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"client","type":"address"}],"name":"LatestClientSet","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"bytes32","name":"previousAdminRole","type":"bytes32"},{"indexed":true,"internalType":"bytes32","name":"newAdminRole","type":"bytes32"}],"name":"RoleAdminChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":true,"internalType":"address","name":"sender","type":"address"}],"name":"RoleGranted","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":true,"internalType":"address","name":"sender","type":"address"}],"name":"RoleRevoked","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"module","type":"address"}],"name":"TrustedModuleAdded","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"module","type":"address"}],"name":"TrustedModuleRemoved","type":"event"},{"inputs":[],"name":"DEFAULT_ADMIN_ROLE","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"IC_GOVERNOR_ROLE","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"client","type":"address"},{"internalType":"bool","name":"updateLatest","type":"bool"}],"name":"addInterchainClient","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"module","type":"address"}],"name":"addTrustedModule","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"bytes32","name":"sender","type":"bytes32"},{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"uint64","name":"entryIndex","type":"uint64"},{"internalType":"bytes","name":"message","type":"bytes"}],"name":"appReceive","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"getAppConfigV1","outputs":[{"components":[{"internalType":"uint256","name":"requiredResponses","type":"uint256"},{"internalType":"uint256","name":"optimisticPeriod","type":"uint256"}],"internalType":"struct AppConfigV1","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getExecutionService","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getInterchainClients","outputs":[{"internalType":"address[]","name":"","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getLatestInterchainClient","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"}],"name":"getLinkedApp","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"}],"name":"getLinkedAppEVM","outputs":[{"internalType":"address","name":"linkedAppEVM","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getModules","outputs":[{"internalType":"address[]","name":"","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getReceivingConfig","outputs":[{"internalType":"bytes","name":"appConfig","type":"bytes"},{"internalType":"address[]","name":"modules","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"}],"name":"getRoleAdmin","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"uint256","name":"index","type":"uint256"}],"name":"getRoleMember","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"}],"name":"getRoleMemberCount","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"grantRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"hasRole","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"},{"internalType":"bytes32","name":"remoteApp","type":"bytes32"}],"name":"linkRemoteApp","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"},{"internalType":"address","name":"remoteApp","type":"address"}],"name":"linkRemoteAppEVM","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"client","type":"address"}],"name":"removeInterchainClient","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"module","type":"address"}],"name":"removeTrustedModule","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"callerConfirmation","type":"address"}],"name":"renounceRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"revokeRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"components":[{"internalType":"uint256","name":"requiredResponses","type":"uint256"},{"internalType":"uint256","name":"optimisticPeriod","type":"uint256"}],"internalType":"struct AppConfigV1","name":"appConfig","type":"tuple"}],"name":"setAppConfigV1","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"executionService","type":"address"}],"name":"setExecutionService","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"client","type":"address"}],"name":"setLatestInterchainClient","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes4","name":"interfaceId","type":"bytes4"}],"name":"supportsInterface","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"}],"userDoc":{"kind":"user","methods":{"IC_GOVERNOR_ROLE()":{"notice":"Role to manage the Interchain setup of the app."},"addInterchainClient(address,bool)":{"notice":"Allows the owner to add the interchain client to the allowed clients set, and optionally set the latest client to this one. Note: only the allowed clients can send messages to this app. Note: the latest client is used for sending messages from this app."},"addTrustedModule(address)":{"notice":"Allows the owner to add the module to the trusted modules set. - This set of modules will be used to verify both sent and received messages."},"appReceive(uint256,bytes32,uint256,uint64,bytes)":{"notice":"Allows the Interchain Client to pass the message to the Interchain App."},"getAppConfigV1()":{"notice":"Returns the app config for the current app: requiredResponses and optimisticPeriod."},"getExecutionService()":{"notice":"Returns the address of the Execution Service used by this app for sending messages."},"getInterchainClients()":{"notice":"Returns the list of Interchain Clients allowed to send messages to this app."},"getLatestInterchainClient()":{"notice":"Returns the address of the latest interchain client. This address is used for sending messages from this app."},"getLinkedApp(uint256)":{"notice":"Returns the linked app address (as bytes32) for the given chain ID."},"getLinkedAppEVM(uint256)":{"notice":"Thin wrapper for `getLinkedApp` to return the linked app address as EVM address."},"getModules()":{"notice":"Returns the list of Interchain Modules trusted by this app. This set of modules will be used to verify both sent and received messages."},"getReceivingConfig()":{"notice":"Returns the verification configuration of the Interchain App."},"linkRemoteApp(uint256,bytes32)":{"notice":"Allows the owner to link the remote app for the given chain ID. - This address will be used as the receiver for the messages sent from this chain. - This address will be the only trusted sender for the messages sent to this chain."},"linkRemoteAppEVM(uint256,address)":{"notice":"Thin wrapper for `linkRemoteApp` to accept EVM address as a parameter."},"removeInterchainClient(address)":{"notice":"Allows the owner to remove the interchain client from the allowed clients set. If the client is the latest client, the latest client is set to the zero address."},"removeTrustedModule(address)":{"notice":"Allows the owner to remove the module from the trusted modules set."},"setAppConfigV1((uint256,uint256))":{"notice":"Allows the owner to set the app config for the current app. App config includes: - requiredResponses: the number of module responses required for accepting the message - optimisticPeriod: the minimum time after which the module responses are considered final"},"setExecutionService(address)":{"notice":"Allows the owner to set the address of the Execution Service. This address will be used to request execution of the messages sent from this chain, by supplying the Service's execution fee."},"setLatestInterchainClient(address)":{"notice":"Allows the owner to set the address of the latest interchain client."}},"version":1},"developerDoc":{"errors":{"AccessControlBadConfirmation()":[{"details":"The caller of a function is not the expected one. NOTE: Don't confuse with {AccessControlUnauthorizedAccount}."}],"AccessControlUnauthorizedAccount(address,bytes32)":[{"details":"The `account` is missing a role."}]},"events":{"RoleAdminChanged(bytes32,bytes32,bytes32)":{"details":"Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole` `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite {RoleAdminChanged} not being emitted signaling this."},"RoleGranted(bytes32,address,address)":{"details":"Emitted when `account` is granted `role`. `sender` is the account that originated the contract call, an admin role bearer except when using {AccessControl-_setupRole}."},"RoleRevoked(bytes32,address,address)":{"details":"Emitted when `account` is revoked `role`. `sender` is the account that originated the contract call:   - if using `revokeRole`, it is the admin role bearer   - if using `renounceRole`, it is the role bearer (i.e. `account`)"}},"kind":"dev","methods":{"addInterchainClient(address,bool)":{"params":{"client":"The address of the interchain client to add.","updateLatest":"Whether to set the latest client to this one."}},"appReceive(uint256,bytes32,uint256,uint64,bytes)":{"details":"App is responsible for keeping track of interchain clients, and must verify the message sender.","params":{"dbNonce":"The Interchain DB nonce of the batch containing the message entry.","entryIndex":"The index of the message entry within the batch.","message":"The message being sent.","sender":"Sender address on the source chain, as a bytes32 value.","srcChainId":"Chain ID of the source chain, where the message was sent from."}},"getLinkedAppEVM(uint256)":{"details":"Will revert if the linked app address is not an EVM address."},"getReceivingConfig()":{"details":"This configuration is used by the Interchain Client to verify that message has been confirmed by the Interchain Modules on the destination chain. Note: V1 version of AppConfig includes the required responses count, and optimistic period after which the message is considered confirmed by the module. Following versions may include additional fields.","returns":{"appConfig":"   The versioned configuration of the Interchain App, encoded as bytes.","modules":"     The list of Interchain Modules that app is trusting to confirm the messages."}},"getRoleAdmin(bytes32)":{"details":"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"getRoleMember(bytes32,uint256)":{"details":"Returns one of the accounts that have `role`. `index` must be a value between 0 and {getRoleMemberCount}, non-inclusive. Role bearers are not sorted in any particular way, and their ordering may change at any point. WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure you perform all queries on the same block. See the following https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post] for more information."},"getRoleMemberCount(bytes32)":{"details":"Returns the number of accounts that have `role`. Can be used together with {getRoleMember} to enumerate all bearers of a role."},"grantRole(bytes32,address)":{"details":"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleGranted} event."},"hasRole(bytes32,address)":{"details":"Returns `true` if `account` has been granted `role`."},"linkRemoteApp(uint256,bytes32)":{"params":{"chainId":"The remote chain ID.","remoteApp":"The address of the remote app to link."}},"removeInterchainClient(address)":{"params":{"client":"The address of the interchain client to remove."}},"renounceRole(bytes32,address)":{"details":"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `callerConfirmation`. May emit a {RoleRevoked} event."},"revokeRole(bytes32,address)":{"details":"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleRevoked} event."},"setLatestInterchainClient(address)":{"details":"The new latest client must be an allowed client or zero address. Setting the client to zero address effectively pauses the app ability to send messages, while allowing to receive them.","params":{"client":"The address of the latest interchain client."}},"supportsInterface(bytes4)":{"details":"See {IERC165-supportsInterface}."}},"stateVariables":{"_appConfigV1":{"details":"Required responses and optimistic period for the module responses."},"_executionService":{"details":"Execution Service to use for sending messages."},"_interchainClients":{"details":"Interchain Clients allowed to send messages to this app."},"_latestClient":{"details":"Address of the latest Interchain Client, used for sending messages."},"_linkedApp":{"details":"Address of the linked app deployed on the remote chain."},"_trustedModules":{"details":"Trusted Interchain modules."}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"AccessControlBadConfirmation\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"neededRole\",\"type\":\"bytes32\"}],\"name\":\"AccessControlUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"}],\"name\":\"InterchainApp__AlreadyLatestClient\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InterchainApp__AppZeroAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"required\",\"type\":\"uint256\"}],\"name\":\"InterchainApp__BalanceTooLow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"}],\"name\":\"InterchainApp__ClientAlreadyAdded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InterchainApp__InterchainClientZeroAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requiredResponses\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"optimisticPeriod\",\"type\":\"uint256\"}],\"name\":\"InterchainApp__InvalidAppConfig\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"InterchainApp__ModuleAlreadyAdded\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"InterchainApp__ModuleNotAdded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InterchainApp__ModuleZeroAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"linkedApp\",\"type\":\"bytes32\"}],\"name\":\"InterchainApp__NotEVMLinkedApp\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"InterchainApp__NotInterchainClient\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"InterchainApp__ReceiverNotSet\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"InterchainApp__SameChainId\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"}],\"name\":\"InterchainApp__SenderNotAllowed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requiredResponses\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"optimisticPeriod\",\"type\":\"uint256\"}],\"name\":\"AppConfigV1Set\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"remoteApp\",\"type\":\"bytes32\"}],\"name\":\"AppLinked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"executionService\",\"type\":\"address\"}],\"name\":\"ExecutionServiceSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"}],\"name\":\"InterchainClientAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"}],\"name\":\"InterchainClientRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"}],\"name\":\"LatestClientSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"TrustedModuleAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"TrustedModuleRemoved\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"IC_GOVERNOR_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"updateLatest\",\"type\":\"bool\"}],\"name\":\"addInterchainClient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"addTrustedModule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"appReceive\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAppConfigV1\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"requiredResponses\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"optimisticPeriod\",\"type\":\"uint256\"}],\"internalType\":\"struct AppConfigV1\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getExecutionService\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getInterchainClients\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLatestInterchainClient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"getLinkedApp\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"getLinkedAppEVM\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"linkedAppEVM\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getModules\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReceivingConfig\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"appConfig\",\"type\":\"bytes\"},{\"internalType\":\"address[]\",\"name\":\"modules\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getRoleMember\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleMemberCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"remoteApp\",\"type\":\"bytes32\"}],\"name\":\"linkRemoteApp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"remoteApp\",\"type\":\"address\"}],\"name\":\"linkRemoteAppEVM\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"}],\"name\":\"removeInterchainClient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"removeTrustedModule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"callerConfirmation\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"requiredResponses\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"optimisticPeriod\",\"type\":\"uint256\"}],\"internalType\":\"struct AppConfigV1\",\"name\":\"appConfig\",\"type\":\"tuple\"}],\"name\":\"setAppConfigV1\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"executionService\",\"type\":\"address\"}],\"name\":\"setExecutionService\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"}],\"name\":\"setLatestInterchainClient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"errors\":{\"AccessControlBadConfirmation()\":[{\"details\":\"The caller of a function is not the expected one. NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\"}],\"AccessControlUnauthorizedAccount(address,bytes32)\":[{\"details\":\"The `account` is missing a role.\"}]},\"events\":{\"RoleAdminChanged(bytes32,bytes32,bytes32)\":{\"details\":\"Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole` `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite {RoleAdminChanged} not being emitted signaling this.\"},\"RoleGranted(bytes32,address,address)\":{\"details\":\"Emitted when `account` is granted `role`. `sender` is the account that originated the contract call, an admin role bearer except when using {AccessControl-_setupRole}.\"},\"RoleRevoked(bytes32,address,address)\":{\"details\":\"Emitted when `account` is revoked `role`. `sender` is the account that originated the contract call:   - if using `revokeRole`, it is the admin role bearer   - if using `renounceRole`, it is the role bearer (i.e. `account`)\"}},\"kind\":\"dev\",\"methods\":{\"addInterchainClient(address,bool)\":{\"params\":{\"client\":\"The address of the interchain client to add.\",\"updateLatest\":\"Whether to set the latest client to this one.\"}},\"appReceive(uint256,bytes32,uint256,uint64,bytes)\":{\"details\":\"App is responsible for keeping track of interchain clients, and must verify the message sender.\",\"params\":{\"dbNonce\":\"The Interchain DB nonce of the batch containing the message entry.\",\"entryIndex\":\"The index of the message entry within the batch.\",\"message\":\"The message being sent.\",\"sender\":\"Sender address on the source chain, as a bytes32 value.\",\"srcChainId\":\"Chain ID of the source chain, where the message was sent from.\"}},\"getLinkedAppEVM(uint256)\":{\"details\":\"Will revert if the linked app address is not an EVM address.\"},\"getReceivingConfig()\":{\"details\":\"This configuration is used by the Interchain Client to verify that message has been confirmed by the Interchain Modules on the destination chain. Note: V1 version of AppConfig includes the required responses count, and optimistic period after which the message is considered confirmed by the module. Following versions may include additional fields.\",\"returns\":{\"appConfig\":\"   The versioned configuration of the Interchain App, encoded as bytes.\",\"modules\":\"     The list of Interchain Modules that app is trusting to confirm the messages.\"}},\"getRoleAdmin(bytes32)\":{\"details\":\"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.\"},\"getRoleMember(bytes32,uint256)\":{\"details\":\"Returns one of the accounts that have `role`. `index` must be a value between 0 and {getRoleMemberCount}, non-inclusive. Role bearers are not sorted in any particular way, and their ordering may change at any point. WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure you perform all queries on the same block. See the following https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post] for more information.\"},\"getRoleMemberCount(bytes32)\":{\"details\":\"Returns the number of accounts that have `role`. Can be used together with {getRoleMember} to enumerate all bearers of a role.\"},\"grantRole(bytes32,address)\":{\"details\":\"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleGranted} event.\"},\"hasRole(bytes32,address)\":{\"details\":\"Returns `true` if `account` has been granted `role`.\"},\"linkRemoteApp(uint256,bytes32)\":{\"params\":{\"chainId\":\"The remote chain ID.\",\"remoteApp\":\"The address of the remote app to link.\"}},\"removeInterchainClient(address)\":{\"params\":{\"client\":\"The address of the interchain client to remove.\"}},\"renounceRole(bytes32,address)\":{\"details\":\"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `callerConfirmation`. May emit a {RoleRevoked} event.\"},\"revokeRole(bytes32,address)\":{\"details\":\"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleRevoked} event.\"},\"setLatestInterchainClient(address)\":{\"details\":\"The new latest client must be an allowed client or zero address. Setting the client to zero address effectively pauses the app ability to send messages, while allowing to receive them.\",\"params\":{\"client\":\"The address of the latest interchain client.\"}},\"supportsInterface(bytes4)\":{\"details\":\"See {IERC165-supportsInterface}.\"}},\"stateVariables\":{\"_appConfigV1\":{\"details\":\"Required responses and optimistic period for the module responses.\"},\"_executionService\":{\"details\":\"Execution Service to use for sending messages.\"},\"_interchainClients\":{\"details\":\"Interchain Clients allowed to send messages to this app.\"},\"_latestClient\":{\"details\":\"Address of the latest Interchain Client, used for sending messages.\"},\"_linkedApp\":{\"details\":\"Address of the linked app deployed on the remote chain.\"},\"_trustedModules\":{\"details\":\"Trusted Interchain modules.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"IC_GOVERNOR_ROLE()\":{\"notice\":\"Role to manage the Interchain setup of the app.\"},\"addInterchainClient(address,bool)\":{\"notice\":\"Allows the owner to add the interchain client to the allowed clients set, and optionally set the latest client to this one. Note: only the allowed clients can send messages to this app. Note: the latest client is used for sending messages from this app.\"},\"addTrustedModule(address)\":{\"notice\":\"Allows the owner to add the module to the trusted modules set. - This set of modules will be used to verify both sent and received messages.\"},\"appReceive(uint256,bytes32,uint256,uint64,bytes)\":{\"notice\":\"Allows the Interchain Client to pass the message to the Interchain App.\"},\"getAppConfigV1()\":{\"notice\":\"Returns the app config for the current app: requiredResponses and optimisticPeriod.\"},\"getExecutionService()\":{\"notice\":\"Returns the address of the Execution Service used by this app for sending messages.\"},\"getInterchainClients()\":{\"notice\":\"Returns the list of Interchain Clients allowed to send messages to this app.\"},\"getLatestInterchainClient()\":{\"notice\":\"Returns the address of the latest interchain client. This address is used for sending messages from this app.\"},\"getLinkedApp(uint256)\":{\"notice\":\"Returns the linked app address (as bytes32) for the given chain ID.\"},\"getLinkedAppEVM(uint256)\":{\"notice\":\"Thin wrapper for `getLinkedApp` to return the linked app address as EVM address.\"},\"getModules()\":{\"notice\":\"Returns the list of Interchain Modules trusted by this app. This set of modules will be used to verify both sent and received messages.\"},\"getReceivingConfig()\":{\"notice\":\"Returns the verification configuration of the Interchain App.\"},\"linkRemoteApp(uint256,bytes32)\":{\"notice\":\"Allows the owner to link the remote app for the given chain ID. - This address will be used as the receiver for the messages sent from this chain. - This address will be the only trusted sender for the messages sent to this chain.\"},\"linkRemoteAppEVM(uint256,address)\":{\"notice\":\"Thin wrapper for `linkRemoteApp` to accept EVM address as a parameter.\"},\"removeInterchainClient(address)\":{\"notice\":\"Allows the owner to remove the interchain client from the allowed clients set. If the client is the latest client, the latest client is set to the zero address.\"},\"removeTrustedModule(address)\":{\"notice\":\"Allows the owner to remove the module from the trusted modules set.\"},\"setAppConfigV1((uint256,uint256))\":{\"notice\":\"Allows the owner to set the app config for the current app. App config includes: - requiredResponses: the number of module responses required for accepting the message - optimisticPeriod: the minimum time after which the module responses are considered final\"},\"setExecutionService(address)\":{\"notice\":\"Allows the owner to set the address of the Execution Service. This address will be used to request execution of the messages sent from this chain, by supplying the Service's execution fee.\"},\"setLatestInterchainClient(address)\":{\"notice\":\"Allows the owner to set the address of the latest interchain client.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/ExampleAppV1.sol\":\"ICAppV1\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/ExampleAppV1.sol\":{\"keccak256\":\"0x4c94807e7a2671ad6fcf49fb03cfafa6f51f6b4596f34092fba0bf17b6d482cf\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://4fabc9aa6f6891674b77809808b14ff1f2e8829de650caafa1fb3c3444a07331\",\"dweb:/ipfs/QmVzYNSfkuSkXNaFKuNY3hmkdspssruAhQx4qZuJU3Ceg9\"]}},\"version\":1}"},"hashes":{"DEFAULT_ADMIN_ROLE()":"a217fddf","IC_GOVERNOR_ROLE()":"1c489e4f","addInterchainClient(address,bool)":"f22ba23d","addTrustedModule(address)":"cb5038fb","appReceive(uint256,bytes32,uint256,uint64,bytes)":"68a69847","getAppConfigV1()":"7717a647","getExecutionService()":"c313c807","getInterchainClients()":"a1aa5d68","getLatestInterchainClient()":"bc0d912c","getLinkedApp(uint256)":"b9b74b18","getLinkedAppEVM(uint256)":"a9ac04b6","getModules()":"b2494df3","getReceivingConfig()":"287bc057","getRoleAdmin(bytes32)":"248a9ca3","getRoleMember(bytes32,uint256)":"9010d07c","getRoleMemberCount(bytes32)":"ca15c873","grantRole(bytes32,address)":"2f2ff15d","hasRole(bytes32,address)":"91d14854","linkRemoteApp(uint256,bytes32)":"51a30802","linkRemoteAppEVM(uint256,address)":"af8fcc8e","removeInterchainClient(address)":"0fb59156","removeTrustedModule(address)":"b70c40b3","renounceRole(bytes32,address)":"36568abe","revokeRole(bytes32,address)":"d547741f","setAppConfigV1((uint256,uint256))":"0d32b505","setExecutionService(address)":"496774b1","setLatestInterchainClient(address)":"eb53b44e","supportsInterface(bytes4)":"01ffc9a7"}},"solidity/ExampleAppV1.sol:IERC165":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/AbstractICAppEvents.sol\n\nabstract contract AbstractICAppEvents {\n    event InterchainClientAdded(address client);\n    event InterchainClientRemoved(address client);\n    event LatestClientSet(address client);\n}\n\n// contracts/events/InterchainAppV1Events.sol\n\nabstract contract InterchainAppV1Events {\n    event AppConfigV1Set(uint256 requiredResponses, uint256 optimisticPeriod);\n    event AppLinked(uint256 indexed chainId, bytes32 indexed remoteApp);\n    event ExecutionServiceSet(address executionService);\n    event TrustedModuleAdded(address module);\n    event TrustedModuleRemoved(address module);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    /// @notice Allows the Interchain Client to pass the message to the Interchain App.\n    /// @dev App is responsible for keeping track of interchain clients, and must verify the message sender.\n    /// @param srcChainId   Chain ID of the source chain, where the message was sent from.\n    /// @param sender       Sender address on the source chain, as a bytes32 value.\n    /// @param dbNonce      The Interchain DB nonce of the batch containing the message entry.\n    /// @param entryIndex   The index of the message entry within the batch.\n    /// @param message      The message being sent.\n    function appReceive(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /// @notice Returns the verification configuration of the Interchain App.\n    /// @dev This configuration is used by the Interchain Client to verify that message has been confirmed\n    /// by the Interchain Modules on the destination chain.\n    /// Note: V1 version of AppConfig includes the required responses count, and optimistic period after which\n    /// the message is considered confirmed by the module. Following versions may include additional fields.\n    /// @return appConfig    The versioned configuration of the Interchain App, encoded as bytes.\n    /// @return modules      The list of Interchain Modules that app is trusting to confirm the messages.\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    uint8 constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint8 version);\n\n    /// @notice Encodes versioned app config into a bytes format.\n    /// @param version      The version of the app config.\n    /// @param appConfig    The app config to encode.\n    function encodeVersionedAppConfig(uint8 version, bytes memory appConfig) internal pure returns (bytes memory) {\n        return abi.encode(version, appConfig);\n    }\n\n    /// @notice Decodes versioned app config from a bytes format back into a version and app config.\n    /// @param data         The versioned app config data in bytes format.\n    /// @return version     The version of the app config.\n    /// @return appConfig   The app config as bytes.\n    function decodeVersionedAppConfig(bytes memory data)\n        internal\n        pure\n        returns (uint8 version, bytes memory appConfig)\n    {\n        (version, appConfig) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return encodeVersionedAppConfig(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal pure returns (AppConfigV1 memory) {\n        (uint8 version, bytes memory appConfig) = decodeVersionedAppConfig(data);\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(appConfig, (AppConfigV1));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    uint8 constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint8 version);\n\n    /// @notice Encodes versioned options into a bytes format.\n    /// @param version      The version of the options.\n    /// @param options      The options to encode.\n    function encodeVersionedOptions(uint8 version, bytes memory options) internal pure returns (bytes memory) {\n        return abi.encode(version, options);\n    }\n\n    /// @notice Decodes versioned options from a bytes format back into a version and options.\n    /// @param data         The versioned options data in bytes format.\n    /// @return version     The version of the options.\n    /// @return options     The options as bytes.\n    function decodeVersionedOptions(bytes memory data) internal pure returns (uint8 version, bytes memory options) {\n        (version, options) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return encodeVersionedOptions(OPTIONS_V1, abi.encode(options));\n    }\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal pure returns (OptionsV1 memory) {\n        (uint8 version, bytes memory options) = decodeVersionedOptions(data);\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(options, (OptionsV1));\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/IAccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n\n// node_modules/@openzeppelin/contracts/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance \u003c amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance \u003c value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 \u0026\u0026 target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/libs/InterchainTransaction.sol\n\nstruct InterchainTransaction {\n    uint256 srcChainId;\n    bytes32 srcSender;\n    uint256 dstChainId;\n    bytes32 dstReceiver;\n    uint256 dbNonce;\n    uint64 entryIndex;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint256 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    function constructLocalTransaction(\n        address srcSender,\n        uint256 dstChainId,\n        bytes32 dstReceiver,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: block.chainid,\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(transaction);\n    }\n\n    function decodeTransaction(bytes memory encodedTx) internal pure returns (InterchainTransaction memory) {\n        return abi.decode(encodedTx, (InterchainTransaction));\n    }\n\n    function transactionId(InterchainTransaction memory transaction) internal pure returns (bytes32) {\n        return keccak256(abi.encode(transaction));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/IAccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/IAccessControlEnumerable.sol)\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n// contracts/interfaces/IInterchainAppV1.sol\n\ninterface IInterchainAppV1 is IInterchainApp {\n    error InterchainApp__AppZeroAddress();\n    error InterchainApp__InvalidAppConfig(uint256 requiredResponses, uint256 optimisticPeriod);\n    error InterchainApp__ModuleAlreadyAdded(address module);\n    error InterchainApp__ModuleNotAdded(address module);\n    error InterchainApp__ModuleZeroAddress();\n    error InterchainApp__NotEVMLinkedApp(bytes32 linkedApp);\n\n    /// @notice Allows the owner to add the interchain client to the allowed clients set,\n    /// and optionally set the latest client to this one.\n    /// Note: only the allowed clients can send messages to this app.\n    /// Note: the latest client is used for sending messages from this app.\n    /// @param client       The address of the interchain client to add.\n    /// @param updateLatest Whether to set the latest client to this one.\n    function addInterchainClient(address client, bool updateLatest) external;\n\n    /// @notice Allows the owner to remove the interchain client from the allowed clients set.\n    /// If the client is the latest client, the latest client is set to the zero address.\n    /// @param client       The address of the interchain client to remove.\n    function removeInterchainClient(address client) external;\n\n    /// @notice Allows the owner to set the address of the latest interchain client.\n    /// @dev The new latest client must be an allowed client or zero address.\n    /// Setting the client to zero address effectively pauses the app ability to send messages,\n    /// while allowing to receive them.\n    /// @param client       The address of the latest interchain client.\n    function setLatestInterchainClient(address client) external;\n\n    /// @notice Allows the owner to link the remote app for the given chain ID.\n    /// - This address will be used as the receiver for the messages sent from this chain.\n    /// - This address will be the only trusted sender for the messages sent to this chain.\n    /// @param chainId      The remote chain ID.\n    /// @param remoteApp    The address of the remote app to link.\n    function linkRemoteApp(uint256 chainId, bytes32 remoteApp) external;\n\n    /// @notice Thin wrapper for `linkRemoteApp` to accept EVM address as a parameter.\n    function linkRemoteAppEVM(uint256 chainId, address remoteApp) external;\n\n    /// @notice Allows the owner to add the module to the trusted modules set.\n    /// - This set of modules will be used to verify both sent and received messages.\n    function addTrustedModule(address module) external;\n\n    /// @notice Allows the owner to remove the module from the trusted modules set.\n    function removeTrustedModule(address module) external;\n\n    /// @notice Allows the owner to set the app config for the current app. App config includes:\n    /// - requiredResponses: the number of module responses required for accepting the message\n    /// - optimisticPeriod: the minimum time after which the module responses are considered final\n    function setAppConfigV1(AppConfigV1 memory appConfig) external;\n\n    /// @notice Allows the owner to set the address of the Execution Service.\n    /// This address will be used to request execution of the messages sent from this chain,\n    /// by supplying the Service's execution fee.\n    function setExecutionService(address executionService) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Returns the app config for the current app: requiredResponses and optimisticPeriod.\n    function getAppConfigV1() external view returns (AppConfigV1 memory);\n\n    /// @notice Returns the address of the Execution Service used by this app for sending messages.\n    function getExecutionService() external view returns (address);\n\n    /// @notice Returns the list of Interchain Clients allowed to send messages to this app.\n    function getInterchainClients() external view returns (address[] memory);\n\n    /// @notice Returns the address of the latest interchain client.\n    /// This address is used for sending messages from this app.\n    function getLatestInterchainClient() external view returns (address);\n\n    /// @notice Returns the linked app address (as bytes32) for the given chain ID.\n    function getLinkedApp(uint256 chainId) external view returns (bytes32);\n\n    /// @notice Thin wrapper for `getLinkedApp` to return the linked app address as EVM address.\n    /// @dev Will revert if the linked app address is not an EVM address.\n    function getLinkedAppEVM(uint256 chainId) external view returns (address);\n\n    /// @notice Returns the list of Interchain Modules trusted by this app.\n    /// This set of modules will be used to verify both sent and received messages.\n    function getModules() external view returns (address[] memory);\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint256 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__NoLinkedClient(uint256 chainId);\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint256 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint256 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint256 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint256 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint256 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param message              The message being sent.\n    function getInterchainFee(\n        uint256 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint256 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint256 chainId) external view returns (address);\n}\n\n// node_modules/@openzeppelin/contracts/access/AccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account =\u003e bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role =\u003e RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n// contracts/apps/AbstractICApp.sol\n\nabstract contract AbstractICApp is AbstractICAppEvents, IInterchainApp {\n    using TypeCasts for address;\n\n    error InterchainApp__AlreadyLatestClient(address client);\n    error InterchainApp__BalanceTooLow(uint256 actual, uint256 required);\n    error InterchainApp__ClientAlreadyAdded(address client);\n    error InterchainApp__InterchainClientZeroAddress();\n    error InterchainApp__NotInterchainClient(address account);\n    error InterchainApp__ReceiverNotSet(uint256 chainId);\n    error InterchainApp__SameChainId(uint256 chainId);\n    error InterchainApp__SenderNotAllowed(uint256 srcChainId, bytes32 sender);\n\n    /// @inheritdoc IInterchainApp\n    function appReceive(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        if (!_isInterchainClient(msg.sender)) {\n            revert InterchainApp__NotInterchainClient(msg.sender);\n        }\n        if (srcChainId == block.chainid) {\n            revert InterchainApp__SameChainId(srcChainId);\n        }\n        if (!_isAllowedSender(srcChainId, sender)) {\n            revert InterchainApp__SenderNotAllowed(srcChainId, sender);\n        }\n        _receiveMessage(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n\n    /// @inheritdoc IInterchainApp\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules) {\n        appConfig = _getAppConfig();\n        modules = _getModules();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Performs necessary checks and adds an Interchain Client.\n    /// Optionally sets the latest client to this one.\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _addClient(address client, bool updateLatest) internal {\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (_isInterchainClient(client)) {\n            revert InterchainApp__ClientAlreadyAdded(client);\n        }\n        _toggleClientState(client, true);\n        emit InterchainClientAdded(client);\n        if (updateLatest) {\n            _setLatestClient(client);\n        }\n    }\n\n    /// @dev Performs necessary checks and removes an Interchain Client. If this client is the latest one,\n    /// the latest client is set to zero address (effectively pausing the app ability to send messages).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _removeClient(address client) internal {\n        if (!_isInterchainClient(client)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        _toggleClientState(client, false);\n        emit InterchainClientRemoved(client);\n        if (client == _getLatestClient()) {\n            _setLatestClient(address(0));\n        }\n    }\n\n    /// @dev Sets the latest Interchain Client to one of the allowed clients. Setting the client to zero address\n    /// is allowed and effectively pauses the app ability to send messages (but still allows to receive them).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _setLatestClient(address client) internal {\n        // New latest client must be an allowed client or zero address.\n        if (!_isInterchainClient(client) \u0026\u0026 client != address(0)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        if (client == _getLatestClient()) {\n            revert InterchainApp__AlreadyLatestClient(client);\n        }\n        _storeLatestClient(client);\n        emit LatestClientSet(client);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal virtual;\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal virtual;\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to accept EVM address as a parameter.\n    function _sendInterchainMessageEVM(\n        uint256 dstChainId,\n        address receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _sendInterchainMessage(dstChainId, receiver.addressToBytes32(), messageFee, options, message);\n    }\n\n    /// @dev Performs necessary checks and sends an interchain message.\n    function _sendInterchainMessage(\n        uint256 dstChainId,\n        bytes32 receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (dstChainId == block.chainid) {\n            revert InterchainApp__SameChainId(dstChainId);\n        }\n        if (receiver == 0) {\n            revert InterchainApp__ReceiverNotSet(dstChainId);\n        }\n        if (address(this).balance \u003c messageFee) {\n            revert InterchainApp__BalanceTooLow({actual: address(this).balance, required: messageFee});\n        }\n        return IInterchainClientV1(client).interchainSend{value: messageFee}(\n            dstChainId, receiver, _getExecutionService(), _getModules(), options, message\n        );\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        virtual;\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee for sending an Interchain message.\n    function _getInterchainFee(\n        uint256 dstChainId,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        return IInterchainClientV1(client).getInterchainFee(\n            dstChainId, _getExecutionService(), _getModules(), options, message\n        );\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view virtual returns (bytes memory);\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view virtual returns (address);\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view virtual returns (address);\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view virtual returns (address[] memory);\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint256 srcChainId, bytes32 sender) internal view virtual returns (bool);\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view virtual returns (bool);\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/AccessControlEnumerable.sol)\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 role =\u003e EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {AccessControl-_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool granted = super._grantRole(role, account);\n        if (granted) {\n            _roleMembers[role].add(account);\n        }\n        return granted;\n    }\n\n    /**\n     * @dev Overload {AccessControl-_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool revoked = super._revokeRole(role, account);\n        if (revoked) {\n            _roleMembers[role].remove(account);\n        }\n        return revoked;\n    }\n}\n\n// contracts/apps/ICAppV1.sol\n\nabstract contract ICAppV1 is AbstractICApp, AccessControlEnumerable, InterchainAppV1Events, IInterchainAppV1 {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Role to manage the Interchain setup of the app.\n    bytes32 public constant IC_GOVERNOR_ROLE = keccak256(\"IC_GOVERNOR_ROLE\");\n\n    /// @dev Address of the latest Interchain Client, used for sending messages.\n    address private _latestClient;\n\n    /// @dev Required responses and optimistic period for the module responses.\n    AppConfigV1 private _appConfigV1;\n    /// @dev Address of the linked app deployed on the remote chain.\n    mapping(uint256 chainId =\u003e bytes32 remoteApp) private _linkedApp;\n    /// @dev Interchain Clients allowed to send messages to this app.\n    EnumerableSet.AddressSet private _interchainClients;\n    /// @dev Trusted Interchain modules.\n    EnumerableSet.AddressSet private _trustedModules;\n    /// @dev Execution Service to use for sending messages.\n    address private _executionService;\n\n    constructor(address admin) {\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addInterchainClient(address client, bool updateLatest) external onlyRole(IC_GOVERNOR_ROLE) {\n        _addClient(client, updateLatest);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _removeClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setLatestInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _setLatestClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteApp(uint256 chainId, bytes32 remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteAppEVM(uint256 chainId, address remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp.addressToBytes32());\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (module == address(0)) {\n            revert InterchainApp__ModuleZeroAddress();\n        }\n        bool added = _trustedModules.add(module);\n        if (!added) {\n            revert InterchainApp__ModuleAlreadyAdded(module);\n        }\n        emit TrustedModuleAdded(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        bool removed = _trustedModules.remove(module);\n        if (!removed) {\n            revert InterchainApp__ModuleNotAdded(module);\n        }\n        emit TrustedModuleRemoved(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setAppConfigV1(AppConfigV1 memory appConfig) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (appConfig.requiredResponses == 0 || appConfig.optimisticPeriod == 0) {\n            revert InterchainApp__InvalidAppConfig(appConfig.requiredResponses, appConfig.optimisticPeriod);\n        }\n        _appConfigV1 = appConfig;\n        emit AppConfigV1Set(appConfig.requiredResponses, appConfig.optimisticPeriod);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setExecutionService(address executionService) external onlyRole(IC_GOVERNOR_ROLE) {\n        _executionService = executionService;\n        emit ExecutionServiceSet(executionService);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainAppV1\n    function getAppConfigV1() external view returns (AppConfigV1 memory) {\n        return _appConfigV1;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getExecutionService() external view returns (address) {\n        return _executionService;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getInterchainClients() external view returns (address[] memory) {\n        return _interchainClients.values();\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLatestInterchainClient() external view returns (address) {\n        return _latestClient;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedApp(uint256 chainId) external view returns (bytes32) {\n        return _linkedApp[chainId];\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedAppEVM(uint256 chainId) external view returns (address linkedAppEVM) {\n        bytes32 linkedApp = _linkedApp[chainId];\n        linkedAppEVM = linkedApp.bytes32ToAddress();\n        if (linkedAppEVM.addressToBytes32() != linkedApp) {\n            revert InterchainApp__NotEVMLinkedApp(linkedApp);\n        }\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getModules() external view returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Links the remote app to the current app.\n    /// Will revert if the chainId is the same as the chainId of the local app.\n    /// Note: Should be guarded with permissions check.\n    function _linkRemoteApp(uint256 chainId, bytes32 remoteApp) internal {\n        if (chainId == block.chainid) {\n            revert InterchainApp__SameChainId(chainId);\n        }\n        if (remoteApp == 0) {\n            revert InterchainApp__AppZeroAddress();\n        }\n        _linkedApp[chainId] = remoteApp;\n        emit AppLinked(chainId, remoteApp);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal override {\n        _latestClient = client;\n    }\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal override {\n        if (allowed) {\n            _interchainClients.add(client);\n        } else {\n            _interchainClients.remove(client);\n        }\n    }\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to send the message to the linked app.\n    function _sendToLinkedApp(\n        uint256 dstChainId,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _sendInterchainMessage(dstChainId, _linkedApp[dstChainId], messageFee, encodedOptions, message);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee to send a message to the linked app on the remote chain.\n    function _getMessageFee(\n        uint256 dstChainId,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _getInterchainFee(dstChainId, encodedOptions, message);\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view override returns (bytes memory) {\n        return _appConfigV1.encodeAppConfigV1();\n    }\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view override returns (address) {\n        return _executionService;\n    }\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view override returns (address) {\n        return _latestClient;\n    }\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view override returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint256 srcChainId, bytes32 sender) internal view override returns (bool) {\n        return _linkedApp[srcChainId] == sender;\n    }\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view override returns (bool) {\n        return _interchainClients.contains(caller);\n    }\n}\n\n// contracts/apps/examples/ExampleAppV1.sol\n\ncontract ExampleAppV1 is ICAppV1 {\n    event MessageReceived(uint256 srcChainId, bytes32 sender, uint256 dbNonce, uint64 entryIndex, bytes message);\n    event MessageSent(uint256 dstChainId, uint256 dbNonce, uint64 entryIndex, bytes32 transactionId);\n\n    constructor(address admin) ICAppV1(admin) {\n        _grantRole(IC_GOVERNOR_ROLE, admin);\n    }\n\n    /// @notice Allows the Admin to withdraw the native asset from the contract.\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        Address.sendValue(payable(msg.sender), address(this).balance);\n    }\n\n    /// @notice Sends a basic message to the destination chain.\n    function sendMessage(\n        uint256 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        InterchainTxDescriptor memory desc = _sendToLinkedApp({\n            dstChainId: dstChainId,\n            messageFee: msg.value,\n            options: OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}),\n            message: message\n        });\n        emit MessageSent(dstChainId, desc.dbNonce, desc.entryIndex, desc.transactionId);\n    }\n\n    /// @notice Returns the fee required to send a message using `sendMessage`.\n    function getMessageFee(\n        uint256 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes memory message\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _getMessageFee(dstChainId, OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}), message);\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        override\n    {\n        emit MessageReceived(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"bytes4","name":"interfaceId","type":"bytes4"}],"name":"supportsInterface","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"details":"Interface of the ERC165 standard, as defined in the https://eips.ethereum.org/EIPS/eip-165[EIP]. Implementers can declare support of contract interfaces, which can then be queried by others ({ERC165Checker}). For an implementation, see {ERC165}.","kind":"dev","methods":{"supportsInterface(bytes4)":{"details":"Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas."}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Interface of the ERC165 standard, as defined in the https://eips.ethereum.org/EIPS/eip-165[EIP]. Implementers can declare support of contract interfaces, which can then be queried by others ({ERC165Checker}). For an implementation, see {ERC165}.\",\"kind\":\"dev\",\"methods\":{\"supportsInterface(bytes4)\":{\"details\":\"Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/ExampleAppV1.sol\":\"IERC165\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/ExampleAppV1.sol\":{\"keccak256\":\"0x4c94807e7a2671ad6fcf49fb03cfafa6f51f6b4596f34092fba0bf17b6d482cf\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://4fabc9aa6f6891674b77809808b14ff1f2e8829de650caafa1fb3c3444a07331\",\"dweb:/ipfs/QmVzYNSfkuSkXNaFKuNY3hmkdspssruAhQx4qZuJU3Ceg9\"]}},\"version\":1}"},"hashes":{"supportsInterface(bytes4)":"01ffc9a7"}},"solidity/ExampleAppV1.sol:IInterchainApp":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/AbstractICAppEvents.sol\n\nabstract contract AbstractICAppEvents {\n    event InterchainClientAdded(address client);\n    event InterchainClientRemoved(address client);\n    event LatestClientSet(address client);\n}\n\n// contracts/events/InterchainAppV1Events.sol\n\nabstract contract InterchainAppV1Events {\n    event AppConfigV1Set(uint256 requiredResponses, uint256 optimisticPeriod);\n    event AppLinked(uint256 indexed chainId, bytes32 indexed remoteApp);\n    event ExecutionServiceSet(address executionService);\n    event TrustedModuleAdded(address module);\n    event TrustedModuleRemoved(address module);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    /// @notice Allows the Interchain Client to pass the message to the Interchain App.\n    /// @dev App is responsible for keeping track of interchain clients, and must verify the message sender.\n    /// @param srcChainId   Chain ID of the source chain, where the message was sent from.\n    /// @param sender       Sender address on the source chain, as a bytes32 value.\n    /// @param dbNonce      The Interchain DB nonce of the batch containing the message entry.\n    /// @param entryIndex   The index of the message entry within the batch.\n    /// @param message      The message being sent.\n    function appReceive(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /// @notice Returns the verification configuration of the Interchain App.\n    /// @dev This configuration is used by the Interchain Client to verify that message has been confirmed\n    /// by the Interchain Modules on the destination chain.\n    /// Note: V1 version of AppConfig includes the required responses count, and optimistic period after which\n    /// the message is considered confirmed by the module. Following versions may include additional fields.\n    /// @return appConfig    The versioned configuration of the Interchain App, encoded as bytes.\n    /// @return modules      The list of Interchain Modules that app is trusting to confirm the messages.\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    uint8 constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint8 version);\n\n    /// @notice Encodes versioned app config into a bytes format.\n    /// @param version      The version of the app config.\n    /// @param appConfig    The app config to encode.\n    function encodeVersionedAppConfig(uint8 version, bytes memory appConfig) internal pure returns (bytes memory) {\n        return abi.encode(version, appConfig);\n    }\n\n    /// @notice Decodes versioned app config from a bytes format back into a version and app config.\n    /// @param data         The versioned app config data in bytes format.\n    /// @return version     The version of the app config.\n    /// @return appConfig   The app config as bytes.\n    function decodeVersionedAppConfig(bytes memory data)\n        internal\n        pure\n        returns (uint8 version, bytes memory appConfig)\n    {\n        (version, appConfig) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return encodeVersionedAppConfig(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal pure returns (AppConfigV1 memory) {\n        (uint8 version, bytes memory appConfig) = decodeVersionedAppConfig(data);\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(appConfig, (AppConfigV1));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    uint8 constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint8 version);\n\n    /// @notice Encodes versioned options into a bytes format.\n    /// @param version      The version of the options.\n    /// @param options      The options to encode.\n    function encodeVersionedOptions(uint8 version, bytes memory options) internal pure returns (bytes memory) {\n        return abi.encode(version, options);\n    }\n\n    /// @notice Decodes versioned options from a bytes format back into a version and options.\n    /// @param data         The versioned options data in bytes format.\n    /// @return version     The version of the options.\n    /// @return options     The options as bytes.\n    function decodeVersionedOptions(bytes memory data) internal pure returns (uint8 version, bytes memory options) {\n        (version, options) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return encodeVersionedOptions(OPTIONS_V1, abi.encode(options));\n    }\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal pure returns (OptionsV1 memory) {\n        (uint8 version, bytes memory options) = decodeVersionedOptions(data);\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(options, (OptionsV1));\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/IAccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n\n// node_modules/@openzeppelin/contracts/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance \u003c amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance \u003c value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 \u0026\u0026 target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/libs/InterchainTransaction.sol\n\nstruct InterchainTransaction {\n    uint256 srcChainId;\n    bytes32 srcSender;\n    uint256 dstChainId;\n    bytes32 dstReceiver;\n    uint256 dbNonce;\n    uint64 entryIndex;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint256 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    function constructLocalTransaction(\n        address srcSender,\n        uint256 dstChainId,\n        bytes32 dstReceiver,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: block.chainid,\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(transaction);\n    }\n\n    function decodeTransaction(bytes memory encodedTx) internal pure returns (InterchainTransaction memory) {\n        return abi.decode(encodedTx, (InterchainTransaction));\n    }\n\n    function transactionId(InterchainTransaction memory transaction) internal pure returns (bytes32) {\n        return keccak256(abi.encode(transaction));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/IAccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/IAccessControlEnumerable.sol)\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n// contracts/interfaces/IInterchainAppV1.sol\n\ninterface IInterchainAppV1 is IInterchainApp {\n    error InterchainApp__AppZeroAddress();\n    error InterchainApp__InvalidAppConfig(uint256 requiredResponses, uint256 optimisticPeriod);\n    error InterchainApp__ModuleAlreadyAdded(address module);\n    error InterchainApp__ModuleNotAdded(address module);\n    error InterchainApp__ModuleZeroAddress();\n    error InterchainApp__NotEVMLinkedApp(bytes32 linkedApp);\n\n    /// @notice Allows the owner to add the interchain client to the allowed clients set,\n    /// and optionally set the latest client to this one.\n    /// Note: only the allowed clients can send messages to this app.\n    /// Note: the latest client is used for sending messages from this app.\n    /// @param client       The address of the interchain client to add.\n    /// @param updateLatest Whether to set the latest client to this one.\n    function addInterchainClient(address client, bool updateLatest) external;\n\n    /// @notice Allows the owner to remove the interchain client from the allowed clients set.\n    /// If the client is the latest client, the latest client is set to the zero address.\n    /// @param client       The address of the interchain client to remove.\n    function removeInterchainClient(address client) external;\n\n    /// @notice Allows the owner to set the address of the latest interchain client.\n    /// @dev The new latest client must be an allowed client or zero address.\n    /// Setting the client to zero address effectively pauses the app ability to send messages,\n    /// while allowing to receive them.\n    /// @param client       The address of the latest interchain client.\n    function setLatestInterchainClient(address client) external;\n\n    /// @notice Allows the owner to link the remote app for the given chain ID.\n    /// - This address will be used as the receiver for the messages sent from this chain.\n    /// - This address will be the only trusted sender for the messages sent to this chain.\n    /// @param chainId      The remote chain ID.\n    /// @param remoteApp    The address of the remote app to link.\n    function linkRemoteApp(uint256 chainId, bytes32 remoteApp) external;\n\n    /// @notice Thin wrapper for `linkRemoteApp` to accept EVM address as a parameter.\n    function linkRemoteAppEVM(uint256 chainId, address remoteApp) external;\n\n    /// @notice Allows the owner to add the module to the trusted modules set.\n    /// - This set of modules will be used to verify both sent and received messages.\n    function addTrustedModule(address module) external;\n\n    /// @notice Allows the owner to remove the module from the trusted modules set.\n    function removeTrustedModule(address module) external;\n\n    /// @notice Allows the owner to set the app config for the current app. App config includes:\n    /// - requiredResponses: the number of module responses required for accepting the message\n    /// - optimisticPeriod: the minimum time after which the module responses are considered final\n    function setAppConfigV1(AppConfigV1 memory appConfig) external;\n\n    /// @notice Allows the owner to set the address of the Execution Service.\n    /// This address will be used to request execution of the messages sent from this chain,\n    /// by supplying the Service's execution fee.\n    function setExecutionService(address executionService) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Returns the app config for the current app: requiredResponses and optimisticPeriod.\n    function getAppConfigV1() external view returns (AppConfigV1 memory);\n\n    /// @notice Returns the address of the Execution Service used by this app for sending messages.\n    function getExecutionService() external view returns (address);\n\n    /// @notice Returns the list of Interchain Clients allowed to send messages to this app.\n    function getInterchainClients() external view returns (address[] memory);\n\n    /// @notice Returns the address of the latest interchain client.\n    /// This address is used for sending messages from this app.\n    function getLatestInterchainClient() external view returns (address);\n\n    /// @notice Returns the linked app address (as bytes32) for the given chain ID.\n    function getLinkedApp(uint256 chainId) external view returns (bytes32);\n\n    /// @notice Thin wrapper for `getLinkedApp` to return the linked app address as EVM address.\n    /// @dev Will revert if the linked app address is not an EVM address.\n    function getLinkedAppEVM(uint256 chainId) external view returns (address);\n\n    /// @notice Returns the list of Interchain Modules trusted by this app.\n    /// This set of modules will be used to verify both sent and received messages.\n    function getModules() external view returns (address[] memory);\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint256 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__NoLinkedClient(uint256 chainId);\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint256 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint256 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint256 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint256 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint256 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param message              The message being sent.\n    function getInterchainFee(\n        uint256 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint256 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint256 chainId) external view returns (address);\n}\n\n// node_modules/@openzeppelin/contracts/access/AccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account =\u003e bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role =\u003e RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n// contracts/apps/AbstractICApp.sol\n\nabstract contract AbstractICApp is AbstractICAppEvents, IInterchainApp {\n    using TypeCasts for address;\n\n    error InterchainApp__AlreadyLatestClient(address client);\n    error InterchainApp__BalanceTooLow(uint256 actual, uint256 required);\n    error InterchainApp__ClientAlreadyAdded(address client);\n    error InterchainApp__InterchainClientZeroAddress();\n    error InterchainApp__NotInterchainClient(address account);\n    error InterchainApp__ReceiverNotSet(uint256 chainId);\n    error InterchainApp__SameChainId(uint256 chainId);\n    error InterchainApp__SenderNotAllowed(uint256 srcChainId, bytes32 sender);\n\n    /// @inheritdoc IInterchainApp\n    function appReceive(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        if (!_isInterchainClient(msg.sender)) {\n            revert InterchainApp__NotInterchainClient(msg.sender);\n        }\n        if (srcChainId == block.chainid) {\n            revert InterchainApp__SameChainId(srcChainId);\n        }\n        if (!_isAllowedSender(srcChainId, sender)) {\n            revert InterchainApp__SenderNotAllowed(srcChainId, sender);\n        }\n        _receiveMessage(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n\n    /// @inheritdoc IInterchainApp\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules) {\n        appConfig = _getAppConfig();\n        modules = _getModules();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Performs necessary checks and adds an Interchain Client.\n    /// Optionally sets the latest client to this one.\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _addClient(address client, bool updateLatest) internal {\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (_isInterchainClient(client)) {\n            revert InterchainApp__ClientAlreadyAdded(client);\n        }\n        _toggleClientState(client, true);\n        emit InterchainClientAdded(client);\n        if (updateLatest) {\n            _setLatestClient(client);\n        }\n    }\n\n    /// @dev Performs necessary checks and removes an Interchain Client. If this client is the latest one,\n    /// the latest client is set to zero address (effectively pausing the app ability to send messages).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _removeClient(address client) internal {\n        if (!_isInterchainClient(client)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        _toggleClientState(client, false);\n        emit InterchainClientRemoved(client);\n        if (client == _getLatestClient()) {\n            _setLatestClient(address(0));\n        }\n    }\n\n    /// @dev Sets the latest Interchain Client to one of the allowed clients. Setting the client to zero address\n    /// is allowed and effectively pauses the app ability to send messages (but still allows to receive them).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _setLatestClient(address client) internal {\n        // New latest client must be an allowed client or zero address.\n        if (!_isInterchainClient(client) \u0026\u0026 client != address(0)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        if (client == _getLatestClient()) {\n            revert InterchainApp__AlreadyLatestClient(client);\n        }\n        _storeLatestClient(client);\n        emit LatestClientSet(client);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal virtual;\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal virtual;\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to accept EVM address as a parameter.\n    function _sendInterchainMessageEVM(\n        uint256 dstChainId,\n        address receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _sendInterchainMessage(dstChainId, receiver.addressToBytes32(), messageFee, options, message);\n    }\n\n    /// @dev Performs necessary checks and sends an interchain message.\n    function _sendInterchainMessage(\n        uint256 dstChainId,\n        bytes32 receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (dstChainId == block.chainid) {\n            revert InterchainApp__SameChainId(dstChainId);\n        }\n        if (receiver == 0) {\n            revert InterchainApp__ReceiverNotSet(dstChainId);\n        }\n        if (address(this).balance \u003c messageFee) {\n            revert InterchainApp__BalanceTooLow({actual: address(this).balance, required: messageFee});\n        }\n        return IInterchainClientV1(client).interchainSend{value: messageFee}(\n            dstChainId, receiver, _getExecutionService(), _getModules(), options, message\n        );\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        virtual;\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee for sending an Interchain message.\n    function _getInterchainFee(\n        uint256 dstChainId,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        return IInterchainClientV1(client).getInterchainFee(\n            dstChainId, _getExecutionService(), _getModules(), options, message\n        );\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view virtual returns (bytes memory);\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view virtual returns (address);\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view virtual returns (address);\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view virtual returns (address[] memory);\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint256 srcChainId, bytes32 sender) internal view virtual returns (bool);\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view virtual returns (bool);\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/AccessControlEnumerable.sol)\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 role =\u003e EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {AccessControl-_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool granted = super._grantRole(role, account);\n        if (granted) {\n            _roleMembers[role].add(account);\n        }\n        return granted;\n    }\n\n    /**\n     * @dev Overload {AccessControl-_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool revoked = super._revokeRole(role, account);\n        if (revoked) {\n            _roleMembers[role].remove(account);\n        }\n        return revoked;\n    }\n}\n\n// contracts/apps/ICAppV1.sol\n\nabstract contract ICAppV1 is AbstractICApp, AccessControlEnumerable, InterchainAppV1Events, IInterchainAppV1 {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Role to manage the Interchain setup of the app.\n    bytes32 public constant IC_GOVERNOR_ROLE = keccak256(\"IC_GOVERNOR_ROLE\");\n\n    /// @dev Address of the latest Interchain Client, used for sending messages.\n    address private _latestClient;\n\n    /// @dev Required responses and optimistic period for the module responses.\n    AppConfigV1 private _appConfigV1;\n    /// @dev Address of the linked app deployed on the remote chain.\n    mapping(uint256 chainId =\u003e bytes32 remoteApp) private _linkedApp;\n    /// @dev Interchain Clients allowed to send messages to this app.\n    EnumerableSet.AddressSet private _interchainClients;\n    /// @dev Trusted Interchain modules.\n    EnumerableSet.AddressSet private _trustedModules;\n    /// @dev Execution Service to use for sending messages.\n    address private _executionService;\n\n    constructor(address admin) {\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addInterchainClient(address client, bool updateLatest) external onlyRole(IC_GOVERNOR_ROLE) {\n        _addClient(client, updateLatest);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _removeClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setLatestInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _setLatestClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteApp(uint256 chainId, bytes32 remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteAppEVM(uint256 chainId, address remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp.addressToBytes32());\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (module == address(0)) {\n            revert InterchainApp__ModuleZeroAddress();\n        }\n        bool added = _trustedModules.add(module);\n        if (!added) {\n            revert InterchainApp__ModuleAlreadyAdded(module);\n        }\n        emit TrustedModuleAdded(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        bool removed = _trustedModules.remove(module);\n        if (!removed) {\n            revert InterchainApp__ModuleNotAdded(module);\n        }\n        emit TrustedModuleRemoved(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setAppConfigV1(AppConfigV1 memory appConfig) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (appConfig.requiredResponses == 0 || appConfig.optimisticPeriod == 0) {\n            revert InterchainApp__InvalidAppConfig(appConfig.requiredResponses, appConfig.optimisticPeriod);\n        }\n        _appConfigV1 = appConfig;\n        emit AppConfigV1Set(appConfig.requiredResponses, appConfig.optimisticPeriod);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setExecutionService(address executionService) external onlyRole(IC_GOVERNOR_ROLE) {\n        _executionService = executionService;\n        emit ExecutionServiceSet(executionService);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainAppV1\n    function getAppConfigV1() external view returns (AppConfigV1 memory) {\n        return _appConfigV1;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getExecutionService() external view returns (address) {\n        return _executionService;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getInterchainClients() external view returns (address[] memory) {\n        return _interchainClients.values();\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLatestInterchainClient() external view returns (address) {\n        return _latestClient;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedApp(uint256 chainId) external view returns (bytes32) {\n        return _linkedApp[chainId];\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedAppEVM(uint256 chainId) external view returns (address linkedAppEVM) {\n        bytes32 linkedApp = _linkedApp[chainId];\n        linkedAppEVM = linkedApp.bytes32ToAddress();\n        if (linkedAppEVM.addressToBytes32() != linkedApp) {\n            revert InterchainApp__NotEVMLinkedApp(linkedApp);\n        }\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getModules() external view returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Links the remote app to the current app.\n    /// Will revert if the chainId is the same as the chainId of the local app.\n    /// Note: Should be guarded with permissions check.\n    function _linkRemoteApp(uint256 chainId, bytes32 remoteApp) internal {\n        if (chainId == block.chainid) {\n            revert InterchainApp__SameChainId(chainId);\n        }\n        if (remoteApp == 0) {\n            revert InterchainApp__AppZeroAddress();\n        }\n        _linkedApp[chainId] = remoteApp;\n        emit AppLinked(chainId, remoteApp);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal override {\n        _latestClient = client;\n    }\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal override {\n        if (allowed) {\n            _interchainClients.add(client);\n        } else {\n            _interchainClients.remove(client);\n        }\n    }\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to send the message to the linked app.\n    function _sendToLinkedApp(\n        uint256 dstChainId,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _sendInterchainMessage(dstChainId, _linkedApp[dstChainId], messageFee, encodedOptions, message);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee to send a message to the linked app on the remote chain.\n    function _getMessageFee(\n        uint256 dstChainId,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _getInterchainFee(dstChainId, encodedOptions, message);\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view override returns (bytes memory) {\n        return _appConfigV1.encodeAppConfigV1();\n    }\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view override returns (address) {\n        return _executionService;\n    }\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view override returns (address) {\n        return _latestClient;\n    }\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view override returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint256 srcChainId, bytes32 sender) internal view override returns (bool) {\n        return _linkedApp[srcChainId] == sender;\n    }\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view override returns (bool) {\n        return _interchainClients.contains(caller);\n    }\n}\n\n// contracts/apps/examples/ExampleAppV1.sol\n\ncontract ExampleAppV1 is ICAppV1 {\n    event MessageReceived(uint256 srcChainId, bytes32 sender, uint256 dbNonce, uint64 entryIndex, bytes message);\n    event MessageSent(uint256 dstChainId, uint256 dbNonce, uint64 entryIndex, bytes32 transactionId);\n\n    constructor(address admin) ICAppV1(admin) {\n        _grantRole(IC_GOVERNOR_ROLE, admin);\n    }\n\n    /// @notice Allows the Admin to withdraw the native asset from the contract.\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        Address.sendValue(payable(msg.sender), address(this).balance);\n    }\n\n    /// @notice Sends a basic message to the destination chain.\n    function sendMessage(\n        uint256 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        InterchainTxDescriptor memory desc = _sendToLinkedApp({\n            dstChainId: dstChainId,\n            messageFee: msg.value,\n            options: OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}),\n            message: message\n        });\n        emit MessageSent(dstChainId, desc.dbNonce, desc.entryIndex, desc.transactionId);\n    }\n\n    /// @notice Returns the fee required to send a message using `sendMessage`.\n    function getMessageFee(\n        uint256 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes memory message\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _getMessageFee(dstChainId, OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}), message);\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        override\n    {\n        emit MessageReceived(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"bytes32","name":"sender","type":"bytes32"},{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"uint64","name":"entryIndex","type":"uint64"},{"internalType":"bytes","name":"message","type":"bytes"}],"name":"appReceive","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"getReceivingConfig","outputs":[{"internalType":"bytes","name":"appConfig","type":"bytes"},{"internalType":"address[]","name":"modules","type":"address[]"}],"stateMutability":"view","type":"function"}],"userDoc":{"kind":"user","methods":{"appReceive(uint256,bytes32,uint256,uint64,bytes)":{"notice":"Allows the Interchain Client to pass the message to the Interchain App."},"getReceivingConfig()":{"notice":"Returns the verification configuration of the Interchain App."}},"notice":"Minimal interface for the Interchain App to work with the Interchain Client.","version":1},"developerDoc":{"kind":"dev","methods":{"appReceive(uint256,bytes32,uint256,uint64,bytes)":{"details":"App is responsible for keeping track of interchain clients, and must verify the message sender.","params":{"dbNonce":"The Interchain DB nonce of the batch containing the message entry.","entryIndex":"The index of the message entry within the batch.","message":"The message being sent.","sender":"Sender address on the source chain, as a bytes32 value.","srcChainId":"Chain ID of the source chain, where the message was sent from."}},"getReceivingConfig()":{"details":"This configuration is used by the Interchain Client to verify that message has been confirmed by the Interchain Modules on the destination chain. Note: V1 version of AppConfig includes the required responses count, and optimistic period after which the message is considered confirmed by the module. Following versions may include additional fields.","returns":{"appConfig":"   The versioned configuration of the Interchain App, encoded as bytes.","modules":"     The list of Interchain Modules that app is trusting to confirm the messages."}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"appReceive\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReceivingConfig\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"appConfig\",\"type\":\"bytes\"},{\"internalType\":\"address[]\",\"name\":\"modules\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"appReceive(uint256,bytes32,uint256,uint64,bytes)\":{\"details\":\"App is responsible for keeping track of interchain clients, and must verify the message sender.\",\"params\":{\"dbNonce\":\"The Interchain DB nonce of the batch containing the message entry.\",\"entryIndex\":\"The index of the message entry within the batch.\",\"message\":\"The message being sent.\",\"sender\":\"Sender address on the source chain, as a bytes32 value.\",\"srcChainId\":\"Chain ID of the source chain, where the message was sent from.\"}},\"getReceivingConfig()\":{\"details\":\"This configuration is used by the Interchain Client to verify that message has been confirmed by the Interchain Modules on the destination chain. Note: V1 version of AppConfig includes the required responses count, and optimistic period after which the message is considered confirmed by the module. Following versions may include additional fields.\",\"returns\":{\"appConfig\":\"   The versioned configuration of the Interchain App, encoded as bytes.\",\"modules\":\"     The list of Interchain Modules that app is trusting to confirm the messages.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"appReceive(uint256,bytes32,uint256,uint64,bytes)\":{\"notice\":\"Allows the Interchain Client to pass the message to the Interchain App.\"},\"getReceivingConfig()\":{\"notice\":\"Returns the verification configuration of the Interchain App.\"}},\"notice\":\"Minimal interface for the Interchain App to work with the Interchain Client.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/ExampleAppV1.sol\":\"IInterchainApp\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/ExampleAppV1.sol\":{\"keccak256\":\"0x4c94807e7a2671ad6fcf49fb03cfafa6f51f6b4596f34092fba0bf17b6d482cf\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://4fabc9aa6f6891674b77809808b14ff1f2e8829de650caafa1fb3c3444a07331\",\"dweb:/ipfs/QmVzYNSfkuSkXNaFKuNY3hmkdspssruAhQx4qZuJU3Ceg9\"]}},\"version\":1}"},"hashes":{"appReceive(uint256,bytes32,uint256,uint64,bytes)":"68a69847","getReceivingConfig()":"287bc057"}},"solidity/ExampleAppV1.sol:IInterchainAppV1":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/AbstractICAppEvents.sol\n\nabstract contract AbstractICAppEvents {\n    event InterchainClientAdded(address client);\n    event InterchainClientRemoved(address client);\n    event LatestClientSet(address client);\n}\n\n// contracts/events/InterchainAppV1Events.sol\n\nabstract contract InterchainAppV1Events {\n    event AppConfigV1Set(uint256 requiredResponses, uint256 optimisticPeriod);\n    event AppLinked(uint256 indexed chainId, bytes32 indexed remoteApp);\n    event ExecutionServiceSet(address executionService);\n    event TrustedModuleAdded(address module);\n    event TrustedModuleRemoved(address module);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    /// @notice Allows the Interchain Client to pass the message to the Interchain App.\n    /// @dev App is responsible for keeping track of interchain clients, and must verify the message sender.\n    /// @param srcChainId   Chain ID of the source chain, where the message was sent from.\n    /// @param sender       Sender address on the source chain, as a bytes32 value.\n    /// @param dbNonce      The Interchain DB nonce of the batch containing the message entry.\n    /// @param entryIndex   The index of the message entry within the batch.\n    /// @param message      The message being sent.\n    function appReceive(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /// @notice Returns the verification configuration of the Interchain App.\n    /// @dev This configuration is used by the Interchain Client to verify that message has been confirmed\n    /// by the Interchain Modules on the destination chain.\n    /// Note: V1 version of AppConfig includes the required responses count, and optimistic period after which\n    /// the message is considered confirmed by the module. Following versions may include additional fields.\n    /// @return appConfig    The versioned configuration of the Interchain App, encoded as bytes.\n    /// @return modules      The list of Interchain Modules that app is trusting to confirm the messages.\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    uint8 constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint8 version);\n\n    /// @notice Encodes versioned app config into a bytes format.\n    /// @param version      The version of the app config.\n    /// @param appConfig    The app config to encode.\n    function encodeVersionedAppConfig(uint8 version, bytes memory appConfig) internal pure returns (bytes memory) {\n        return abi.encode(version, appConfig);\n    }\n\n    /// @notice Decodes versioned app config from a bytes format back into a version and app config.\n    /// @param data         The versioned app config data in bytes format.\n    /// @return version     The version of the app config.\n    /// @return appConfig   The app config as bytes.\n    function decodeVersionedAppConfig(bytes memory data)\n        internal\n        pure\n        returns (uint8 version, bytes memory appConfig)\n    {\n        (version, appConfig) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return encodeVersionedAppConfig(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal pure returns (AppConfigV1 memory) {\n        (uint8 version, bytes memory appConfig) = decodeVersionedAppConfig(data);\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(appConfig, (AppConfigV1));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    uint8 constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint8 version);\n\n    /// @notice Encodes versioned options into a bytes format.\n    /// @param version      The version of the options.\n    /// @param options      The options to encode.\n    function encodeVersionedOptions(uint8 version, bytes memory options) internal pure returns (bytes memory) {\n        return abi.encode(version, options);\n    }\n\n    /// @notice Decodes versioned options from a bytes format back into a version and options.\n    /// @param data         The versioned options data in bytes format.\n    /// @return version     The version of the options.\n    /// @return options     The options as bytes.\n    function decodeVersionedOptions(bytes memory data) internal pure returns (uint8 version, bytes memory options) {\n        (version, options) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return encodeVersionedOptions(OPTIONS_V1, abi.encode(options));\n    }\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal pure returns (OptionsV1 memory) {\n        (uint8 version, bytes memory options) = decodeVersionedOptions(data);\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(options, (OptionsV1));\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/IAccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n\n// node_modules/@openzeppelin/contracts/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance \u003c amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance \u003c value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 \u0026\u0026 target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/libs/InterchainTransaction.sol\n\nstruct InterchainTransaction {\n    uint256 srcChainId;\n    bytes32 srcSender;\n    uint256 dstChainId;\n    bytes32 dstReceiver;\n    uint256 dbNonce;\n    uint64 entryIndex;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint256 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    function constructLocalTransaction(\n        address srcSender,\n        uint256 dstChainId,\n        bytes32 dstReceiver,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: block.chainid,\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(transaction);\n    }\n\n    function decodeTransaction(bytes memory encodedTx) internal pure returns (InterchainTransaction memory) {\n        return abi.decode(encodedTx, (InterchainTransaction));\n    }\n\n    function transactionId(InterchainTransaction memory transaction) internal pure returns (bytes32) {\n        return keccak256(abi.encode(transaction));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/IAccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/IAccessControlEnumerable.sol)\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n// contracts/interfaces/IInterchainAppV1.sol\n\ninterface IInterchainAppV1 is IInterchainApp {\n    error InterchainApp__AppZeroAddress();\n    error InterchainApp__InvalidAppConfig(uint256 requiredResponses, uint256 optimisticPeriod);\n    error InterchainApp__ModuleAlreadyAdded(address module);\n    error InterchainApp__ModuleNotAdded(address module);\n    error InterchainApp__ModuleZeroAddress();\n    error InterchainApp__NotEVMLinkedApp(bytes32 linkedApp);\n\n    /// @notice Allows the owner to add the interchain client to the allowed clients set,\n    /// and optionally set the latest client to this one.\n    /// Note: only the allowed clients can send messages to this app.\n    /// Note: the latest client is used for sending messages from this app.\n    /// @param client       The address of the interchain client to add.\n    /// @param updateLatest Whether to set the latest client to this one.\n    function addInterchainClient(address client, bool updateLatest) external;\n\n    /// @notice Allows the owner to remove the interchain client from the allowed clients set.\n    /// If the client is the latest client, the latest client is set to the zero address.\n    /// @param client       The address of the interchain client to remove.\n    function removeInterchainClient(address client) external;\n\n    /// @notice Allows the owner to set the address of the latest interchain client.\n    /// @dev The new latest client must be an allowed client or zero address.\n    /// Setting the client to zero address effectively pauses the app ability to send messages,\n    /// while allowing to receive them.\n    /// @param client       The address of the latest interchain client.\n    function setLatestInterchainClient(address client) external;\n\n    /// @notice Allows the owner to link the remote app for the given chain ID.\n    /// - This address will be used as the receiver for the messages sent from this chain.\n    /// - This address will be the only trusted sender for the messages sent to this chain.\n    /// @param chainId      The remote chain ID.\n    /// @param remoteApp    The address of the remote app to link.\n    function linkRemoteApp(uint256 chainId, bytes32 remoteApp) external;\n\n    /// @notice Thin wrapper for `linkRemoteApp` to accept EVM address as a parameter.\n    function linkRemoteAppEVM(uint256 chainId, address remoteApp) external;\n\n    /// @notice Allows the owner to add the module to the trusted modules set.\n    /// - This set of modules will be used to verify both sent and received messages.\n    function addTrustedModule(address module) external;\n\n    /// @notice Allows the owner to remove the module from the trusted modules set.\n    function removeTrustedModule(address module) external;\n\n    /// @notice Allows the owner to set the app config for the current app. App config includes:\n    /// - requiredResponses: the number of module responses required for accepting the message\n    /// - optimisticPeriod: the minimum time after which the module responses are considered final\n    function setAppConfigV1(AppConfigV1 memory appConfig) external;\n\n    /// @notice Allows the owner to set the address of the Execution Service.\n    /// This address will be used to request execution of the messages sent from this chain,\n    /// by supplying the Service's execution fee.\n    function setExecutionService(address executionService) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Returns the app config for the current app: requiredResponses and optimisticPeriod.\n    function getAppConfigV1() external view returns (AppConfigV1 memory);\n\n    /// @notice Returns the address of the Execution Service used by this app for sending messages.\n    function getExecutionService() external view returns (address);\n\n    /// @notice Returns the list of Interchain Clients allowed to send messages to this app.\n    function getInterchainClients() external view returns (address[] memory);\n\n    /// @notice Returns the address of the latest interchain client.\n    /// This address is used for sending messages from this app.\n    function getLatestInterchainClient() external view returns (address);\n\n    /// @notice Returns the linked app address (as bytes32) for the given chain ID.\n    function getLinkedApp(uint256 chainId) external view returns (bytes32);\n\n    /// @notice Thin wrapper for `getLinkedApp` to return the linked app address as EVM address.\n    /// @dev Will revert if the linked app address is not an EVM address.\n    function getLinkedAppEVM(uint256 chainId) external view returns (address);\n\n    /// @notice Returns the list of Interchain Modules trusted by this app.\n    /// This set of modules will be used to verify both sent and received messages.\n    function getModules() external view returns (address[] memory);\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint256 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__NoLinkedClient(uint256 chainId);\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint256 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint256 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint256 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint256 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint256 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param message              The message being sent.\n    function getInterchainFee(\n        uint256 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint256 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint256 chainId) external view returns (address);\n}\n\n// node_modules/@openzeppelin/contracts/access/AccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account =\u003e bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role =\u003e RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n// contracts/apps/AbstractICApp.sol\n\nabstract contract AbstractICApp is AbstractICAppEvents, IInterchainApp {\n    using TypeCasts for address;\n\n    error InterchainApp__AlreadyLatestClient(address client);\n    error InterchainApp__BalanceTooLow(uint256 actual, uint256 required);\n    error InterchainApp__ClientAlreadyAdded(address client);\n    error InterchainApp__InterchainClientZeroAddress();\n    error InterchainApp__NotInterchainClient(address account);\n    error InterchainApp__ReceiverNotSet(uint256 chainId);\n    error InterchainApp__SameChainId(uint256 chainId);\n    error InterchainApp__SenderNotAllowed(uint256 srcChainId, bytes32 sender);\n\n    /// @inheritdoc IInterchainApp\n    function appReceive(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        if (!_isInterchainClient(msg.sender)) {\n            revert InterchainApp__NotInterchainClient(msg.sender);\n        }\n        if (srcChainId == block.chainid) {\n            revert InterchainApp__SameChainId(srcChainId);\n        }\n        if (!_isAllowedSender(srcChainId, sender)) {\n            revert InterchainApp__SenderNotAllowed(srcChainId, sender);\n        }\n        _receiveMessage(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n\n    /// @inheritdoc IInterchainApp\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules) {\n        appConfig = _getAppConfig();\n        modules = _getModules();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Performs necessary checks and adds an Interchain Client.\n    /// Optionally sets the latest client to this one.\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _addClient(address client, bool updateLatest) internal {\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (_isInterchainClient(client)) {\n            revert InterchainApp__ClientAlreadyAdded(client);\n        }\n        _toggleClientState(client, true);\n        emit InterchainClientAdded(client);\n        if (updateLatest) {\n            _setLatestClient(client);\n        }\n    }\n\n    /// @dev Performs necessary checks and removes an Interchain Client. If this client is the latest one,\n    /// the latest client is set to zero address (effectively pausing the app ability to send messages).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _removeClient(address client) internal {\n        if (!_isInterchainClient(client)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        _toggleClientState(client, false);\n        emit InterchainClientRemoved(client);\n        if (client == _getLatestClient()) {\n            _setLatestClient(address(0));\n        }\n    }\n\n    /// @dev Sets the latest Interchain Client to one of the allowed clients. Setting the client to zero address\n    /// is allowed and effectively pauses the app ability to send messages (but still allows to receive them).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _setLatestClient(address client) internal {\n        // New latest client must be an allowed client or zero address.\n        if (!_isInterchainClient(client) \u0026\u0026 client != address(0)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        if (client == _getLatestClient()) {\n            revert InterchainApp__AlreadyLatestClient(client);\n        }\n        _storeLatestClient(client);\n        emit LatestClientSet(client);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal virtual;\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal virtual;\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to accept EVM address as a parameter.\n    function _sendInterchainMessageEVM(\n        uint256 dstChainId,\n        address receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _sendInterchainMessage(dstChainId, receiver.addressToBytes32(), messageFee, options, message);\n    }\n\n    /// @dev Performs necessary checks and sends an interchain message.\n    function _sendInterchainMessage(\n        uint256 dstChainId,\n        bytes32 receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (dstChainId == block.chainid) {\n            revert InterchainApp__SameChainId(dstChainId);\n        }\n        if (receiver == 0) {\n            revert InterchainApp__ReceiverNotSet(dstChainId);\n        }\n        if (address(this).balance \u003c messageFee) {\n            revert InterchainApp__BalanceTooLow({actual: address(this).balance, required: messageFee});\n        }\n        return IInterchainClientV1(client).interchainSend{value: messageFee}(\n            dstChainId, receiver, _getExecutionService(), _getModules(), options, message\n        );\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        virtual;\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee for sending an Interchain message.\n    function _getInterchainFee(\n        uint256 dstChainId,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        return IInterchainClientV1(client).getInterchainFee(\n            dstChainId, _getExecutionService(), _getModules(), options, message\n        );\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view virtual returns (bytes memory);\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view virtual returns (address);\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view virtual returns (address);\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view virtual returns (address[] memory);\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint256 srcChainId, bytes32 sender) internal view virtual returns (bool);\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view virtual returns (bool);\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/AccessControlEnumerable.sol)\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 role =\u003e EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {AccessControl-_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool granted = super._grantRole(role, account);\n        if (granted) {\n            _roleMembers[role].add(account);\n        }\n        return granted;\n    }\n\n    /**\n     * @dev Overload {AccessControl-_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool revoked = super._revokeRole(role, account);\n        if (revoked) {\n            _roleMembers[role].remove(account);\n        }\n        return revoked;\n    }\n}\n\n// contracts/apps/ICAppV1.sol\n\nabstract contract ICAppV1 is AbstractICApp, AccessControlEnumerable, InterchainAppV1Events, IInterchainAppV1 {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Role to manage the Interchain setup of the app.\n    bytes32 public constant IC_GOVERNOR_ROLE = keccak256(\"IC_GOVERNOR_ROLE\");\n\n    /// @dev Address of the latest Interchain Client, used for sending messages.\n    address private _latestClient;\n\n    /// @dev Required responses and optimistic period for the module responses.\n    AppConfigV1 private _appConfigV1;\n    /// @dev Address of the linked app deployed on the remote chain.\n    mapping(uint256 chainId =\u003e bytes32 remoteApp) private _linkedApp;\n    /// @dev Interchain Clients allowed to send messages to this app.\n    EnumerableSet.AddressSet private _interchainClients;\n    /// @dev Trusted Interchain modules.\n    EnumerableSet.AddressSet private _trustedModules;\n    /// @dev Execution Service to use for sending messages.\n    address private _executionService;\n\n    constructor(address admin) {\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addInterchainClient(address client, bool updateLatest) external onlyRole(IC_GOVERNOR_ROLE) {\n        _addClient(client, updateLatest);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _removeClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setLatestInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _setLatestClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteApp(uint256 chainId, bytes32 remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteAppEVM(uint256 chainId, address remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp.addressToBytes32());\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (module == address(0)) {\n            revert InterchainApp__ModuleZeroAddress();\n        }\n        bool added = _trustedModules.add(module);\n        if (!added) {\n            revert InterchainApp__ModuleAlreadyAdded(module);\n        }\n        emit TrustedModuleAdded(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        bool removed = _trustedModules.remove(module);\n        if (!removed) {\n            revert InterchainApp__ModuleNotAdded(module);\n        }\n        emit TrustedModuleRemoved(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setAppConfigV1(AppConfigV1 memory appConfig) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (appConfig.requiredResponses == 0 || appConfig.optimisticPeriod == 0) {\n            revert InterchainApp__InvalidAppConfig(appConfig.requiredResponses, appConfig.optimisticPeriod);\n        }\n        _appConfigV1 = appConfig;\n        emit AppConfigV1Set(appConfig.requiredResponses, appConfig.optimisticPeriod);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setExecutionService(address executionService) external onlyRole(IC_GOVERNOR_ROLE) {\n        _executionService = executionService;\n        emit ExecutionServiceSet(executionService);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainAppV1\n    function getAppConfigV1() external view returns (AppConfigV1 memory) {\n        return _appConfigV1;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getExecutionService() external view returns (address) {\n        return _executionService;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getInterchainClients() external view returns (address[] memory) {\n        return _interchainClients.values();\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLatestInterchainClient() external view returns (address) {\n        return _latestClient;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedApp(uint256 chainId) external view returns (bytes32) {\n        return _linkedApp[chainId];\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedAppEVM(uint256 chainId) external view returns (address linkedAppEVM) {\n        bytes32 linkedApp = _linkedApp[chainId];\n        linkedAppEVM = linkedApp.bytes32ToAddress();\n        if (linkedAppEVM.addressToBytes32() != linkedApp) {\n            revert InterchainApp__NotEVMLinkedApp(linkedApp);\n        }\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getModules() external view returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Links the remote app to the current app.\n    /// Will revert if the chainId is the same as the chainId of the local app.\n    /// Note: Should be guarded with permissions check.\n    function _linkRemoteApp(uint256 chainId, bytes32 remoteApp) internal {\n        if (chainId == block.chainid) {\n            revert InterchainApp__SameChainId(chainId);\n        }\n        if (remoteApp == 0) {\n            revert InterchainApp__AppZeroAddress();\n        }\n        _linkedApp[chainId] = remoteApp;\n        emit AppLinked(chainId, remoteApp);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal override {\n        _latestClient = client;\n    }\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal override {\n        if (allowed) {\n            _interchainClients.add(client);\n        } else {\n            _interchainClients.remove(client);\n        }\n    }\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to send the message to the linked app.\n    function _sendToLinkedApp(\n        uint256 dstChainId,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _sendInterchainMessage(dstChainId, _linkedApp[dstChainId], messageFee, encodedOptions, message);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee to send a message to the linked app on the remote chain.\n    function _getMessageFee(\n        uint256 dstChainId,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _getInterchainFee(dstChainId, encodedOptions, message);\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view override returns (bytes memory) {\n        return _appConfigV1.encodeAppConfigV1();\n    }\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view override returns (address) {\n        return _executionService;\n    }\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view override returns (address) {\n        return _latestClient;\n    }\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view override returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint256 srcChainId, bytes32 sender) internal view override returns (bool) {\n        return _linkedApp[srcChainId] == sender;\n    }\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view override returns (bool) {\n        return _interchainClients.contains(caller);\n    }\n}\n\n// contracts/apps/examples/ExampleAppV1.sol\n\ncontract ExampleAppV1 is ICAppV1 {\n    event MessageReceived(uint256 srcChainId, bytes32 sender, uint256 dbNonce, uint64 entryIndex, bytes message);\n    event MessageSent(uint256 dstChainId, uint256 dbNonce, uint64 entryIndex, bytes32 transactionId);\n\n    constructor(address admin) ICAppV1(admin) {\n        _grantRole(IC_GOVERNOR_ROLE, admin);\n    }\n\n    /// @notice Allows the Admin to withdraw the native asset from the contract.\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        Address.sendValue(payable(msg.sender), address(this).balance);\n    }\n\n    /// @notice Sends a basic message to the destination chain.\n    function sendMessage(\n        uint256 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        InterchainTxDescriptor memory desc = _sendToLinkedApp({\n            dstChainId: dstChainId,\n            messageFee: msg.value,\n            options: OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}),\n            message: message\n        });\n        emit MessageSent(dstChainId, desc.dbNonce, desc.entryIndex, desc.transactionId);\n    }\n\n    /// @notice Returns the fee required to send a message using `sendMessage`.\n    function getMessageFee(\n        uint256 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes memory message\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _getMessageFee(dstChainId, OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}), message);\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        override\n    {\n        emit MessageReceived(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[],"name":"InterchainApp__AppZeroAddress","type":"error"},{"inputs":[{"internalType":"uint256","name":"requiredResponses","type":"uint256"},{"internalType":"uint256","name":"optimisticPeriod","type":"uint256"}],"name":"InterchainApp__InvalidAppConfig","type":"error"},{"inputs":[{"internalType":"address","name":"module","type":"address"}],"name":"InterchainApp__ModuleAlreadyAdded","type":"error"},{"inputs":[{"internalType":"address","name":"module","type":"address"}],"name":"InterchainApp__ModuleNotAdded","type":"error"},{"inputs":[],"name":"InterchainApp__ModuleZeroAddress","type":"error"},{"inputs":[{"internalType":"bytes32","name":"linkedApp","type":"bytes32"}],"name":"InterchainApp__NotEVMLinkedApp","type":"error"},{"inputs":[{"internalType":"address","name":"client","type":"address"},{"internalType":"bool","name":"updateLatest","type":"bool"}],"name":"addInterchainClient","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"module","type":"address"}],"name":"addTrustedModule","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"bytes32","name":"sender","type":"bytes32"},{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"uint64","name":"entryIndex","type":"uint64"},{"internalType":"bytes","name":"message","type":"bytes"}],"name":"appReceive","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"getAppConfigV1","outputs":[{"components":[{"internalType":"uint256","name":"requiredResponses","type":"uint256"},{"internalType":"uint256","name":"optimisticPeriod","type":"uint256"}],"internalType":"struct AppConfigV1","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getExecutionService","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getInterchainClients","outputs":[{"internalType":"address[]","name":"","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getLatestInterchainClient","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"}],"name":"getLinkedApp","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"}],"name":"getLinkedAppEVM","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getModules","outputs":[{"internalType":"address[]","name":"","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getReceivingConfig","outputs":[{"internalType":"bytes","name":"appConfig","type":"bytes"},{"internalType":"address[]","name":"modules","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"},{"internalType":"bytes32","name":"remoteApp","type":"bytes32"}],"name":"linkRemoteApp","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"},{"internalType":"address","name":"remoteApp","type":"address"}],"name":"linkRemoteAppEVM","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"client","type":"address"}],"name":"removeInterchainClient","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"module","type":"address"}],"name":"removeTrustedModule","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"components":[{"internalType":"uint256","name":"requiredResponses","type":"uint256"},{"internalType":"uint256","name":"optimisticPeriod","type":"uint256"}],"internalType":"struct AppConfigV1","name":"appConfig","type":"tuple"}],"name":"setAppConfigV1","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"executionService","type":"address"}],"name":"setExecutionService","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"client","type":"address"}],"name":"setLatestInterchainClient","outputs":[],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{"addInterchainClient(address,bool)":{"notice":"Allows the owner to add the interchain client to the allowed clients set, and optionally set the latest client to this one. Note: only the allowed clients can send messages to this app. Note: the latest client is used for sending messages from this app."},"addTrustedModule(address)":{"notice":"Allows the owner to add the module to the trusted modules set. - This set of modules will be used to verify both sent and received messages."},"appReceive(uint256,bytes32,uint256,uint64,bytes)":{"notice":"Allows the Interchain Client to pass the message to the Interchain App."},"getAppConfigV1()":{"notice":"Returns the app config for the current app: requiredResponses and optimisticPeriod."},"getExecutionService()":{"notice":"Returns the address of the Execution Service used by this app for sending messages."},"getInterchainClients()":{"notice":"Returns the list of Interchain Clients allowed to send messages to this app."},"getLatestInterchainClient()":{"notice":"Returns the address of the latest interchain client. This address is used for sending messages from this app."},"getLinkedApp(uint256)":{"notice":"Returns the linked app address (as bytes32) for the given chain ID."},"getLinkedAppEVM(uint256)":{"notice":"Thin wrapper for `getLinkedApp` to return the linked app address as EVM address."},"getModules()":{"notice":"Returns the list of Interchain Modules trusted by this app. This set of modules will be used to verify both sent and received messages."},"getReceivingConfig()":{"notice":"Returns the verification configuration of the Interchain App."},"linkRemoteApp(uint256,bytes32)":{"notice":"Allows the owner to link the remote app for the given chain ID. - This address will be used as the receiver for the messages sent from this chain. - This address will be the only trusted sender for the messages sent to this chain."},"linkRemoteAppEVM(uint256,address)":{"notice":"Thin wrapper for `linkRemoteApp` to accept EVM address as a parameter."},"removeInterchainClient(address)":{"notice":"Allows the owner to remove the interchain client from the allowed clients set. If the client is the latest client, the latest client is set to the zero address."},"removeTrustedModule(address)":{"notice":"Allows the owner to remove the module from the trusted modules set."},"setAppConfigV1((uint256,uint256))":{"notice":"Allows the owner to set the app config for the current app. App config includes: - requiredResponses: the number of module responses required for accepting the message - optimisticPeriod: the minimum time after which the module responses are considered final"},"setExecutionService(address)":{"notice":"Allows the owner to set the address of the Execution Service. This address will be used to request execution of the messages sent from this chain, by supplying the Service's execution fee."},"setLatestInterchainClient(address)":{"notice":"Allows the owner to set the address of the latest interchain client."}},"version":1},"developerDoc":{"kind":"dev","methods":{"addInterchainClient(address,bool)":{"params":{"client":"The address of the interchain client to add.","updateLatest":"Whether to set the latest client to this one."}},"appReceive(uint256,bytes32,uint256,uint64,bytes)":{"details":"App is responsible for keeping track of interchain clients, and must verify the message sender.","params":{"dbNonce":"The Interchain DB nonce of the batch containing the message entry.","entryIndex":"The index of the message entry within the batch.","message":"The message being sent.","sender":"Sender address on the source chain, as a bytes32 value.","srcChainId":"Chain ID of the source chain, where the message was sent from."}},"getLinkedAppEVM(uint256)":{"details":"Will revert if the linked app address is not an EVM address."},"getReceivingConfig()":{"details":"This configuration is used by the Interchain Client to verify that message has been confirmed by the Interchain Modules on the destination chain. Note: V1 version of AppConfig includes the required responses count, and optimistic period after which the message is considered confirmed by the module. Following versions may include additional fields.","returns":{"appConfig":"   The versioned configuration of the Interchain App, encoded as bytes.","modules":"     The list of Interchain Modules that app is trusting to confirm the messages."}},"linkRemoteApp(uint256,bytes32)":{"params":{"chainId":"The remote chain ID.","remoteApp":"The address of the remote app to link."}},"removeInterchainClient(address)":{"params":{"client":"The address of the interchain client to remove."}},"setLatestInterchainClient(address)":{"details":"The new latest client must be an allowed client or zero address. Setting the client to zero address effectively pauses the app ability to send messages, while allowing to receive them.","params":{"client":"The address of the latest interchain client."}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"InterchainApp__AppZeroAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requiredResponses\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"optimisticPeriod\",\"type\":\"uint256\"}],\"name\":\"InterchainApp__InvalidAppConfig\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"InterchainApp__ModuleAlreadyAdded\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"InterchainApp__ModuleNotAdded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InterchainApp__ModuleZeroAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"linkedApp\",\"type\":\"bytes32\"}],\"name\":\"InterchainApp__NotEVMLinkedApp\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"updateLatest\",\"type\":\"bool\"}],\"name\":\"addInterchainClient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"addTrustedModule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"appReceive\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAppConfigV1\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"requiredResponses\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"optimisticPeriod\",\"type\":\"uint256\"}],\"internalType\":\"struct AppConfigV1\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getExecutionService\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getInterchainClients\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLatestInterchainClient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"getLinkedApp\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"getLinkedAppEVM\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getModules\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReceivingConfig\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"appConfig\",\"type\":\"bytes\"},{\"internalType\":\"address[]\",\"name\":\"modules\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"remoteApp\",\"type\":\"bytes32\"}],\"name\":\"linkRemoteApp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"remoteApp\",\"type\":\"address\"}],\"name\":\"linkRemoteAppEVM\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"}],\"name\":\"removeInterchainClient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"removeTrustedModule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"requiredResponses\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"optimisticPeriod\",\"type\":\"uint256\"}],\"internalType\":\"struct AppConfigV1\",\"name\":\"appConfig\",\"type\":\"tuple\"}],\"name\":\"setAppConfigV1\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"executionService\",\"type\":\"address\"}],\"name\":\"setExecutionService\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"}],\"name\":\"setLatestInterchainClient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"addInterchainClient(address,bool)\":{\"params\":{\"client\":\"The address of the interchain client to add.\",\"updateLatest\":\"Whether to set the latest client to this one.\"}},\"appReceive(uint256,bytes32,uint256,uint64,bytes)\":{\"details\":\"App is responsible for keeping track of interchain clients, and must verify the message sender.\",\"params\":{\"dbNonce\":\"The Interchain DB nonce of the batch containing the message entry.\",\"entryIndex\":\"The index of the message entry within the batch.\",\"message\":\"The message being sent.\",\"sender\":\"Sender address on the source chain, as a bytes32 value.\",\"srcChainId\":\"Chain ID of the source chain, where the message was sent from.\"}},\"getLinkedAppEVM(uint256)\":{\"details\":\"Will revert if the linked app address is not an EVM address.\"},\"getReceivingConfig()\":{\"details\":\"This configuration is used by the Interchain Client to verify that message has been confirmed by the Interchain Modules on the destination chain. Note: V1 version of AppConfig includes the required responses count, and optimistic period after which the message is considered confirmed by the module. Following versions may include additional fields.\",\"returns\":{\"appConfig\":\"   The versioned configuration of the Interchain App, encoded as bytes.\",\"modules\":\"     The list of Interchain Modules that app is trusting to confirm the messages.\"}},\"linkRemoteApp(uint256,bytes32)\":{\"params\":{\"chainId\":\"The remote chain ID.\",\"remoteApp\":\"The address of the remote app to link.\"}},\"removeInterchainClient(address)\":{\"params\":{\"client\":\"The address of the interchain client to remove.\"}},\"setLatestInterchainClient(address)\":{\"details\":\"The new latest client must be an allowed client or zero address. Setting the client to zero address effectively pauses the app ability to send messages, while allowing to receive them.\",\"params\":{\"client\":\"The address of the latest interchain client.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"addInterchainClient(address,bool)\":{\"notice\":\"Allows the owner to add the interchain client to the allowed clients set, and optionally set the latest client to this one. Note: only the allowed clients can send messages to this app. Note: the latest client is used for sending messages from this app.\"},\"addTrustedModule(address)\":{\"notice\":\"Allows the owner to add the module to the trusted modules set. - This set of modules will be used to verify both sent and received messages.\"},\"appReceive(uint256,bytes32,uint256,uint64,bytes)\":{\"notice\":\"Allows the Interchain Client to pass the message to the Interchain App.\"},\"getAppConfigV1()\":{\"notice\":\"Returns the app config for the current app: requiredResponses and optimisticPeriod.\"},\"getExecutionService()\":{\"notice\":\"Returns the address of the Execution Service used by this app for sending messages.\"},\"getInterchainClients()\":{\"notice\":\"Returns the list of Interchain Clients allowed to send messages to this app.\"},\"getLatestInterchainClient()\":{\"notice\":\"Returns the address of the latest interchain client. This address is used for sending messages from this app.\"},\"getLinkedApp(uint256)\":{\"notice\":\"Returns the linked app address (as bytes32) for the given chain ID.\"},\"getLinkedAppEVM(uint256)\":{\"notice\":\"Thin wrapper for `getLinkedApp` to return the linked app address as EVM address.\"},\"getModules()\":{\"notice\":\"Returns the list of Interchain Modules trusted by this app. This set of modules will be used to verify both sent and received messages.\"},\"getReceivingConfig()\":{\"notice\":\"Returns the verification configuration of the Interchain App.\"},\"linkRemoteApp(uint256,bytes32)\":{\"notice\":\"Allows the owner to link the remote app for the given chain ID. - This address will be used as the receiver for the messages sent from this chain. - This address will be the only trusted sender for the messages sent to this chain.\"},\"linkRemoteAppEVM(uint256,address)\":{\"notice\":\"Thin wrapper for `linkRemoteApp` to accept EVM address as a parameter.\"},\"removeInterchainClient(address)\":{\"notice\":\"Allows the owner to remove the interchain client from the allowed clients set. If the client is the latest client, the latest client is set to the zero address.\"},\"removeTrustedModule(address)\":{\"notice\":\"Allows the owner to remove the module from the trusted modules set.\"},\"setAppConfigV1((uint256,uint256))\":{\"notice\":\"Allows the owner to set the app config for the current app. App config includes: - requiredResponses: the number of module responses required for accepting the message - optimisticPeriod: the minimum time after which the module responses are considered final\"},\"setExecutionService(address)\":{\"notice\":\"Allows the owner to set the address of the Execution Service. This address will be used to request execution of the messages sent from this chain, by supplying the Service's execution fee.\"},\"setLatestInterchainClient(address)\":{\"notice\":\"Allows the owner to set the address of the latest interchain client.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/ExampleAppV1.sol\":\"IInterchainAppV1\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/ExampleAppV1.sol\":{\"keccak256\":\"0x4c94807e7a2671ad6fcf49fb03cfafa6f51f6b4596f34092fba0bf17b6d482cf\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://4fabc9aa6f6891674b77809808b14ff1f2e8829de650caafa1fb3c3444a07331\",\"dweb:/ipfs/QmVzYNSfkuSkXNaFKuNY3hmkdspssruAhQx4qZuJU3Ceg9\"]}},\"version\":1}"},"hashes":{"addInterchainClient(address,bool)":"f22ba23d","addTrustedModule(address)":"cb5038fb","appReceive(uint256,bytes32,uint256,uint64,bytes)":"68a69847","getAppConfigV1()":"7717a647","getExecutionService()":"c313c807","getInterchainClients()":"a1aa5d68","getLatestInterchainClient()":"bc0d912c","getLinkedApp(uint256)":"b9b74b18","getLinkedAppEVM(uint256)":"a9ac04b6","getModules()":"b2494df3","getReceivingConfig()":"287bc057","linkRemoteApp(uint256,bytes32)":"51a30802","linkRemoteAppEVM(uint256,address)":"af8fcc8e","removeInterchainClient(address)":"0fb59156","removeTrustedModule(address)":"b70c40b3","setAppConfigV1((uint256,uint256))":"0d32b505","setExecutionService(address)":"496774b1","setLatestInterchainClient(address)":"eb53b44e"}},"solidity/ExampleAppV1.sol:IInterchainClientV1":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/AbstractICAppEvents.sol\n\nabstract contract AbstractICAppEvents {\n    event InterchainClientAdded(address client);\n    event InterchainClientRemoved(address client);\n    event LatestClientSet(address client);\n}\n\n// contracts/events/InterchainAppV1Events.sol\n\nabstract contract InterchainAppV1Events {\n    event AppConfigV1Set(uint256 requiredResponses, uint256 optimisticPeriod);\n    event AppLinked(uint256 indexed chainId, bytes32 indexed remoteApp);\n    event ExecutionServiceSet(address executionService);\n    event TrustedModuleAdded(address module);\n    event TrustedModuleRemoved(address module);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    /// @notice Allows the Interchain Client to pass the message to the Interchain App.\n    /// @dev App is responsible for keeping track of interchain clients, and must verify the message sender.\n    /// @param srcChainId   Chain ID of the source chain, where the message was sent from.\n    /// @param sender       Sender address on the source chain, as a bytes32 value.\n    /// @param dbNonce      The Interchain DB nonce of the batch containing the message entry.\n    /// @param entryIndex   The index of the message entry within the batch.\n    /// @param message      The message being sent.\n    function appReceive(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /// @notice Returns the verification configuration of the Interchain App.\n    /// @dev This configuration is used by the Interchain Client to verify that message has been confirmed\n    /// by the Interchain Modules on the destination chain.\n    /// Note: V1 version of AppConfig includes the required responses count, and optimistic period after which\n    /// the message is considered confirmed by the module. Following versions may include additional fields.\n    /// @return appConfig    The versioned configuration of the Interchain App, encoded as bytes.\n    /// @return modules      The list of Interchain Modules that app is trusting to confirm the messages.\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    uint8 constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint8 version);\n\n    /// @notice Encodes versioned app config into a bytes format.\n    /// @param version      The version of the app config.\n    /// @param appConfig    The app config to encode.\n    function encodeVersionedAppConfig(uint8 version, bytes memory appConfig) internal pure returns (bytes memory) {\n        return abi.encode(version, appConfig);\n    }\n\n    /// @notice Decodes versioned app config from a bytes format back into a version and app config.\n    /// @param data         The versioned app config data in bytes format.\n    /// @return version     The version of the app config.\n    /// @return appConfig   The app config as bytes.\n    function decodeVersionedAppConfig(bytes memory data)\n        internal\n        pure\n        returns (uint8 version, bytes memory appConfig)\n    {\n        (version, appConfig) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return encodeVersionedAppConfig(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal pure returns (AppConfigV1 memory) {\n        (uint8 version, bytes memory appConfig) = decodeVersionedAppConfig(data);\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(appConfig, (AppConfigV1));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    uint8 constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint8 version);\n\n    /// @notice Encodes versioned options into a bytes format.\n    /// @param version      The version of the options.\n    /// @param options      The options to encode.\n    function encodeVersionedOptions(uint8 version, bytes memory options) internal pure returns (bytes memory) {\n        return abi.encode(version, options);\n    }\n\n    /// @notice Decodes versioned options from a bytes format back into a version and options.\n    /// @param data         The versioned options data in bytes format.\n    /// @return version     The version of the options.\n    /// @return options     The options as bytes.\n    function decodeVersionedOptions(bytes memory data) internal pure returns (uint8 version, bytes memory options) {\n        (version, options) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return encodeVersionedOptions(OPTIONS_V1, abi.encode(options));\n    }\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal pure returns (OptionsV1 memory) {\n        (uint8 version, bytes memory options) = decodeVersionedOptions(data);\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(options, (OptionsV1));\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/IAccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n\n// node_modules/@openzeppelin/contracts/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance \u003c amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance \u003c value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 \u0026\u0026 target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/libs/InterchainTransaction.sol\n\nstruct InterchainTransaction {\n    uint256 srcChainId;\n    bytes32 srcSender;\n    uint256 dstChainId;\n    bytes32 dstReceiver;\n    uint256 dbNonce;\n    uint64 entryIndex;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint256 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    function constructLocalTransaction(\n        address srcSender,\n        uint256 dstChainId,\n        bytes32 dstReceiver,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: block.chainid,\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(transaction);\n    }\n\n    function decodeTransaction(bytes memory encodedTx) internal pure returns (InterchainTransaction memory) {\n        return abi.decode(encodedTx, (InterchainTransaction));\n    }\n\n    function transactionId(InterchainTransaction memory transaction) internal pure returns (bytes32) {\n        return keccak256(abi.encode(transaction));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/IAccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/IAccessControlEnumerable.sol)\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n// contracts/interfaces/IInterchainAppV1.sol\n\ninterface IInterchainAppV1 is IInterchainApp {\n    error InterchainApp__AppZeroAddress();\n    error InterchainApp__InvalidAppConfig(uint256 requiredResponses, uint256 optimisticPeriod);\n    error InterchainApp__ModuleAlreadyAdded(address module);\n    error InterchainApp__ModuleNotAdded(address module);\n    error InterchainApp__ModuleZeroAddress();\n    error InterchainApp__NotEVMLinkedApp(bytes32 linkedApp);\n\n    /// @notice Allows the owner to add the interchain client to the allowed clients set,\n    /// and optionally set the latest client to this one.\n    /// Note: only the allowed clients can send messages to this app.\n    /// Note: the latest client is used for sending messages from this app.\n    /// @param client       The address of the interchain client to add.\n    /// @param updateLatest Whether to set the latest client to this one.\n    function addInterchainClient(address client, bool updateLatest) external;\n\n    /// @notice Allows the owner to remove the interchain client from the allowed clients set.\n    /// If the client is the latest client, the latest client is set to the zero address.\n    /// @param client       The address of the interchain client to remove.\n    function removeInterchainClient(address client) external;\n\n    /// @notice Allows the owner to set the address of the latest interchain client.\n    /// @dev The new latest client must be an allowed client or zero address.\n    /// Setting the client to zero address effectively pauses the app ability to send messages,\n    /// while allowing to receive them.\n    /// @param client       The address of the latest interchain client.\n    function setLatestInterchainClient(address client) external;\n\n    /// @notice Allows the owner to link the remote app for the given chain ID.\n    /// - This address will be used as the receiver for the messages sent from this chain.\n    /// - This address will be the only trusted sender for the messages sent to this chain.\n    /// @param chainId      The remote chain ID.\n    /// @param remoteApp    The address of the remote app to link.\n    function linkRemoteApp(uint256 chainId, bytes32 remoteApp) external;\n\n    /// @notice Thin wrapper for `linkRemoteApp` to accept EVM address as a parameter.\n    function linkRemoteAppEVM(uint256 chainId, address remoteApp) external;\n\n    /// @notice Allows the owner to add the module to the trusted modules set.\n    /// - This set of modules will be used to verify both sent and received messages.\n    function addTrustedModule(address module) external;\n\n    /// @notice Allows the owner to remove the module from the trusted modules set.\n    function removeTrustedModule(address module) external;\n\n    /// @notice Allows the owner to set the app config for the current app. App config includes:\n    /// - requiredResponses: the number of module responses required for accepting the message\n    /// - optimisticPeriod: the minimum time after which the module responses are considered final\n    function setAppConfigV1(AppConfigV1 memory appConfig) external;\n\n    /// @notice Allows the owner to set the address of the Execution Service.\n    /// This address will be used to request execution of the messages sent from this chain,\n    /// by supplying the Service's execution fee.\n    function setExecutionService(address executionService) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Returns the app config for the current app: requiredResponses and optimisticPeriod.\n    function getAppConfigV1() external view returns (AppConfigV1 memory);\n\n    /// @notice Returns the address of the Execution Service used by this app for sending messages.\n    function getExecutionService() external view returns (address);\n\n    /// @notice Returns the list of Interchain Clients allowed to send messages to this app.\n    function getInterchainClients() external view returns (address[] memory);\n\n    /// @notice Returns the address of the latest interchain client.\n    /// This address is used for sending messages from this app.\n    function getLatestInterchainClient() external view returns (address);\n\n    /// @notice Returns the linked app address (as bytes32) for the given chain ID.\n    function getLinkedApp(uint256 chainId) external view returns (bytes32);\n\n    /// @notice Thin wrapper for `getLinkedApp` to return the linked app address as EVM address.\n    /// @dev Will revert if the linked app address is not an EVM address.\n    function getLinkedAppEVM(uint256 chainId) external view returns (address);\n\n    /// @notice Returns the list of Interchain Modules trusted by this app.\n    /// This set of modules will be used to verify both sent and received messages.\n    function getModules() external view returns (address[] memory);\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint256 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__NoLinkedClient(uint256 chainId);\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint256 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint256 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint256 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint256 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint256 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param message              The message being sent.\n    function getInterchainFee(\n        uint256 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint256 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint256 chainId) external view returns (address);\n}\n\n// node_modules/@openzeppelin/contracts/access/AccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account =\u003e bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role =\u003e RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n// contracts/apps/AbstractICApp.sol\n\nabstract contract AbstractICApp is AbstractICAppEvents, IInterchainApp {\n    using TypeCasts for address;\n\n    error InterchainApp__AlreadyLatestClient(address client);\n    error InterchainApp__BalanceTooLow(uint256 actual, uint256 required);\n    error InterchainApp__ClientAlreadyAdded(address client);\n    error InterchainApp__InterchainClientZeroAddress();\n    error InterchainApp__NotInterchainClient(address account);\n    error InterchainApp__ReceiverNotSet(uint256 chainId);\n    error InterchainApp__SameChainId(uint256 chainId);\n    error InterchainApp__SenderNotAllowed(uint256 srcChainId, bytes32 sender);\n\n    /// @inheritdoc IInterchainApp\n    function appReceive(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        if (!_isInterchainClient(msg.sender)) {\n            revert InterchainApp__NotInterchainClient(msg.sender);\n        }\n        if (srcChainId == block.chainid) {\n            revert InterchainApp__SameChainId(srcChainId);\n        }\n        if (!_isAllowedSender(srcChainId, sender)) {\n            revert InterchainApp__SenderNotAllowed(srcChainId, sender);\n        }\n        _receiveMessage(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n\n    /// @inheritdoc IInterchainApp\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules) {\n        appConfig = _getAppConfig();\n        modules = _getModules();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Performs necessary checks and adds an Interchain Client.\n    /// Optionally sets the latest client to this one.\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _addClient(address client, bool updateLatest) internal {\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (_isInterchainClient(client)) {\n            revert InterchainApp__ClientAlreadyAdded(client);\n        }\n        _toggleClientState(client, true);\n        emit InterchainClientAdded(client);\n        if (updateLatest) {\n            _setLatestClient(client);\n        }\n    }\n\n    /// @dev Performs necessary checks and removes an Interchain Client. If this client is the latest one,\n    /// the latest client is set to zero address (effectively pausing the app ability to send messages).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _removeClient(address client) internal {\n        if (!_isInterchainClient(client)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        _toggleClientState(client, false);\n        emit InterchainClientRemoved(client);\n        if (client == _getLatestClient()) {\n            _setLatestClient(address(0));\n        }\n    }\n\n    /// @dev Sets the latest Interchain Client to one of the allowed clients. Setting the client to zero address\n    /// is allowed and effectively pauses the app ability to send messages (but still allows to receive them).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _setLatestClient(address client) internal {\n        // New latest client must be an allowed client or zero address.\n        if (!_isInterchainClient(client) \u0026\u0026 client != address(0)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        if (client == _getLatestClient()) {\n            revert InterchainApp__AlreadyLatestClient(client);\n        }\n        _storeLatestClient(client);\n        emit LatestClientSet(client);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal virtual;\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal virtual;\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to accept EVM address as a parameter.\n    function _sendInterchainMessageEVM(\n        uint256 dstChainId,\n        address receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _sendInterchainMessage(dstChainId, receiver.addressToBytes32(), messageFee, options, message);\n    }\n\n    /// @dev Performs necessary checks and sends an interchain message.\n    function _sendInterchainMessage(\n        uint256 dstChainId,\n        bytes32 receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (dstChainId == block.chainid) {\n            revert InterchainApp__SameChainId(dstChainId);\n        }\n        if (receiver == 0) {\n            revert InterchainApp__ReceiverNotSet(dstChainId);\n        }\n        if (address(this).balance \u003c messageFee) {\n            revert InterchainApp__BalanceTooLow({actual: address(this).balance, required: messageFee});\n        }\n        return IInterchainClientV1(client).interchainSend{value: messageFee}(\n            dstChainId, receiver, _getExecutionService(), _getModules(), options, message\n        );\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        virtual;\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee for sending an Interchain message.\n    function _getInterchainFee(\n        uint256 dstChainId,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        return IInterchainClientV1(client).getInterchainFee(\n            dstChainId, _getExecutionService(), _getModules(), options, message\n        );\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view virtual returns (bytes memory);\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view virtual returns (address);\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view virtual returns (address);\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view virtual returns (address[] memory);\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint256 srcChainId, bytes32 sender) internal view virtual returns (bool);\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view virtual returns (bool);\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/AccessControlEnumerable.sol)\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 role =\u003e EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {AccessControl-_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool granted = super._grantRole(role, account);\n        if (granted) {\n            _roleMembers[role].add(account);\n        }\n        return granted;\n    }\n\n    /**\n     * @dev Overload {AccessControl-_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool revoked = super._revokeRole(role, account);\n        if (revoked) {\n            _roleMembers[role].remove(account);\n        }\n        return revoked;\n    }\n}\n\n// contracts/apps/ICAppV1.sol\n\nabstract contract ICAppV1 is AbstractICApp, AccessControlEnumerable, InterchainAppV1Events, IInterchainAppV1 {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Role to manage the Interchain setup of the app.\n    bytes32 public constant IC_GOVERNOR_ROLE = keccak256(\"IC_GOVERNOR_ROLE\");\n\n    /// @dev Address of the latest Interchain Client, used for sending messages.\n    address private _latestClient;\n\n    /// @dev Required responses and optimistic period for the module responses.\n    AppConfigV1 private _appConfigV1;\n    /// @dev Address of the linked app deployed on the remote chain.\n    mapping(uint256 chainId =\u003e bytes32 remoteApp) private _linkedApp;\n    /// @dev Interchain Clients allowed to send messages to this app.\n    EnumerableSet.AddressSet private _interchainClients;\n    /// @dev Trusted Interchain modules.\n    EnumerableSet.AddressSet private _trustedModules;\n    /// @dev Execution Service to use for sending messages.\n    address private _executionService;\n\n    constructor(address admin) {\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addInterchainClient(address client, bool updateLatest) external onlyRole(IC_GOVERNOR_ROLE) {\n        _addClient(client, updateLatest);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _removeClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setLatestInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _setLatestClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteApp(uint256 chainId, bytes32 remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteAppEVM(uint256 chainId, address remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp.addressToBytes32());\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (module == address(0)) {\n            revert InterchainApp__ModuleZeroAddress();\n        }\n        bool added = _trustedModules.add(module);\n        if (!added) {\n            revert InterchainApp__ModuleAlreadyAdded(module);\n        }\n        emit TrustedModuleAdded(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        bool removed = _trustedModules.remove(module);\n        if (!removed) {\n            revert InterchainApp__ModuleNotAdded(module);\n        }\n        emit TrustedModuleRemoved(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setAppConfigV1(AppConfigV1 memory appConfig) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (appConfig.requiredResponses == 0 || appConfig.optimisticPeriod == 0) {\n            revert InterchainApp__InvalidAppConfig(appConfig.requiredResponses, appConfig.optimisticPeriod);\n        }\n        _appConfigV1 = appConfig;\n        emit AppConfigV1Set(appConfig.requiredResponses, appConfig.optimisticPeriod);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setExecutionService(address executionService) external onlyRole(IC_GOVERNOR_ROLE) {\n        _executionService = executionService;\n        emit ExecutionServiceSet(executionService);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainAppV1\n    function getAppConfigV1() external view returns (AppConfigV1 memory) {\n        return _appConfigV1;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getExecutionService() external view returns (address) {\n        return _executionService;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getInterchainClients() external view returns (address[] memory) {\n        return _interchainClients.values();\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLatestInterchainClient() external view returns (address) {\n        return _latestClient;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedApp(uint256 chainId) external view returns (bytes32) {\n        return _linkedApp[chainId];\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedAppEVM(uint256 chainId) external view returns (address linkedAppEVM) {\n        bytes32 linkedApp = _linkedApp[chainId];\n        linkedAppEVM = linkedApp.bytes32ToAddress();\n        if (linkedAppEVM.addressToBytes32() != linkedApp) {\n            revert InterchainApp__NotEVMLinkedApp(linkedApp);\n        }\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getModules() external view returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Links the remote app to the current app.\n    /// Will revert if the chainId is the same as the chainId of the local app.\n    /// Note: Should be guarded with permissions check.\n    function _linkRemoteApp(uint256 chainId, bytes32 remoteApp) internal {\n        if (chainId == block.chainid) {\n            revert InterchainApp__SameChainId(chainId);\n        }\n        if (remoteApp == 0) {\n            revert InterchainApp__AppZeroAddress();\n        }\n        _linkedApp[chainId] = remoteApp;\n        emit AppLinked(chainId, remoteApp);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal override {\n        _latestClient = client;\n    }\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal override {\n        if (allowed) {\n            _interchainClients.add(client);\n        } else {\n            _interchainClients.remove(client);\n        }\n    }\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to send the message to the linked app.\n    function _sendToLinkedApp(\n        uint256 dstChainId,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _sendInterchainMessage(dstChainId, _linkedApp[dstChainId], messageFee, encodedOptions, message);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee to send a message to the linked app on the remote chain.\n    function _getMessageFee(\n        uint256 dstChainId,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _getInterchainFee(dstChainId, encodedOptions, message);\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view override returns (bytes memory) {\n        return _appConfigV1.encodeAppConfigV1();\n    }\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view override returns (address) {\n        return _executionService;\n    }\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view override returns (address) {\n        return _latestClient;\n    }\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view override returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint256 srcChainId, bytes32 sender) internal view override returns (bool) {\n        return _linkedApp[srcChainId] == sender;\n    }\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view override returns (bool) {\n        return _interchainClients.contains(caller);\n    }\n}\n\n// contracts/apps/examples/ExampleAppV1.sol\n\ncontract ExampleAppV1 is ICAppV1 {\n    event MessageReceived(uint256 srcChainId, bytes32 sender, uint256 dbNonce, uint64 entryIndex, bytes message);\n    event MessageSent(uint256 dstChainId, uint256 dbNonce, uint64 entryIndex, bytes32 transactionId);\n\n    constructor(address admin) ICAppV1(admin) {\n        _grantRole(IC_GOVERNOR_ROLE, admin);\n    }\n\n    /// @notice Allows the Admin to withdraw the native asset from the contract.\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        Address.sendValue(payable(msg.sender), address(this).balance);\n    }\n\n    /// @notice Sends a basic message to the destination chain.\n    function sendMessage(\n        uint256 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        InterchainTxDescriptor memory desc = _sendToLinkedApp({\n            dstChainId: dstChainId,\n            messageFee: msg.value,\n            options: OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}),\n            message: message\n        });\n        emit MessageSent(dstChainId, desc.dbNonce, desc.entryIndex, desc.transactionId);\n    }\n\n    /// @notice Returns the fee required to send a message using `sendMessage`.\n    function getMessageFee(\n        uint256 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes memory message\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _getMessageFee(dstChainId, OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}), message);\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        override\n    {\n        emit MessageReceived(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"uint256","name":"actual","type":"uint256"},{"internalType":"uint256","name":"required","type":"uint256"}],"name":"InterchainClientV1__FeeAmountTooLow","type":"error"},{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"}],"name":"InterchainClientV1__IncorrectDstChainId","type":"error"},{"inputs":[{"internalType":"uint256","name":"actual","type":"uint256"},{"internalType":"uint256","name":"required","type":"uint256"}],"name":"InterchainClientV1__IncorrectMsgValue","type":"error"},{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"}],"name":"InterchainClientV1__NoLinkedClient","type":"error"},{"inputs":[{"internalType":"bytes32","name":"client","type":"bytes32"}],"name":"InterchainClientV1__NotEVMClient","type":"error"},{"inputs":[{"internalType":"uint256","name":"actual","type":"uint256"},{"internalType":"uint256","name":"required","type":"uint256"}],"name":"InterchainClientV1__NotEnoughResponses","type":"error"},{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"}],"name":"InterchainClientV1__NotRemoteChainId","type":"error"},{"inputs":[{"internalType":"bytes32","name":"transactionId","type":"bytes32"}],"name":"InterchainClientV1__TxAlreadyExecuted","type":"error"},{"inputs":[{"internalType":"bytes32","name":"transactionId","type":"bytes32"}],"name":"InterchainClientV1__TxNotExecuted","type":"error"},{"inputs":[],"name":"InterchainClientV1__ZeroReceiver","type":"error"},{"inputs":[],"name":"InterchainClientV1__ZeroRequiredResponses","type":"error"},{"inputs":[{"internalType":"bytes","name":"transaction","type":"bytes"}],"name":"getExecutor","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"transactionId","type":"bytes32"}],"name":"getExecutorById","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"dstChainId","type":"uint256"},{"internalType":"address","name":"srcExecutionService","type":"address"},{"internalType":"address[]","name":"srcModules","type":"address[]"},{"internalType":"bytes","name":"options","type":"bytes"},{"internalType":"bytes","name":"message","type":"bytes"}],"name":"getInterchainFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"}],"name":"getLinkedClient","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"}],"name":"getLinkedClientEVM","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"gasLimit","type":"uint256"},{"internalType":"bytes","name":"transaction","type":"bytes"},{"internalType":"bytes32[]","name":"proof","type":"bytes32[]"}],"name":"interchainExecute","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint256","name":"dstChainId","type":"uint256"},{"internalType":"bytes32","name":"receiver","type":"bytes32"},{"internalType":"address","name":"srcExecutionService","type":"address"},{"internalType":"address[]","name":"srcModules","type":"address[]"},{"internalType":"bytes","name":"options","type":"bytes"},{"internalType":"bytes","name":"message","type":"bytes"}],"name":"interchainSend","outputs":[{"components":[{"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"uint64","name":"entryIndex","type":"uint64"}],"internalType":"struct InterchainTxDescriptor","name":"desc","type":"tuple"}],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint256","name":"dstChainId","type":"uint256"},{"internalType":"address","name":"receiver","type":"address"},{"internalType":"address","name":"srcExecutionService","type":"address"},{"internalType":"address[]","name":"srcModules","type":"address[]"},{"internalType":"bytes","name":"options","type":"bytes"},{"internalType":"bytes","name":"message","type":"bytes"}],"name":"interchainSendEVM","outputs":[{"components":[{"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"uint64","name":"entryIndex","type":"uint64"}],"internalType":"struct InterchainTxDescriptor","name":"desc","type":"tuple"}],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"bytes","name":"transaction","type":"bytes"},{"internalType":"bytes32[]","name":"proof","type":"bytes32[]"}],"name":"isExecutable","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"executionFees_","type":"address"}],"name":"setExecutionFees","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"},{"internalType":"bytes32","name":"client","type":"bytes32"}],"name":"setLinkedClient","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"transactionId","type":"bytes32"}],"name":"writeExecutionProof","outputs":[{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"uint64","name":"entryIndex","type":"uint64"}],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{"getExecutor(bytes)":{"notice":"Returns the address of the executor for a transaction that has been sent to the local chain."},"getExecutorById(bytes32)":{"notice":"Returns the address of the executor for a transaction that has been sent to the local chain."},"getInterchainFee(uint256,address,address[],bytes,bytes)":{"notice":"Returns the fee for sending an Interchain message."},"getLinkedClient(uint256)":{"notice":"Returns the address of the linked client (as bytes32) for a specific chain ID."},"getLinkedClientEVM(uint256)":{"notice":"Returns the EVM address of the linked client for a specific chain ID."},"interchainExecute(uint256,bytes,bytes32[])":{"notice":"Executes a transaction that has been sent via the Interchain."},"interchainSend(uint256,bytes32,address,address[],bytes,bytes)":{"notice":"Sends a message to another chain via the Interchain Communication Protocol."},"isExecutable(bytes,bytes32[])":{"notice":"Checks if a transaction is executable."},"setExecutionFees(address)":{"notice":"Sets the address of the ExecutionFees contract."},"setLinkedClient(uint256,bytes32)":{"notice":"Sets the linked client for a specific chain ID."},"writeExecutionProof(bytes32)":{"notice":"Writes the proof of execution for a transaction into the InterchainDB."}},"version":1},"developerDoc":{"kind":"dev","methods":{"getInterchainFee(uint256,address,address[],bytes,bytes)":{"params":{"dstChainId":"The chain ID of the destination chain.","message":"The message being sent.","options":"Execution options for the message sent, currently gas limit + native gas drop.","srcExecutionService":"The address of the execution service to use for the message.","srcModules":"The source modules involved in the message sending."}},"getLinkedClient(uint256)":{"details":"Will return 0x0 if no client is linked for the chain ID."},"getLinkedClientEVM(uint256)":{"details":"Will return 0x0 if no client is linked for the chain ID. Will revert if the client is not an EVM client."},"interchainExecute(uint256,bytes,bytes32[])":{"details":"The transaction must have been previously sent and recorded. Transaction data includes the requested gas limit, but the executors could specify a different gas limit. If the specified gas limit is lower than requested, the requested gas limit will be used. Otherwise, the specified gas limit will be used. This allows to execute the transactions with requested gas limit set too low.","params":{"gasLimit":"The gas limit to use for the execution.","proof":"The Merkle proof for transaction execution, fetched from the source chain.","transaction":"The transaction data."}},"interchainSend(uint256,bytes32,address,address[],bytes,bytes)":{"details":"Charges a fee for the message, which is payable upon calling this function: - Verification fees: paid to every module that verifies the message. - Execution fee: paid to the executor that executes the message. Note: while a specific execution service is specified to request the execution of the message, any executor is able to execute the message on destination chain, earning the execution fee.","params":{"dstChainId":"The chain ID of the destination chain.","message":"The message being sent.","options":"Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.","receiver":"The address of the receiver on the destination chain.","srcExecutionService":"The address of the execution service to use for the message.","srcModules":"The source modules involved in the message sending."},"returns":{"desc":"The descriptor of the sent transaction: - transactionId: the ID of the transaction that was sent. - dbNonce: the database nonce of the batch containing the written entry for transaction. - entryIndex: the index of the written entry for transaction within the batch."}},"isExecutable(bytes,bytes32[])":{"details":"Determines if a transaction meets the criteria to be executed based on: - If approved modules have written to the InterchainDB - If the threshold of approved modules have been met - If the optimistic window has passed for all modules","params":{"proof":"The Merkle proof for transaction execution, fetched from the source chain.","transaction":"The InterchainTransaction struct to be checked."},"returns":{"_0":"bool Returns true if the transaction is executable, false otherwise."}},"setExecutionFees(address)":{"details":"Only callable by the contract owner or an authorized account.","params":{"executionFees_":"The address of the ExecutionFees contract."}},"setLinkedClient(uint256,bytes32)":{"details":"Stores the address of the linked client in a mapping with the chain ID as the key.","params":{"chainId":"The chain ID for which the client is being set.","client":"The address of the client being linked."}},"writeExecutionProof(bytes32)":{"details":"Will revert if the transaction has not been executed.","params":{"transactionId":"The ID of the transaction to write the proof for."},"returns":{"dbNonce":"        The database nonce of the batch containing the written proof for transaction.","entryIndex":"     The index of the written proof for transaction within the batch."}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"required\",\"type\":\"uint256\"}],\"name\":\"InterchainClientV1__FeeAmountTooLow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"InterchainClientV1__IncorrectDstChainId\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"required\",\"type\":\"uint256\"}],\"name\":\"InterchainClientV1__IncorrectMsgValue\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"InterchainClientV1__NoLinkedClient\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"client\",\"type\":\"bytes32\"}],\"name\":\"InterchainClientV1__NotEVMClient\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"required\",\"type\":\"uint256\"}],\"name\":\"InterchainClientV1__NotEnoughResponses\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"InterchainClientV1__NotRemoteChainId\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"}],\"name\":\"InterchainClientV1__TxAlreadyExecuted\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"}],\"name\":\"InterchainClientV1__TxNotExecuted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InterchainClientV1__ZeroReceiver\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InterchainClientV1__ZeroRequiredResponses\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"transaction\",\"type\":\"bytes\"}],\"name\":\"getExecutor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"}],\"name\":\"getExecutorById\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dstChainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"srcExecutionService\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"},{\"internalType\":\"bytes\",\"name\":\"options\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"getInterchainFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"getLinkedClient\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"getLinkedClientEVM\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"transaction\",\"type\":\"bytes\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"interchainExecute\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dstChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"receiver\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"srcExecutionService\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"},{\"internalType\":\"bytes\",\"name\":\"options\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"interchainSend\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"}],\"internalType\":\"struct InterchainTxDescriptor\",\"name\":\"desc\",\"type\":\"tuple\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dstChainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"srcExecutionService\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"},{\"internalType\":\"bytes\",\"name\":\"options\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"interchainSendEVM\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"}],\"internalType\":\"struct InterchainTxDescriptor\",\"name\":\"desc\",\"type\":\"tuple\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"transaction\",\"type\":\"bytes\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"isExecutable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"executionFees_\",\"type\":\"address\"}],\"name\":\"setExecutionFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"client\",\"type\":\"bytes32\"}],\"name\":\"setLinkedClient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"}],\"name\":\"writeExecutionProof\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"getInterchainFee(uint256,address,address[],bytes,bytes)\":{\"params\":{\"dstChainId\":\"The chain ID of the destination chain.\",\"message\":\"The message being sent.\",\"options\":\"Execution options for the message sent, currently gas limit + native gas drop.\",\"srcExecutionService\":\"The address of the execution service to use for the message.\",\"srcModules\":\"The source modules involved in the message sending.\"}},\"getLinkedClient(uint256)\":{\"details\":\"Will return 0x0 if no client is linked for the chain ID.\"},\"getLinkedClientEVM(uint256)\":{\"details\":\"Will return 0x0 if no client is linked for the chain ID. Will revert if the client is not an EVM client.\"},\"interchainExecute(uint256,bytes,bytes32[])\":{\"details\":\"The transaction must have been previously sent and recorded. Transaction data includes the requested gas limit, but the executors could specify a different gas limit. If the specified gas limit is lower than requested, the requested gas limit will be used. Otherwise, the specified gas limit will be used. This allows to execute the transactions with requested gas limit set too low.\",\"params\":{\"gasLimit\":\"The gas limit to use for the execution.\",\"proof\":\"The Merkle proof for transaction execution, fetched from the source chain.\",\"transaction\":\"The transaction data.\"}},\"interchainSend(uint256,bytes32,address,address[],bytes,bytes)\":{\"details\":\"Charges a fee for the message, which is payable upon calling this function: - Verification fees: paid to every module that verifies the message. - Execution fee: paid to the executor that executes the message. Note: while a specific execution service is specified to request the execution of the message, any executor is able to execute the message on destination chain, earning the execution fee.\",\"params\":{\"dstChainId\":\"The chain ID of the destination chain.\",\"message\":\"The message being sent.\",\"options\":\"Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\",\"receiver\":\"The address of the receiver on the destination chain.\",\"srcExecutionService\":\"The address of the execution service to use for the message.\",\"srcModules\":\"The source modules involved in the message sending.\"},\"returns\":{\"desc\":\"The descriptor of the sent transaction: - transactionId: the ID of the transaction that was sent. - dbNonce: the database nonce of the batch containing the written entry for transaction. - entryIndex: the index of the written entry for transaction within the batch.\"}},\"isExecutable(bytes,bytes32[])\":{\"details\":\"Determines if a transaction meets the criteria to be executed based on: - If approved modules have written to the InterchainDB - If the threshold of approved modules have been met - If the optimistic window has passed for all modules\",\"params\":{\"proof\":\"The Merkle proof for transaction execution, fetched from the source chain.\",\"transaction\":\"The InterchainTransaction struct to be checked.\"},\"returns\":{\"_0\":\"bool Returns true if the transaction is executable, false otherwise.\"}},\"setExecutionFees(address)\":{\"details\":\"Only callable by the contract owner or an authorized account.\",\"params\":{\"executionFees_\":\"The address of the ExecutionFees contract.\"}},\"setLinkedClient(uint256,bytes32)\":{\"details\":\"Stores the address of the linked client in a mapping with the chain ID as the key.\",\"params\":{\"chainId\":\"The chain ID for which the client is being set.\",\"client\":\"The address of the client being linked.\"}},\"writeExecutionProof(bytes32)\":{\"details\":\"Will revert if the transaction has not been executed.\",\"params\":{\"transactionId\":\"The ID of the transaction to write the proof for.\"},\"returns\":{\"dbNonce\":\"        The database nonce of the batch containing the written proof for transaction.\",\"entryIndex\":\"     The index of the written proof for transaction within the batch.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"getExecutor(bytes)\":{\"notice\":\"Returns the address of the executor for a transaction that has been sent to the local chain.\"},\"getExecutorById(bytes32)\":{\"notice\":\"Returns the address of the executor for a transaction that has been sent to the local chain.\"},\"getInterchainFee(uint256,address,address[],bytes,bytes)\":{\"notice\":\"Returns the fee for sending an Interchain message.\"},\"getLinkedClient(uint256)\":{\"notice\":\"Returns the address of the linked client (as bytes32) for a specific chain ID.\"},\"getLinkedClientEVM(uint256)\":{\"notice\":\"Returns the EVM address of the linked client for a specific chain ID.\"},\"interchainExecute(uint256,bytes,bytes32[])\":{\"notice\":\"Executes a transaction that has been sent via the Interchain.\"},\"interchainSend(uint256,bytes32,address,address[],bytes,bytes)\":{\"notice\":\"Sends a message to another chain via the Interchain Communication Protocol.\"},\"isExecutable(bytes,bytes32[])\":{\"notice\":\"Checks if a transaction is executable.\"},\"setExecutionFees(address)\":{\"notice\":\"Sets the address of the ExecutionFees contract.\"},\"setLinkedClient(uint256,bytes32)\":{\"notice\":\"Sets the linked client for a specific chain ID.\"},\"writeExecutionProof(bytes32)\":{\"notice\":\"Writes the proof of execution for a transaction into the InterchainDB.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/ExampleAppV1.sol\":\"IInterchainClientV1\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/ExampleAppV1.sol\":{\"keccak256\":\"0x4c94807e7a2671ad6fcf49fb03cfafa6f51f6b4596f34092fba0bf17b6d482cf\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://4fabc9aa6f6891674b77809808b14ff1f2e8829de650caafa1fb3c3444a07331\",\"dweb:/ipfs/QmVzYNSfkuSkXNaFKuNY3hmkdspssruAhQx4qZuJU3Ceg9\"]}},\"version\":1}"},"hashes":{"getExecutor(bytes)":"f92a79ff","getExecutorById(bytes32)":"f1a61fac","getInterchainFee(uint256,address,address[],bytes,bytes)":"3c383e7b","getLinkedClient(uint256)":"aa102ec4","getLinkedClientEVM(uint256)":"02172a35","interchainExecute(uint256,bytes,bytes32[])":"53b67d74","interchainSend(uint256,bytes32,address,address[],bytes,bytes)":"98939d28","interchainSendEVM(uint256,address,address,address[],bytes,bytes)":"827f940d","isExecutable(bytes,bytes32[])":"1450c281","setExecutionFees(address)":"3dc68b87","setLinkedClient(uint256,bytes32)":"f34234c8","writeExecutionProof(bytes32)":"90e81077"}},"solidity/ExampleAppV1.sol:InterchainAppV1Events":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/AbstractICAppEvents.sol\n\nabstract contract AbstractICAppEvents {\n    event InterchainClientAdded(address client);\n    event InterchainClientRemoved(address client);\n    event LatestClientSet(address client);\n}\n\n// contracts/events/InterchainAppV1Events.sol\n\nabstract contract InterchainAppV1Events {\n    event AppConfigV1Set(uint256 requiredResponses, uint256 optimisticPeriod);\n    event AppLinked(uint256 indexed chainId, bytes32 indexed remoteApp);\n    event ExecutionServiceSet(address executionService);\n    event TrustedModuleAdded(address module);\n    event TrustedModuleRemoved(address module);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    /// @notice Allows the Interchain Client to pass the message to the Interchain App.\n    /// @dev App is responsible for keeping track of interchain clients, and must verify the message sender.\n    /// @param srcChainId   Chain ID of the source chain, where the message was sent from.\n    /// @param sender       Sender address on the source chain, as a bytes32 value.\n    /// @param dbNonce      The Interchain DB nonce of the batch containing the message entry.\n    /// @param entryIndex   The index of the message entry within the batch.\n    /// @param message      The message being sent.\n    function appReceive(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /// @notice Returns the verification configuration of the Interchain App.\n    /// @dev This configuration is used by the Interchain Client to verify that message has been confirmed\n    /// by the Interchain Modules on the destination chain.\n    /// Note: V1 version of AppConfig includes the required responses count, and optimistic period after which\n    /// the message is considered confirmed by the module. Following versions may include additional fields.\n    /// @return appConfig    The versioned configuration of the Interchain App, encoded as bytes.\n    /// @return modules      The list of Interchain Modules that app is trusting to confirm the messages.\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    uint8 constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint8 version);\n\n    /// @notice Encodes versioned app config into a bytes format.\n    /// @param version      The version of the app config.\n    /// @param appConfig    The app config to encode.\n    function encodeVersionedAppConfig(uint8 version, bytes memory appConfig) internal pure returns (bytes memory) {\n        return abi.encode(version, appConfig);\n    }\n\n    /// @notice Decodes versioned app config from a bytes format back into a version and app config.\n    /// @param data         The versioned app config data in bytes format.\n    /// @return version     The version of the app config.\n    /// @return appConfig   The app config as bytes.\n    function decodeVersionedAppConfig(bytes memory data)\n        internal\n        pure\n        returns (uint8 version, bytes memory appConfig)\n    {\n        (version, appConfig) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return encodeVersionedAppConfig(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal pure returns (AppConfigV1 memory) {\n        (uint8 version, bytes memory appConfig) = decodeVersionedAppConfig(data);\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(appConfig, (AppConfigV1));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    uint8 constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint8 version);\n\n    /// @notice Encodes versioned options into a bytes format.\n    /// @param version      The version of the options.\n    /// @param options      The options to encode.\n    function encodeVersionedOptions(uint8 version, bytes memory options) internal pure returns (bytes memory) {\n        return abi.encode(version, options);\n    }\n\n    /// @notice Decodes versioned options from a bytes format back into a version and options.\n    /// @param data         The versioned options data in bytes format.\n    /// @return version     The version of the options.\n    /// @return options     The options as bytes.\n    function decodeVersionedOptions(bytes memory data) internal pure returns (uint8 version, bytes memory options) {\n        (version, options) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return encodeVersionedOptions(OPTIONS_V1, abi.encode(options));\n    }\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal pure returns (OptionsV1 memory) {\n        (uint8 version, bytes memory options) = decodeVersionedOptions(data);\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(options, (OptionsV1));\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/IAccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n\n// node_modules/@openzeppelin/contracts/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance \u003c amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance \u003c value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 \u0026\u0026 target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/libs/InterchainTransaction.sol\n\nstruct InterchainTransaction {\n    uint256 srcChainId;\n    bytes32 srcSender;\n    uint256 dstChainId;\n    bytes32 dstReceiver;\n    uint256 dbNonce;\n    uint64 entryIndex;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint256 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    function constructLocalTransaction(\n        address srcSender,\n        uint256 dstChainId,\n        bytes32 dstReceiver,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: block.chainid,\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(transaction);\n    }\n\n    function decodeTransaction(bytes memory encodedTx) internal pure returns (InterchainTransaction memory) {\n        return abi.decode(encodedTx, (InterchainTransaction));\n    }\n\n    function transactionId(InterchainTransaction memory transaction) internal pure returns (bytes32) {\n        return keccak256(abi.encode(transaction));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/IAccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/IAccessControlEnumerable.sol)\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n// contracts/interfaces/IInterchainAppV1.sol\n\ninterface IInterchainAppV1 is IInterchainApp {\n    error InterchainApp__AppZeroAddress();\n    error InterchainApp__InvalidAppConfig(uint256 requiredResponses, uint256 optimisticPeriod);\n    error InterchainApp__ModuleAlreadyAdded(address module);\n    error InterchainApp__ModuleNotAdded(address module);\n    error InterchainApp__ModuleZeroAddress();\n    error InterchainApp__NotEVMLinkedApp(bytes32 linkedApp);\n\n    /// @notice Allows the owner to add the interchain client to the allowed clients set,\n    /// and optionally set the latest client to this one.\n    /// Note: only the allowed clients can send messages to this app.\n    /// Note: the latest client is used for sending messages from this app.\n    /// @param client       The address of the interchain client to add.\n    /// @param updateLatest Whether to set the latest client to this one.\n    function addInterchainClient(address client, bool updateLatest) external;\n\n    /// @notice Allows the owner to remove the interchain client from the allowed clients set.\n    /// If the client is the latest client, the latest client is set to the zero address.\n    /// @param client       The address of the interchain client to remove.\n    function removeInterchainClient(address client) external;\n\n    /// @notice Allows the owner to set the address of the latest interchain client.\n    /// @dev The new latest client must be an allowed client or zero address.\n    /// Setting the client to zero address effectively pauses the app ability to send messages,\n    /// while allowing to receive them.\n    /// @param client       The address of the latest interchain client.\n    function setLatestInterchainClient(address client) external;\n\n    /// @notice Allows the owner to link the remote app for the given chain ID.\n    /// - This address will be used as the receiver for the messages sent from this chain.\n    /// - This address will be the only trusted sender for the messages sent to this chain.\n    /// @param chainId      The remote chain ID.\n    /// @param remoteApp    The address of the remote app to link.\n    function linkRemoteApp(uint256 chainId, bytes32 remoteApp) external;\n\n    /// @notice Thin wrapper for `linkRemoteApp` to accept EVM address as a parameter.\n    function linkRemoteAppEVM(uint256 chainId, address remoteApp) external;\n\n    /// @notice Allows the owner to add the module to the trusted modules set.\n    /// - This set of modules will be used to verify both sent and received messages.\n    function addTrustedModule(address module) external;\n\n    /// @notice Allows the owner to remove the module from the trusted modules set.\n    function removeTrustedModule(address module) external;\n\n    /// @notice Allows the owner to set the app config for the current app. App config includes:\n    /// - requiredResponses: the number of module responses required for accepting the message\n    /// - optimisticPeriod: the minimum time after which the module responses are considered final\n    function setAppConfigV1(AppConfigV1 memory appConfig) external;\n\n    /// @notice Allows the owner to set the address of the Execution Service.\n    /// This address will be used to request execution of the messages sent from this chain,\n    /// by supplying the Service's execution fee.\n    function setExecutionService(address executionService) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Returns the app config for the current app: requiredResponses and optimisticPeriod.\n    function getAppConfigV1() external view returns (AppConfigV1 memory);\n\n    /// @notice Returns the address of the Execution Service used by this app for sending messages.\n    function getExecutionService() external view returns (address);\n\n    /// @notice Returns the list of Interchain Clients allowed to send messages to this app.\n    function getInterchainClients() external view returns (address[] memory);\n\n    /// @notice Returns the address of the latest interchain client.\n    /// This address is used for sending messages from this app.\n    function getLatestInterchainClient() external view returns (address);\n\n    /// @notice Returns the linked app address (as bytes32) for the given chain ID.\n    function getLinkedApp(uint256 chainId) external view returns (bytes32);\n\n    /// @notice Thin wrapper for `getLinkedApp` to return the linked app address as EVM address.\n    /// @dev Will revert if the linked app address is not an EVM address.\n    function getLinkedAppEVM(uint256 chainId) external view returns (address);\n\n    /// @notice Returns the list of Interchain Modules trusted by this app.\n    /// This set of modules will be used to verify both sent and received messages.\n    function getModules() external view returns (address[] memory);\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint256 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__NoLinkedClient(uint256 chainId);\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint256 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint256 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint256 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint256 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint256 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param message              The message being sent.\n    function getInterchainFee(\n        uint256 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint256 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint256 chainId) external view returns (address);\n}\n\n// node_modules/@openzeppelin/contracts/access/AccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account =\u003e bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role =\u003e RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n// contracts/apps/AbstractICApp.sol\n\nabstract contract AbstractICApp is AbstractICAppEvents, IInterchainApp {\n    using TypeCasts for address;\n\n    error InterchainApp__AlreadyLatestClient(address client);\n    error InterchainApp__BalanceTooLow(uint256 actual, uint256 required);\n    error InterchainApp__ClientAlreadyAdded(address client);\n    error InterchainApp__InterchainClientZeroAddress();\n    error InterchainApp__NotInterchainClient(address account);\n    error InterchainApp__ReceiverNotSet(uint256 chainId);\n    error InterchainApp__SameChainId(uint256 chainId);\n    error InterchainApp__SenderNotAllowed(uint256 srcChainId, bytes32 sender);\n\n    /// @inheritdoc IInterchainApp\n    function appReceive(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        if (!_isInterchainClient(msg.sender)) {\n            revert InterchainApp__NotInterchainClient(msg.sender);\n        }\n        if (srcChainId == block.chainid) {\n            revert InterchainApp__SameChainId(srcChainId);\n        }\n        if (!_isAllowedSender(srcChainId, sender)) {\n            revert InterchainApp__SenderNotAllowed(srcChainId, sender);\n        }\n        _receiveMessage(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n\n    /// @inheritdoc IInterchainApp\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules) {\n        appConfig = _getAppConfig();\n        modules = _getModules();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Performs necessary checks and adds an Interchain Client.\n    /// Optionally sets the latest client to this one.\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _addClient(address client, bool updateLatest) internal {\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (_isInterchainClient(client)) {\n            revert InterchainApp__ClientAlreadyAdded(client);\n        }\n        _toggleClientState(client, true);\n        emit InterchainClientAdded(client);\n        if (updateLatest) {\n            _setLatestClient(client);\n        }\n    }\n\n    /// @dev Performs necessary checks and removes an Interchain Client. If this client is the latest one,\n    /// the latest client is set to zero address (effectively pausing the app ability to send messages).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _removeClient(address client) internal {\n        if (!_isInterchainClient(client)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        _toggleClientState(client, false);\n        emit InterchainClientRemoved(client);\n        if (client == _getLatestClient()) {\n            _setLatestClient(address(0));\n        }\n    }\n\n    /// @dev Sets the latest Interchain Client to one of the allowed clients. Setting the client to zero address\n    /// is allowed and effectively pauses the app ability to send messages (but still allows to receive them).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _setLatestClient(address client) internal {\n        // New latest client must be an allowed client or zero address.\n        if (!_isInterchainClient(client) \u0026\u0026 client != address(0)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        if (client == _getLatestClient()) {\n            revert InterchainApp__AlreadyLatestClient(client);\n        }\n        _storeLatestClient(client);\n        emit LatestClientSet(client);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal virtual;\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal virtual;\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to accept EVM address as a parameter.\n    function _sendInterchainMessageEVM(\n        uint256 dstChainId,\n        address receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _sendInterchainMessage(dstChainId, receiver.addressToBytes32(), messageFee, options, message);\n    }\n\n    /// @dev Performs necessary checks and sends an interchain message.\n    function _sendInterchainMessage(\n        uint256 dstChainId,\n        bytes32 receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (dstChainId == block.chainid) {\n            revert InterchainApp__SameChainId(dstChainId);\n        }\n        if (receiver == 0) {\n            revert InterchainApp__ReceiverNotSet(dstChainId);\n        }\n        if (address(this).balance \u003c messageFee) {\n            revert InterchainApp__BalanceTooLow({actual: address(this).balance, required: messageFee});\n        }\n        return IInterchainClientV1(client).interchainSend{value: messageFee}(\n            dstChainId, receiver, _getExecutionService(), _getModules(), options, message\n        );\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        virtual;\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee for sending an Interchain message.\n    function _getInterchainFee(\n        uint256 dstChainId,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        return IInterchainClientV1(client).getInterchainFee(\n            dstChainId, _getExecutionService(), _getModules(), options, message\n        );\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view virtual returns (bytes memory);\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view virtual returns (address);\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view virtual returns (address);\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view virtual returns (address[] memory);\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint256 srcChainId, bytes32 sender) internal view virtual returns (bool);\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view virtual returns (bool);\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/AccessControlEnumerable.sol)\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 role =\u003e EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {AccessControl-_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool granted = super._grantRole(role, account);\n        if (granted) {\n            _roleMembers[role].add(account);\n        }\n        return granted;\n    }\n\n    /**\n     * @dev Overload {AccessControl-_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool revoked = super._revokeRole(role, account);\n        if (revoked) {\n            _roleMembers[role].remove(account);\n        }\n        return revoked;\n    }\n}\n\n// contracts/apps/ICAppV1.sol\n\nabstract contract ICAppV1 is AbstractICApp, AccessControlEnumerable, InterchainAppV1Events, IInterchainAppV1 {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Role to manage the Interchain setup of the app.\n    bytes32 public constant IC_GOVERNOR_ROLE = keccak256(\"IC_GOVERNOR_ROLE\");\n\n    /// @dev Address of the latest Interchain Client, used for sending messages.\n    address private _latestClient;\n\n    /// @dev Required responses and optimistic period for the module responses.\n    AppConfigV1 private _appConfigV1;\n    /// @dev Address of the linked app deployed on the remote chain.\n    mapping(uint256 chainId =\u003e bytes32 remoteApp) private _linkedApp;\n    /// @dev Interchain Clients allowed to send messages to this app.\n    EnumerableSet.AddressSet private _interchainClients;\n    /// @dev Trusted Interchain modules.\n    EnumerableSet.AddressSet private _trustedModules;\n    /// @dev Execution Service to use for sending messages.\n    address private _executionService;\n\n    constructor(address admin) {\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addInterchainClient(address client, bool updateLatest) external onlyRole(IC_GOVERNOR_ROLE) {\n        _addClient(client, updateLatest);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _removeClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setLatestInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _setLatestClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteApp(uint256 chainId, bytes32 remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteAppEVM(uint256 chainId, address remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp.addressToBytes32());\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (module == address(0)) {\n            revert InterchainApp__ModuleZeroAddress();\n        }\n        bool added = _trustedModules.add(module);\n        if (!added) {\n            revert InterchainApp__ModuleAlreadyAdded(module);\n        }\n        emit TrustedModuleAdded(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        bool removed = _trustedModules.remove(module);\n        if (!removed) {\n            revert InterchainApp__ModuleNotAdded(module);\n        }\n        emit TrustedModuleRemoved(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setAppConfigV1(AppConfigV1 memory appConfig) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (appConfig.requiredResponses == 0 || appConfig.optimisticPeriod == 0) {\n            revert InterchainApp__InvalidAppConfig(appConfig.requiredResponses, appConfig.optimisticPeriod);\n        }\n        _appConfigV1 = appConfig;\n        emit AppConfigV1Set(appConfig.requiredResponses, appConfig.optimisticPeriod);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setExecutionService(address executionService) external onlyRole(IC_GOVERNOR_ROLE) {\n        _executionService = executionService;\n        emit ExecutionServiceSet(executionService);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainAppV1\n    function getAppConfigV1() external view returns (AppConfigV1 memory) {\n        return _appConfigV1;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getExecutionService() external view returns (address) {\n        return _executionService;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getInterchainClients() external view returns (address[] memory) {\n        return _interchainClients.values();\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLatestInterchainClient() external view returns (address) {\n        return _latestClient;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedApp(uint256 chainId) external view returns (bytes32) {\n        return _linkedApp[chainId];\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedAppEVM(uint256 chainId) external view returns (address linkedAppEVM) {\n        bytes32 linkedApp = _linkedApp[chainId];\n        linkedAppEVM = linkedApp.bytes32ToAddress();\n        if (linkedAppEVM.addressToBytes32() != linkedApp) {\n            revert InterchainApp__NotEVMLinkedApp(linkedApp);\n        }\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getModules() external view returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Links the remote app to the current app.\n    /// Will revert if the chainId is the same as the chainId of the local app.\n    /// Note: Should be guarded with permissions check.\n    function _linkRemoteApp(uint256 chainId, bytes32 remoteApp) internal {\n        if (chainId == block.chainid) {\n            revert InterchainApp__SameChainId(chainId);\n        }\n        if (remoteApp == 0) {\n            revert InterchainApp__AppZeroAddress();\n        }\n        _linkedApp[chainId] = remoteApp;\n        emit AppLinked(chainId, remoteApp);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal override {\n        _latestClient = client;\n    }\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal override {\n        if (allowed) {\n            _interchainClients.add(client);\n        } else {\n            _interchainClients.remove(client);\n        }\n    }\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to send the message to the linked app.\n    function _sendToLinkedApp(\n        uint256 dstChainId,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _sendInterchainMessage(dstChainId, _linkedApp[dstChainId], messageFee, encodedOptions, message);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee to send a message to the linked app on the remote chain.\n    function _getMessageFee(\n        uint256 dstChainId,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _getInterchainFee(dstChainId, encodedOptions, message);\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view override returns (bytes memory) {\n        return _appConfigV1.encodeAppConfigV1();\n    }\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view override returns (address) {\n        return _executionService;\n    }\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view override returns (address) {\n        return _latestClient;\n    }\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view override returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint256 srcChainId, bytes32 sender) internal view override returns (bool) {\n        return _linkedApp[srcChainId] == sender;\n    }\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view override returns (bool) {\n        return _interchainClients.contains(caller);\n    }\n}\n\n// contracts/apps/examples/ExampleAppV1.sol\n\ncontract ExampleAppV1 is ICAppV1 {\n    event MessageReceived(uint256 srcChainId, bytes32 sender, uint256 dbNonce, uint64 entryIndex, bytes message);\n    event MessageSent(uint256 dstChainId, uint256 dbNonce, uint64 entryIndex, bytes32 transactionId);\n\n    constructor(address admin) ICAppV1(admin) {\n        _grantRole(IC_GOVERNOR_ROLE, admin);\n    }\n\n    /// @notice Allows the Admin to withdraw the native asset from the contract.\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        Address.sendValue(payable(msg.sender), address(this).balance);\n    }\n\n    /// @notice Sends a basic message to the destination chain.\n    function sendMessage(\n        uint256 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        InterchainTxDescriptor memory desc = _sendToLinkedApp({\n            dstChainId: dstChainId,\n            messageFee: msg.value,\n            options: OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}),\n            message: message\n        });\n        emit MessageSent(dstChainId, desc.dbNonce, desc.entryIndex, desc.transactionId);\n    }\n\n    /// @notice Returns the fee required to send a message using `sendMessage`.\n    function getMessageFee(\n        uint256 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes memory message\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _getMessageFee(dstChainId, OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}), message);\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        override\n    {\n        emit MessageReceived(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"requiredResponses","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"optimisticPeriod","type":"uint256"}],"name":"AppConfigV1Set","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"chainId","type":"uint256"},{"indexed":true,"internalType":"bytes32","name":"remoteApp","type":"bytes32"}],"name":"AppLinked","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"executionService","type":"address"}],"name":"ExecutionServiceSet","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"module","type":"address"}],"name":"TrustedModuleAdded","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"module","type":"address"}],"name":"TrustedModuleRemoved","type":"event"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requiredResponses\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"optimisticPeriod\",\"type\":\"uint256\"}],\"name\":\"AppConfigV1Set\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"remoteApp\",\"type\":\"bytes32\"}],\"name\":\"AppLinked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"executionService\",\"type\":\"address\"}],\"name\":\"ExecutionServiceSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"TrustedModuleAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"TrustedModuleRemoved\",\"type\":\"event\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/ExampleAppV1.sol\":\"InterchainAppV1Events\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/ExampleAppV1.sol\":{\"keccak256\":\"0x4c94807e7a2671ad6fcf49fb03cfafa6f51f6b4596f34092fba0bf17b6d482cf\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://4fabc9aa6f6891674b77809808b14ff1f2e8829de650caafa1fb3c3444a07331\",\"dweb:/ipfs/QmVzYNSfkuSkXNaFKuNY3hmkdspssruAhQx4qZuJU3Ceg9\"]}},\"version\":1}"},"hashes":{}},"solidity/ExampleAppV1.sol:InterchainTransactionLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220cde40722d739fdd26871ffdfcdc28e75af4b136efb095beec6051b293a33e50c64736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220cde40722d739fdd26871ffdfcdc28e75af4b136efb095beec6051b293a33e50c64736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/AbstractICAppEvents.sol\n\nabstract contract AbstractICAppEvents {\n    event InterchainClientAdded(address client);\n    event InterchainClientRemoved(address client);\n    event LatestClientSet(address client);\n}\n\n// contracts/events/InterchainAppV1Events.sol\n\nabstract contract InterchainAppV1Events {\n    event AppConfigV1Set(uint256 requiredResponses, uint256 optimisticPeriod);\n    event AppLinked(uint256 indexed chainId, bytes32 indexed remoteApp);\n    event ExecutionServiceSet(address executionService);\n    event TrustedModuleAdded(address module);\n    event TrustedModuleRemoved(address module);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    /// @notice Allows the Interchain Client to pass the message to the Interchain App.\n    /// @dev App is responsible for keeping track of interchain clients, and must verify the message sender.\n    /// @param srcChainId   Chain ID of the source chain, where the message was sent from.\n    /// @param sender       Sender address on the source chain, as a bytes32 value.\n    /// @param dbNonce      The Interchain DB nonce of the batch containing the message entry.\n    /// @param entryIndex   The index of the message entry within the batch.\n    /// @param message      The message being sent.\n    function appReceive(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /// @notice Returns the verification configuration of the Interchain App.\n    /// @dev This configuration is used by the Interchain Client to verify that message has been confirmed\n    /// by the Interchain Modules on the destination chain.\n    /// Note: V1 version of AppConfig includes the required responses count, and optimistic period after which\n    /// the message is considered confirmed by the module. Following versions may include additional fields.\n    /// @return appConfig    The versioned configuration of the Interchain App, encoded as bytes.\n    /// @return modules      The list of Interchain Modules that app is trusting to confirm the messages.\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    uint8 constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint8 version);\n\n    /// @notice Encodes versioned app config into a bytes format.\n    /// @param version      The version of the app config.\n    /// @param appConfig    The app config to encode.\n    function encodeVersionedAppConfig(uint8 version, bytes memory appConfig) internal pure returns (bytes memory) {\n        return abi.encode(version, appConfig);\n    }\n\n    /// @notice Decodes versioned app config from a bytes format back into a version and app config.\n    /// @param data         The versioned app config data in bytes format.\n    /// @return version     The version of the app config.\n    /// @return appConfig   The app config as bytes.\n    function decodeVersionedAppConfig(bytes memory data)\n        internal\n        pure\n        returns (uint8 version, bytes memory appConfig)\n    {\n        (version, appConfig) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return encodeVersionedAppConfig(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal pure returns (AppConfigV1 memory) {\n        (uint8 version, bytes memory appConfig) = decodeVersionedAppConfig(data);\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(appConfig, (AppConfigV1));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    uint8 constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint8 version);\n\n    /// @notice Encodes versioned options into a bytes format.\n    /// @param version      The version of the options.\n    /// @param options      The options to encode.\n    function encodeVersionedOptions(uint8 version, bytes memory options) internal pure returns (bytes memory) {\n        return abi.encode(version, options);\n    }\n\n    /// @notice Decodes versioned options from a bytes format back into a version and options.\n    /// @param data         The versioned options data in bytes format.\n    /// @return version     The version of the options.\n    /// @return options     The options as bytes.\n    function decodeVersionedOptions(bytes memory data) internal pure returns (uint8 version, bytes memory options) {\n        (version, options) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return encodeVersionedOptions(OPTIONS_V1, abi.encode(options));\n    }\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal pure returns (OptionsV1 memory) {\n        (uint8 version, bytes memory options) = decodeVersionedOptions(data);\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(options, (OptionsV1));\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/IAccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n\n// node_modules/@openzeppelin/contracts/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance \u003c amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance \u003c value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 \u0026\u0026 target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/libs/InterchainTransaction.sol\n\nstruct InterchainTransaction {\n    uint256 srcChainId;\n    bytes32 srcSender;\n    uint256 dstChainId;\n    bytes32 dstReceiver;\n    uint256 dbNonce;\n    uint64 entryIndex;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint256 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    function constructLocalTransaction(\n        address srcSender,\n        uint256 dstChainId,\n        bytes32 dstReceiver,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: block.chainid,\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(transaction);\n    }\n\n    function decodeTransaction(bytes memory encodedTx) internal pure returns (InterchainTransaction memory) {\n        return abi.decode(encodedTx, (InterchainTransaction));\n    }\n\n    function transactionId(InterchainTransaction memory transaction) internal pure returns (bytes32) {\n        return keccak256(abi.encode(transaction));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/IAccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/IAccessControlEnumerable.sol)\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n// contracts/interfaces/IInterchainAppV1.sol\n\ninterface IInterchainAppV1 is IInterchainApp {\n    error InterchainApp__AppZeroAddress();\n    error InterchainApp__InvalidAppConfig(uint256 requiredResponses, uint256 optimisticPeriod);\n    error InterchainApp__ModuleAlreadyAdded(address module);\n    error InterchainApp__ModuleNotAdded(address module);\n    error InterchainApp__ModuleZeroAddress();\n    error InterchainApp__NotEVMLinkedApp(bytes32 linkedApp);\n\n    /// @notice Allows the owner to add the interchain client to the allowed clients set,\n    /// and optionally set the latest client to this one.\n    /// Note: only the allowed clients can send messages to this app.\n    /// Note: the latest client is used for sending messages from this app.\n    /// @param client       The address of the interchain client to add.\n    /// @param updateLatest Whether to set the latest client to this one.\n    function addInterchainClient(address client, bool updateLatest) external;\n\n    /// @notice Allows the owner to remove the interchain client from the allowed clients set.\n    /// If the client is the latest client, the latest client is set to the zero address.\n    /// @param client       The address of the interchain client to remove.\n    function removeInterchainClient(address client) external;\n\n    /// @notice Allows the owner to set the address of the latest interchain client.\n    /// @dev The new latest client must be an allowed client or zero address.\n    /// Setting the client to zero address effectively pauses the app ability to send messages,\n    /// while allowing to receive them.\n    /// @param client       The address of the latest interchain client.\n    function setLatestInterchainClient(address client) external;\n\n    /// @notice Allows the owner to link the remote app for the given chain ID.\n    /// - This address will be used as the receiver for the messages sent from this chain.\n    /// - This address will be the only trusted sender for the messages sent to this chain.\n    /// @param chainId      The remote chain ID.\n    /// @param remoteApp    The address of the remote app to link.\n    function linkRemoteApp(uint256 chainId, bytes32 remoteApp) external;\n\n    /// @notice Thin wrapper for `linkRemoteApp` to accept EVM address as a parameter.\n    function linkRemoteAppEVM(uint256 chainId, address remoteApp) external;\n\n    /// @notice Allows the owner to add the module to the trusted modules set.\n    /// - This set of modules will be used to verify both sent and received messages.\n    function addTrustedModule(address module) external;\n\n    /// @notice Allows the owner to remove the module from the trusted modules set.\n    function removeTrustedModule(address module) external;\n\n    /// @notice Allows the owner to set the app config for the current app. App config includes:\n    /// - requiredResponses: the number of module responses required for accepting the message\n    /// - optimisticPeriod: the minimum time after which the module responses are considered final\n    function setAppConfigV1(AppConfigV1 memory appConfig) external;\n\n    /// @notice Allows the owner to set the address of the Execution Service.\n    /// This address will be used to request execution of the messages sent from this chain,\n    /// by supplying the Service's execution fee.\n    function setExecutionService(address executionService) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Returns the app config for the current app: requiredResponses and optimisticPeriod.\n    function getAppConfigV1() external view returns (AppConfigV1 memory);\n\n    /// @notice Returns the address of the Execution Service used by this app for sending messages.\n    function getExecutionService() external view returns (address);\n\n    /// @notice Returns the list of Interchain Clients allowed to send messages to this app.\n    function getInterchainClients() external view returns (address[] memory);\n\n    /// @notice Returns the address of the latest interchain client.\n    /// This address is used for sending messages from this app.\n    function getLatestInterchainClient() external view returns (address);\n\n    /// @notice Returns the linked app address (as bytes32) for the given chain ID.\n    function getLinkedApp(uint256 chainId) external view returns (bytes32);\n\n    /// @notice Thin wrapper for `getLinkedApp` to return the linked app address as EVM address.\n    /// @dev Will revert if the linked app address is not an EVM address.\n    function getLinkedAppEVM(uint256 chainId) external view returns (address);\n\n    /// @notice Returns the list of Interchain Modules trusted by this app.\n    /// This set of modules will be used to verify both sent and received messages.\n    function getModules() external view returns (address[] memory);\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint256 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__NoLinkedClient(uint256 chainId);\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint256 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint256 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint256 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint256 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint256 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param message              The message being sent.\n    function getInterchainFee(\n        uint256 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint256 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint256 chainId) external view returns (address);\n}\n\n// node_modules/@openzeppelin/contracts/access/AccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account =\u003e bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role =\u003e RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n// contracts/apps/AbstractICApp.sol\n\nabstract contract AbstractICApp is AbstractICAppEvents, IInterchainApp {\n    using TypeCasts for address;\n\n    error InterchainApp__AlreadyLatestClient(address client);\n    error InterchainApp__BalanceTooLow(uint256 actual, uint256 required);\n    error InterchainApp__ClientAlreadyAdded(address client);\n    error InterchainApp__InterchainClientZeroAddress();\n    error InterchainApp__NotInterchainClient(address account);\n    error InterchainApp__ReceiverNotSet(uint256 chainId);\n    error InterchainApp__SameChainId(uint256 chainId);\n    error InterchainApp__SenderNotAllowed(uint256 srcChainId, bytes32 sender);\n\n    /// @inheritdoc IInterchainApp\n    function appReceive(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        if (!_isInterchainClient(msg.sender)) {\n            revert InterchainApp__NotInterchainClient(msg.sender);\n        }\n        if (srcChainId == block.chainid) {\n            revert InterchainApp__SameChainId(srcChainId);\n        }\n        if (!_isAllowedSender(srcChainId, sender)) {\n            revert InterchainApp__SenderNotAllowed(srcChainId, sender);\n        }\n        _receiveMessage(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n\n    /// @inheritdoc IInterchainApp\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules) {\n        appConfig = _getAppConfig();\n        modules = _getModules();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Performs necessary checks and adds an Interchain Client.\n    /// Optionally sets the latest client to this one.\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _addClient(address client, bool updateLatest) internal {\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (_isInterchainClient(client)) {\n            revert InterchainApp__ClientAlreadyAdded(client);\n        }\n        _toggleClientState(client, true);\n        emit InterchainClientAdded(client);\n        if (updateLatest) {\n            _setLatestClient(client);\n        }\n    }\n\n    /// @dev Performs necessary checks and removes an Interchain Client. If this client is the latest one,\n    /// the latest client is set to zero address (effectively pausing the app ability to send messages).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _removeClient(address client) internal {\n        if (!_isInterchainClient(client)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        _toggleClientState(client, false);\n        emit InterchainClientRemoved(client);\n        if (client == _getLatestClient()) {\n            _setLatestClient(address(0));\n        }\n    }\n\n    /// @dev Sets the latest Interchain Client to one of the allowed clients. Setting the client to zero address\n    /// is allowed and effectively pauses the app ability to send messages (but still allows to receive them).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _setLatestClient(address client) internal {\n        // New latest client must be an allowed client or zero address.\n        if (!_isInterchainClient(client) \u0026\u0026 client != address(0)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        if (client == _getLatestClient()) {\n            revert InterchainApp__AlreadyLatestClient(client);\n        }\n        _storeLatestClient(client);\n        emit LatestClientSet(client);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal virtual;\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal virtual;\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to accept EVM address as a parameter.\n    function _sendInterchainMessageEVM(\n        uint256 dstChainId,\n        address receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _sendInterchainMessage(dstChainId, receiver.addressToBytes32(), messageFee, options, message);\n    }\n\n    /// @dev Performs necessary checks and sends an interchain message.\n    function _sendInterchainMessage(\n        uint256 dstChainId,\n        bytes32 receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (dstChainId == block.chainid) {\n            revert InterchainApp__SameChainId(dstChainId);\n        }\n        if (receiver == 0) {\n            revert InterchainApp__ReceiverNotSet(dstChainId);\n        }\n        if (address(this).balance \u003c messageFee) {\n            revert InterchainApp__BalanceTooLow({actual: address(this).balance, required: messageFee});\n        }\n        return IInterchainClientV1(client).interchainSend{value: messageFee}(\n            dstChainId, receiver, _getExecutionService(), _getModules(), options, message\n        );\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        virtual;\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee for sending an Interchain message.\n    function _getInterchainFee(\n        uint256 dstChainId,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        return IInterchainClientV1(client).getInterchainFee(\n            dstChainId, _getExecutionService(), _getModules(), options, message\n        );\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view virtual returns (bytes memory);\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view virtual returns (address);\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view virtual returns (address);\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view virtual returns (address[] memory);\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint256 srcChainId, bytes32 sender) internal view virtual returns (bool);\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view virtual returns (bool);\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/AccessControlEnumerable.sol)\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 role =\u003e EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {AccessControl-_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool granted = super._grantRole(role, account);\n        if (granted) {\n            _roleMembers[role].add(account);\n        }\n        return granted;\n    }\n\n    /**\n     * @dev Overload {AccessControl-_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool revoked = super._revokeRole(role, account);\n        if (revoked) {\n            _roleMembers[role].remove(account);\n        }\n        return revoked;\n    }\n}\n\n// contracts/apps/ICAppV1.sol\n\nabstract contract ICAppV1 is AbstractICApp, AccessControlEnumerable, InterchainAppV1Events, IInterchainAppV1 {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Role to manage the Interchain setup of the app.\n    bytes32 public constant IC_GOVERNOR_ROLE = keccak256(\"IC_GOVERNOR_ROLE\");\n\n    /// @dev Address of the latest Interchain Client, used for sending messages.\n    address private _latestClient;\n\n    /// @dev Required responses and optimistic period for the module responses.\n    AppConfigV1 private _appConfigV1;\n    /// @dev Address of the linked app deployed on the remote chain.\n    mapping(uint256 chainId =\u003e bytes32 remoteApp) private _linkedApp;\n    /// @dev Interchain Clients allowed to send messages to this app.\n    EnumerableSet.AddressSet private _interchainClients;\n    /// @dev Trusted Interchain modules.\n    EnumerableSet.AddressSet private _trustedModules;\n    /// @dev Execution Service to use for sending messages.\n    address private _executionService;\n\n    constructor(address admin) {\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addInterchainClient(address client, bool updateLatest) external onlyRole(IC_GOVERNOR_ROLE) {\n        _addClient(client, updateLatest);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _removeClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setLatestInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _setLatestClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteApp(uint256 chainId, bytes32 remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteAppEVM(uint256 chainId, address remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp.addressToBytes32());\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (module == address(0)) {\n            revert InterchainApp__ModuleZeroAddress();\n        }\n        bool added = _trustedModules.add(module);\n        if (!added) {\n            revert InterchainApp__ModuleAlreadyAdded(module);\n        }\n        emit TrustedModuleAdded(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        bool removed = _trustedModules.remove(module);\n        if (!removed) {\n            revert InterchainApp__ModuleNotAdded(module);\n        }\n        emit TrustedModuleRemoved(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setAppConfigV1(AppConfigV1 memory appConfig) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (appConfig.requiredResponses == 0 || appConfig.optimisticPeriod == 0) {\n            revert InterchainApp__InvalidAppConfig(appConfig.requiredResponses, appConfig.optimisticPeriod);\n        }\n        _appConfigV1 = appConfig;\n        emit AppConfigV1Set(appConfig.requiredResponses, appConfig.optimisticPeriod);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setExecutionService(address executionService) external onlyRole(IC_GOVERNOR_ROLE) {\n        _executionService = executionService;\n        emit ExecutionServiceSet(executionService);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainAppV1\n    function getAppConfigV1() external view returns (AppConfigV1 memory) {\n        return _appConfigV1;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getExecutionService() external view returns (address) {\n        return _executionService;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getInterchainClients() external view returns (address[] memory) {\n        return _interchainClients.values();\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLatestInterchainClient() external view returns (address) {\n        return _latestClient;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedApp(uint256 chainId) external view returns (bytes32) {\n        return _linkedApp[chainId];\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedAppEVM(uint256 chainId) external view returns (address linkedAppEVM) {\n        bytes32 linkedApp = _linkedApp[chainId];\n        linkedAppEVM = linkedApp.bytes32ToAddress();\n        if (linkedAppEVM.addressToBytes32() != linkedApp) {\n            revert InterchainApp__NotEVMLinkedApp(linkedApp);\n        }\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getModules() external view returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Links the remote app to the current app.\n    /// Will revert if the chainId is the same as the chainId of the local app.\n    /// Note: Should be guarded with permissions check.\n    function _linkRemoteApp(uint256 chainId, bytes32 remoteApp) internal {\n        if (chainId == block.chainid) {\n            revert InterchainApp__SameChainId(chainId);\n        }\n        if (remoteApp == 0) {\n            revert InterchainApp__AppZeroAddress();\n        }\n        _linkedApp[chainId] = remoteApp;\n        emit AppLinked(chainId, remoteApp);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal override {\n        _latestClient = client;\n    }\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal override {\n        if (allowed) {\n            _interchainClients.add(client);\n        } else {\n            _interchainClients.remove(client);\n        }\n    }\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to send the message to the linked app.\n    function _sendToLinkedApp(\n        uint256 dstChainId,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _sendInterchainMessage(dstChainId, _linkedApp[dstChainId], messageFee, encodedOptions, message);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee to send a message to the linked app on the remote chain.\n    function _getMessageFee(\n        uint256 dstChainId,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _getInterchainFee(dstChainId, encodedOptions, message);\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view override returns (bytes memory) {\n        return _appConfigV1.encodeAppConfigV1();\n    }\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view override returns (address) {\n        return _executionService;\n    }\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view override returns (address) {\n        return _latestClient;\n    }\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view override returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint256 srcChainId, bytes32 sender) internal view override returns (bool) {\n        return _linkedApp[srcChainId] == sender;\n    }\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view override returns (bool) {\n        return _interchainClients.contains(caller);\n    }\n}\n\n// contracts/apps/examples/ExampleAppV1.sol\n\ncontract ExampleAppV1 is ICAppV1 {\n    event MessageReceived(uint256 srcChainId, bytes32 sender, uint256 dbNonce, uint64 entryIndex, bytes message);\n    event MessageSent(uint256 dstChainId, uint256 dbNonce, uint64 entryIndex, bytes32 transactionId);\n\n    constructor(address admin) ICAppV1(admin) {\n        _grantRole(IC_GOVERNOR_ROLE, admin);\n    }\n\n    /// @notice Allows the Admin to withdraw the native asset from the contract.\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        Address.sendValue(payable(msg.sender), address(this).balance);\n    }\n\n    /// @notice Sends a basic message to the destination chain.\n    function sendMessage(\n        uint256 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        InterchainTxDescriptor memory desc = _sendToLinkedApp({\n            dstChainId: dstChainId,\n            messageFee: msg.value,\n            options: OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}),\n            message: message\n        });\n        emit MessageSent(dstChainId, desc.dbNonce, desc.entryIndex, desc.transactionId);\n    }\n\n    /// @notice Returns the fee required to send a message using `sendMessage`.\n    function getMessageFee(\n        uint256 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes memory message\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _getMessageFee(dstChainId, OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}), message);\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        override\n    {\n        emit MessageReceived(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"32271:1229:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;32271:1229:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"32271:1229:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/ExampleAppV1.sol\":\"InterchainTransactionLib\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/ExampleAppV1.sol\":{\"keccak256\":\"0x4c94807e7a2671ad6fcf49fb03cfafa6f51f6b4596f34092fba0bf17b6d482cf\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://4fabc9aa6f6891674b77809808b14ff1f2e8829de650caafa1fb3c3444a07331\",\"dweb:/ipfs/QmVzYNSfkuSkXNaFKuNY3hmkdspssruAhQx4qZuJU3Ceg9\"]}},\"version\":1}"},"hashes":{}},"solidity/ExampleAppV1.sol:OptionsLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220a7fd0f5505373519792b9db6a54ae10fc08da351b06bec261394ef985c4ec20664736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220a7fd0f5505373519792b9db6a54ae10fc08da351b06bec261394ef985c4ec20664736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/AbstractICAppEvents.sol\n\nabstract contract AbstractICAppEvents {\n    event InterchainClientAdded(address client);\n    event InterchainClientRemoved(address client);\n    event LatestClientSet(address client);\n}\n\n// contracts/events/InterchainAppV1Events.sol\n\nabstract contract InterchainAppV1Events {\n    event AppConfigV1Set(uint256 requiredResponses, uint256 optimisticPeriod);\n    event AppLinked(uint256 indexed chainId, bytes32 indexed remoteApp);\n    event ExecutionServiceSet(address executionService);\n    event TrustedModuleAdded(address module);\n    event TrustedModuleRemoved(address module);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    /// @notice Allows the Interchain Client to pass the message to the Interchain App.\n    /// @dev App is responsible for keeping track of interchain clients, and must verify the message sender.\n    /// @param srcChainId   Chain ID of the source chain, where the message was sent from.\n    /// @param sender       Sender address on the source chain, as a bytes32 value.\n    /// @param dbNonce      The Interchain DB nonce of the batch containing the message entry.\n    /// @param entryIndex   The index of the message entry within the batch.\n    /// @param message      The message being sent.\n    function appReceive(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /// @notice Returns the verification configuration of the Interchain App.\n    /// @dev This configuration is used by the Interchain Client to verify that message has been confirmed\n    /// by the Interchain Modules on the destination chain.\n    /// Note: V1 version of AppConfig includes the required responses count, and optimistic period after which\n    /// the message is considered confirmed by the module. Following versions may include additional fields.\n    /// @return appConfig    The versioned configuration of the Interchain App, encoded as bytes.\n    /// @return modules      The list of Interchain Modules that app is trusting to confirm the messages.\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    uint8 constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint8 version);\n\n    /// @notice Encodes versioned app config into a bytes format.\n    /// @param version      The version of the app config.\n    /// @param appConfig    The app config to encode.\n    function encodeVersionedAppConfig(uint8 version, bytes memory appConfig) internal pure returns (bytes memory) {\n        return abi.encode(version, appConfig);\n    }\n\n    /// @notice Decodes versioned app config from a bytes format back into a version and app config.\n    /// @param data         The versioned app config data in bytes format.\n    /// @return version     The version of the app config.\n    /// @return appConfig   The app config as bytes.\n    function decodeVersionedAppConfig(bytes memory data)\n        internal\n        pure\n        returns (uint8 version, bytes memory appConfig)\n    {\n        (version, appConfig) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return encodeVersionedAppConfig(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal pure returns (AppConfigV1 memory) {\n        (uint8 version, bytes memory appConfig) = decodeVersionedAppConfig(data);\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(appConfig, (AppConfigV1));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    uint8 constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint8 version);\n\n    /// @notice Encodes versioned options into a bytes format.\n    /// @param version      The version of the options.\n    /// @param options      The options to encode.\n    function encodeVersionedOptions(uint8 version, bytes memory options) internal pure returns (bytes memory) {\n        return abi.encode(version, options);\n    }\n\n    /// @notice Decodes versioned options from a bytes format back into a version and options.\n    /// @param data         The versioned options data in bytes format.\n    /// @return version     The version of the options.\n    /// @return options     The options as bytes.\n    function decodeVersionedOptions(bytes memory data) internal pure returns (uint8 version, bytes memory options) {\n        (version, options) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return encodeVersionedOptions(OPTIONS_V1, abi.encode(options));\n    }\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal pure returns (OptionsV1 memory) {\n        (uint8 version, bytes memory options) = decodeVersionedOptions(data);\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(options, (OptionsV1));\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/IAccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n\n// node_modules/@openzeppelin/contracts/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance \u003c amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance \u003c value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 \u0026\u0026 target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/libs/InterchainTransaction.sol\n\nstruct InterchainTransaction {\n    uint256 srcChainId;\n    bytes32 srcSender;\n    uint256 dstChainId;\n    bytes32 dstReceiver;\n    uint256 dbNonce;\n    uint64 entryIndex;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint256 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    function constructLocalTransaction(\n        address srcSender,\n        uint256 dstChainId,\n        bytes32 dstReceiver,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: block.chainid,\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(transaction);\n    }\n\n    function decodeTransaction(bytes memory encodedTx) internal pure returns (InterchainTransaction memory) {\n        return abi.decode(encodedTx, (InterchainTransaction));\n    }\n\n    function transactionId(InterchainTransaction memory transaction) internal pure returns (bytes32) {\n        return keccak256(abi.encode(transaction));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/IAccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/IAccessControlEnumerable.sol)\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n// contracts/interfaces/IInterchainAppV1.sol\n\ninterface IInterchainAppV1 is IInterchainApp {\n    error InterchainApp__AppZeroAddress();\n    error InterchainApp__InvalidAppConfig(uint256 requiredResponses, uint256 optimisticPeriod);\n    error InterchainApp__ModuleAlreadyAdded(address module);\n    error InterchainApp__ModuleNotAdded(address module);\n    error InterchainApp__ModuleZeroAddress();\n    error InterchainApp__NotEVMLinkedApp(bytes32 linkedApp);\n\n    /// @notice Allows the owner to add the interchain client to the allowed clients set,\n    /// and optionally set the latest client to this one.\n    /// Note: only the allowed clients can send messages to this app.\n    /// Note: the latest client is used for sending messages from this app.\n    /// @param client       The address of the interchain client to add.\n    /// @param updateLatest Whether to set the latest client to this one.\n    function addInterchainClient(address client, bool updateLatest) external;\n\n    /// @notice Allows the owner to remove the interchain client from the allowed clients set.\n    /// If the client is the latest client, the latest client is set to the zero address.\n    /// @param client       The address of the interchain client to remove.\n    function removeInterchainClient(address client) external;\n\n    /// @notice Allows the owner to set the address of the latest interchain client.\n    /// @dev The new latest client must be an allowed client or zero address.\n    /// Setting the client to zero address effectively pauses the app ability to send messages,\n    /// while allowing to receive them.\n    /// @param client       The address of the latest interchain client.\n    function setLatestInterchainClient(address client) external;\n\n    /// @notice Allows the owner to link the remote app for the given chain ID.\n    /// - This address will be used as the receiver for the messages sent from this chain.\n    /// - This address will be the only trusted sender for the messages sent to this chain.\n    /// @param chainId      The remote chain ID.\n    /// @param remoteApp    The address of the remote app to link.\n    function linkRemoteApp(uint256 chainId, bytes32 remoteApp) external;\n\n    /// @notice Thin wrapper for `linkRemoteApp` to accept EVM address as a parameter.\n    function linkRemoteAppEVM(uint256 chainId, address remoteApp) external;\n\n    /// @notice Allows the owner to add the module to the trusted modules set.\n    /// - This set of modules will be used to verify both sent and received messages.\n    function addTrustedModule(address module) external;\n\n    /// @notice Allows the owner to remove the module from the trusted modules set.\n    function removeTrustedModule(address module) external;\n\n    /// @notice Allows the owner to set the app config for the current app. App config includes:\n    /// - requiredResponses: the number of module responses required for accepting the message\n    /// - optimisticPeriod: the minimum time after which the module responses are considered final\n    function setAppConfigV1(AppConfigV1 memory appConfig) external;\n\n    /// @notice Allows the owner to set the address of the Execution Service.\n    /// This address will be used to request execution of the messages sent from this chain,\n    /// by supplying the Service's execution fee.\n    function setExecutionService(address executionService) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Returns the app config for the current app: requiredResponses and optimisticPeriod.\n    function getAppConfigV1() external view returns (AppConfigV1 memory);\n\n    /// @notice Returns the address of the Execution Service used by this app for sending messages.\n    function getExecutionService() external view returns (address);\n\n    /// @notice Returns the list of Interchain Clients allowed to send messages to this app.\n    function getInterchainClients() external view returns (address[] memory);\n\n    /// @notice Returns the address of the latest interchain client.\n    /// This address is used for sending messages from this app.\n    function getLatestInterchainClient() external view returns (address);\n\n    /// @notice Returns the linked app address (as bytes32) for the given chain ID.\n    function getLinkedApp(uint256 chainId) external view returns (bytes32);\n\n    /// @notice Thin wrapper for `getLinkedApp` to return the linked app address as EVM address.\n    /// @dev Will revert if the linked app address is not an EVM address.\n    function getLinkedAppEVM(uint256 chainId) external view returns (address);\n\n    /// @notice Returns the list of Interchain Modules trusted by this app.\n    /// This set of modules will be used to verify both sent and received messages.\n    function getModules() external view returns (address[] memory);\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint256 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__NoLinkedClient(uint256 chainId);\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint256 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint256 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint256 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint256 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint256 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param message              The message being sent.\n    function getInterchainFee(\n        uint256 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint256 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint256 chainId) external view returns (address);\n}\n\n// node_modules/@openzeppelin/contracts/access/AccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account =\u003e bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role =\u003e RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n// contracts/apps/AbstractICApp.sol\n\nabstract contract AbstractICApp is AbstractICAppEvents, IInterchainApp {\n    using TypeCasts for address;\n\n    error InterchainApp__AlreadyLatestClient(address client);\n    error InterchainApp__BalanceTooLow(uint256 actual, uint256 required);\n    error InterchainApp__ClientAlreadyAdded(address client);\n    error InterchainApp__InterchainClientZeroAddress();\n    error InterchainApp__NotInterchainClient(address account);\n    error InterchainApp__ReceiverNotSet(uint256 chainId);\n    error InterchainApp__SameChainId(uint256 chainId);\n    error InterchainApp__SenderNotAllowed(uint256 srcChainId, bytes32 sender);\n\n    /// @inheritdoc IInterchainApp\n    function appReceive(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        if (!_isInterchainClient(msg.sender)) {\n            revert InterchainApp__NotInterchainClient(msg.sender);\n        }\n        if (srcChainId == block.chainid) {\n            revert InterchainApp__SameChainId(srcChainId);\n        }\n        if (!_isAllowedSender(srcChainId, sender)) {\n            revert InterchainApp__SenderNotAllowed(srcChainId, sender);\n        }\n        _receiveMessage(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n\n    /// @inheritdoc IInterchainApp\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules) {\n        appConfig = _getAppConfig();\n        modules = _getModules();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Performs necessary checks and adds an Interchain Client.\n    /// Optionally sets the latest client to this one.\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _addClient(address client, bool updateLatest) internal {\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (_isInterchainClient(client)) {\n            revert InterchainApp__ClientAlreadyAdded(client);\n        }\n        _toggleClientState(client, true);\n        emit InterchainClientAdded(client);\n        if (updateLatest) {\n            _setLatestClient(client);\n        }\n    }\n\n    /// @dev Performs necessary checks and removes an Interchain Client. If this client is the latest one,\n    /// the latest client is set to zero address (effectively pausing the app ability to send messages).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _removeClient(address client) internal {\n        if (!_isInterchainClient(client)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        _toggleClientState(client, false);\n        emit InterchainClientRemoved(client);\n        if (client == _getLatestClient()) {\n            _setLatestClient(address(0));\n        }\n    }\n\n    /// @dev Sets the latest Interchain Client to one of the allowed clients. Setting the client to zero address\n    /// is allowed and effectively pauses the app ability to send messages (but still allows to receive them).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _setLatestClient(address client) internal {\n        // New latest client must be an allowed client or zero address.\n        if (!_isInterchainClient(client) \u0026\u0026 client != address(0)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        if (client == _getLatestClient()) {\n            revert InterchainApp__AlreadyLatestClient(client);\n        }\n        _storeLatestClient(client);\n        emit LatestClientSet(client);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal virtual;\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal virtual;\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to accept EVM address as a parameter.\n    function _sendInterchainMessageEVM(\n        uint256 dstChainId,\n        address receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _sendInterchainMessage(dstChainId, receiver.addressToBytes32(), messageFee, options, message);\n    }\n\n    /// @dev Performs necessary checks and sends an interchain message.\n    function _sendInterchainMessage(\n        uint256 dstChainId,\n        bytes32 receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (dstChainId == block.chainid) {\n            revert InterchainApp__SameChainId(dstChainId);\n        }\n        if (receiver == 0) {\n            revert InterchainApp__ReceiverNotSet(dstChainId);\n        }\n        if (address(this).balance \u003c messageFee) {\n            revert InterchainApp__BalanceTooLow({actual: address(this).balance, required: messageFee});\n        }\n        return IInterchainClientV1(client).interchainSend{value: messageFee}(\n            dstChainId, receiver, _getExecutionService(), _getModules(), options, message\n        );\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        virtual;\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee for sending an Interchain message.\n    function _getInterchainFee(\n        uint256 dstChainId,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        return IInterchainClientV1(client).getInterchainFee(\n            dstChainId, _getExecutionService(), _getModules(), options, message\n        );\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view virtual returns (bytes memory);\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view virtual returns (address);\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view virtual returns (address);\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view virtual returns (address[] memory);\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint256 srcChainId, bytes32 sender) internal view virtual returns (bool);\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view virtual returns (bool);\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/AccessControlEnumerable.sol)\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 role =\u003e EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {AccessControl-_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool granted = super._grantRole(role, account);\n        if (granted) {\n            _roleMembers[role].add(account);\n        }\n        return granted;\n    }\n\n    /**\n     * @dev Overload {AccessControl-_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool revoked = super._revokeRole(role, account);\n        if (revoked) {\n            _roleMembers[role].remove(account);\n        }\n        return revoked;\n    }\n}\n\n// contracts/apps/ICAppV1.sol\n\nabstract contract ICAppV1 is AbstractICApp, AccessControlEnumerable, InterchainAppV1Events, IInterchainAppV1 {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Role to manage the Interchain setup of the app.\n    bytes32 public constant IC_GOVERNOR_ROLE = keccak256(\"IC_GOVERNOR_ROLE\");\n\n    /// @dev Address of the latest Interchain Client, used for sending messages.\n    address private _latestClient;\n\n    /// @dev Required responses and optimistic period for the module responses.\n    AppConfigV1 private _appConfigV1;\n    /// @dev Address of the linked app deployed on the remote chain.\n    mapping(uint256 chainId =\u003e bytes32 remoteApp) private _linkedApp;\n    /// @dev Interchain Clients allowed to send messages to this app.\n    EnumerableSet.AddressSet private _interchainClients;\n    /// @dev Trusted Interchain modules.\n    EnumerableSet.AddressSet private _trustedModules;\n    /// @dev Execution Service to use for sending messages.\n    address private _executionService;\n\n    constructor(address admin) {\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addInterchainClient(address client, bool updateLatest) external onlyRole(IC_GOVERNOR_ROLE) {\n        _addClient(client, updateLatest);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _removeClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setLatestInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _setLatestClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteApp(uint256 chainId, bytes32 remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteAppEVM(uint256 chainId, address remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp.addressToBytes32());\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (module == address(0)) {\n            revert InterchainApp__ModuleZeroAddress();\n        }\n        bool added = _trustedModules.add(module);\n        if (!added) {\n            revert InterchainApp__ModuleAlreadyAdded(module);\n        }\n        emit TrustedModuleAdded(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        bool removed = _trustedModules.remove(module);\n        if (!removed) {\n            revert InterchainApp__ModuleNotAdded(module);\n        }\n        emit TrustedModuleRemoved(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setAppConfigV1(AppConfigV1 memory appConfig) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (appConfig.requiredResponses == 0 || appConfig.optimisticPeriod == 0) {\n            revert InterchainApp__InvalidAppConfig(appConfig.requiredResponses, appConfig.optimisticPeriod);\n        }\n        _appConfigV1 = appConfig;\n        emit AppConfigV1Set(appConfig.requiredResponses, appConfig.optimisticPeriod);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setExecutionService(address executionService) external onlyRole(IC_GOVERNOR_ROLE) {\n        _executionService = executionService;\n        emit ExecutionServiceSet(executionService);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainAppV1\n    function getAppConfigV1() external view returns (AppConfigV1 memory) {\n        return _appConfigV1;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getExecutionService() external view returns (address) {\n        return _executionService;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getInterchainClients() external view returns (address[] memory) {\n        return _interchainClients.values();\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLatestInterchainClient() external view returns (address) {\n        return _latestClient;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedApp(uint256 chainId) external view returns (bytes32) {\n        return _linkedApp[chainId];\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedAppEVM(uint256 chainId) external view returns (address linkedAppEVM) {\n        bytes32 linkedApp = _linkedApp[chainId];\n        linkedAppEVM = linkedApp.bytes32ToAddress();\n        if (linkedAppEVM.addressToBytes32() != linkedApp) {\n            revert InterchainApp__NotEVMLinkedApp(linkedApp);\n        }\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getModules() external view returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Links the remote app to the current app.\n    /// Will revert if the chainId is the same as the chainId of the local app.\n    /// Note: Should be guarded with permissions check.\n    function _linkRemoteApp(uint256 chainId, bytes32 remoteApp) internal {\n        if (chainId == block.chainid) {\n            revert InterchainApp__SameChainId(chainId);\n        }\n        if (remoteApp == 0) {\n            revert InterchainApp__AppZeroAddress();\n        }\n        _linkedApp[chainId] = remoteApp;\n        emit AppLinked(chainId, remoteApp);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal override {\n        _latestClient = client;\n    }\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal override {\n        if (allowed) {\n            _interchainClients.add(client);\n        } else {\n            _interchainClients.remove(client);\n        }\n    }\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to send the message to the linked app.\n    function _sendToLinkedApp(\n        uint256 dstChainId,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _sendInterchainMessage(dstChainId, _linkedApp[dstChainId], messageFee, encodedOptions, message);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee to send a message to the linked app on the remote chain.\n    function _getMessageFee(\n        uint256 dstChainId,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _getInterchainFee(dstChainId, encodedOptions, message);\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view override returns (bytes memory) {\n        return _appConfigV1.encodeAppConfigV1();\n    }\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view override returns (address) {\n        return _executionService;\n    }\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view override returns (address) {\n        return _latestClient;\n    }\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view override returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint256 srcChainId, bytes32 sender) internal view override returns (bool) {\n        return _linkedApp[srcChainId] == sender;\n    }\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view override returns (bool) {\n        return _interchainClients.contains(caller);\n    }\n}\n\n// contracts/apps/examples/ExampleAppV1.sol\n\ncontract ExampleAppV1 is ICAppV1 {\n    event MessageReceived(uint256 srcChainId, bytes32 sender, uint256 dbNonce, uint64 entryIndex, bytes message);\n    event MessageSent(uint256 dstChainId, uint256 dbNonce, uint64 entryIndex, bytes32 transactionId);\n\n    constructor(address admin) ICAppV1(admin) {\n        _grantRole(IC_GOVERNOR_ROLE, admin);\n    }\n\n    /// @notice Allows the Admin to withdraw the native asset from the contract.\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        Address.sendValue(payable(msg.sender), address(this).balance);\n    }\n\n    /// @notice Sends a basic message to the destination chain.\n    function sendMessage(\n        uint256 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        InterchainTxDescriptor memory desc = _sendToLinkedApp({\n            dstChainId: dstChainId,\n            messageFee: msg.value,\n            options: OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}),\n            message: message\n        });\n        emit MessageSent(dstChainId, desc.dbNonce, desc.entryIndex, desc.transactionId);\n    }\n\n    /// @notice Returns the fee required to send a message using `sendMessage`.\n    function getMessageFee(\n        uint256 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes memory message\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _getMessageFee(dstChainId, OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}), message);\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        override\n    {\n        emit MessageReceived(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"5197:1958:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;5197:1958:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"5197:1958:0:-:0;;;;;;;;","abiDefinition":[{"inputs":[{"internalType":"uint8","name":"version","type":"uint8"}],"name":"OptionsLib__IncorrectVersion","type":"error"}],"userDoc":{"kind":"user","methods":{},"notice":"A library for encoding and decoding Interchain options related to interchain messages.","version":1},"developerDoc":{"kind":"dev","methods":{},"title":"OptionsLib","version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"OptionsLib__IncorrectVersion\",\"type\":\"error\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"title\":\"OptionsLib\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"A library for encoding and decoding Interchain options related to interchain messages.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/ExampleAppV1.sol\":\"OptionsLib\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/ExampleAppV1.sol\":{\"keccak256\":\"0x4c94807e7a2671ad6fcf49fb03cfafa6f51f6b4596f34092fba0bf17b6d482cf\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://4fabc9aa6f6891674b77809808b14ff1f2e8829de650caafa1fb3c3444a07331\",\"dweb:/ipfs/QmVzYNSfkuSkXNaFKuNY3hmkdspssruAhQx4qZuJU3Ceg9\"]}},\"version\":1}"},"hashes":{}},"solidity/ExampleAppV1.sol:TypeCasts":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220dc0ee80b0ca90dc437643be29f5069a6eb156f0170b2cf222fe4059a44a5b08e64736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220dc0ee80b0ca90dc437643be29f5069a6eb156f0170b2cf222fe4059a44a5b08e64736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/AbstractICAppEvents.sol\n\nabstract contract AbstractICAppEvents {\n    event InterchainClientAdded(address client);\n    event InterchainClientRemoved(address client);\n    event LatestClientSet(address client);\n}\n\n// contracts/events/InterchainAppV1Events.sol\n\nabstract contract InterchainAppV1Events {\n    event AppConfigV1Set(uint256 requiredResponses, uint256 optimisticPeriod);\n    event AppLinked(uint256 indexed chainId, bytes32 indexed remoteApp);\n    event ExecutionServiceSet(address executionService);\n    event TrustedModuleAdded(address module);\n    event TrustedModuleRemoved(address module);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    /// @notice Allows the Interchain Client to pass the message to the Interchain App.\n    /// @dev App is responsible for keeping track of interchain clients, and must verify the message sender.\n    /// @param srcChainId   Chain ID of the source chain, where the message was sent from.\n    /// @param sender       Sender address on the source chain, as a bytes32 value.\n    /// @param dbNonce      The Interchain DB nonce of the batch containing the message entry.\n    /// @param entryIndex   The index of the message entry within the batch.\n    /// @param message      The message being sent.\n    function appReceive(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /// @notice Returns the verification configuration of the Interchain App.\n    /// @dev This configuration is used by the Interchain Client to verify that message has been confirmed\n    /// by the Interchain Modules on the destination chain.\n    /// Note: V1 version of AppConfig includes the required responses count, and optimistic period after which\n    /// the message is considered confirmed by the module. Following versions may include additional fields.\n    /// @return appConfig    The versioned configuration of the Interchain App, encoded as bytes.\n    /// @return modules      The list of Interchain Modules that app is trusting to confirm the messages.\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    uint8 constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint8 version);\n\n    /// @notice Encodes versioned app config into a bytes format.\n    /// @param version      The version of the app config.\n    /// @param appConfig    The app config to encode.\n    function encodeVersionedAppConfig(uint8 version, bytes memory appConfig) internal pure returns (bytes memory) {\n        return abi.encode(version, appConfig);\n    }\n\n    /// @notice Decodes versioned app config from a bytes format back into a version and app config.\n    /// @param data         The versioned app config data in bytes format.\n    /// @return version     The version of the app config.\n    /// @return appConfig   The app config as bytes.\n    function decodeVersionedAppConfig(bytes memory data)\n        internal\n        pure\n        returns (uint8 version, bytes memory appConfig)\n    {\n        (version, appConfig) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return encodeVersionedAppConfig(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal pure returns (AppConfigV1 memory) {\n        (uint8 version, bytes memory appConfig) = decodeVersionedAppConfig(data);\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(appConfig, (AppConfigV1));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    uint8 constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint8 version);\n\n    /// @notice Encodes versioned options into a bytes format.\n    /// @param version      The version of the options.\n    /// @param options      The options to encode.\n    function encodeVersionedOptions(uint8 version, bytes memory options) internal pure returns (bytes memory) {\n        return abi.encode(version, options);\n    }\n\n    /// @notice Decodes versioned options from a bytes format back into a version and options.\n    /// @param data         The versioned options data in bytes format.\n    /// @return version     The version of the options.\n    /// @return options     The options as bytes.\n    function decodeVersionedOptions(bytes memory data) internal pure returns (uint8 version, bytes memory options) {\n        (version, options) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return encodeVersionedOptions(OPTIONS_V1, abi.encode(options));\n    }\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal pure returns (OptionsV1 memory) {\n        (uint8 version, bytes memory options) = decodeVersionedOptions(data);\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(options, (OptionsV1));\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/IAccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n\n// node_modules/@openzeppelin/contracts/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance \u003c amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance \u003c value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 \u0026\u0026 target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/libs/InterchainTransaction.sol\n\nstruct InterchainTransaction {\n    uint256 srcChainId;\n    bytes32 srcSender;\n    uint256 dstChainId;\n    bytes32 dstReceiver;\n    uint256 dbNonce;\n    uint64 entryIndex;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint256 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    function constructLocalTransaction(\n        address srcSender,\n        uint256 dstChainId,\n        bytes32 dstReceiver,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: block.chainid,\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(transaction);\n    }\n\n    function decodeTransaction(bytes memory encodedTx) internal pure returns (InterchainTransaction memory) {\n        return abi.decode(encodedTx, (InterchainTransaction));\n    }\n\n    function transactionId(InterchainTransaction memory transaction) internal pure returns (bytes32) {\n        return keccak256(abi.encode(transaction));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/IAccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/IAccessControlEnumerable.sol)\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n// contracts/interfaces/IInterchainAppV1.sol\n\ninterface IInterchainAppV1 is IInterchainApp {\n    error InterchainApp__AppZeroAddress();\n    error InterchainApp__InvalidAppConfig(uint256 requiredResponses, uint256 optimisticPeriod);\n    error InterchainApp__ModuleAlreadyAdded(address module);\n    error InterchainApp__ModuleNotAdded(address module);\n    error InterchainApp__ModuleZeroAddress();\n    error InterchainApp__NotEVMLinkedApp(bytes32 linkedApp);\n\n    /// @notice Allows the owner to add the interchain client to the allowed clients set,\n    /// and optionally set the latest client to this one.\n    /// Note: only the allowed clients can send messages to this app.\n    /// Note: the latest client is used for sending messages from this app.\n    /// @param client       The address of the interchain client to add.\n    /// @param updateLatest Whether to set the latest client to this one.\n    function addInterchainClient(address client, bool updateLatest) external;\n\n    /// @notice Allows the owner to remove the interchain client from the allowed clients set.\n    /// If the client is the latest client, the latest client is set to the zero address.\n    /// @param client       The address of the interchain client to remove.\n    function removeInterchainClient(address client) external;\n\n    /// @notice Allows the owner to set the address of the latest interchain client.\n    /// @dev The new latest client must be an allowed client or zero address.\n    /// Setting the client to zero address effectively pauses the app ability to send messages,\n    /// while allowing to receive them.\n    /// @param client       The address of the latest interchain client.\n    function setLatestInterchainClient(address client) external;\n\n    /// @notice Allows the owner to link the remote app for the given chain ID.\n    /// - This address will be used as the receiver for the messages sent from this chain.\n    /// - This address will be the only trusted sender for the messages sent to this chain.\n    /// @param chainId      The remote chain ID.\n    /// @param remoteApp    The address of the remote app to link.\n    function linkRemoteApp(uint256 chainId, bytes32 remoteApp) external;\n\n    /// @notice Thin wrapper for `linkRemoteApp` to accept EVM address as a parameter.\n    function linkRemoteAppEVM(uint256 chainId, address remoteApp) external;\n\n    /// @notice Allows the owner to add the module to the trusted modules set.\n    /// - This set of modules will be used to verify both sent and received messages.\n    function addTrustedModule(address module) external;\n\n    /// @notice Allows the owner to remove the module from the trusted modules set.\n    function removeTrustedModule(address module) external;\n\n    /// @notice Allows the owner to set the app config for the current app. App config includes:\n    /// - requiredResponses: the number of module responses required for accepting the message\n    /// - optimisticPeriod: the minimum time after which the module responses are considered final\n    function setAppConfigV1(AppConfigV1 memory appConfig) external;\n\n    /// @notice Allows the owner to set the address of the Execution Service.\n    /// This address will be used to request execution of the messages sent from this chain,\n    /// by supplying the Service's execution fee.\n    function setExecutionService(address executionService) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Returns the app config for the current app: requiredResponses and optimisticPeriod.\n    function getAppConfigV1() external view returns (AppConfigV1 memory);\n\n    /// @notice Returns the address of the Execution Service used by this app for sending messages.\n    function getExecutionService() external view returns (address);\n\n    /// @notice Returns the list of Interchain Clients allowed to send messages to this app.\n    function getInterchainClients() external view returns (address[] memory);\n\n    /// @notice Returns the address of the latest interchain client.\n    /// This address is used for sending messages from this app.\n    function getLatestInterchainClient() external view returns (address);\n\n    /// @notice Returns the linked app address (as bytes32) for the given chain ID.\n    function getLinkedApp(uint256 chainId) external view returns (bytes32);\n\n    /// @notice Thin wrapper for `getLinkedApp` to return the linked app address as EVM address.\n    /// @dev Will revert if the linked app address is not an EVM address.\n    function getLinkedAppEVM(uint256 chainId) external view returns (address);\n\n    /// @notice Returns the list of Interchain Modules trusted by this app.\n    /// This set of modules will be used to verify both sent and received messages.\n    function getModules() external view returns (address[] memory);\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint256 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__NoLinkedClient(uint256 chainId);\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint256 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint256 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint256 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint256 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint256 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param message              The message being sent.\n    function getInterchainFee(\n        uint256 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint256 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint256 chainId) external view returns (address);\n}\n\n// node_modules/@openzeppelin/contracts/access/AccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account =\u003e bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role =\u003e RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n// contracts/apps/AbstractICApp.sol\n\nabstract contract AbstractICApp is AbstractICAppEvents, IInterchainApp {\n    using TypeCasts for address;\n\n    error InterchainApp__AlreadyLatestClient(address client);\n    error InterchainApp__BalanceTooLow(uint256 actual, uint256 required);\n    error InterchainApp__ClientAlreadyAdded(address client);\n    error InterchainApp__InterchainClientZeroAddress();\n    error InterchainApp__NotInterchainClient(address account);\n    error InterchainApp__ReceiverNotSet(uint256 chainId);\n    error InterchainApp__SameChainId(uint256 chainId);\n    error InterchainApp__SenderNotAllowed(uint256 srcChainId, bytes32 sender);\n\n    /// @inheritdoc IInterchainApp\n    function appReceive(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        if (!_isInterchainClient(msg.sender)) {\n            revert InterchainApp__NotInterchainClient(msg.sender);\n        }\n        if (srcChainId == block.chainid) {\n            revert InterchainApp__SameChainId(srcChainId);\n        }\n        if (!_isAllowedSender(srcChainId, sender)) {\n            revert InterchainApp__SenderNotAllowed(srcChainId, sender);\n        }\n        _receiveMessage(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n\n    /// @inheritdoc IInterchainApp\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules) {\n        appConfig = _getAppConfig();\n        modules = _getModules();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Performs necessary checks and adds an Interchain Client.\n    /// Optionally sets the latest client to this one.\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _addClient(address client, bool updateLatest) internal {\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (_isInterchainClient(client)) {\n            revert InterchainApp__ClientAlreadyAdded(client);\n        }\n        _toggleClientState(client, true);\n        emit InterchainClientAdded(client);\n        if (updateLatest) {\n            _setLatestClient(client);\n        }\n    }\n\n    /// @dev Performs necessary checks and removes an Interchain Client. If this client is the latest one,\n    /// the latest client is set to zero address (effectively pausing the app ability to send messages).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _removeClient(address client) internal {\n        if (!_isInterchainClient(client)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        _toggleClientState(client, false);\n        emit InterchainClientRemoved(client);\n        if (client == _getLatestClient()) {\n            _setLatestClient(address(0));\n        }\n    }\n\n    /// @dev Sets the latest Interchain Client to one of the allowed clients. Setting the client to zero address\n    /// is allowed and effectively pauses the app ability to send messages (but still allows to receive them).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _setLatestClient(address client) internal {\n        // New latest client must be an allowed client or zero address.\n        if (!_isInterchainClient(client) \u0026\u0026 client != address(0)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        if (client == _getLatestClient()) {\n            revert InterchainApp__AlreadyLatestClient(client);\n        }\n        _storeLatestClient(client);\n        emit LatestClientSet(client);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal virtual;\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal virtual;\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to accept EVM address as a parameter.\n    function _sendInterchainMessageEVM(\n        uint256 dstChainId,\n        address receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _sendInterchainMessage(dstChainId, receiver.addressToBytes32(), messageFee, options, message);\n    }\n\n    /// @dev Performs necessary checks and sends an interchain message.\n    function _sendInterchainMessage(\n        uint256 dstChainId,\n        bytes32 receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (dstChainId == block.chainid) {\n            revert InterchainApp__SameChainId(dstChainId);\n        }\n        if (receiver == 0) {\n            revert InterchainApp__ReceiverNotSet(dstChainId);\n        }\n        if (address(this).balance \u003c messageFee) {\n            revert InterchainApp__BalanceTooLow({actual: address(this).balance, required: messageFee});\n        }\n        return IInterchainClientV1(client).interchainSend{value: messageFee}(\n            dstChainId, receiver, _getExecutionService(), _getModules(), options, message\n        );\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        virtual;\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee for sending an Interchain message.\n    function _getInterchainFee(\n        uint256 dstChainId,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        return IInterchainClientV1(client).getInterchainFee(\n            dstChainId, _getExecutionService(), _getModules(), options, message\n        );\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view virtual returns (bytes memory);\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view virtual returns (address);\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view virtual returns (address);\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view virtual returns (address[] memory);\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint256 srcChainId, bytes32 sender) internal view virtual returns (bool);\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view virtual returns (bool);\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/AccessControlEnumerable.sol)\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 role =\u003e EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {AccessControl-_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool granted = super._grantRole(role, account);\n        if (granted) {\n            _roleMembers[role].add(account);\n        }\n        return granted;\n    }\n\n    /**\n     * @dev Overload {AccessControl-_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool revoked = super._revokeRole(role, account);\n        if (revoked) {\n            _roleMembers[role].remove(account);\n        }\n        return revoked;\n    }\n}\n\n// contracts/apps/ICAppV1.sol\n\nabstract contract ICAppV1 is AbstractICApp, AccessControlEnumerable, InterchainAppV1Events, IInterchainAppV1 {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Role to manage the Interchain setup of the app.\n    bytes32 public constant IC_GOVERNOR_ROLE = keccak256(\"IC_GOVERNOR_ROLE\");\n\n    /// @dev Address of the latest Interchain Client, used for sending messages.\n    address private _latestClient;\n\n    /// @dev Required responses and optimistic period for the module responses.\n    AppConfigV1 private _appConfigV1;\n    /// @dev Address of the linked app deployed on the remote chain.\n    mapping(uint256 chainId =\u003e bytes32 remoteApp) private _linkedApp;\n    /// @dev Interchain Clients allowed to send messages to this app.\n    EnumerableSet.AddressSet private _interchainClients;\n    /// @dev Trusted Interchain modules.\n    EnumerableSet.AddressSet private _trustedModules;\n    /// @dev Execution Service to use for sending messages.\n    address private _executionService;\n\n    constructor(address admin) {\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addInterchainClient(address client, bool updateLatest) external onlyRole(IC_GOVERNOR_ROLE) {\n        _addClient(client, updateLatest);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _removeClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setLatestInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _setLatestClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteApp(uint256 chainId, bytes32 remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteAppEVM(uint256 chainId, address remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp.addressToBytes32());\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (module == address(0)) {\n            revert InterchainApp__ModuleZeroAddress();\n        }\n        bool added = _trustedModules.add(module);\n        if (!added) {\n            revert InterchainApp__ModuleAlreadyAdded(module);\n        }\n        emit TrustedModuleAdded(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        bool removed = _trustedModules.remove(module);\n        if (!removed) {\n            revert InterchainApp__ModuleNotAdded(module);\n        }\n        emit TrustedModuleRemoved(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setAppConfigV1(AppConfigV1 memory appConfig) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (appConfig.requiredResponses == 0 || appConfig.optimisticPeriod == 0) {\n            revert InterchainApp__InvalidAppConfig(appConfig.requiredResponses, appConfig.optimisticPeriod);\n        }\n        _appConfigV1 = appConfig;\n        emit AppConfigV1Set(appConfig.requiredResponses, appConfig.optimisticPeriod);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setExecutionService(address executionService) external onlyRole(IC_GOVERNOR_ROLE) {\n        _executionService = executionService;\n        emit ExecutionServiceSet(executionService);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainAppV1\n    function getAppConfigV1() external view returns (AppConfigV1 memory) {\n        return _appConfigV1;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getExecutionService() external view returns (address) {\n        return _executionService;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getInterchainClients() external view returns (address[] memory) {\n        return _interchainClients.values();\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLatestInterchainClient() external view returns (address) {\n        return _latestClient;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedApp(uint256 chainId) external view returns (bytes32) {\n        return _linkedApp[chainId];\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedAppEVM(uint256 chainId) external view returns (address linkedAppEVM) {\n        bytes32 linkedApp = _linkedApp[chainId];\n        linkedAppEVM = linkedApp.bytes32ToAddress();\n        if (linkedAppEVM.addressToBytes32() != linkedApp) {\n            revert InterchainApp__NotEVMLinkedApp(linkedApp);\n        }\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getModules() external view returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Links the remote app to the current app.\n    /// Will revert if the chainId is the same as the chainId of the local app.\n    /// Note: Should be guarded with permissions check.\n    function _linkRemoteApp(uint256 chainId, bytes32 remoteApp) internal {\n        if (chainId == block.chainid) {\n            revert InterchainApp__SameChainId(chainId);\n        }\n        if (remoteApp == 0) {\n            revert InterchainApp__AppZeroAddress();\n        }\n        _linkedApp[chainId] = remoteApp;\n        emit AppLinked(chainId, remoteApp);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal override {\n        _latestClient = client;\n    }\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal override {\n        if (allowed) {\n            _interchainClients.add(client);\n        } else {\n            _interchainClients.remove(client);\n        }\n    }\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to send the message to the linked app.\n    function _sendToLinkedApp(\n        uint256 dstChainId,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _sendInterchainMessage(dstChainId, _linkedApp[dstChainId], messageFee, encodedOptions, message);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee to send a message to the linked app on the remote chain.\n    function _getMessageFee(\n        uint256 dstChainId,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _getInterchainFee(dstChainId, encodedOptions, message);\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view override returns (bytes memory) {\n        return _appConfigV1.encodeAppConfigV1();\n    }\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view override returns (address) {\n        return _executionService;\n    }\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view override returns (address) {\n        return _latestClient;\n    }\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view override returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint256 srcChainId, bytes32 sender) internal view override returns (bool) {\n        return _linkedApp[srcChainId] == sender;\n    }\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view override returns (bool) {\n        return _interchainClients.contains(caller);\n    }\n}\n\n// contracts/apps/examples/ExampleAppV1.sol\n\ncontract ExampleAppV1 is ICAppV1 {\n    event MessageReceived(uint256 srcChainId, bytes32 sender, uint256 dbNonce, uint64 entryIndex, bytes message);\n    event MessageSent(uint256 dstChainId, uint256 dbNonce, uint64 entryIndex, bytes32 transactionId);\n\n    constructor(address admin) ICAppV1(admin) {\n        _grantRole(IC_GOVERNOR_ROLE, admin);\n    }\n\n    /// @notice Allows the Admin to withdraw the native asset from the contract.\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        Address.sendValue(payable(msg.sender), address(this).balance);\n    }\n\n    /// @notice Sends a basic message to the destination chain.\n    function sendMessage(\n        uint256 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        InterchainTxDescriptor memory desc = _sendToLinkedApp({\n            dstChainId: dstChainId,\n            messageFee: msg.value,\n            options: OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}),\n            message: message\n        });\n        emit MessageSent(dstChainId, desc.dbNonce, desc.entryIndex, desc.transactionId);\n    }\n\n    /// @notice Returns the fee required to send a message using `sendMessage`.\n    function getMessageFee(\n        uint256 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes memory message\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _getMessageFee(dstChainId, OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}), message);\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint256 srcChainId,\n        bytes32 sender,\n        uint256 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        override\n    {\n        emit MessageReceived(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"7190:280:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;7190:280:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"7190:280:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/ExampleAppV1.sol\":\"TypeCasts\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/ExampleAppV1.sol\":{\"keccak256\":\"0x4c94807e7a2671ad6fcf49fb03cfafa6f51f6b4596f34092fba0bf17b6d482cf\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://4fabc9aa6f6891674b77809808b14ff1f2e8829de650caafa1fb3c3444a07331\",\"dweb:/ipfs/QmVzYNSfkuSkXNaFKuNY3hmkdspssruAhQx4qZuJU3Ceg9\"]}},\"version\":1}"},"hashes":{}}}