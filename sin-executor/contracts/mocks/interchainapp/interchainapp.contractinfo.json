{"solidity/InterchainApp.sol:AppConfigLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212209f5affa708e3871fcbebed46226f189611882164b69517fcf6c6530ff05bbd4164736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212209f5affa708e3871fcbebed46226f189611882164b69517fcf6c6530ff05bbd4164736f6c63430008140033","info":{"source":"pragma solidity =0.8.20 ^0.8.0 ^0.8.13;\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    function appReceive(uint256 srcChainId, bytes32 sender, uint256 dbNonce, bytes calldata message) external payable;\n\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint256 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectSrcChainId(uint256 chainId);\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint256 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return transactionId The ID of the transaction that was sent.\n     * @return dbNonce The database nonce of the written entry for the transaction.\n     */\n    function interchainSend(\n        uint256 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (bytes32 transactionId, uint256 dbNonce);\n\n    function interchainSendEVM(\n        uint256 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (bytes32 transactionId, uint256 dbNonce);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     */\n    function interchainExecute(uint256 gasLimit, bytes calldata transaction) external payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the written entry for the proof.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint256 dbNonce);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction The InterchainTransaction struct to be checked.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param message              The message being sent.\n    function getInterchainFee(\n        uint256 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    error AppConfigLib__IncorrectVersion(uint8 version);\n\n    uint8 constant APP_CONFIG_V1 = 1;\n\n    /// @notice Encodes versioned app config into a bytes format.\n    /// @param version      The version of the app config.\n    /// @param appConfig    The app config to encode.\n    function encodeVersionedAppConfig(uint8 version, bytes memory appConfig) internal pure returns (bytes memory) {\n        return abi.encode(version, appConfig);\n    }\n\n    /// @notice Decodes versioned app config from a bytes format back into a version and app config.\n    /// @param data         The versioned app config data in bytes format.\n    /// @return version     The version of the app config.\n    /// @return appConfig   The app config as bytes.\n    function decodeVersionedAppConfig(bytes memory data)\n        internal\n        pure\n        returns (uint8 version, bytes memory appConfig)\n    {\n        (version, appConfig) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return encodeVersionedAppConfig(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal pure returns (AppConfigV1 memory) {\n        (uint8 version, bytes memory appConfig) = decodeVersionedAppConfig(data);\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(appConfig, (AppConfigV1));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    error OptionsLib__IncorrectVersion(uint8 version);\n\n    uint8 constant OPTIONS_V1 = 1;\n\n    /// @notice Encodes versioned options into a bytes format.\n    /// @param version      The version of the options.\n    /// @param options      The options to encode.\n    function encodeVersionedOptions(uint8 version, bytes memory options) internal pure returns (bytes memory) {\n        return abi.encode(version, options);\n    }\n\n    /// @notice Decodes versioned options from a bytes format back into a version and options.\n    /// @param data         The versioned options data in bytes format.\n    /// @return version     The version of the options.\n    /// @return options     The options as bytes.\n    function decodeVersionedOptions(bytes memory data) internal pure returns (uint8 version, bytes memory options) {\n        (version, options) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return encodeVersionedOptions(OPTIONS_V1, abi.encode(options));\n    }\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal pure returns (OptionsV1 memory) {\n        (uint8 version, bytes memory options) = decodeVersionedOptions(data);\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(options, (OptionsV1));\n    }\n}\n\n// contracts/InterchainApp.sol\n\ncontract InterchainApp is IInterchainApp {\n    using AppConfigLib for bytes;\n    // What properties should Interchain be pulling from InterchainApp?\n    // 1. Which modules to use, and how many are required?\n\n    IInterchainClientV1 public interchain;\n\n    address[] private sendingModules;\n    address[] private receivingModules;\n    address private executionService;\n\n    struct AppConfig {\n        // ChainID -\u003e Linked IApps\n        mapping(uint64 =\u003e address) linkedIApps;\n        // Sends message to be verified through all modules\n        address[] sendingModules;\n        // Accepts messages from these destination chain modules\n        address[] receivingModules;\n        AppConfigV1 bytesAppConfig;\n    }\n\n    AppConfig private localAppConfig;\n\n    // Set the application configuration\n    function setAppConfig(\n        uint64[] memory chainIDs,\n        address[] memory linkedIApps,\n        address[] memory _sendingModules,\n        address[] memory _receivingModules,\n        address _executionService,\n        uint256 _requiredResponses,\n        uint64 _optimisticTimePeriod\n    )\n        public\n    {\n        // TODO: Add access control or ownership checks\n        require(chainIDs.length == linkedIApps.length, \"ChainIDs and IApps length mismatch\");\n\n        for (uint256 i = 0; i \u003c chainIDs.length; i++) {\n            localAppConfig.linkedIApps[chainIDs[i]] = linkedIApps[i];\n        }\n\n        localAppConfig.bytesAppConfig =\n            AppConfigV1({requiredResponses: _requiredResponses, optimisticPeriod: _optimisticTimePeriod});\n\n        localAppConfig.sendingModules = _sendingModules;\n        localAppConfig.receivingModules = _receivingModules;\n        executionService = _executionService;\n    }\n\n    // Getters for the application configuration\n    function getLinkedIApp(uint64 chainID) external view returns (address) {\n        return localAppConfig.linkedIApps[chainID];\n    }\n\n    // TODO: Is a receiving module the same as a sending module?\n    function getSendingModules() external view returns (address[] memory) {\n        return localAppConfig.sendingModules;\n    }\n\n    function getReceivingModules() external view returns (address[] memory) {\n        return localAppConfig.receivingModules;\n    }\n\n    function getRequiredResponses() external view returns (uint256) {\n        return localAppConfig.bytesAppConfig.requiredResponses;\n    }\n\n    function getOptimisticTimePeriod() external view returns (uint256) {\n        return localAppConfig.bytesAppConfig.optimisticPeriod;\n    }\n\n    function getSendingModules(bytes32 receiver, uint256 dstChainId) external view returns (address[] memory) {\n        return sendingModules;\n    }\n\n    function getReceivingConfig() external view returns (bytes memory, address[] memory) {\n        return (AppConfigLib.encodeAppConfigV1(localAppConfig.bytesAppConfig), localAppConfig.receivingModules);\n    }\n\n    constructor(address _interchain, address[] memory _sendingModules, address[] memory _receivingModules) {\n        interchain = IInterchainClientV1(_interchain);\n        localAppConfig.sendingModules = _sendingModules;\n        localAppConfig.receivingModules = _receivingModules;\n    }\n\n    event AppMessageRecieve();\n    event AppMessageSent();\n\n    function send(bytes32 receiver, uint256 dstChainId, bytes calldata message) external payable {\n        bytes memory options = OptionsV1(200_000, 0).encodeOptionsV1();\n        // TODO: Currently, we forward all gas to Interchain, this may not be expected behavior, and the real abstract contract shouldn't do this\n        interchain.interchainSend{value: msg.value}(\n            dstChainId, receiver, executionService, localAppConfig.sendingModules, options, message\n        );\n        emit AppMessageSent();\n    }\n\n    // TODO: Auth checks based on incoming message\n    function appReceive(uint256 srcChainId, bytes32 sender, uint256 dbNonce, bytes calldata message) external payable {\n        emit AppMessageRecieve();\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"6580:2072:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;6580:2072:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"6580:2072:0:-:0;;;;;;;;","abiDefinition":[{"inputs":[{"internalType":"uint8","name":"version","type":"uint8"}],"name":"AppConfigLib__IncorrectVersion","type":"error"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"AppConfigLib__IncorrectVersion\",\"type\":\"error\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainApp.sol\":\"AppConfigLib\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainApp.sol\":{\"keccak256\":\"0x97256ebb052f6f28fecf0beec3b1dfa66674bc1f309fa5ee1d848c8510a9efce\",\"urls\":[\"bzz-raw://4449ebe8a883f01fc9475e12203c0ba46d8546f96ac1296fa4eefe6a2b236127\",\"dweb:/ipfs/QmPW2zd3zqaAsMed1LSjVLafcE6zXNNiTwqEkHfbnRC69p\"]}},\"version\":1}"},"hashes":{}},"solidity/InterchainApp.sol:IInterchainApp":{"code":"0x","runtime-code":"0x","info":{"source":"pragma solidity =0.8.20 ^0.8.0 ^0.8.13;\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    function appReceive(uint256 srcChainId, bytes32 sender, uint256 dbNonce, bytes calldata message) external payable;\n\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint256 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectSrcChainId(uint256 chainId);\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint256 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return transactionId The ID of the transaction that was sent.\n     * @return dbNonce The database nonce of the written entry for the transaction.\n     */\n    function interchainSend(\n        uint256 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (bytes32 transactionId, uint256 dbNonce);\n\n    function interchainSendEVM(\n        uint256 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (bytes32 transactionId, uint256 dbNonce);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     */\n    function interchainExecute(uint256 gasLimit, bytes calldata transaction) external payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the written entry for the proof.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint256 dbNonce);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction The InterchainTransaction struct to be checked.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param message              The message being sent.\n    function getInterchainFee(\n        uint256 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    error AppConfigLib__IncorrectVersion(uint8 version);\n\n    uint8 constant APP_CONFIG_V1 = 1;\n\n    /// @notice Encodes versioned app config into a bytes format.\n    /// @param version      The version of the app config.\n    /// @param appConfig    The app config to encode.\n    function encodeVersionedAppConfig(uint8 version, bytes memory appConfig) internal pure returns (bytes memory) {\n        return abi.encode(version, appConfig);\n    }\n\n    /// @notice Decodes versioned app config from a bytes format back into a version and app config.\n    /// @param data         The versioned app config data in bytes format.\n    /// @return version     The version of the app config.\n    /// @return appConfig   The app config as bytes.\n    function decodeVersionedAppConfig(bytes memory data)\n        internal\n        pure\n        returns (uint8 version, bytes memory appConfig)\n    {\n        (version, appConfig) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return encodeVersionedAppConfig(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal pure returns (AppConfigV1 memory) {\n        (uint8 version, bytes memory appConfig) = decodeVersionedAppConfig(data);\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(appConfig, (AppConfigV1));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    error OptionsLib__IncorrectVersion(uint8 version);\n\n    uint8 constant OPTIONS_V1 = 1;\n\n    /// @notice Encodes versioned options into a bytes format.\n    /// @param version      The version of the options.\n    /// @param options      The options to encode.\n    function encodeVersionedOptions(uint8 version, bytes memory options) internal pure returns (bytes memory) {\n        return abi.encode(version, options);\n    }\n\n    /// @notice Decodes versioned options from a bytes format back into a version and options.\n    /// @param data         The versioned options data in bytes format.\n    /// @return version     The version of the options.\n    /// @return options     The options as bytes.\n    function decodeVersionedOptions(bytes memory data) internal pure returns (uint8 version, bytes memory options) {\n        (version, options) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return encodeVersionedOptions(OPTIONS_V1, abi.encode(options));\n    }\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal pure returns (OptionsV1 memory) {\n        (uint8 version, bytes memory options) = decodeVersionedOptions(data);\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(options, (OptionsV1));\n    }\n}\n\n// contracts/InterchainApp.sol\n\ncontract InterchainApp is IInterchainApp {\n    using AppConfigLib for bytes;\n    // What properties should Interchain be pulling from InterchainApp?\n    // 1. Which modules to use, and how many are required?\n\n    IInterchainClientV1 public interchain;\n\n    address[] private sendingModules;\n    address[] private receivingModules;\n    address private executionService;\n\n    struct AppConfig {\n        // ChainID -\u003e Linked IApps\n        mapping(uint64 =\u003e address) linkedIApps;\n        // Sends message to be verified through all modules\n        address[] sendingModules;\n        // Accepts messages from these destination chain modules\n        address[] receivingModules;\n        AppConfigV1 bytesAppConfig;\n    }\n\n    AppConfig private localAppConfig;\n\n    // Set the application configuration\n    function setAppConfig(\n        uint64[] memory chainIDs,\n        address[] memory linkedIApps,\n        address[] memory _sendingModules,\n        address[] memory _receivingModules,\n        address _executionService,\n        uint256 _requiredResponses,\n        uint64 _optimisticTimePeriod\n    )\n        public\n    {\n        // TODO: Add access control or ownership checks\n        require(chainIDs.length == linkedIApps.length, \"ChainIDs and IApps length mismatch\");\n\n        for (uint256 i = 0; i \u003c chainIDs.length; i++) {\n            localAppConfig.linkedIApps[chainIDs[i]] = linkedIApps[i];\n        }\n\n        localAppConfig.bytesAppConfig =\n            AppConfigV1({requiredResponses: _requiredResponses, optimisticPeriod: _optimisticTimePeriod});\n\n        localAppConfig.sendingModules = _sendingModules;\n        localAppConfig.receivingModules = _receivingModules;\n        executionService = _executionService;\n    }\n\n    // Getters for the application configuration\n    function getLinkedIApp(uint64 chainID) external view returns (address) {\n        return localAppConfig.linkedIApps[chainID];\n    }\n\n    // TODO: Is a receiving module the same as a sending module?\n    function getSendingModules() external view returns (address[] memory) {\n        return localAppConfig.sendingModules;\n    }\n\n    function getReceivingModules() external view returns (address[] memory) {\n        return localAppConfig.receivingModules;\n    }\n\n    function getRequiredResponses() external view returns (uint256) {\n        return localAppConfig.bytesAppConfig.requiredResponses;\n    }\n\n    function getOptimisticTimePeriod() external view returns (uint256) {\n        return localAppConfig.bytesAppConfig.optimisticPeriod;\n    }\n\n    function getSendingModules(bytes32 receiver, uint256 dstChainId) external view returns (address[] memory) {\n        return sendingModules;\n    }\n\n    function getReceivingConfig() external view returns (bytes memory, address[] memory) {\n        return (AppConfigLib.encodeAppConfigV1(localAppConfig.bytesAppConfig), localAppConfig.receivingModules);\n    }\n\n    constructor(address _interchain, address[] memory _sendingModules, address[] memory _receivingModules) {\n        interchain = IInterchainClientV1(_interchain);\n        localAppConfig.sendingModules = _sendingModules;\n        localAppConfig.receivingModules = _receivingModules;\n    }\n\n    event AppMessageRecieve();\n    event AppMessageSent();\n\n    function send(bytes32 receiver, uint256 dstChainId, bytes calldata message) external payable {\n        bytes memory options = OptionsV1(200_000, 0).encodeOptionsV1();\n        // TODO: Currently, we forward all gas to Interchain, this may not be expected behavior, and the real abstract contract shouldn't do this\n        interchain.interchainSend{value: msg.value}(\n            dstChainId, receiver, executionService, localAppConfig.sendingModules, options, message\n        );\n        emit AppMessageSent();\n    }\n\n    // TODO: Auth checks based on incoming message\n    function appReceive(uint256 srcChainId, bytes32 sender, uint256 dbNonce, bytes calldata message) external payable {\n        emit AppMessageRecieve();\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"bytes32","name":"sender","type":"bytes32"},{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"bytes","name":"message","type":"bytes"}],"name":"appReceive","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"getReceivingConfig","outputs":[{"internalType":"bytes","name":"appConfig","type":"bytes"},{"internalType":"address[]","name":"modules","type":"address[]"}],"stateMutability":"view","type":"function"}],"userDoc":{"kind":"user","methods":{},"notice":"Minimal interface for the Interchain App to work with the Interchain Client.","version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"appReceive\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReceivingConfig\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"appConfig\",\"type\":\"bytes\"},{\"internalType\":\"address[]\",\"name\":\"modules\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"Minimal interface for the Interchain App to work with the Interchain Client.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainApp.sol\":\"IInterchainApp\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainApp.sol\":{\"keccak256\":\"0x97256ebb052f6f28fecf0beec3b1dfa66674bc1f309fa5ee1d848c8510a9efce\",\"urls\":[\"bzz-raw://4449ebe8a883f01fc9475e12203c0ba46d8546f96ac1296fa4eefe6a2b236127\",\"dweb:/ipfs/QmPW2zd3zqaAsMed1LSjVLafcE6zXNNiTwqEkHfbnRC69p\"]}},\"version\":1}"},"hashes":{"appReceive(uint256,bytes32,uint256,bytes)":"b399470d","getReceivingConfig()":"287bc057"}},"solidity/InterchainApp.sol:IInterchainClientV1":{"code":"0x","runtime-code":"0x","info":{"source":"pragma solidity =0.8.20 ^0.8.0 ^0.8.13;\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    function appReceive(uint256 srcChainId, bytes32 sender, uint256 dbNonce, bytes calldata message) external payable;\n\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint256 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectSrcChainId(uint256 chainId);\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint256 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return transactionId The ID of the transaction that was sent.\n     * @return dbNonce The database nonce of the written entry for the transaction.\n     */\n    function interchainSend(\n        uint256 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (bytes32 transactionId, uint256 dbNonce);\n\n    function interchainSendEVM(\n        uint256 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (bytes32 transactionId, uint256 dbNonce);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     */\n    function interchainExecute(uint256 gasLimit, bytes calldata transaction) external payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the written entry for the proof.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint256 dbNonce);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction The InterchainTransaction struct to be checked.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param message              The message being sent.\n    function getInterchainFee(\n        uint256 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    error AppConfigLib__IncorrectVersion(uint8 version);\n\n    uint8 constant APP_CONFIG_V1 = 1;\n\n    /// @notice Encodes versioned app config into a bytes format.\n    /// @param version      The version of the app config.\n    /// @param appConfig    The app config to encode.\n    function encodeVersionedAppConfig(uint8 version, bytes memory appConfig) internal pure returns (bytes memory) {\n        return abi.encode(version, appConfig);\n    }\n\n    /// @notice Decodes versioned app config from a bytes format back into a version and app config.\n    /// @param data         The versioned app config data in bytes format.\n    /// @return version     The version of the app config.\n    /// @return appConfig   The app config as bytes.\n    function decodeVersionedAppConfig(bytes memory data)\n        internal\n        pure\n        returns (uint8 version, bytes memory appConfig)\n    {\n        (version, appConfig) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return encodeVersionedAppConfig(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal pure returns (AppConfigV1 memory) {\n        (uint8 version, bytes memory appConfig) = decodeVersionedAppConfig(data);\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(appConfig, (AppConfigV1));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    error OptionsLib__IncorrectVersion(uint8 version);\n\n    uint8 constant OPTIONS_V1 = 1;\n\n    /// @notice Encodes versioned options into a bytes format.\n    /// @param version      The version of the options.\n    /// @param options      The options to encode.\n    function encodeVersionedOptions(uint8 version, bytes memory options) internal pure returns (bytes memory) {\n        return abi.encode(version, options);\n    }\n\n    /// @notice Decodes versioned options from a bytes format back into a version and options.\n    /// @param data         The versioned options data in bytes format.\n    /// @return version     The version of the options.\n    /// @return options     The options as bytes.\n    function decodeVersionedOptions(bytes memory data) internal pure returns (uint8 version, bytes memory options) {\n        (version, options) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return encodeVersionedOptions(OPTIONS_V1, abi.encode(options));\n    }\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal pure returns (OptionsV1 memory) {\n        (uint8 version, bytes memory options) = decodeVersionedOptions(data);\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(options, (OptionsV1));\n    }\n}\n\n// contracts/InterchainApp.sol\n\ncontract InterchainApp is IInterchainApp {\n    using AppConfigLib for bytes;\n    // What properties should Interchain be pulling from InterchainApp?\n    // 1. Which modules to use, and how many are required?\n\n    IInterchainClientV1 public interchain;\n\n    address[] private sendingModules;\n    address[] private receivingModules;\n    address private executionService;\n\n    struct AppConfig {\n        // ChainID -\u003e Linked IApps\n        mapping(uint64 =\u003e address) linkedIApps;\n        // Sends message to be verified through all modules\n        address[] sendingModules;\n        // Accepts messages from these destination chain modules\n        address[] receivingModules;\n        AppConfigV1 bytesAppConfig;\n    }\n\n    AppConfig private localAppConfig;\n\n    // Set the application configuration\n    function setAppConfig(\n        uint64[] memory chainIDs,\n        address[] memory linkedIApps,\n        address[] memory _sendingModules,\n        address[] memory _receivingModules,\n        address _executionService,\n        uint256 _requiredResponses,\n        uint64 _optimisticTimePeriod\n    )\n        public\n    {\n        // TODO: Add access control or ownership checks\n        require(chainIDs.length == linkedIApps.length, \"ChainIDs and IApps length mismatch\");\n\n        for (uint256 i = 0; i \u003c chainIDs.length; i++) {\n            localAppConfig.linkedIApps[chainIDs[i]] = linkedIApps[i];\n        }\n\n        localAppConfig.bytesAppConfig =\n            AppConfigV1({requiredResponses: _requiredResponses, optimisticPeriod: _optimisticTimePeriod});\n\n        localAppConfig.sendingModules = _sendingModules;\n        localAppConfig.receivingModules = _receivingModules;\n        executionService = _executionService;\n    }\n\n    // Getters for the application configuration\n    function getLinkedIApp(uint64 chainID) external view returns (address) {\n        return localAppConfig.linkedIApps[chainID];\n    }\n\n    // TODO: Is a receiving module the same as a sending module?\n    function getSendingModules() external view returns (address[] memory) {\n        return localAppConfig.sendingModules;\n    }\n\n    function getReceivingModules() external view returns (address[] memory) {\n        return localAppConfig.receivingModules;\n    }\n\n    function getRequiredResponses() external view returns (uint256) {\n        return localAppConfig.bytesAppConfig.requiredResponses;\n    }\n\n    function getOptimisticTimePeriod() external view returns (uint256) {\n        return localAppConfig.bytesAppConfig.optimisticPeriod;\n    }\n\n    function getSendingModules(bytes32 receiver, uint256 dstChainId) external view returns (address[] memory) {\n        return sendingModules;\n    }\n\n    function getReceivingConfig() external view returns (bytes memory, address[] memory) {\n        return (AppConfigLib.encodeAppConfigV1(localAppConfig.bytesAppConfig), localAppConfig.receivingModules);\n    }\n\n    constructor(address _interchain, address[] memory _sendingModules, address[] memory _receivingModules) {\n        interchain = IInterchainClientV1(_interchain);\n        localAppConfig.sendingModules = _sendingModules;\n        localAppConfig.receivingModules = _receivingModules;\n    }\n\n    event AppMessageRecieve();\n    event AppMessageSent();\n\n    function send(bytes32 receiver, uint256 dstChainId, bytes calldata message) external payable {\n        bytes memory options = OptionsV1(200_000, 0).encodeOptionsV1();\n        // TODO: Currently, we forward all gas to Interchain, this may not be expected behavior, and the real abstract contract shouldn't do this\n        interchain.interchainSend{value: msg.value}(\n            dstChainId, receiver, executionService, localAppConfig.sendingModules, options, message\n        );\n        emit AppMessageSent();\n    }\n\n    // TODO: Auth checks based on incoming message\n    function appReceive(uint256 srcChainId, bytes32 sender, uint256 dbNonce, bytes calldata message) external payable {\n        emit AppMessageRecieve();\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"uint256","name":"actual","type":"uint256"},{"internalType":"uint256","name":"required","type":"uint256"}],"name":"InterchainClientV1__FeeAmountTooLow","type":"error"},{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"}],"name":"InterchainClientV1__IncorrectDstChainId","type":"error"},{"inputs":[{"internalType":"uint256","name":"actual","type":"uint256"},{"internalType":"uint256","name":"required","type":"uint256"}],"name":"InterchainClientV1__IncorrectMsgValue","type":"error"},{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"}],"name":"InterchainClientV1__IncorrectSrcChainId","type":"error"},{"inputs":[{"internalType":"uint256","name":"actual","type":"uint256"},{"internalType":"uint256","name":"required","type":"uint256"}],"name":"InterchainClientV1__NotEnoughResponses","type":"error"},{"inputs":[{"internalType":"bytes32","name":"transactionId","type":"bytes32"}],"name":"InterchainClientV1__TxAlreadyExecuted","type":"error"},{"inputs":[{"internalType":"bytes32","name":"transactionId","type":"bytes32"}],"name":"InterchainClientV1__TxNotExecuted","type":"error"},{"inputs":[{"internalType":"bytes","name":"transaction","type":"bytes"}],"name":"getExecutor","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"transactionId","type":"bytes32"}],"name":"getExecutorById","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"dstChainId","type":"uint256"},{"internalType":"address","name":"srcExecutionService","type":"address"},{"internalType":"address[]","name":"srcModules","type":"address[]"},{"internalType":"bytes","name":"options","type":"bytes"},{"internalType":"bytes","name":"message","type":"bytes"}],"name":"getInterchainFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"gasLimit","type":"uint256"},{"internalType":"bytes","name":"transaction","type":"bytes"}],"name":"interchainExecute","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint256","name":"dstChainId","type":"uint256"},{"internalType":"bytes32","name":"receiver","type":"bytes32"},{"internalType":"address","name":"srcExecutionService","type":"address"},{"internalType":"address[]","name":"srcModules","type":"address[]"},{"internalType":"bytes","name":"options","type":"bytes"},{"internalType":"bytes","name":"message","type":"bytes"}],"name":"interchainSend","outputs":[{"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"internalType":"uint256","name":"dbNonce","type":"uint256"}],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint256","name":"dstChainId","type":"uint256"},{"internalType":"address","name":"receiver","type":"address"},{"internalType":"address","name":"srcExecutionService","type":"address"},{"internalType":"address[]","name":"srcModules","type":"address[]"},{"internalType":"bytes","name":"options","type":"bytes"},{"internalType":"bytes","name":"message","type":"bytes"}],"name":"interchainSendEVM","outputs":[{"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"internalType":"uint256","name":"dbNonce","type":"uint256"}],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"bytes","name":"transaction","type":"bytes"}],"name":"isExecutable","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"executionFees_","type":"address"}],"name":"setExecutionFees","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"},{"internalType":"bytes32","name":"client","type":"bytes32"}],"name":"setLinkedClient","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"transactionId","type":"bytes32"}],"name":"writeExecutionProof","outputs":[{"internalType":"uint256","name":"dbNonce","type":"uint256"}],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{"getExecutor(bytes)":{"notice":"Returns the address of the executor for a transaction that has been sent to the local chain."},"getExecutorById(bytes32)":{"notice":"Returns the address of the executor for a transaction that has been sent to the local chain."},"getInterchainFee(uint256,address,address[],bytes,bytes)":{"notice":"Returns the fee for sending an Interchain message."},"interchainExecute(uint256,bytes)":{"notice":"Executes a transaction that has been sent via the Interchain."},"interchainSend(uint256,bytes32,address,address[],bytes,bytes)":{"notice":"Sends a message to another chain via the Interchain Communication Protocol."},"isExecutable(bytes)":{"notice":"Checks if a transaction is executable."},"setExecutionFees(address)":{"notice":"Sets the address of the ExecutionFees contract."},"setLinkedClient(uint256,bytes32)":{"notice":"Sets the linked client for a specific chain ID."},"writeExecutionProof(bytes32)":{"notice":"Writes the proof of execution for a transaction into the InterchainDB."}},"version":1},"developerDoc":{"kind":"dev","methods":{"getInterchainFee(uint256,address,address[],bytes,bytes)":{"params":{"dstChainId":"The chain ID of the destination chain.","message":"The message being sent.","options":"Execution options for the message sent, currently gas limit + native gas drop.","srcExecutionService":"The address of the execution service to use for the message.","srcModules":"The source modules involved in the message sending."}},"interchainExecute(uint256,bytes)":{"details":"The transaction must have been previously sent and recorded. Transaction data includes the requested gas limit, but the executors could specify a different gas limit. If the specified gas limit is lower than requested, the requested gas limit will be used. Otherwise, the specified gas limit will be used. This allows to execute the transactions with requested gas limit set too low.","params":{"gasLimit":"The gas limit to use for the execution.","transaction":"The transaction data."}},"interchainSend(uint256,bytes32,address,address[],bytes,bytes)":{"details":"Charges a fee for the message, which is payable upon calling this function: - Verification fees: paid to every module that verifies the message. - Execution fee: paid to the executor that executes the message. Note: while a specific execution service is specified to request the execution of the message, any executor is able to execute the message on destination chain, earning the execution fee.","params":{"dstChainId":"The chain ID of the destination chain.","message":"The message being sent.","options":"Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.","receiver":"The address of the receiver on the destination chain.","srcExecutionService":"The address of the execution service to use for the message.","srcModules":"The source modules involved in the message sending."},"returns":{"dbNonce":"The database nonce of the written entry for the transaction.","transactionId":"The ID of the transaction that was sent."}},"isExecutable(bytes)":{"details":"Determines if a transaction meets the criteria to be executed based on: - If approved modules have written to the InterchainDB - If the threshold of approved modules have been met - If the optimistic window has passed for all modules","params":{"transaction":"The InterchainTransaction struct to be checked."},"returns":{"_0":"bool Returns true if the transaction is executable, false otherwise."}},"setExecutionFees(address)":{"details":"Only callable by the contract owner or an authorized account.","params":{"executionFees_":"The address of the ExecutionFees contract."}},"setLinkedClient(uint256,bytes32)":{"details":"Stores the address of the linked client in a mapping with the chain ID as the key.","params":{"chainId":"The chain ID for which the client is being set.","client":"The address of the client being linked."}},"writeExecutionProof(bytes32)":{"details":"Will revert if the transaction has not been executed.","params":{"transactionId":"The ID of the transaction to write the proof for."},"returns":{"dbNonce":"        The database nonce of the written entry for the proof."}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"required\",\"type\":\"uint256\"}],\"name\":\"InterchainClientV1__FeeAmountTooLow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"InterchainClientV1__IncorrectDstChainId\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"required\",\"type\":\"uint256\"}],\"name\":\"InterchainClientV1__IncorrectMsgValue\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"InterchainClientV1__IncorrectSrcChainId\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"required\",\"type\":\"uint256\"}],\"name\":\"InterchainClientV1__NotEnoughResponses\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"}],\"name\":\"InterchainClientV1__TxAlreadyExecuted\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"}],\"name\":\"InterchainClientV1__TxNotExecuted\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"transaction\",\"type\":\"bytes\"}],\"name\":\"getExecutor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"}],\"name\":\"getExecutorById\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dstChainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"srcExecutionService\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"},{\"internalType\":\"bytes\",\"name\":\"options\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"getInterchainFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"transaction\",\"type\":\"bytes\"}],\"name\":\"interchainExecute\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dstChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"receiver\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"srcExecutionService\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"},{\"internalType\":\"bytes\",\"name\":\"options\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"interchainSend\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dstChainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"srcExecutionService\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"},{\"internalType\":\"bytes\",\"name\":\"options\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"interchainSendEVM\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"transaction\",\"type\":\"bytes\"}],\"name\":\"isExecutable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"executionFees_\",\"type\":\"address\"}],\"name\":\"setExecutionFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"client\",\"type\":\"bytes32\"}],\"name\":\"setLinkedClient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"}],\"name\":\"writeExecutionProof\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"getInterchainFee(uint256,address,address[],bytes,bytes)\":{\"params\":{\"dstChainId\":\"The chain ID of the destination chain.\",\"message\":\"The message being sent.\",\"options\":\"Execution options for the message sent, currently gas limit + native gas drop.\",\"srcExecutionService\":\"The address of the execution service to use for the message.\",\"srcModules\":\"The source modules involved in the message sending.\"}},\"interchainExecute(uint256,bytes)\":{\"details\":\"The transaction must have been previously sent and recorded. Transaction data includes the requested gas limit, but the executors could specify a different gas limit. If the specified gas limit is lower than requested, the requested gas limit will be used. Otherwise, the specified gas limit will be used. This allows to execute the transactions with requested gas limit set too low.\",\"params\":{\"gasLimit\":\"The gas limit to use for the execution.\",\"transaction\":\"The transaction data.\"}},\"interchainSend(uint256,bytes32,address,address[],bytes,bytes)\":{\"details\":\"Charges a fee for the message, which is payable upon calling this function: - Verification fees: paid to every module that verifies the message. - Execution fee: paid to the executor that executes the message. Note: while a specific execution service is specified to request the execution of the message, any executor is able to execute the message on destination chain, earning the execution fee.\",\"params\":{\"dstChainId\":\"The chain ID of the destination chain.\",\"message\":\"The message being sent.\",\"options\":\"Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\",\"receiver\":\"The address of the receiver on the destination chain.\",\"srcExecutionService\":\"The address of the execution service to use for the message.\",\"srcModules\":\"The source modules involved in the message sending.\"},\"returns\":{\"dbNonce\":\"The database nonce of the written entry for the transaction.\",\"transactionId\":\"The ID of the transaction that was sent.\"}},\"isExecutable(bytes)\":{\"details\":\"Determines if a transaction meets the criteria to be executed based on: - If approved modules have written to the InterchainDB - If the threshold of approved modules have been met - If the optimistic window has passed for all modules\",\"params\":{\"transaction\":\"The InterchainTransaction struct to be checked.\"},\"returns\":{\"_0\":\"bool Returns true if the transaction is executable, false otherwise.\"}},\"setExecutionFees(address)\":{\"details\":\"Only callable by the contract owner or an authorized account.\",\"params\":{\"executionFees_\":\"The address of the ExecutionFees contract.\"}},\"setLinkedClient(uint256,bytes32)\":{\"details\":\"Stores the address of the linked client in a mapping with the chain ID as the key.\",\"params\":{\"chainId\":\"The chain ID for which the client is being set.\",\"client\":\"The address of the client being linked.\"}},\"writeExecutionProof(bytes32)\":{\"details\":\"Will revert if the transaction has not been executed.\",\"params\":{\"transactionId\":\"The ID of the transaction to write the proof for.\"},\"returns\":{\"dbNonce\":\"        The database nonce of the written entry for the proof.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"getExecutor(bytes)\":{\"notice\":\"Returns the address of the executor for a transaction that has been sent to the local chain.\"},\"getExecutorById(bytes32)\":{\"notice\":\"Returns the address of the executor for a transaction that has been sent to the local chain.\"},\"getInterchainFee(uint256,address,address[],bytes,bytes)\":{\"notice\":\"Returns the fee for sending an Interchain message.\"},\"interchainExecute(uint256,bytes)\":{\"notice\":\"Executes a transaction that has been sent via the Interchain.\"},\"interchainSend(uint256,bytes32,address,address[],bytes,bytes)\":{\"notice\":\"Sends a message to another chain via the Interchain Communication Protocol.\"},\"isExecutable(bytes)\":{\"notice\":\"Checks if a transaction is executable.\"},\"setExecutionFees(address)\":{\"notice\":\"Sets the address of the ExecutionFees contract.\"},\"setLinkedClient(uint256,bytes32)\":{\"notice\":\"Sets the linked client for a specific chain ID.\"},\"writeExecutionProof(bytes32)\":{\"notice\":\"Writes the proof of execution for a transaction into the InterchainDB.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainApp.sol\":\"IInterchainClientV1\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainApp.sol\":{\"keccak256\":\"0x97256ebb052f6f28fecf0beec3b1dfa66674bc1f309fa5ee1d848c8510a9efce\",\"urls\":[\"bzz-raw://4449ebe8a883f01fc9475e12203c0ba46d8546f96ac1296fa4eefe6a2b236127\",\"dweb:/ipfs/QmPW2zd3zqaAsMed1LSjVLafcE6zXNNiTwqEkHfbnRC69p\"]}},\"version\":1}"},"hashes":{"getExecutor(bytes)":"f92a79ff","getExecutorById(bytes32)":"f1a61fac","getInterchainFee(uint256,address,address[],bytes,bytes)":"3c383e7b","interchainExecute(uint256,bytes)":"80efe777","interchainSend(uint256,bytes32,address,address[],bytes,bytes)":"98939d28","interchainSendEVM(uint256,address,address,address[],bytes,bytes)":"827f940d","isExecutable(bytes)":"31afa7de","setExecutionFees(address)":"3dc68b87","setLinkedClient(uint256,bytes32)":"f34234c8","writeExecutionProof(bytes32)":"90e81077"}},"solidity/InterchainApp.sol:InterchainApp":{"code":"0x60806040523480156200001157600080fd5b50604051620011a2380380620011a28339810160408190526200003491620001e5565b600080546001600160a01b0319166001600160a01b03851617905581516200006490600590602085019062000084565b5080516200007a90600690602084019062000084565b5050505062000262565b828054828255906000526020600020908101928215620000dc579160200282015b82811115620000dc57825182546001600160a01b0319166001600160a01b03909116178255602090920191600190910190620000a5565b50620000ea929150620000ee565b5090565b5b80821115620000ea5760008155600101620000ef565b80516001600160a01b03811681146200011d57600080fd5b919050565b634e487b7160e01b600052604160045260246000fd5b600082601f8301126200014a57600080fd5b815160206001600160401b038083111562000169576200016962000122565b8260051b604051601f19603f8301168101818110848211171562000191576200019162000122565b604052938452858101830193838101925087851115620001b057600080fd5b83870191505b84821015620001da57620001ca8262000105565b83529183019190830190620001b6565b979650505050505050565b600080600060608486031215620001fb57600080fd5b620002068462000105565b60208501519093506001600160401b03808211156200022457600080fd5b620002328783880162000138565b935060408601519150808211156200024957600080fd5b50620002588682870162000138565b9150509250925092565b610f3080620002726000396000f3fe6080604052600436106100bc5760003560e01c8063ab13961311610074578063e1ef3b3f1161004e578063e1ef3b3f14610222578063ea13398f14610235578063f31b19a91461024a57600080fd5b8063ab139613146101a2578063b399470d146101c2578063bfc849ee146101d557600080fd5b806370838975116100a5578063708389751461010f5780637c9abd3e14610161578063a45e107a1461018057600080fd5b8063287bc057146100c1578063645d575a146100ed575b600080fd5b3480156100cd57600080fd5b506100d661025f565b6040516100e492919061090e565b60405180910390f35b3480156100f957600080fd5b5061010d610108366004610af3565b6102f3565b005b34801561011b57600080fd5b5060005461013c9073ffffffffffffffffffffffffffffffffffffffff1681565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020016100e4565b34801561016d57600080fd5b506008545b6040519081526020016100e4565b34801561018c57600080fd5b506101956104e0565b6040516100e49190610bcb565b3480156101ae57600080fd5b506101956101bd366004610be5565b610552565b61010d6101d0366004610c50565b6105c5565b3480156101e157600080fd5b5061013c6101f0366004610cb1565b67ffffffffffffffff1660009081526004602052604090205473ffffffffffffffffffffffffffffffffffffffff1690565b61010d610230366004610ccc565b6105f5565b34801561024157600080fd5b506101956106f7565b34801561025657600080fd5b50600754610172565b6040805180820190915260075481526008546020820152606090819061028490610767565b60068054604080516020808402820181019092528281529183918301828280156102e457602002820191906000526020600020905b815473ffffffffffffffffffffffffffffffffffffffff1681526001909101906020018083116102b9575b50505050509050915091509091565b8551875114610388576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602260248201527f436861696e49447320616e64204941707073206c656e677468206d69736d617460448201527f6368000000000000000000000000000000000000000000000000000000000000606482015260840160405180910390fd5b60005b8751811015610442578681815181106103a6576103a6610d1f565b6020026020010151600460000160008a84815181106103c7576103c7610d1f565b602002602001015167ffffffffffffffff1667ffffffffffffffff16815260200190815260200160002060006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550808061043a90610d4e565b91505061038b565b506040805180820190915282815267ffffffffffffffff821660209182018190526007849055600855855161047d91600591908801906107ba565b5083516104919060069060208701906107ba565b5050600380547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff93909316929092179091555050505050565b6060600460020180548060200260200160405190810160405280929190818152602001828054801561054857602002820191906000526020600020905b815473ffffffffffffffffffffffffffffffffffffffff16815260019091019060200180831161051d575b5050505050905090565b606060018054806020026020016040519081016040528092919081815260200182805480156105b757602002820191906000526020600020905b815473ffffffffffffffffffffffffffffffffffffffff16815260019091019060200180831161058c575b505050505090505b92915050565b6040517f847042eccd302ccad5013142e14e1f299a4527dba6be2e3b3e41e7e4b4b0ac8b90600090a15050505050565b6000610618604051806040016040528062030d4081526020016000815250610767565b6000546003546040517f98939d2800000000000000000000000000000000000000000000000000000000815292935073ffffffffffffffffffffffffffffffffffffffff918216926398939d28923492610683928a928c92169060059089908c908c90600401610df6565b604080518083038185885af11580156106a0573d6000803e3d6000fd5b50505050506040513d601f19601f820116820180604052508101906106c59190610e9b565b50506040517f943237a3fcaf9fd505830acf03c74d7f672b1b7501aa0f1a79eb0170c553bd4f90600090a15050505050565b606060046001018054806020026020016040519081016040528092919081815260200182805480156105485760200282019190600052602060002090815473ffffffffffffffffffffffffffffffffffffffff16815260019091019060200180831161051d575050505050905090565b60606105bf60018360405160200161077f9190610ebf565b604051602081830303815290604052606082826040516020016107a3929190610ed6565b604051602081830303815290604052905092915050565b828054828255906000526020600020908101928215610834579160200282015b8281111561083457825182547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff9091161782556020909201916001909101906107da565b50610840929150610844565b5090565b5b808211156108405760008155600101610845565b6000815180845260005b8181101561087f57602081850181015186830182015201610863565b5060006020828601015260207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f83011685010191505092915050565b600081518084526020808501945080840160005b8381101561090357815173ffffffffffffffffffffffffffffffffffffffff16875295820195908201906001016108d1565b509495945050505050565b6040815260006109216040830185610859565b828103602084015261093381856108bd565b95945050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff811182821017156109b2576109b261093c565b604052919050565b600067ffffffffffffffff8211156109d4576109d461093c565b5060051b60200190565b803567ffffffffffffffff811681146109f657600080fd5b919050565b600082601f830112610a0c57600080fd5b81356020610a21610a1c836109ba565b61096b565b82815260059290921b84018101918181019086841115610a4057600080fd5b8286015b84811015610a6257610a55816109de565b8352918301918301610a44565b509695505050505050565b803573ffffffffffffffffffffffffffffffffffffffff811681146109f657600080fd5b600082601f830112610aa257600080fd5b81356020610ab2610a1c836109ba565b82815260059290921b84018101918181019086841115610ad157600080fd5b8286015b84811015610a6257610ae681610a6d565b8352918301918301610ad5565b600080600080600080600060e0888a031215610b0e57600080fd5b873567ffffffffffffffff80821115610b2657600080fd5b610b328b838c016109fb565b985060208a0135915080821115610b4857600080fd5b610b548b838c01610a91565b975060408a0135915080821115610b6a57600080fd5b610b768b838c01610a91565b965060608a0135915080821115610b8c57600080fd5b50610b998a828b01610a91565b945050610ba860808901610a6d565b925060a08801359150610bbd60c089016109de565b905092959891949750929550565b602081526000610bde60208301846108bd565b9392505050565b60008060408385031215610bf857600080fd5b50508035926020909101359150565b60008083601f840112610c1957600080fd5b50813567ffffffffffffffff811115610c3157600080fd5b602083019150836020828501011115610c4957600080fd5b9250929050565b600080600080600060808688031215610c6857600080fd5b853594506020860135935060408601359250606086013567ffffffffffffffff811115610c9457600080fd5b610ca088828901610c07565b969995985093965092949392505050565b600060208284031215610cc357600080fd5b610bde826109de565b60008060008060608587031215610ce257600080fd5b8435935060208501359250604085013567ffffffffffffffff811115610d0757600080fd5b610d1387828801610c07565b95989497509550505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203610da6577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b5060010190565b8183528181602085013750600060208284010152600060207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f840116840101905092915050565b600060c082018983526020898185015273ffffffffffffffffffffffffffffffffffffffff808a16604086015260c0606086015282895480855260e0870191508a60005283600020945060005b81811015610e61578554841683526001958601959285019201610e43565b50508581036080870152610e75818a610859565b935050505082810360a0840152610e8d818587610dad565b9a9950505050505050505050565b60008060408385031215610eae57600080fd5b505080516020909101519092909150565b8151815260208083015190820152604081016105bf565b60ff83168152604060208201526000610ef26040830184610859565b94935050505056fea2646970667358221220bfadb7a9cdcc8fe0a3a66c71b90675cf2087b9d292f5be92afcaa877f03bee4264736f6c63430008140033","runtime-code":"0x6080604052600436106100bc5760003560e01c8063ab13961311610074578063e1ef3b3f1161004e578063e1ef3b3f14610222578063ea13398f14610235578063f31b19a91461024a57600080fd5b8063ab139613146101a2578063b399470d146101c2578063bfc849ee146101d557600080fd5b806370838975116100a5578063708389751461010f5780637c9abd3e14610161578063a45e107a1461018057600080fd5b8063287bc057146100c1578063645d575a146100ed575b600080fd5b3480156100cd57600080fd5b506100d661025f565b6040516100e492919061090e565b60405180910390f35b3480156100f957600080fd5b5061010d610108366004610af3565b6102f3565b005b34801561011b57600080fd5b5060005461013c9073ffffffffffffffffffffffffffffffffffffffff1681565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020016100e4565b34801561016d57600080fd5b506008545b6040519081526020016100e4565b34801561018c57600080fd5b506101956104e0565b6040516100e49190610bcb565b3480156101ae57600080fd5b506101956101bd366004610be5565b610552565b61010d6101d0366004610c50565b6105c5565b3480156101e157600080fd5b5061013c6101f0366004610cb1565b67ffffffffffffffff1660009081526004602052604090205473ffffffffffffffffffffffffffffffffffffffff1690565b61010d610230366004610ccc565b6105f5565b34801561024157600080fd5b506101956106f7565b34801561025657600080fd5b50600754610172565b6040805180820190915260075481526008546020820152606090819061028490610767565b60068054604080516020808402820181019092528281529183918301828280156102e457602002820191906000526020600020905b815473ffffffffffffffffffffffffffffffffffffffff1681526001909101906020018083116102b9575b50505050509050915091509091565b8551875114610388576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602260248201527f436861696e49447320616e64204941707073206c656e677468206d69736d617460448201527f6368000000000000000000000000000000000000000000000000000000000000606482015260840160405180910390fd5b60005b8751811015610442578681815181106103a6576103a6610d1f565b6020026020010151600460000160008a84815181106103c7576103c7610d1f565b602002602001015167ffffffffffffffff1667ffffffffffffffff16815260200190815260200160002060006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550808061043a90610d4e565b91505061038b565b506040805180820190915282815267ffffffffffffffff821660209182018190526007849055600855855161047d91600591908801906107ba565b5083516104919060069060208701906107ba565b5050600380547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff93909316929092179091555050505050565b6060600460020180548060200260200160405190810160405280929190818152602001828054801561054857602002820191906000526020600020905b815473ffffffffffffffffffffffffffffffffffffffff16815260019091019060200180831161051d575b5050505050905090565b606060018054806020026020016040519081016040528092919081815260200182805480156105b757602002820191906000526020600020905b815473ffffffffffffffffffffffffffffffffffffffff16815260019091019060200180831161058c575b505050505090505b92915050565b6040517f847042eccd302ccad5013142e14e1f299a4527dba6be2e3b3e41e7e4b4b0ac8b90600090a15050505050565b6000610618604051806040016040528062030d4081526020016000815250610767565b6000546003546040517f98939d2800000000000000000000000000000000000000000000000000000000815292935073ffffffffffffffffffffffffffffffffffffffff918216926398939d28923492610683928a928c92169060059089908c908c90600401610df6565b604080518083038185885af11580156106a0573d6000803e3d6000fd5b50505050506040513d601f19601f820116820180604052508101906106c59190610e9b565b50506040517f943237a3fcaf9fd505830acf03c74d7f672b1b7501aa0f1a79eb0170c553bd4f90600090a15050505050565b606060046001018054806020026020016040519081016040528092919081815260200182805480156105485760200282019190600052602060002090815473ffffffffffffffffffffffffffffffffffffffff16815260019091019060200180831161051d575050505050905090565b60606105bf60018360405160200161077f9190610ebf565b604051602081830303815290604052606082826040516020016107a3929190610ed6565b604051602081830303815290604052905092915050565b828054828255906000526020600020908101928215610834579160200282015b8281111561083457825182547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff9091161782556020909201916001909101906107da565b50610840929150610844565b5090565b5b808211156108405760008155600101610845565b6000815180845260005b8181101561087f57602081850181015186830182015201610863565b5060006020828601015260207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f83011685010191505092915050565b600081518084526020808501945080840160005b8381101561090357815173ffffffffffffffffffffffffffffffffffffffff16875295820195908201906001016108d1565b509495945050505050565b6040815260006109216040830185610859565b828103602084015261093381856108bd565b95945050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff811182821017156109b2576109b261093c565b604052919050565b600067ffffffffffffffff8211156109d4576109d461093c565b5060051b60200190565b803567ffffffffffffffff811681146109f657600080fd5b919050565b600082601f830112610a0c57600080fd5b81356020610a21610a1c836109ba565b61096b565b82815260059290921b84018101918181019086841115610a4057600080fd5b8286015b84811015610a6257610a55816109de565b8352918301918301610a44565b509695505050505050565b803573ffffffffffffffffffffffffffffffffffffffff811681146109f657600080fd5b600082601f830112610aa257600080fd5b81356020610ab2610a1c836109ba565b82815260059290921b84018101918181019086841115610ad157600080fd5b8286015b84811015610a6257610ae681610a6d565b8352918301918301610ad5565b600080600080600080600060e0888a031215610b0e57600080fd5b873567ffffffffffffffff80821115610b2657600080fd5b610b328b838c016109fb565b985060208a0135915080821115610b4857600080fd5b610b548b838c01610a91565b975060408a0135915080821115610b6a57600080fd5b610b768b838c01610a91565b965060608a0135915080821115610b8c57600080fd5b50610b998a828b01610a91565b945050610ba860808901610a6d565b925060a08801359150610bbd60c089016109de565b905092959891949750929550565b602081526000610bde60208301846108bd565b9392505050565b60008060408385031215610bf857600080fd5b50508035926020909101359150565b60008083601f840112610c1957600080fd5b50813567ffffffffffffffff811115610c3157600080fd5b602083019150836020828501011115610c4957600080fd5b9250929050565b600080600080600060808688031215610c6857600080fd5b853594506020860135935060408601359250606086013567ffffffffffffffff811115610c9457600080fd5b610ca088828901610c07565b969995985093965092949392505050565b600060208284031215610cc357600080fd5b610bde826109de565b60008060008060608587031215610ce257600080fd5b8435935060208501359250604085013567ffffffffffffffff811115610d0757600080fd5b610d1387828801610c07565b95989497509550505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203610da6577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b5060010190565b8183528181602085013750600060208284010152600060207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f840116840101905092915050565b600060c082018983526020898185015273ffffffffffffffffffffffffffffffffffffffff808a16604086015260c0606086015282895480855260e0870191508a60005283600020945060005b81811015610e61578554841683526001958601959285019201610e43565b50508581036080870152610e75818a610859565b935050505082810360a0840152610e8d818587610dad565b9a9950505050505050505050565b60008060408385031215610eae57600080fd5b505080516020909101519092909150565b8151815260208083015190820152604081016105bf565b60ff83168152604060208201526000610ef26040830184610859565b94935050505056fea2646970667358221220bfadb7a9cdcc8fe0a3a66c71b90675cf2087b9d292f5be92afcaa877f03bee4264736f6c63430008140033","info":{"source":"pragma solidity =0.8.20 ^0.8.0 ^0.8.13;\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    function appReceive(uint256 srcChainId, bytes32 sender, uint256 dbNonce, bytes calldata message) external payable;\n\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint256 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectSrcChainId(uint256 chainId);\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint256 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return transactionId The ID of the transaction that was sent.\n     * @return dbNonce The database nonce of the written entry for the transaction.\n     */\n    function interchainSend(\n        uint256 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (bytes32 transactionId, uint256 dbNonce);\n\n    function interchainSendEVM(\n        uint256 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (bytes32 transactionId, uint256 dbNonce);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     */\n    function interchainExecute(uint256 gasLimit, bytes calldata transaction) external payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the written entry for the proof.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint256 dbNonce);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction The InterchainTransaction struct to be checked.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param message              The message being sent.\n    function getInterchainFee(\n        uint256 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    error AppConfigLib__IncorrectVersion(uint8 version);\n\n    uint8 constant APP_CONFIG_V1 = 1;\n\n    /// @notice Encodes versioned app config into a bytes format.\n    /// @param version      The version of the app config.\n    /// @param appConfig    The app config to encode.\n    function encodeVersionedAppConfig(uint8 version, bytes memory appConfig) internal pure returns (bytes memory) {\n        return abi.encode(version, appConfig);\n    }\n\n    /// @notice Decodes versioned app config from a bytes format back into a version and app config.\n    /// @param data         The versioned app config data in bytes format.\n    /// @return version     The version of the app config.\n    /// @return appConfig   The app config as bytes.\n    function decodeVersionedAppConfig(bytes memory data)\n        internal\n        pure\n        returns (uint8 version, bytes memory appConfig)\n    {\n        (version, appConfig) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return encodeVersionedAppConfig(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal pure returns (AppConfigV1 memory) {\n        (uint8 version, bytes memory appConfig) = decodeVersionedAppConfig(data);\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(appConfig, (AppConfigV1));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    error OptionsLib__IncorrectVersion(uint8 version);\n\n    uint8 constant OPTIONS_V1 = 1;\n\n    /// @notice Encodes versioned options into a bytes format.\n    /// @param version      The version of the options.\n    /// @param options      The options to encode.\n    function encodeVersionedOptions(uint8 version, bytes memory options) internal pure returns (bytes memory) {\n        return abi.encode(version, options);\n    }\n\n    /// @notice Decodes versioned options from a bytes format back into a version and options.\n    /// @param data         The versioned options data in bytes format.\n    /// @return version     The version of the options.\n    /// @return options     The options as bytes.\n    function decodeVersionedOptions(bytes memory data) internal pure returns (uint8 version, bytes memory options) {\n        (version, options) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return encodeVersionedOptions(OPTIONS_V1, abi.encode(options));\n    }\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal pure returns (OptionsV1 memory) {\n        (uint8 version, bytes memory options) = decodeVersionedOptions(data);\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(options, (OptionsV1));\n    }\n}\n\n// contracts/InterchainApp.sol\n\ncontract InterchainApp is IInterchainApp {\n    using AppConfigLib for bytes;\n    // What properties should Interchain be pulling from InterchainApp?\n    // 1. Which modules to use, and how many are required?\n\n    IInterchainClientV1 public interchain;\n\n    address[] private sendingModules;\n    address[] private receivingModules;\n    address private executionService;\n\n    struct AppConfig {\n        // ChainID -\u003e Linked IApps\n        mapping(uint64 =\u003e address) linkedIApps;\n        // Sends message to be verified through all modules\n        address[] sendingModules;\n        // Accepts messages from these destination chain modules\n        address[] receivingModules;\n        AppConfigV1 bytesAppConfig;\n    }\n\n    AppConfig private localAppConfig;\n\n    // Set the application configuration\n    function setAppConfig(\n        uint64[] memory chainIDs,\n        address[] memory linkedIApps,\n        address[] memory _sendingModules,\n        address[] memory _receivingModules,\n        address _executionService,\n        uint256 _requiredResponses,\n        uint64 _optimisticTimePeriod\n    )\n        public\n    {\n        // TODO: Add access control or ownership checks\n        require(chainIDs.length == linkedIApps.length, \"ChainIDs and IApps length mismatch\");\n\n        for (uint256 i = 0; i \u003c chainIDs.length; i++) {\n            localAppConfig.linkedIApps[chainIDs[i]] = linkedIApps[i];\n        }\n\n        localAppConfig.bytesAppConfig =\n            AppConfigV1({requiredResponses: _requiredResponses, optimisticPeriod: _optimisticTimePeriod});\n\n        localAppConfig.sendingModules = _sendingModules;\n        localAppConfig.receivingModules = _receivingModules;\n        executionService = _executionService;\n    }\n\n    // Getters for the application configuration\n    function getLinkedIApp(uint64 chainID) external view returns (address) {\n        return localAppConfig.linkedIApps[chainID];\n    }\n\n    // TODO: Is a receiving module the same as a sending module?\n    function getSendingModules() external view returns (address[] memory) {\n        return localAppConfig.sendingModules;\n    }\n\n    function getReceivingModules() external view returns (address[] memory) {\n        return localAppConfig.receivingModules;\n    }\n\n    function getRequiredResponses() external view returns (uint256) {\n        return localAppConfig.bytesAppConfig.requiredResponses;\n    }\n\n    function getOptimisticTimePeriod() external view returns (uint256) {\n        return localAppConfig.bytesAppConfig.optimisticPeriod;\n    }\n\n    function getSendingModules(bytes32 receiver, uint256 dstChainId) external view returns (address[] memory) {\n        return sendingModules;\n    }\n\n    function getReceivingConfig() external view returns (bytes memory, address[] memory) {\n        return (AppConfigLib.encodeAppConfigV1(localAppConfig.bytesAppConfig), localAppConfig.receivingModules);\n    }\n\n    constructor(address _interchain, address[] memory _sendingModules, address[] memory _receivingModules) {\n        interchain = IInterchainClientV1(_interchain);\n        localAppConfig.sendingModules = _sendingModules;\n        localAppConfig.receivingModules = _receivingModules;\n    }\n\n    event AppMessageRecieve();\n    event AppMessageSent();\n\n    function send(bytes32 receiver, uint256 dstChainId, bytes calldata message) external payable {\n        bytes memory options = OptionsV1(200_000, 0).encodeOptionsV1();\n        // TODO: Currently, we forward all gas to Interchain, this may not be expected behavior, and the real abstract contract shouldn't do this\n        interchain.interchainSend{value: msg.value}(\n            dstChainId, receiver, executionService, localAppConfig.sendingModules, options, message\n        );\n        emit AppMessageSent();\n    }\n\n    // TODO: Auth checks based on incoming message\n    function appReceive(uint256 srcChainId, bytes32 sender, uint256 dbNonce, bytes calldata message) external payable {\n        emit AppMessageRecieve();\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"11163:3958:0:-:0;;;14045:283;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;14158:10;:45;;-1:-1:-1;;;;;;14158:45:0;-1:-1:-1;;;;;14158:45:0;;;;;14213:47;;;;:29;;:47;;;;;:::i;:::-;-1:-1:-1;14270:51:0;;;;:31;;:51;;;;;:::i;:::-;;14045:283;;;11163:3958;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;;;;;11163:3958:0;-1:-1:-1;;;;;11163:3958:0;;;;;;;;;;;-1:-1:-1;11163:3958:0;;;;;;;-1:-1:-1;11163:3958:0;;;-1:-1:-1;11163:3958:0;:::i;:::-;;;:::o;:::-;;;;;;;;;;;;;;;14:177:1;93:13;;-1:-1:-1;;;;;135:31:1;;125:42;;115:70;;181:1;178;171:12;115:70;14:177;;;:::o;196:127::-;257:10;252:3;248:20;245:1;238:31;288:4;285:1;278:15;312:4;309:1;302:15;328:923;393:5;446:3;439:4;431:6;427:17;423:27;413:55;;464:1;461;454:12;413:55;487:13;;519:4;-1:-1:-1;;;;;572:10:1;;;569:36;;;585:18;;:::i;:::-;631:2;628:1;624:10;663:2;657:9;726:2;722:7;717:2;713;709:11;705:25;697:6;693:38;781:6;769:10;766:22;761:2;749:10;746:18;743:46;740:72;;;792:18;;:::i;:::-;828:2;821:22;878:18;;;954:15;;;950:24;;;912:15;;;;-1:-1:-1;986:15:1;;;983:35;;;1014:1;1011;1004:12;983:35;1050:2;1042:6;1038:15;1027:26;;1062:159;1078:6;1073:3;1070:15;1062:159;;;1144:34;1174:3;1144:34;:::i;:::-;1132:47;;1199:12;;;;1095;;;;1062:159;;;1239:6;328:923;-1:-1:-1;;;;;;;328:923:1:o;1256:699::-;1394:6;1402;1410;1463:2;1451:9;1442:7;1438:23;1434:32;1431:52;;;1479:1;1476;1469:12;1431:52;1502:40;1532:9;1502:40;:::i;:::-;1586:2;1571:18;;1565:25;1492:50;;-1:-1:-1;;;;;;1639:14:1;;;1636:34;;;1666:1;1663;1656:12;1636:34;1689:72;1753:7;1744:6;1733:9;1729:22;1689:72;:::i;:::-;1679:82;;1807:2;1796:9;1792:18;1786:25;1770:41;;1836:2;1826:8;1823:16;1820:36;;;1852:1;1849;1842:12;1820:36;;1875:74;1941:7;1930:8;1919:9;1915:24;1875:74;:::i;:::-;1865:84;;;1256:699;;;;;:::o;:::-;11163:3958:0;;;;;;","srcMapRuntime":"11163:3958:0:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;13834:205;;;;;;;;;;;;;:::i;:::-;;;;;;;;:::i;:::-;;;;;;;;11961:921;;;;;;;;;;-1:-1:-1;11961:921:0;;;;;:::i;:::-;;:::i;:::-;;11376:37;;;;;;;;;;-1:-1:-1;11376:37:0;;;;;;;;;;;5320:42:1;5308:55;;;5290:74;;5278:2;5263:18;11376:37:0;5117:253:1;13541:137:0;;;;;;;;;;-1:-1:-1;13625:46:0;;13541:137;;;5521:25:1;;;5509:2;5494:18;13541:137:0;5375:177:1;13267:127:0;;;;;;;;;;;;;:::i;:::-;;;;;;;:::i;13684:144::-;;;;;;;;;;-1:-1:-1;13684:144:0;;;;;:::i;:::-;;:::i;14964:155::-;;;;;;:::i;:::-;;:::i;12937:130::-;;;;;;;;;;-1:-1:-1;12937:130:0;;;;;:::i;:::-;13025:35;;12999:7;13025:35;;;:14;:35;;;;;;;;;12937:130;14394:513;;;;;;:::i;:::-;;:::i;13138:123::-;;;;;;;;;;;;;:::i;13400:135::-;;;;;;;;;;-1:-1:-1;13481:29:0;:47;13400:135;;13834:205;13937:61;;;;;;;;;13968:29;13937:61;;;;;;;;;13887:12;;;;13937:61;;:30;:61::i;:::-;14000:31;13929:103;;;;;;;;;;;;;;;;;;;;14000:31;;13929:103;;14000:31;13929:103;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;13834:205;;:::o;11961:921::-;12368:11;:18;12349:8;:15;:37;12341:84;;;;;;;8219:2:1;12341:84:0;;;8201:21:1;8258:2;8238:18;;;8231:30;8297:34;8277:18;;;8270:62;8368:4;8348:18;;;8341:32;8390:19;;12341:84:0;;;;;;;;12441:9;12436:127;12460:8;:15;12456:1;:19;12436:127;;;12538:11;12550:1;12538:14;;;;;;;;:::i;:::-;;;;;;;12496;:26;;:39;12523:8;12532:1;12523:11;;;;;;;;:::i;:::-;;;;;;;12496:39;;;;;;;;;;;;;;;;:56;;;;;;;;;;;;;;;;;;12477:3;;;;;:::i;:::-;;;;12436:127;;;-1:-1:-1;12617:93:0;;;;;;;;;;;;;;;;;;;;;;12573:29;:137;;;;;12721:47;;;;:29;;:47;;;;;:::i;:::-;-1:-1:-1;12778:51:0;;;;:31;;:51;;;;;:::i;:::-;-1:-1:-1;;12839:16:0;:36;;;;;;;;;;;;;;;;-1:-1:-1;;;;;11961:921:0:o;13267:127::-;13321:16;13356:14;:31;;13349:38;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;13267:127;:::o;13684:144::-;13772:16;13807:14;13800:21;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;13684:144;;;;;:::o;14964:155::-;15093:19;;;;;;;14964:155;;;;;:::o;14394:513::-;14497:20;14520:39;:21;;;;;;;;14530:7;14520:21;;;;14539:1;14520:21;;;:37;:39::i;:::-;14715:10;;14794:16;;14715:154;;;;;14497:62;;-1:-1:-1;14715:10:0;;;;;:25;;14748:9;;14715:154;;14772:10;;14784:8;;14794:16;;14812:29;;14497:62;;14852:7;;;;14812:14;14715:154;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;-1:-1:-1;;14884:16:0;;;;;;;14487:420;14394:513;;;;:::o;13138:123::-;13190:16;13225:14;:29;;13218:36;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;13138:123;:::o;7676:180::-;7756:12;7787:62;6696:1;7838:9;7827:21;;;;;;;;:::i;:::-;;;;;;;;;;;;;6979:12;7021:7;7030:9;7010:30;;;;;;;;;:::i;:::-;;;;;;;;;;;;;7003:37;;6883:164;;;;:::o;-1:-1:-1:-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;:::o;:::-;;;;;;;;;;;;;;;14:481:1;55:3;93:5;87:12;120:6;115:3;108:19;145:1;155:162;169:6;166:1;163:13;155:162;;;231:4;287:13;;;283:22;;277:29;259:11;;;255:20;;248:59;184:12;155:162;;;159:3;362:1;355:4;346:6;341:3;337:16;333:27;326:38;484:4;414:66;409:2;401:6;397:15;393:88;388:3;384:98;380:109;373:116;;;14:481;;;;:::o;500:484::-;553:3;591:5;585:12;618:6;613:3;606:19;644:4;673:2;668:3;664:12;657:19;;710:2;703:5;699:14;731:1;741:218;755:6;752:1;749:13;741:218;;;820:13;;835:42;816:62;804:75;;899:12;;;;934:15;;;;777:1;770:9;741:218;;;-1:-1:-1;975:3:1;;500:484;-1:-1:-1;;;;;500:484:1:o;989:421::-;1214:2;1203:9;1196:21;1177:4;1240:44;1280:2;1269:9;1265:18;1257:6;1240:44;:::i;:::-;1332:9;1324:6;1320:22;1315:2;1304:9;1300:18;1293:50;1360:44;1397:6;1389;1360:44;:::i;:::-;1352:52;989:421;-1:-1:-1;;;;;989:421:1:o;1415:184::-;1467:77;1464:1;1457:88;1564:4;1561:1;1554:15;1588:4;1585:1;1578:15;1604:334;1675:2;1669:9;1731:2;1721:13;;1736:66;1717:86;1705:99;;1834:18;1819:34;;1855:22;;;1816:62;1813:88;;;1881:18;;:::i;:::-;1917:2;1910:22;1604:334;;-1:-1:-1;1604:334:1:o;1943:182::-;2002:4;2035:18;2027:6;2024:30;2021:56;;;2057:18;;:::i;:::-;-1:-1:-1;2102:1:1;2098:14;2114:4;2094:25;;1943:182::o;2130:171::-;2197:20;;2257:18;2246:30;;2236:41;;2226:69;;2291:1;2288;2281:12;2226:69;2130:171;;;:::o;2306:665::-;2359:5;2412:3;2405:4;2397:6;2393:17;2389:27;2379:55;;2430:1;2427;2420:12;2379:55;2466:6;2453:20;2492:4;2516:59;2532:42;2571:2;2532:42;:::i;:::-;2516:59;:::i;:::-;2609:15;;;2695:1;2691:10;;;;2679:23;;2675:32;;;2640:12;;;;2719:15;;;2716:35;;;2747:1;2744;2737:12;2716:35;2783:2;2775:6;2771:15;2795:147;2811:6;2806:3;2803:15;2795:147;;;2877:22;2895:3;2877:22;:::i;:::-;2865:35;;2920:12;;;;2828;;2795:147;;;-1:-1:-1;2960:5:1;2306:665;-1:-1:-1;;;;;;2306:665:1:o;2976:196::-;3044:20;;3104:42;3093:54;;3083:65;;3073:93;;3162:1;3159;3152:12;3177:667;3231:5;3284:3;3277:4;3269:6;3265:17;3261:27;3251:55;;3302:1;3299;3292:12;3251:55;3338:6;3325:20;3364:4;3388:59;3404:42;3443:2;3404:42;:::i;3388:59::-;3481:15;;;3567:1;3563:10;;;;3551:23;;3547:32;;;3512:12;;;;3591:15;;;3588:35;;;3619:1;3616;3609:12;3588:35;3655:2;3647:6;3643:15;3667:148;3683:6;3678:3;3675:15;3667:148;;;3749:23;3768:3;3749:23;:::i;:::-;3737:36;;3793:12;;;;3700;;3667:148;;3849:1263;4060:6;4068;4076;4084;4092;4100;4108;4161:3;4149:9;4140:7;4136:23;4132:33;4129:53;;;4178:1;4175;4168:12;4129:53;4218:9;4205:23;4247:18;4288:2;4280:6;4277:14;4274:34;;;4304:1;4301;4294:12;4274:34;4327:60;4379:7;4370:6;4359:9;4355:22;4327:60;:::i;:::-;4317:70;;4440:2;4429:9;4425:18;4412:32;4396:48;;4469:2;4459:8;4456:16;4453:36;;;4485:1;4482;4475:12;4453:36;4508:63;4563:7;4552:8;4541:9;4537:24;4508:63;:::i;:::-;4498:73;;4624:2;4613:9;4609:18;4596:32;4580:48;;4653:2;4643:8;4640:16;4637:36;;;4669:1;4666;4659:12;4637:36;4692:63;4747:7;4736:8;4725:9;4721:24;4692:63;:::i;:::-;4682:73;;4808:2;4797:9;4793:18;4780:32;4764:48;;4837:2;4827:8;4824:16;4821:36;;;4853:1;4850;4843:12;4821:36;;4876:63;4931:7;4920:8;4909:9;4905:24;4876:63;:::i;:::-;4866:73;;;4958:39;4992:3;4981:9;4977:19;4958:39;:::i;:::-;4948:49;;5044:3;5033:9;5029:19;5016:33;5006:43;;5068:38;5101:3;5090:9;5086:19;5068:38;:::i;:::-;5058:48;;3849:1263;;;;;;;;;;:::o;5557:261::-;5736:2;5725:9;5718:21;5699:4;5756:56;5808:2;5797:9;5793:18;5785:6;5756:56;:::i;:::-;5748:64;5557:261;-1:-1:-1;;;5557:261:1:o;5823:248::-;5891:6;5899;5952:2;5940:9;5931:7;5927:23;5923:32;5920:52;;;5968:1;5965;5958:12;5920:52;-1:-1:-1;;5991:23:1;;;6061:2;6046:18;;;6033:32;;-1:-1:-1;5823:248:1:o;6076:347::-;6127:8;6137:6;6191:3;6184:4;6176:6;6172:17;6168:27;6158:55;;6209:1;6206;6199:12;6158:55;-1:-1:-1;6232:20:1;;6275:18;6264:30;;6261:50;;;6307:1;6304;6297:12;6261:50;6344:4;6336:6;6332:17;6320:29;;6396:3;6389:4;6380:6;6372;6368:19;6364:30;6361:39;6358:59;;;6413:1;6410;6403:12;6358:59;6076:347;;;;;:::o;6428:614::-;6525:6;6533;6541;6549;6557;6610:3;6598:9;6589:7;6585:23;6581:33;6578:53;;;6627:1;6624;6617:12;6578:53;6663:9;6650:23;6640:33;;6720:2;6709:9;6705:18;6692:32;6682:42;;6771:2;6760:9;6756:18;6743:32;6733:42;;6826:2;6815:9;6811:18;6798:32;6853:18;6845:6;6842:30;6839:50;;;6885:1;6882;6875:12;6839:50;6924:58;6974:7;6965:6;6954:9;6950:22;6924:58;:::i;:::-;6428:614;;;;-1:-1:-1;6428:614:1;;-1:-1:-1;7001:8:1;;6898:84;6428:614;-1:-1:-1;;;6428:614:1:o;7047:184::-;7105:6;7158:2;7146:9;7137:7;7133:23;7129:32;7126:52;;;7174:1;7171;7164:12;7126:52;7197:28;7215:9;7197:28;:::i;7467:545::-;7555:6;7563;7571;7579;7632:2;7620:9;7611:7;7607:23;7603:32;7600:52;;;7648:1;7645;7638:12;7600:52;7684:9;7671:23;7661:33;;7741:2;7730:9;7726:18;7713:32;7703:42;;7796:2;7785:9;7781:18;7768:32;7823:18;7815:6;7812:30;7809:50;;;7855:1;7852;7845:12;7809:50;7894:58;7944:7;7935:6;7924:9;7920:22;7894:58;:::i;:::-;7467:545;;;;-1:-1:-1;7971:8:1;-1:-1:-1;;;;7467:545:1:o;8420:184::-;8472:77;8469:1;8462:88;8569:4;8566:1;8559:15;8593:4;8590:1;8583:15;8609:349;8648:3;8679:66;8672:5;8669:77;8666:257;;8779:77;8776:1;8769:88;8880:4;8877:1;8870:15;8908:4;8905:1;8898:15;8666:257;-1:-1:-1;8950:1:1;8939:13;;8609:349::o;8963:325::-;9051:6;9046:3;9039:19;9103:6;9096:5;9089:4;9084:3;9080:14;9067:43;;9155:1;9148:4;9139:6;9134:3;9130:16;9126:27;9119:38;9021:3;9277:4;9207:66;9202:2;9194:6;9190:15;9186:88;9181:3;9177:98;9173:109;9166:116;;8963:325;;;;:::o;9293:1267::-;9618:4;9666:3;9655:9;9651:19;9697:6;9686:9;9679:25;9723:2;9761:6;9756:2;9745:9;9741:18;9734:34;9787:42;9877:2;9869:6;9865:15;9860:2;9849:9;9845:18;9838:43;9917:3;9912:2;9901:9;9897:18;9890:31;9941:6;9976;9970:13;10007:6;9999;9992:22;10045:3;10034:9;10030:19;10023:26;;10068:6;10065:1;10058:17;10111:2;10108:1;10098:16;10084:30;;10132:1;10142:177;10156:6;10153:1;10150:13;10142:177;;;10221:13;;10217:22;;10205:35;;10307:1;10295:14;;;;10260:12;;;;10171:9;10142:177;;;10146:3;;10365:9;10360:3;10356:19;10350:3;10339:9;10335:19;10328:48;10399:29;10424:3;10416:6;10399:29;:::i;:::-;10385:43;;;;;10477:9;10469:6;10465:22;10459:3;10448:9;10444:19;10437:51;10505:49;10547:6;10539;10531;10505:49;:::i;:::-;10497:57;9293:1267;-1:-1:-1;;;;;;;;;;9293:1267:1:o;10565:245::-;10644:6;10652;10705:2;10693:9;10684:7;10680:23;10676:32;10673:52;;;10721:1;10718;10711:12;10673:52;-1:-1:-1;;10744:16:1;;10800:2;10785:18;;;10779:25;10744:16;;10779:25;;-1:-1:-1;10565:245:1:o;10972:256::-;10892:12;;10880:25;;10954:4;10943:16;;;10937:23;10921:14;;;10914:47;11162:2;11147:18;;11174:48;10815:152;11490:295;11673:4;11665:6;11661:17;11650:9;11643:36;11715:2;11710;11699:9;11695:18;11688:30;11624:4;11735:44;11775:2;11764:9;11760:18;11752:6;11735:44;:::i;:::-;11727:52;11490:295;-1:-1:-1;;;;11490:295:1:o","abiDefinition":[{"inputs":[{"internalType":"address","name":"_interchain","type":"address"},{"internalType":"address[]","name":"_sendingModules","type":"address[]"},{"internalType":"address[]","name":"_receivingModules","type":"address[]"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[],"name":"AppMessageRecieve","type":"event"},{"anonymous":false,"inputs":[],"name":"AppMessageSent","type":"event"},{"inputs":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"bytes32","name":"sender","type":"bytes32"},{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"bytes","name":"message","type":"bytes"}],"name":"appReceive","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint64","name":"chainID","type":"uint64"}],"name":"getLinkedIApp","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getOptimisticTimePeriod","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getReceivingConfig","outputs":[{"internalType":"bytes","name":"","type":"bytes"},{"internalType":"address[]","name":"","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getReceivingModules","outputs":[{"internalType":"address[]","name":"","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getRequiredResponses","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"receiver","type":"bytes32"},{"internalType":"uint256","name":"dstChainId","type":"uint256"}],"name":"getSendingModules","outputs":[{"internalType":"address[]","name":"","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getSendingModules","outputs":[{"internalType":"address[]","name":"","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"interchain","outputs":[{"internalType":"contract IInterchainClientV1","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"receiver","type":"bytes32"},{"internalType":"uint256","name":"dstChainId","type":"uint256"},{"internalType":"bytes","name":"message","type":"bytes"}],"name":"send","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint64[]","name":"chainIDs","type":"uint64[]"},{"internalType":"address[]","name":"linkedIApps","type":"address[]"},{"internalType":"address[]","name":"_sendingModules","type":"address[]"},{"internalType":"address[]","name":"_receivingModules","type":"address[]"},{"internalType":"address","name":"_executionService","type":"address"},{"internalType":"uint256","name":"_requiredResponses","type":"uint256"},{"internalType":"uint64","name":"_optimisticTimePeriod","type":"uint64"}],"name":"setAppConfig","outputs":[],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_interchain\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_sendingModules\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_receivingModules\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"AppMessageRecieve\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"AppMessageSent\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"appReceive\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainID\",\"type\":\"uint64\"}],\"name\":\"getLinkedIApp\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOptimisticTimePeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReceivingConfig\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReceivingModules\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRequiredResponses\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"receiver\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"dstChainId\",\"type\":\"uint256\"}],\"name\":\"getSendingModules\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSendingModules\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"interchain\",\"outputs\":[{\"internalType\":\"contract IInterchainClientV1\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"receiver\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"dstChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"send\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64[]\",\"name\":\"chainIDs\",\"type\":\"uint64[]\"},{\"internalType\":\"address[]\",\"name\":\"linkedIApps\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_sendingModules\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_receivingModules\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"_executionService\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_requiredResponses\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"_optimisticTimePeriod\",\"type\":\"uint64\"}],\"name\":\"setAppConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainApp.sol\":\"InterchainApp\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainApp.sol\":{\"keccak256\":\"0x97256ebb052f6f28fecf0beec3b1dfa66674bc1f309fa5ee1d848c8510a9efce\",\"urls\":[\"bzz-raw://4449ebe8a883f01fc9475e12203c0ba46d8546f96ac1296fa4eefe6a2b236127\",\"dweb:/ipfs/QmPW2zd3zqaAsMed1LSjVLafcE6zXNNiTwqEkHfbnRC69p\"]}},\"version\":1}"},"hashes":{"appReceive(uint256,bytes32,uint256,bytes)":"b399470d","getLinkedIApp(uint64)":"bfc849ee","getOptimisticTimePeriod()":"7c9abd3e","getReceivingConfig()":"287bc057","getReceivingModules()":"a45e107a","getRequiredResponses()":"f31b19a9","getSendingModules()":"ea13398f","getSendingModules(bytes32,uint256)":"ab139613","interchain()":"70838975","send(bytes32,uint256,bytes)":"e1ef3b3f","setAppConfig(uint64[],address[],address[],address[],address,uint256,uint64)":"645d575a"}},"solidity/InterchainApp.sol:OptionsLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122092452693727ca9b81af205ba6b3ab0381c3222743ca25625f9ee98bdafee4dbe64736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122092452693727ca9b81af205ba6b3ab0381c3222743ca25625f9ee98bdafee4dbe64736f6c63430008140033","info":{"source":"pragma solidity =0.8.20 ^0.8.0 ^0.8.13;\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    function appReceive(uint256 srcChainId, bytes32 sender, uint256 dbNonce, bytes calldata message) external payable;\n\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint256 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectSrcChainId(uint256 chainId);\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint256 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return transactionId The ID of the transaction that was sent.\n     * @return dbNonce The database nonce of the written entry for the transaction.\n     */\n    function interchainSend(\n        uint256 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (bytes32 transactionId, uint256 dbNonce);\n\n    function interchainSendEVM(\n        uint256 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (bytes32 transactionId, uint256 dbNonce);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     */\n    function interchainExecute(uint256 gasLimit, bytes calldata transaction) external payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the written entry for the proof.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint256 dbNonce);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction The InterchainTransaction struct to be checked.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param message              The message being sent.\n    function getInterchainFee(\n        uint256 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    error AppConfigLib__IncorrectVersion(uint8 version);\n\n    uint8 constant APP_CONFIG_V1 = 1;\n\n    /// @notice Encodes versioned app config into a bytes format.\n    /// @param version      The version of the app config.\n    /// @param appConfig    The app config to encode.\n    function encodeVersionedAppConfig(uint8 version, bytes memory appConfig) internal pure returns (bytes memory) {\n        return abi.encode(version, appConfig);\n    }\n\n    /// @notice Decodes versioned app config from a bytes format back into a version and app config.\n    /// @param data         The versioned app config data in bytes format.\n    /// @return version     The version of the app config.\n    /// @return appConfig   The app config as bytes.\n    function decodeVersionedAppConfig(bytes memory data)\n        internal\n        pure\n        returns (uint8 version, bytes memory appConfig)\n    {\n        (version, appConfig) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return encodeVersionedAppConfig(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal pure returns (AppConfigV1 memory) {\n        (uint8 version, bytes memory appConfig) = decodeVersionedAppConfig(data);\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(appConfig, (AppConfigV1));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    error OptionsLib__IncorrectVersion(uint8 version);\n\n    uint8 constant OPTIONS_V1 = 1;\n\n    /// @notice Encodes versioned options into a bytes format.\n    /// @param version      The version of the options.\n    /// @param options      The options to encode.\n    function encodeVersionedOptions(uint8 version, bytes memory options) internal pure returns (bytes memory) {\n        return abi.encode(version, options);\n    }\n\n    /// @notice Decodes versioned options from a bytes format back into a version and options.\n    /// @param data         The versioned options data in bytes format.\n    /// @return version     The version of the options.\n    /// @return options     The options as bytes.\n    function decodeVersionedOptions(bytes memory data) internal pure returns (uint8 version, bytes memory options) {\n        (version, options) = abi.decode(data, (uint8, bytes));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return encodeVersionedOptions(OPTIONS_V1, abi.encode(options));\n    }\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal pure returns (OptionsV1 memory) {\n        (uint8 version, bytes memory options) = decodeVersionedOptions(data);\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(options, (OptionsV1));\n    }\n}\n\n// contracts/InterchainApp.sol\n\ncontract InterchainApp is IInterchainApp {\n    using AppConfigLib for bytes;\n    // What properties should Interchain be pulling from InterchainApp?\n    // 1. Which modules to use, and how many are required?\n\n    IInterchainClientV1 public interchain;\n\n    address[] private sendingModules;\n    address[] private receivingModules;\n    address private executionService;\n\n    struct AppConfig {\n        // ChainID -\u003e Linked IApps\n        mapping(uint64 =\u003e address) linkedIApps;\n        // Sends message to be verified through all modules\n        address[] sendingModules;\n        // Accepts messages from these destination chain modules\n        address[] receivingModules;\n        AppConfigV1 bytesAppConfig;\n    }\n\n    AppConfig private localAppConfig;\n\n    // Set the application configuration\n    function setAppConfig(\n        uint64[] memory chainIDs,\n        address[] memory linkedIApps,\n        address[] memory _sendingModules,\n        address[] memory _receivingModules,\n        address _executionService,\n        uint256 _requiredResponses,\n        uint64 _optimisticTimePeriod\n    )\n        public\n    {\n        // TODO: Add access control or ownership checks\n        require(chainIDs.length == linkedIApps.length, \"ChainIDs and IApps length mismatch\");\n\n        for (uint256 i = 0; i \u003c chainIDs.length; i++) {\n            localAppConfig.linkedIApps[chainIDs[i]] = linkedIApps[i];\n        }\n\n        localAppConfig.bytesAppConfig =\n            AppConfigV1({requiredResponses: _requiredResponses, optimisticPeriod: _optimisticTimePeriod});\n\n        localAppConfig.sendingModules = _sendingModules;\n        localAppConfig.receivingModules = _receivingModules;\n        executionService = _executionService;\n    }\n\n    // Getters for the application configuration\n    function getLinkedIApp(uint64 chainID) external view returns (address) {\n        return localAppConfig.linkedIApps[chainID];\n    }\n\n    // TODO: Is a receiving module the same as a sending module?\n    function getSendingModules() external view returns (address[] memory) {\n        return localAppConfig.sendingModules;\n    }\n\n    function getReceivingModules() external view returns (address[] memory) {\n        return localAppConfig.receivingModules;\n    }\n\n    function getRequiredResponses() external view returns (uint256) {\n        return localAppConfig.bytesAppConfig.requiredResponses;\n    }\n\n    function getOptimisticTimePeriod() external view returns (uint256) {\n        return localAppConfig.bytesAppConfig.optimisticPeriod;\n    }\n\n    function getSendingModules(bytes32 receiver, uint256 dstChainId) external view returns (address[] memory) {\n        return sendingModules;\n    }\n\n    function getReceivingConfig() external view returns (bytes memory, address[] memory) {\n        return (AppConfigLib.encodeAppConfigV1(localAppConfig.bytesAppConfig), localAppConfig.receivingModules);\n    }\n\n    constructor(address _interchain, address[] memory _sendingModules, address[] memory _receivingModules) {\n        interchain = IInterchainClientV1(_interchain);\n        localAppConfig.sendingModules = _sendingModules;\n        localAppConfig.receivingModules = _receivingModules;\n    }\n\n    event AppMessageRecieve();\n    event AppMessageSent();\n\n    function send(bytes32 receiver, uint256 dstChainId, bytes calldata message) external payable {\n        bytes memory options = OptionsV1(200_000, 0).encodeOptionsV1();\n        // TODO: Currently, we forward all gas to Interchain, this may not be expected behavior, and the real abstract contract shouldn't do this\n        interchain.interchainSend{value: msg.value}(\n            dstChainId, receiver, executionService, localAppConfig.sendingModules, options, message\n        );\n        emit AppMessageSent();\n    }\n\n    // TODO: Auth checks based on incoming message\n    function appReceive(uint256 srcChainId, bytes32 sender, uint256 dbNonce, bytes calldata message) external payable {\n        emit AppMessageRecieve();\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"9171:1958:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;9171:1958:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"9171:1958:0:-:0;;;;;;;;","abiDefinition":[{"inputs":[{"internalType":"uint8","name":"version","type":"uint8"}],"name":"OptionsLib__IncorrectVersion","type":"error"}],"userDoc":{"kind":"user","methods":{},"notice":"A library for encoding and decoding Interchain options related to interchain messages.","version":1},"developerDoc":{"kind":"dev","methods":{},"title":"OptionsLib","version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"OptionsLib__IncorrectVersion\",\"type\":\"error\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"title\":\"OptionsLib\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"A library for encoding and decoding Interchain options related to interchain messages.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainApp.sol\":\"OptionsLib\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainApp.sol\":{\"keccak256\":\"0x97256ebb052f6f28fecf0beec3b1dfa66674bc1f309fa5ee1d848c8510a9efce\",\"urls\":[\"bzz-raw://4449ebe8a883f01fc9475e12203c0ba46d8546f96ac1296fa4eefe6a2b236127\",\"dweb:/ipfs/QmPW2zd3zqaAsMed1LSjVLafcE6zXNNiTwqEkHfbnRC69p\"]}},\"version\":1}"},"hashes":{}}}