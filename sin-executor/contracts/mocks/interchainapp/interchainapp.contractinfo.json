{"solidity/ExampleAppV1.sol:AbstractICApp":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/AbstractICAppEvents.sol\n\nabstract contract AbstractICAppEvents {\n    event InterchainClientAdded(address client);\n    event InterchainClientRemoved(address client);\n    event LatestClientSet(address client);\n}\n\n// contracts/events/InterchainAppV1Events.sol\n\nabstract contract InterchainAppV1Events {\n    event AppConfigV1Set(uint256 requiredResponses, uint256 optimisticPeriod);\n    event AppLinked(uint256 indexed chainId, bytes32 indexed remoteApp);\n    event ExecutionServiceSet(address executionService);\n    event TrustedModuleAdded(address module);\n    event TrustedModuleRemoved(address module);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    /// @notice Allows the Interchain Client to pass the message to the Interchain App.\n    /// @dev App is responsible for keeping track of interchain clients, and must verify the message sender.\n    /// @param srcChainId   Chain ID of the source chain, where the message was sent from.\n    /// @param sender       Sender address on the source chain, as a bytes32 value.\n    /// @param dbNonce      The Interchain DB nonce of the batch containing the message entry.\n    /// @param entryIndex   The index of the message entry within the batch.\n    /// @param message      The message being sent.\n    function appReceive(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /// @notice Returns the verification configuration of the Interchain App.\n    /// @dev This configuration is used by the Interchain Client to verify that message has been confirmed\n    /// by the Interchain Modules on the destination chain.\n    /// Note: V1 version of AppConfig includes the required responses count, and optimistic period after which\n    /// the message is considered confirmed by the module. Following versions may include additional fields.\n    /// @return appConfig    The versioned configuration of the Interchain App, encoded as bytes.\n    /// @return modules      The list of Interchain Modules that app is trusting to confirm the messages.\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/Math.sol\n\nlibrary MathLib {\n    /// @notice Rounds up to the nearest multiple of 32.\n    /// Note: Returns zero on overflows instead of reverting. This is fine for practical\n    /// use cases, as this is used for determining the size of the payload in memory.\n    function roundUpToWord(uint256 x) internal pure returns (uint256) {\n        unchecked {\n            return (x + 31) \u0026 ~uint256(31);\n        }\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/VersionedPayload.sol\n\n// solhint-disable no-inline-assembly\n// solhint-disable ordering\nlibrary VersionedPayloadLib {\n    /// @notice Amount of bytes reserved for the version (uint16) in the versioned payload\n    uint256 internal constant VERSION_LENGTH = 2;\n\n    error VersionedPayload__TooShort(bytes versionedPayload);\n    error VersionedPayload__PrecompileFailed();\n\n    /// @notice Encodes the versioned payload into a single bytes array.\n    /// @param version  The payload's version.\n    /// @param payload  The payload to encode.\n    function encodeVersionedPayload(uint16 version, bytes memory payload) internal pure returns (bytes memory) {\n        return abi.encodePacked(version, payload);\n    }\n\n    /// @notice Extracts the version from the versioned payload (calldata reference).\n    /// @param versionedPayload     The versioned payload (calldata reference).\n    function getVersion(bytes calldata versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            version := shr(240, calldataload(versionedPayload.offset))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (calldata reference).\n    /// @dev The extracted payload is also returned as a calldata reference.\n    /// @param versionedPayload     The versioned payload.\n    function getPayload(bytes calldata versionedPayload) internal pure returns (bytes calldata) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        return versionedPayload[VERSION_LENGTH:];\n    }\n\n    /// @notice Extracts the version from the versioned payload (memory reference).\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getVersionFromMemory(bytes memory versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            // We add 0x20 to skip the length of the bytes array.\n            version := shr(240, mload(add(versionedPayload, 0x20)))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (memory reference).\n    /// @dev The extracted payload is copied into a new memory location. Use `getPayload` when possible\n    /// to avoid extra memory allocation.\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getPayloadFromMemory(bytes memory versionedPayload) internal view returns (bytes memory payload) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        // Figure how many bytes to copy and allocate the memory for the extracted payload.\n        uint256 toCopy;\n        unchecked {\n            toCopy = versionedPayload.length - VERSION_LENGTH;\n        }\n        payload = new bytes(toCopy);\n        // Use identity precompile (0x04) to copy the payload. Unlike MCOPY, this is available on all EVM chains.\n        bool res;\n        assembly {\n            // We add 0x20 to skip the length of the bytes array.\n            // We add 0x02 to skip the 2 bytes reserved for the version.\n            // Copy the payload to the previously allocated memory.\n            res := staticcall(gas(), 0x04, add(versionedPayload, 0x22), toCopy, add(payload, 0x20), toCopy)\n        }\n        if (!res) {\n            revert VersionedPayload__PrecompileFailed();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/IAccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n\n// node_modules/@openzeppelin/contracts/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance \u003c amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance \u003c value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 \u0026\u0026 target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SafeCast.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value \u003e type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value \u003e type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value \u003e type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value \u003e type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value \u003e type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value \u003e type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value \u003e type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value \u003e type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value \u003e type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value \u003e type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value \u003e type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value \u003e type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value \u003e type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value \u003e type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value \u003e type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value \u003e type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value \u003e type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value \u003e type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value \u003e type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value \u003e type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value \u003e type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value \u003e type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value \u003e type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value \u003e type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value \u003e type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value \u003e type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value \u003e type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value \u003e type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value \u003e type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value \u003e type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value \u003e type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value \u003c 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value \u003e uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal view returns (AppConfigV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (AppConfigV1));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal view returns (OptionsV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (OptionsV1));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(OPTIONS_V1, abi.encode(options));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/IAccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/IAccessControlEnumerable.sol)\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n// contracts/interfaces/IInterchainAppV1.sol\n\ninterface IInterchainAppV1 is IInterchainApp {\n    error InterchainApp__AppZeroAddress();\n    error InterchainApp__InvalidAppConfig(uint256 requiredResponses, uint256 optimisticPeriod);\n    error InterchainApp__ModuleAlreadyAdded(address module);\n    error InterchainApp__ModuleNotAdded(address module);\n    error InterchainApp__ModuleZeroAddress();\n    error InterchainApp__NotEVMLinkedApp(bytes32 linkedApp);\n\n    /// @notice Allows the owner to add the interchain client to the allowed clients set,\n    /// and optionally set the latest client to this one.\n    /// Note: only the allowed clients can send messages to this app.\n    /// Note: the latest client is used for sending messages from this app.\n    /// @param client       The address of the interchain client to add.\n    /// @param updateLatest Whether to set the latest client to this one.\n    function addInterchainClient(address client, bool updateLatest) external;\n\n    /// @notice Allows the owner to remove the interchain client from the allowed clients set.\n    /// If the client is the latest client, the latest client is set to the zero address.\n    /// @param client       The address of the interchain client to remove.\n    function removeInterchainClient(address client) external;\n\n    /// @notice Allows the owner to set the address of the latest interchain client.\n    /// @dev The new latest client must be an allowed client or zero address.\n    /// Setting the client to zero address effectively pauses the app ability to send messages,\n    /// while allowing to receive them.\n    /// @param client       The address of the latest interchain client.\n    function setLatestInterchainClient(address client) external;\n\n    /// @notice Allows the owner to link the remote app for the given chain ID.\n    /// - This address will be used as the receiver for the messages sent from this chain.\n    /// - This address will be the only trusted sender for the messages sent to this chain.\n    /// @param chainId      The remote chain ID.\n    /// @param remoteApp    The address of the remote app to link.\n    function linkRemoteApp(uint64 chainId, bytes32 remoteApp) external;\n\n    /// @notice Thin wrapper for `linkRemoteApp` to accept EVM address as a parameter.\n    function linkRemoteAppEVM(uint64 chainId, address remoteApp) external;\n\n    /// @notice Allows the owner to add the module to the trusted modules set.\n    /// - This set of modules will be used to verify both sent and received messages.\n    function addTrustedModule(address module) external;\n\n    /// @notice Allows the owner to remove the module from the trusted modules set.\n    function removeTrustedModule(address module) external;\n\n    /// @notice Allows the owner to set the app config for the current app. App config includes:\n    /// - requiredResponses: the number of module responses required for accepting the message\n    /// - optimisticPeriod: the minimum time after which the module responses are considered final\n    function setAppConfigV1(AppConfigV1 memory appConfig) external;\n\n    /// @notice Allows the owner to set the address of the Execution Service.\n    /// This address will be used to request execution of the messages sent from this chain,\n    /// by supplying the Service's execution fee.\n    function setExecutionService(address executionService) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Returns the app config for the current app: requiredResponses and optimisticPeriod.\n    function getAppConfigV1() external view returns (AppConfigV1 memory);\n\n    /// @notice Returns the address of the Execution Service used by this app for sending messages.\n    function getExecutionService() external view returns (address);\n\n    /// @notice Returns the list of Interchain Clients allowed to send messages to this app.\n    function getInterchainClients() external view returns (address[] memory);\n\n    /// @notice Returns the address of the latest interchain client.\n    /// This address is used for sending messages from this app.\n    function getLatestInterchainClient() external view returns (address);\n\n    /// @notice Returns the linked app address (as bytes32) for the given chain ID.\n    function getLinkedApp(uint64 chainId) external view returns (bytes32);\n\n    /// @notice Thin wrapper for `getLinkedApp` to return the linked app address as EVM address.\n    /// @dev Will revert if the linked app address is not an EVM address.\n    function getLinkedAppEVM(uint64 chainId) external view returns (address);\n\n    /// @notice Returns the list of Interchain Modules trusted by this app.\n    /// This set of modules will be used to verify both sent and received messages.\n    function getModules() external view returns (address[] memory);\n}\n\n// contracts/libs/InterchainTransaction.sol\n\ntype ICTxHeader is uint256;\n\nstruct InterchainTransaction {\n    uint64 srcChainId;\n    uint64 dstChainId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcSender;\n    bytes32 dstReceiver;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    using MathLib for uint256;\n    using VersionedPayloadLib for bytes;\n\n    function constructLocalTransaction(\n        address srcSender,\n        uint64 dstChainId,\n        bytes32 dstReceiver,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: SafeCast.toUint64(block.chainid),\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            encodeTxHeader(transaction.srcChainId, transaction.dstChainId, transaction.dbNonce, transaction.entryIndex),\n            transaction.srcSender,\n            transaction.dstReceiver,\n            transaction.options,\n            transaction.message\n        );\n    }\n\n    function decodeTransaction(bytes calldata transaction) internal pure returns (InterchainTransaction memory icTx) {\n        ICTxHeader header;\n        (header, icTx.srcSender, icTx.dstReceiver, icTx.options, icTx.message) =\n            abi.decode(transaction, (ICTxHeader, bytes32, bytes32, bytes, bytes));\n        (icTx.srcChainId, icTx.dstChainId, icTx.dbNonce, icTx.entryIndex) = decodeTxHeader(header);\n    }\n\n    function payloadSize(uint256 optionsLen, uint256 messageLen) internal pure returns (uint256) {\n        // 2 bytes are reserved for the transaction version\n        // + 5 fields * 32 bytes (3 values for static, 2 offsets for dynamic) + 2 * 32 bytes (lengths for dynamic) = 226\n        // (srcChainId, dstChainId, dbNonce, entryIndex) are merged into a single 32 bytes field\n        // Both options and message are dynamic fields, which are padded up to 32 bytes\n        return 226 + optionsLen.roundUpToWord() + messageLen.roundUpToWord();\n    }\n\n    function encodeTxHeader(\n        uint64 srcChainId,\n        uint64 dstChainId,\n        uint64 dbNonce,\n        uint64 entryIndex\n    )\n        internal\n        pure\n        returns (ICTxHeader)\n    {\n        return ICTxHeader.wrap(\n            (uint256(srcChainId) \u003c\u003c 192) | (uint256(dstChainId) \u003c\u003c 128) | (uint256(dbNonce) \u003c\u003c 64) | uint256(entryIndex)\n        );\n    }\n\n    function decodeTxHeader(ICTxHeader header)\n        internal\n        pure\n        returns (uint64 srcChainId, uint64 dstChainId, uint64 dbNonce, uint64 entryIndex)\n    {\n        srcChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 192);\n        dstChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 128);\n        dbNonce = uint64(ICTxHeader.unwrap(header) \u003e\u003e 64);\n        entryIndex = uint64(ICTxHeader.unwrap(header));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/AccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account =\u003e bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role =\u003e RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint64 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__InvalidTransactionVersion(uint16 version);\n    error InterchainClientV1__NoLinkedClient(uint64 chainId);\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint64 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint64 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint64 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint64 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param messageLen           The length of the message being sent.\n    function getInterchainFee(\n        uint64 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        uint256 messageLen\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint64 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint64 chainId) external view returns (address);\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/AccessControlEnumerable.sol)\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 role =\u003e EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {AccessControl-_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool granted = super._grantRole(role, account);\n        if (granted) {\n            _roleMembers[role].add(account);\n        }\n        return granted;\n    }\n\n    /**\n     * @dev Overload {AccessControl-_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool revoked = super._revokeRole(role, account);\n        if (revoked) {\n            _roleMembers[role].remove(account);\n        }\n        return revoked;\n    }\n}\n\n// contracts/apps/AbstractICApp.sol\n\nabstract contract AbstractICApp is AbstractICAppEvents, IInterchainApp {\n    using TypeCasts for address;\n\n    error InterchainApp__AlreadyLatestClient(address client);\n    error InterchainApp__BalanceTooLow(uint256 actual, uint256 required);\n    error InterchainApp__ClientAlreadyAdded(address client);\n    error InterchainApp__InterchainClientZeroAddress();\n    error InterchainApp__NotInterchainClient(address account);\n    error InterchainApp__ReceiverNotSet(uint64 chainId);\n    error InterchainApp__SameChainId(uint64 chainId);\n    error InterchainApp__SenderNotAllowed(uint64 srcChainId, bytes32 sender);\n\n    /// @inheritdoc IInterchainApp\n    function appReceive(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        if (!_isInterchainClient(msg.sender)) {\n            revert InterchainApp__NotInterchainClient(msg.sender);\n        }\n        if (srcChainId == block.chainid) {\n            revert InterchainApp__SameChainId(srcChainId);\n        }\n        if (!_isAllowedSender(srcChainId, sender)) {\n            revert InterchainApp__SenderNotAllowed(srcChainId, sender);\n        }\n        _receiveMessage(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n\n    /// @inheritdoc IInterchainApp\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules) {\n        appConfig = _getAppConfig();\n        modules = _getModules();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Performs necessary checks and adds an Interchain Client.\n    /// Optionally sets the latest client to this one.\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _addClient(address client, bool updateLatest) internal {\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (_isInterchainClient(client)) {\n            revert InterchainApp__ClientAlreadyAdded(client);\n        }\n        _toggleClientState(client, true);\n        emit InterchainClientAdded(client);\n        if (updateLatest) {\n            _setLatestClient(client);\n        }\n    }\n\n    /// @dev Performs necessary checks and removes an Interchain Client. If this client is the latest one,\n    /// the latest client is set to zero address (effectively pausing the app ability to send messages).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _removeClient(address client) internal {\n        if (!_isInterchainClient(client)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        _toggleClientState(client, false);\n        emit InterchainClientRemoved(client);\n        if (client == _getLatestClient()) {\n            _setLatestClient(address(0));\n        }\n    }\n\n    /// @dev Sets the latest Interchain Client to one of the allowed clients. Setting the client to zero address\n    /// is allowed and effectively pauses the app ability to send messages (but still allows to receive them).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _setLatestClient(address client) internal {\n        // New latest client must be an allowed client or zero address.\n        if (!_isInterchainClient(client) \u0026\u0026 client != address(0)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        if (client == _getLatestClient()) {\n            revert InterchainApp__AlreadyLatestClient(client);\n        }\n        _storeLatestClient(client);\n        emit LatestClientSet(client);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal virtual;\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal virtual;\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to accept EVM address as a parameter.\n    function _sendInterchainMessageEVM(\n        uint64 dstChainId,\n        address receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _sendInterchainMessage(dstChainId, receiver.addressToBytes32(), messageFee, options, message);\n    }\n\n    /// @dev Performs necessary checks and sends an interchain message.\n    function _sendInterchainMessage(\n        uint64 dstChainId,\n        bytes32 receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (dstChainId == block.chainid) {\n            revert InterchainApp__SameChainId(dstChainId);\n        }\n        if (receiver == 0) {\n            revert InterchainApp__ReceiverNotSet(dstChainId);\n        }\n        if (address(this).balance \u003c messageFee) {\n            revert InterchainApp__BalanceTooLow({actual: address(this).balance, required: messageFee});\n        }\n        return IInterchainClientV1(client).interchainSend{value: messageFee}(\n            dstChainId, receiver, _getExecutionService(), _getModules(), options, message\n        );\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        virtual;\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee for sending an Interchain message.\n    function _getInterchainFee(\n        uint64 dstChainId,\n        bytes memory options,\n        uint256 messageLen\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        return IInterchainClientV1(client).getInterchainFee(\n            dstChainId, _getExecutionService(), _getModules(), options, messageLen\n        );\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view virtual returns (bytes memory);\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view virtual returns (address);\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view virtual returns (address);\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view virtual returns (address[] memory);\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint64 srcChainId, bytes32 sender) internal view virtual returns (bool);\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view virtual returns (bool);\n}\n\n// contracts/apps/ICAppV1.sol\n\nabstract contract ICAppV1 is AbstractICApp, AccessControlEnumerable, InterchainAppV1Events, IInterchainAppV1 {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Role to manage the Interchain setup of the app.\n    bytes32 public constant IC_GOVERNOR_ROLE = keccak256(\"IC_GOVERNOR_ROLE\");\n\n    /// @dev Address of the latest Interchain Client, used for sending messages.\n    address private _latestClient;\n\n    /// @dev Required responses and optimistic period for the module responses.\n    AppConfigV1 private _appConfigV1;\n    /// @dev Address of the linked app deployed on the remote chain.\n    mapping(uint64 chainId =\u003e bytes32 remoteApp) private _linkedApp;\n    /// @dev Interchain Clients allowed to send messages to this app.\n    EnumerableSet.AddressSet private _interchainClients;\n    /// @dev Trusted Interchain modules.\n    EnumerableSet.AddressSet private _trustedModules;\n    /// @dev Execution Service to use for sending messages.\n    address private _executionService;\n\n    constructor(address admin) {\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addInterchainClient(address client, bool updateLatest) external onlyRole(IC_GOVERNOR_ROLE) {\n        _addClient(client, updateLatest);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _removeClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setLatestInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _setLatestClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteApp(uint64 chainId, bytes32 remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteAppEVM(uint64 chainId, address remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp.addressToBytes32());\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (module == address(0)) {\n            revert InterchainApp__ModuleZeroAddress();\n        }\n        bool added = _trustedModules.add(module);\n        if (!added) {\n            revert InterchainApp__ModuleAlreadyAdded(module);\n        }\n        emit TrustedModuleAdded(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        bool removed = _trustedModules.remove(module);\n        if (!removed) {\n            revert InterchainApp__ModuleNotAdded(module);\n        }\n        emit TrustedModuleRemoved(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setAppConfigV1(AppConfigV1 memory appConfig) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (appConfig.requiredResponses == 0 || appConfig.optimisticPeriod == 0) {\n            revert InterchainApp__InvalidAppConfig(appConfig.requiredResponses, appConfig.optimisticPeriod);\n        }\n        _appConfigV1 = appConfig;\n        emit AppConfigV1Set(appConfig.requiredResponses, appConfig.optimisticPeriod);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setExecutionService(address executionService) external onlyRole(IC_GOVERNOR_ROLE) {\n        _executionService = executionService;\n        emit ExecutionServiceSet(executionService);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainAppV1\n    function getAppConfigV1() external view returns (AppConfigV1 memory) {\n        return _appConfigV1;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getExecutionService() external view returns (address) {\n        return _executionService;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getInterchainClients() external view returns (address[] memory) {\n        return _interchainClients.values();\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLatestInterchainClient() external view returns (address) {\n        return _latestClient;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedApp(uint64 chainId) external view returns (bytes32) {\n        return _linkedApp[chainId];\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedAppEVM(uint64 chainId) external view returns (address linkedAppEVM) {\n        bytes32 linkedApp = _linkedApp[chainId];\n        linkedAppEVM = linkedApp.bytes32ToAddress();\n        if (linkedAppEVM.addressToBytes32() != linkedApp) {\n            revert InterchainApp__NotEVMLinkedApp(linkedApp);\n        }\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getModules() external view returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Links the remote app to the current app.\n    /// Will revert if the chainId is the same as the chainId of the local app.\n    /// Note: Should be guarded with permissions check.\n    function _linkRemoteApp(uint64 chainId, bytes32 remoteApp) internal {\n        if (chainId == block.chainid) {\n            revert InterchainApp__SameChainId(chainId);\n        }\n        if (remoteApp == 0) {\n            revert InterchainApp__AppZeroAddress();\n        }\n        _linkedApp[chainId] = remoteApp;\n        emit AppLinked(chainId, remoteApp);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal override {\n        _latestClient = client;\n    }\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal override {\n        if (allowed) {\n            _interchainClients.add(client);\n        } else {\n            _interchainClients.remove(client);\n        }\n    }\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to send the message to the linked app.\n    function _sendToLinkedApp(\n        uint64 dstChainId,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _sendInterchainMessage(dstChainId, _linkedApp[dstChainId], messageFee, encodedOptions, message);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee to send a message to the linked app on the remote chain.\n    function _getMessageFee(\n        uint64 dstChainId,\n        OptionsV1 memory options,\n        uint256 messageLen\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _getInterchainFee(dstChainId, encodedOptions, messageLen);\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view override returns (bytes memory) {\n        return _appConfigV1.encodeAppConfigV1();\n    }\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view override returns (address) {\n        return _executionService;\n    }\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view override returns (address) {\n        return _latestClient;\n    }\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view override returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint64 srcChainId, bytes32 sender) internal view override returns (bool) {\n        return _linkedApp[srcChainId] == sender;\n    }\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view override returns (bool) {\n        return _interchainClients.contains(caller);\n    }\n}\n\n// contracts/apps/examples/ExampleAppV1.sol\n\ncontract ExampleAppV1 is ICAppV1 {\n    event MessageReceived(uint64 srcChainId, bytes32 sender, uint64 dbNonce, uint64 entryIndex, bytes message);\n    event MessageSent(uint64 dstChainId, uint64 dbNonce, uint64 entryIndex, bytes32 transactionId);\n\n    constructor(address admin) ICAppV1(admin) {\n        _grantRole(IC_GOVERNOR_ROLE, admin);\n    }\n\n    /// @notice Allows the Admin to withdraw the native asset from the contract.\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        Address.sendValue(payable(msg.sender), address(this).balance);\n    }\n\n    /// @notice Sends a basic message to the destination chain.\n    function sendMessage(\n        uint64 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        InterchainTxDescriptor memory desc = _sendToLinkedApp({\n            dstChainId: dstChainId,\n            messageFee: msg.value,\n            options: OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}),\n            message: message\n        });\n        emit MessageSent(dstChainId, desc.dbNonce, desc.entryIndex, desc.transactionId);\n    }\n\n    /// @notice Returns the fee required to send a message using `sendMessage`.\n    function getMessageFee(\n        uint64 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes memory message\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _getMessageFee(dstChainId, OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}), message.length);\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        override\n    {\n        emit MessageReceived(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"address","name":"client","type":"address"}],"name":"InterchainApp__AlreadyLatestClient","type":"error"},{"inputs":[{"internalType":"uint256","name":"actual","type":"uint256"},{"internalType":"uint256","name":"required","type":"uint256"}],"name":"InterchainApp__BalanceTooLow","type":"error"},{"inputs":[{"internalType":"address","name":"client","type":"address"}],"name":"InterchainApp__ClientAlreadyAdded","type":"error"},{"inputs":[],"name":"InterchainApp__InterchainClientZeroAddress","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"InterchainApp__NotInterchainClient","type":"error"},{"inputs":[{"internalType":"uint64","name":"chainId","type":"uint64"}],"name":"InterchainApp__ReceiverNotSet","type":"error"},{"inputs":[{"internalType":"uint64","name":"chainId","type":"uint64"}],"name":"InterchainApp__SameChainId","type":"error"},{"inputs":[{"internalType":"uint64","name":"srcChainId","type":"uint64"},{"internalType":"bytes32","name":"sender","type":"bytes32"}],"name":"InterchainApp__SenderNotAllowed","type":"error"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"client","type":"address"}],"name":"InterchainClientAdded","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"client","type":"address"}],"name":"InterchainClientRemoved","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"client","type":"address"}],"name":"LatestClientSet","type":"event"},{"inputs":[{"internalType":"uint64","name":"srcChainId","type":"uint64"},{"internalType":"bytes32","name":"sender","type":"bytes32"},{"internalType":"uint64","name":"dbNonce","type":"uint64"},{"internalType":"uint64","name":"entryIndex","type":"uint64"},{"internalType":"bytes","name":"message","type":"bytes"}],"name":"appReceive","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"getReceivingConfig","outputs":[{"internalType":"bytes","name":"appConfig","type":"bytes"},{"internalType":"address[]","name":"modules","type":"address[]"}],"stateMutability":"view","type":"function"}],"userDoc":{"kind":"user","methods":{"appReceive(uint64,bytes32,uint64,uint64,bytes)":{"notice":"Allows the Interchain Client to pass the message to the Interchain App."},"getReceivingConfig()":{"notice":"Returns the verification configuration of the Interchain App."}},"version":1},"developerDoc":{"kind":"dev","methods":{"appReceive(uint64,bytes32,uint64,uint64,bytes)":{"details":"App is responsible for keeping track of interchain clients, and must verify the message sender.","params":{"dbNonce":"The Interchain DB nonce of the batch containing the message entry.","entryIndex":"The index of the message entry within the batch.","message":"The message being sent.","sender":"Sender address on the source chain, as a bytes32 value.","srcChainId":"Chain ID of the source chain, where the message was sent from."}},"getReceivingConfig()":{"details":"This configuration is used by the Interchain Client to verify that message has been confirmed by the Interchain Modules on the destination chain. Note: V1 version of AppConfig includes the required responses count, and optimistic period after which the message is considered confirmed by the module. Following versions may include additional fields.","returns":{"appConfig":"   The versioned configuration of the Interchain App, encoded as bytes.","modules":"     The list of Interchain Modules that app is trusting to confirm the messages."}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"}],\"name\":\"InterchainApp__AlreadyLatestClient\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"required\",\"type\":\"uint256\"}],\"name\":\"InterchainApp__BalanceTooLow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"}],\"name\":\"InterchainApp__ClientAlreadyAdded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InterchainApp__InterchainClientZeroAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"InterchainApp__NotInterchainClient\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"}],\"name\":\"InterchainApp__ReceiverNotSet\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"}],\"name\":\"InterchainApp__SameChainId\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"srcChainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"}],\"name\":\"InterchainApp__SenderNotAllowed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"}],\"name\":\"InterchainClientAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"}],\"name\":\"InterchainClientRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"}],\"name\":\"LatestClientSet\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"srcChainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"appReceive\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReceivingConfig\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"appConfig\",\"type\":\"bytes\"},{\"internalType\":\"address[]\",\"name\":\"modules\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"appReceive(uint64,bytes32,uint64,uint64,bytes)\":{\"details\":\"App is responsible for keeping track of interchain clients, and must verify the message sender.\",\"params\":{\"dbNonce\":\"The Interchain DB nonce of the batch containing the message entry.\",\"entryIndex\":\"The index of the message entry within the batch.\",\"message\":\"The message being sent.\",\"sender\":\"Sender address on the source chain, as a bytes32 value.\",\"srcChainId\":\"Chain ID of the source chain, where the message was sent from.\"}},\"getReceivingConfig()\":{\"details\":\"This configuration is used by the Interchain Client to verify that message has been confirmed by the Interchain Modules on the destination chain. Note: V1 version of AppConfig includes the required responses count, and optimistic period after which the message is considered confirmed by the module. Following versions may include additional fields.\",\"returns\":{\"appConfig\":\"   The versioned configuration of the Interchain App, encoded as bytes.\",\"modules\":\"     The list of Interchain Modules that app is trusting to confirm the messages.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"appReceive(uint64,bytes32,uint64,uint64,bytes)\":{\"notice\":\"Allows the Interchain Client to pass the message to the Interchain App.\"},\"getReceivingConfig()\":{\"notice\":\"Returns the verification configuration of the Interchain App.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/ExampleAppV1.sol\":\"AbstractICApp\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/ExampleAppV1.sol\":{\"keccak256\":\"0xb1e9550aef785a0afc4e03fc843839919987ba4f906f09992c6788979c3c0396\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://0ede697223dfa3a2e23501efc1ed5926d5ff6458ee7b9ba833e0587162166c79\",\"dweb:/ipfs/QmUzgopL2ptWG5DYNdGAcoErPnBC4KCoRp8C61dkHHRaA6\"]}},\"version\":1}"},"hashes":{"appReceive(uint64,bytes32,uint64,uint64,bytes)":"6e9fd609","getReceivingConfig()":"287bc057"}},"solidity/ExampleAppV1.sol:AbstractICAppEvents":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/AbstractICAppEvents.sol\n\nabstract contract AbstractICAppEvents {\n    event InterchainClientAdded(address client);\n    event InterchainClientRemoved(address client);\n    event LatestClientSet(address client);\n}\n\n// contracts/events/InterchainAppV1Events.sol\n\nabstract contract InterchainAppV1Events {\n    event AppConfigV1Set(uint256 requiredResponses, uint256 optimisticPeriod);\n    event AppLinked(uint256 indexed chainId, bytes32 indexed remoteApp);\n    event ExecutionServiceSet(address executionService);\n    event TrustedModuleAdded(address module);\n    event TrustedModuleRemoved(address module);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    /// @notice Allows the Interchain Client to pass the message to the Interchain App.\n    /// @dev App is responsible for keeping track of interchain clients, and must verify the message sender.\n    /// @param srcChainId   Chain ID of the source chain, where the message was sent from.\n    /// @param sender       Sender address on the source chain, as a bytes32 value.\n    /// @param dbNonce      The Interchain DB nonce of the batch containing the message entry.\n    /// @param entryIndex   The index of the message entry within the batch.\n    /// @param message      The message being sent.\n    function appReceive(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /// @notice Returns the verification configuration of the Interchain App.\n    /// @dev This configuration is used by the Interchain Client to verify that message has been confirmed\n    /// by the Interchain Modules on the destination chain.\n    /// Note: V1 version of AppConfig includes the required responses count, and optimistic period after which\n    /// the message is considered confirmed by the module. Following versions may include additional fields.\n    /// @return appConfig    The versioned configuration of the Interchain App, encoded as bytes.\n    /// @return modules      The list of Interchain Modules that app is trusting to confirm the messages.\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/Math.sol\n\nlibrary MathLib {\n    /// @notice Rounds up to the nearest multiple of 32.\n    /// Note: Returns zero on overflows instead of reverting. This is fine for practical\n    /// use cases, as this is used for determining the size of the payload in memory.\n    function roundUpToWord(uint256 x) internal pure returns (uint256) {\n        unchecked {\n            return (x + 31) \u0026 ~uint256(31);\n        }\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/VersionedPayload.sol\n\n// solhint-disable no-inline-assembly\n// solhint-disable ordering\nlibrary VersionedPayloadLib {\n    /// @notice Amount of bytes reserved for the version (uint16) in the versioned payload\n    uint256 internal constant VERSION_LENGTH = 2;\n\n    error VersionedPayload__TooShort(bytes versionedPayload);\n    error VersionedPayload__PrecompileFailed();\n\n    /// @notice Encodes the versioned payload into a single bytes array.\n    /// @param version  The payload's version.\n    /// @param payload  The payload to encode.\n    function encodeVersionedPayload(uint16 version, bytes memory payload) internal pure returns (bytes memory) {\n        return abi.encodePacked(version, payload);\n    }\n\n    /// @notice Extracts the version from the versioned payload (calldata reference).\n    /// @param versionedPayload     The versioned payload (calldata reference).\n    function getVersion(bytes calldata versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            version := shr(240, calldataload(versionedPayload.offset))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (calldata reference).\n    /// @dev The extracted payload is also returned as a calldata reference.\n    /// @param versionedPayload     The versioned payload.\n    function getPayload(bytes calldata versionedPayload) internal pure returns (bytes calldata) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        return versionedPayload[VERSION_LENGTH:];\n    }\n\n    /// @notice Extracts the version from the versioned payload (memory reference).\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getVersionFromMemory(bytes memory versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            // We add 0x20 to skip the length of the bytes array.\n            version := shr(240, mload(add(versionedPayload, 0x20)))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (memory reference).\n    /// @dev The extracted payload is copied into a new memory location. Use `getPayload` when possible\n    /// to avoid extra memory allocation.\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getPayloadFromMemory(bytes memory versionedPayload) internal view returns (bytes memory payload) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        // Figure how many bytes to copy and allocate the memory for the extracted payload.\n        uint256 toCopy;\n        unchecked {\n            toCopy = versionedPayload.length - VERSION_LENGTH;\n        }\n        payload = new bytes(toCopy);\n        // Use identity precompile (0x04) to copy the payload. Unlike MCOPY, this is available on all EVM chains.\n        bool res;\n        assembly {\n            // We add 0x20 to skip the length of the bytes array.\n            // We add 0x02 to skip the 2 bytes reserved for the version.\n            // Copy the payload to the previously allocated memory.\n            res := staticcall(gas(), 0x04, add(versionedPayload, 0x22), toCopy, add(payload, 0x20), toCopy)\n        }\n        if (!res) {\n            revert VersionedPayload__PrecompileFailed();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/IAccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n\n// node_modules/@openzeppelin/contracts/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance \u003c amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance \u003c value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 \u0026\u0026 target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SafeCast.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value \u003e type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value \u003e type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value \u003e type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value \u003e type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value \u003e type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value \u003e type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value \u003e type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value \u003e type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value \u003e type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value \u003e type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value \u003e type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value \u003e type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value \u003e type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value \u003e type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value \u003e type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value \u003e type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value \u003e type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value \u003e type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value \u003e type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value \u003e type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value \u003e type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value \u003e type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value \u003e type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value \u003e type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value \u003e type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value \u003e type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value \u003e type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value \u003e type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value \u003e type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value \u003e type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value \u003e type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value \u003c 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value \u003e uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal view returns (AppConfigV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (AppConfigV1));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal view returns (OptionsV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (OptionsV1));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(OPTIONS_V1, abi.encode(options));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/IAccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/IAccessControlEnumerable.sol)\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n// contracts/interfaces/IInterchainAppV1.sol\n\ninterface IInterchainAppV1 is IInterchainApp {\n    error InterchainApp__AppZeroAddress();\n    error InterchainApp__InvalidAppConfig(uint256 requiredResponses, uint256 optimisticPeriod);\n    error InterchainApp__ModuleAlreadyAdded(address module);\n    error InterchainApp__ModuleNotAdded(address module);\n    error InterchainApp__ModuleZeroAddress();\n    error InterchainApp__NotEVMLinkedApp(bytes32 linkedApp);\n\n    /// @notice Allows the owner to add the interchain client to the allowed clients set,\n    /// and optionally set the latest client to this one.\n    /// Note: only the allowed clients can send messages to this app.\n    /// Note: the latest client is used for sending messages from this app.\n    /// @param client       The address of the interchain client to add.\n    /// @param updateLatest Whether to set the latest client to this one.\n    function addInterchainClient(address client, bool updateLatest) external;\n\n    /// @notice Allows the owner to remove the interchain client from the allowed clients set.\n    /// If the client is the latest client, the latest client is set to the zero address.\n    /// @param client       The address of the interchain client to remove.\n    function removeInterchainClient(address client) external;\n\n    /// @notice Allows the owner to set the address of the latest interchain client.\n    /// @dev The new latest client must be an allowed client or zero address.\n    /// Setting the client to zero address effectively pauses the app ability to send messages,\n    /// while allowing to receive them.\n    /// @param client       The address of the latest interchain client.\n    function setLatestInterchainClient(address client) external;\n\n    /// @notice Allows the owner to link the remote app for the given chain ID.\n    /// - This address will be used as the receiver for the messages sent from this chain.\n    /// - This address will be the only trusted sender for the messages sent to this chain.\n    /// @param chainId      The remote chain ID.\n    /// @param remoteApp    The address of the remote app to link.\n    function linkRemoteApp(uint64 chainId, bytes32 remoteApp) external;\n\n    /// @notice Thin wrapper for `linkRemoteApp` to accept EVM address as a parameter.\n    function linkRemoteAppEVM(uint64 chainId, address remoteApp) external;\n\n    /// @notice Allows the owner to add the module to the trusted modules set.\n    /// - This set of modules will be used to verify both sent and received messages.\n    function addTrustedModule(address module) external;\n\n    /// @notice Allows the owner to remove the module from the trusted modules set.\n    function removeTrustedModule(address module) external;\n\n    /// @notice Allows the owner to set the app config for the current app. App config includes:\n    /// - requiredResponses: the number of module responses required for accepting the message\n    /// - optimisticPeriod: the minimum time after which the module responses are considered final\n    function setAppConfigV1(AppConfigV1 memory appConfig) external;\n\n    /// @notice Allows the owner to set the address of the Execution Service.\n    /// This address will be used to request execution of the messages sent from this chain,\n    /// by supplying the Service's execution fee.\n    function setExecutionService(address executionService) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Returns the app config for the current app: requiredResponses and optimisticPeriod.\n    function getAppConfigV1() external view returns (AppConfigV1 memory);\n\n    /// @notice Returns the address of the Execution Service used by this app for sending messages.\n    function getExecutionService() external view returns (address);\n\n    /// @notice Returns the list of Interchain Clients allowed to send messages to this app.\n    function getInterchainClients() external view returns (address[] memory);\n\n    /// @notice Returns the address of the latest interchain client.\n    /// This address is used for sending messages from this app.\n    function getLatestInterchainClient() external view returns (address);\n\n    /// @notice Returns the linked app address (as bytes32) for the given chain ID.\n    function getLinkedApp(uint64 chainId) external view returns (bytes32);\n\n    /// @notice Thin wrapper for `getLinkedApp` to return the linked app address as EVM address.\n    /// @dev Will revert if the linked app address is not an EVM address.\n    function getLinkedAppEVM(uint64 chainId) external view returns (address);\n\n    /// @notice Returns the list of Interchain Modules trusted by this app.\n    /// This set of modules will be used to verify both sent and received messages.\n    function getModules() external view returns (address[] memory);\n}\n\n// contracts/libs/InterchainTransaction.sol\n\ntype ICTxHeader is uint256;\n\nstruct InterchainTransaction {\n    uint64 srcChainId;\n    uint64 dstChainId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcSender;\n    bytes32 dstReceiver;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    using MathLib for uint256;\n    using VersionedPayloadLib for bytes;\n\n    function constructLocalTransaction(\n        address srcSender,\n        uint64 dstChainId,\n        bytes32 dstReceiver,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: SafeCast.toUint64(block.chainid),\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            encodeTxHeader(transaction.srcChainId, transaction.dstChainId, transaction.dbNonce, transaction.entryIndex),\n            transaction.srcSender,\n            transaction.dstReceiver,\n            transaction.options,\n            transaction.message\n        );\n    }\n\n    function decodeTransaction(bytes calldata transaction) internal pure returns (InterchainTransaction memory icTx) {\n        ICTxHeader header;\n        (header, icTx.srcSender, icTx.dstReceiver, icTx.options, icTx.message) =\n            abi.decode(transaction, (ICTxHeader, bytes32, bytes32, bytes, bytes));\n        (icTx.srcChainId, icTx.dstChainId, icTx.dbNonce, icTx.entryIndex) = decodeTxHeader(header);\n    }\n\n    function payloadSize(uint256 optionsLen, uint256 messageLen) internal pure returns (uint256) {\n        // 2 bytes are reserved for the transaction version\n        // + 5 fields * 32 bytes (3 values for static, 2 offsets for dynamic) + 2 * 32 bytes (lengths for dynamic) = 226\n        // (srcChainId, dstChainId, dbNonce, entryIndex) are merged into a single 32 bytes field\n        // Both options and message are dynamic fields, which are padded up to 32 bytes\n        return 226 + optionsLen.roundUpToWord() + messageLen.roundUpToWord();\n    }\n\n    function encodeTxHeader(\n        uint64 srcChainId,\n        uint64 dstChainId,\n        uint64 dbNonce,\n        uint64 entryIndex\n    )\n        internal\n        pure\n        returns (ICTxHeader)\n    {\n        return ICTxHeader.wrap(\n            (uint256(srcChainId) \u003c\u003c 192) | (uint256(dstChainId) \u003c\u003c 128) | (uint256(dbNonce) \u003c\u003c 64) | uint256(entryIndex)\n        );\n    }\n\n    function decodeTxHeader(ICTxHeader header)\n        internal\n        pure\n        returns (uint64 srcChainId, uint64 dstChainId, uint64 dbNonce, uint64 entryIndex)\n    {\n        srcChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 192);\n        dstChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 128);\n        dbNonce = uint64(ICTxHeader.unwrap(header) \u003e\u003e 64);\n        entryIndex = uint64(ICTxHeader.unwrap(header));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/AccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account =\u003e bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role =\u003e RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint64 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__InvalidTransactionVersion(uint16 version);\n    error InterchainClientV1__NoLinkedClient(uint64 chainId);\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint64 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint64 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint64 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint64 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param messageLen           The length of the message being sent.\n    function getInterchainFee(\n        uint64 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        uint256 messageLen\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint64 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint64 chainId) external view returns (address);\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/AccessControlEnumerable.sol)\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 role =\u003e EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {AccessControl-_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool granted = super._grantRole(role, account);\n        if (granted) {\n            _roleMembers[role].add(account);\n        }\n        return granted;\n    }\n\n    /**\n     * @dev Overload {AccessControl-_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool revoked = super._revokeRole(role, account);\n        if (revoked) {\n            _roleMembers[role].remove(account);\n        }\n        return revoked;\n    }\n}\n\n// contracts/apps/AbstractICApp.sol\n\nabstract contract AbstractICApp is AbstractICAppEvents, IInterchainApp {\n    using TypeCasts for address;\n\n    error InterchainApp__AlreadyLatestClient(address client);\n    error InterchainApp__BalanceTooLow(uint256 actual, uint256 required);\n    error InterchainApp__ClientAlreadyAdded(address client);\n    error InterchainApp__InterchainClientZeroAddress();\n    error InterchainApp__NotInterchainClient(address account);\n    error InterchainApp__ReceiverNotSet(uint64 chainId);\n    error InterchainApp__SameChainId(uint64 chainId);\n    error InterchainApp__SenderNotAllowed(uint64 srcChainId, bytes32 sender);\n\n    /// @inheritdoc IInterchainApp\n    function appReceive(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        if (!_isInterchainClient(msg.sender)) {\n            revert InterchainApp__NotInterchainClient(msg.sender);\n        }\n        if (srcChainId == block.chainid) {\n            revert InterchainApp__SameChainId(srcChainId);\n        }\n        if (!_isAllowedSender(srcChainId, sender)) {\n            revert InterchainApp__SenderNotAllowed(srcChainId, sender);\n        }\n        _receiveMessage(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n\n    /// @inheritdoc IInterchainApp\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules) {\n        appConfig = _getAppConfig();\n        modules = _getModules();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Performs necessary checks and adds an Interchain Client.\n    /// Optionally sets the latest client to this one.\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _addClient(address client, bool updateLatest) internal {\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (_isInterchainClient(client)) {\n            revert InterchainApp__ClientAlreadyAdded(client);\n        }\n        _toggleClientState(client, true);\n        emit InterchainClientAdded(client);\n        if (updateLatest) {\n            _setLatestClient(client);\n        }\n    }\n\n    /// @dev Performs necessary checks and removes an Interchain Client. If this client is the latest one,\n    /// the latest client is set to zero address (effectively pausing the app ability to send messages).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _removeClient(address client) internal {\n        if (!_isInterchainClient(client)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        _toggleClientState(client, false);\n        emit InterchainClientRemoved(client);\n        if (client == _getLatestClient()) {\n            _setLatestClient(address(0));\n        }\n    }\n\n    /// @dev Sets the latest Interchain Client to one of the allowed clients. Setting the client to zero address\n    /// is allowed and effectively pauses the app ability to send messages (but still allows to receive them).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _setLatestClient(address client) internal {\n        // New latest client must be an allowed client or zero address.\n        if (!_isInterchainClient(client) \u0026\u0026 client != address(0)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        if (client == _getLatestClient()) {\n            revert InterchainApp__AlreadyLatestClient(client);\n        }\n        _storeLatestClient(client);\n        emit LatestClientSet(client);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal virtual;\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal virtual;\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to accept EVM address as a parameter.\n    function _sendInterchainMessageEVM(\n        uint64 dstChainId,\n        address receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _sendInterchainMessage(dstChainId, receiver.addressToBytes32(), messageFee, options, message);\n    }\n\n    /// @dev Performs necessary checks and sends an interchain message.\n    function _sendInterchainMessage(\n        uint64 dstChainId,\n        bytes32 receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (dstChainId == block.chainid) {\n            revert InterchainApp__SameChainId(dstChainId);\n        }\n        if (receiver == 0) {\n            revert InterchainApp__ReceiverNotSet(dstChainId);\n        }\n        if (address(this).balance \u003c messageFee) {\n            revert InterchainApp__BalanceTooLow({actual: address(this).balance, required: messageFee});\n        }\n        return IInterchainClientV1(client).interchainSend{value: messageFee}(\n            dstChainId, receiver, _getExecutionService(), _getModules(), options, message\n        );\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        virtual;\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee for sending an Interchain message.\n    function _getInterchainFee(\n        uint64 dstChainId,\n        bytes memory options,\n        uint256 messageLen\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        return IInterchainClientV1(client).getInterchainFee(\n            dstChainId, _getExecutionService(), _getModules(), options, messageLen\n        );\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view virtual returns (bytes memory);\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view virtual returns (address);\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view virtual returns (address);\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view virtual returns (address[] memory);\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint64 srcChainId, bytes32 sender) internal view virtual returns (bool);\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view virtual returns (bool);\n}\n\n// contracts/apps/ICAppV1.sol\n\nabstract contract ICAppV1 is AbstractICApp, AccessControlEnumerable, InterchainAppV1Events, IInterchainAppV1 {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Role to manage the Interchain setup of the app.\n    bytes32 public constant IC_GOVERNOR_ROLE = keccak256(\"IC_GOVERNOR_ROLE\");\n\n    /// @dev Address of the latest Interchain Client, used for sending messages.\n    address private _latestClient;\n\n    /// @dev Required responses and optimistic period for the module responses.\n    AppConfigV1 private _appConfigV1;\n    /// @dev Address of the linked app deployed on the remote chain.\n    mapping(uint64 chainId =\u003e bytes32 remoteApp) private _linkedApp;\n    /// @dev Interchain Clients allowed to send messages to this app.\n    EnumerableSet.AddressSet private _interchainClients;\n    /// @dev Trusted Interchain modules.\n    EnumerableSet.AddressSet private _trustedModules;\n    /// @dev Execution Service to use for sending messages.\n    address private _executionService;\n\n    constructor(address admin) {\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addInterchainClient(address client, bool updateLatest) external onlyRole(IC_GOVERNOR_ROLE) {\n        _addClient(client, updateLatest);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _removeClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setLatestInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _setLatestClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteApp(uint64 chainId, bytes32 remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteAppEVM(uint64 chainId, address remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp.addressToBytes32());\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (module == address(0)) {\n            revert InterchainApp__ModuleZeroAddress();\n        }\n        bool added = _trustedModules.add(module);\n        if (!added) {\n            revert InterchainApp__ModuleAlreadyAdded(module);\n        }\n        emit TrustedModuleAdded(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        bool removed = _trustedModules.remove(module);\n        if (!removed) {\n            revert InterchainApp__ModuleNotAdded(module);\n        }\n        emit TrustedModuleRemoved(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setAppConfigV1(AppConfigV1 memory appConfig) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (appConfig.requiredResponses == 0 || appConfig.optimisticPeriod == 0) {\n            revert InterchainApp__InvalidAppConfig(appConfig.requiredResponses, appConfig.optimisticPeriod);\n        }\n        _appConfigV1 = appConfig;\n        emit AppConfigV1Set(appConfig.requiredResponses, appConfig.optimisticPeriod);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setExecutionService(address executionService) external onlyRole(IC_GOVERNOR_ROLE) {\n        _executionService = executionService;\n        emit ExecutionServiceSet(executionService);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainAppV1\n    function getAppConfigV1() external view returns (AppConfigV1 memory) {\n        return _appConfigV1;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getExecutionService() external view returns (address) {\n        return _executionService;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getInterchainClients() external view returns (address[] memory) {\n        return _interchainClients.values();\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLatestInterchainClient() external view returns (address) {\n        return _latestClient;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedApp(uint64 chainId) external view returns (bytes32) {\n        return _linkedApp[chainId];\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedAppEVM(uint64 chainId) external view returns (address linkedAppEVM) {\n        bytes32 linkedApp = _linkedApp[chainId];\n        linkedAppEVM = linkedApp.bytes32ToAddress();\n        if (linkedAppEVM.addressToBytes32() != linkedApp) {\n            revert InterchainApp__NotEVMLinkedApp(linkedApp);\n        }\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getModules() external view returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Links the remote app to the current app.\n    /// Will revert if the chainId is the same as the chainId of the local app.\n    /// Note: Should be guarded with permissions check.\n    function _linkRemoteApp(uint64 chainId, bytes32 remoteApp) internal {\n        if (chainId == block.chainid) {\n            revert InterchainApp__SameChainId(chainId);\n        }\n        if (remoteApp == 0) {\n            revert InterchainApp__AppZeroAddress();\n        }\n        _linkedApp[chainId] = remoteApp;\n        emit AppLinked(chainId, remoteApp);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal override {\n        _latestClient = client;\n    }\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal override {\n        if (allowed) {\n            _interchainClients.add(client);\n        } else {\n            _interchainClients.remove(client);\n        }\n    }\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to send the message to the linked app.\n    function _sendToLinkedApp(\n        uint64 dstChainId,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _sendInterchainMessage(dstChainId, _linkedApp[dstChainId], messageFee, encodedOptions, message);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee to send a message to the linked app on the remote chain.\n    function _getMessageFee(\n        uint64 dstChainId,\n        OptionsV1 memory options,\n        uint256 messageLen\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _getInterchainFee(dstChainId, encodedOptions, messageLen);\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view override returns (bytes memory) {\n        return _appConfigV1.encodeAppConfigV1();\n    }\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view override returns (address) {\n        return _executionService;\n    }\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view override returns (address) {\n        return _latestClient;\n    }\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view override returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint64 srcChainId, bytes32 sender) internal view override returns (bool) {\n        return _linkedApp[srcChainId] == sender;\n    }\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view override returns (bool) {\n        return _interchainClients.contains(caller);\n    }\n}\n\n// contracts/apps/examples/ExampleAppV1.sol\n\ncontract ExampleAppV1 is ICAppV1 {\n    event MessageReceived(uint64 srcChainId, bytes32 sender, uint64 dbNonce, uint64 entryIndex, bytes message);\n    event MessageSent(uint64 dstChainId, uint64 dbNonce, uint64 entryIndex, bytes32 transactionId);\n\n    constructor(address admin) ICAppV1(admin) {\n        _grantRole(IC_GOVERNOR_ROLE, admin);\n    }\n\n    /// @notice Allows the Admin to withdraw the native asset from the contract.\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        Address.sendValue(payable(msg.sender), address(this).balance);\n    }\n\n    /// @notice Sends a basic message to the destination chain.\n    function sendMessage(\n        uint64 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        InterchainTxDescriptor memory desc = _sendToLinkedApp({\n            dstChainId: dstChainId,\n            messageFee: msg.value,\n            options: OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}),\n            message: message\n        });\n        emit MessageSent(dstChainId, desc.dbNonce, desc.entryIndex, desc.transactionId);\n    }\n\n    /// @notice Returns the fee required to send a message using `sendMessage`.\n    function getMessageFee(\n        uint64 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes memory message\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _getMessageFee(dstChainId, OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}), message.length);\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        override\n    {\n        emit MessageReceived(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"client","type":"address"}],"name":"InterchainClientAdded","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"client","type":"address"}],"name":"InterchainClientRemoved","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"client","type":"address"}],"name":"LatestClientSet","type":"event"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"}],\"name\":\"InterchainClientAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"}],\"name\":\"InterchainClientRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"}],\"name\":\"LatestClientSet\",\"type\":\"event\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/ExampleAppV1.sol\":\"AbstractICAppEvents\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/ExampleAppV1.sol\":{\"keccak256\":\"0xb1e9550aef785a0afc4e03fc843839919987ba4f906f09992c6788979c3c0396\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://0ede697223dfa3a2e23501efc1ed5926d5ff6458ee7b9ba833e0587162166c79\",\"dweb:/ipfs/QmUzgopL2ptWG5DYNdGAcoErPnBC4KCoRp8C61dkHHRaA6\"]}},\"version\":1}"},"hashes":{}},"solidity/ExampleAppV1.sol:AccessControl":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/AbstractICAppEvents.sol\n\nabstract contract AbstractICAppEvents {\n    event InterchainClientAdded(address client);\n    event InterchainClientRemoved(address client);\n    event LatestClientSet(address client);\n}\n\n// contracts/events/InterchainAppV1Events.sol\n\nabstract contract InterchainAppV1Events {\n    event AppConfigV1Set(uint256 requiredResponses, uint256 optimisticPeriod);\n    event AppLinked(uint256 indexed chainId, bytes32 indexed remoteApp);\n    event ExecutionServiceSet(address executionService);\n    event TrustedModuleAdded(address module);\n    event TrustedModuleRemoved(address module);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    /// @notice Allows the Interchain Client to pass the message to the Interchain App.\n    /// @dev App is responsible for keeping track of interchain clients, and must verify the message sender.\n    /// @param srcChainId   Chain ID of the source chain, where the message was sent from.\n    /// @param sender       Sender address on the source chain, as a bytes32 value.\n    /// @param dbNonce      The Interchain DB nonce of the batch containing the message entry.\n    /// @param entryIndex   The index of the message entry within the batch.\n    /// @param message      The message being sent.\n    function appReceive(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /// @notice Returns the verification configuration of the Interchain App.\n    /// @dev This configuration is used by the Interchain Client to verify that message has been confirmed\n    /// by the Interchain Modules on the destination chain.\n    /// Note: V1 version of AppConfig includes the required responses count, and optimistic period after which\n    /// the message is considered confirmed by the module. Following versions may include additional fields.\n    /// @return appConfig    The versioned configuration of the Interchain App, encoded as bytes.\n    /// @return modules      The list of Interchain Modules that app is trusting to confirm the messages.\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/Math.sol\n\nlibrary MathLib {\n    /// @notice Rounds up to the nearest multiple of 32.\n    /// Note: Returns zero on overflows instead of reverting. This is fine for practical\n    /// use cases, as this is used for determining the size of the payload in memory.\n    function roundUpToWord(uint256 x) internal pure returns (uint256) {\n        unchecked {\n            return (x + 31) \u0026 ~uint256(31);\n        }\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/VersionedPayload.sol\n\n// solhint-disable no-inline-assembly\n// solhint-disable ordering\nlibrary VersionedPayloadLib {\n    /// @notice Amount of bytes reserved for the version (uint16) in the versioned payload\n    uint256 internal constant VERSION_LENGTH = 2;\n\n    error VersionedPayload__TooShort(bytes versionedPayload);\n    error VersionedPayload__PrecompileFailed();\n\n    /// @notice Encodes the versioned payload into a single bytes array.\n    /// @param version  The payload's version.\n    /// @param payload  The payload to encode.\n    function encodeVersionedPayload(uint16 version, bytes memory payload) internal pure returns (bytes memory) {\n        return abi.encodePacked(version, payload);\n    }\n\n    /// @notice Extracts the version from the versioned payload (calldata reference).\n    /// @param versionedPayload     The versioned payload (calldata reference).\n    function getVersion(bytes calldata versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            version := shr(240, calldataload(versionedPayload.offset))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (calldata reference).\n    /// @dev The extracted payload is also returned as a calldata reference.\n    /// @param versionedPayload     The versioned payload.\n    function getPayload(bytes calldata versionedPayload) internal pure returns (bytes calldata) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        return versionedPayload[VERSION_LENGTH:];\n    }\n\n    /// @notice Extracts the version from the versioned payload (memory reference).\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getVersionFromMemory(bytes memory versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            // We add 0x20 to skip the length of the bytes array.\n            version := shr(240, mload(add(versionedPayload, 0x20)))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (memory reference).\n    /// @dev The extracted payload is copied into a new memory location. Use `getPayload` when possible\n    /// to avoid extra memory allocation.\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getPayloadFromMemory(bytes memory versionedPayload) internal view returns (bytes memory payload) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        // Figure how many bytes to copy and allocate the memory for the extracted payload.\n        uint256 toCopy;\n        unchecked {\n            toCopy = versionedPayload.length - VERSION_LENGTH;\n        }\n        payload = new bytes(toCopy);\n        // Use identity precompile (0x04) to copy the payload. Unlike MCOPY, this is available on all EVM chains.\n        bool res;\n        assembly {\n            // We add 0x20 to skip the length of the bytes array.\n            // We add 0x02 to skip the 2 bytes reserved for the version.\n            // Copy the payload to the previously allocated memory.\n            res := staticcall(gas(), 0x04, add(versionedPayload, 0x22), toCopy, add(payload, 0x20), toCopy)\n        }\n        if (!res) {\n            revert VersionedPayload__PrecompileFailed();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/IAccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n\n// node_modules/@openzeppelin/contracts/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance \u003c amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance \u003c value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 \u0026\u0026 target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SafeCast.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value \u003e type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value \u003e type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value \u003e type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value \u003e type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value \u003e type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value \u003e type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value \u003e type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value \u003e type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value \u003e type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value \u003e type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value \u003e type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value \u003e type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value \u003e type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value \u003e type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value \u003e type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value \u003e type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value \u003e type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value \u003e type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value \u003e type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value \u003e type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value \u003e type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value \u003e type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value \u003e type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value \u003e type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value \u003e type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value \u003e type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value \u003e type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value \u003e type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value \u003e type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value \u003e type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value \u003e type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value \u003c 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value \u003e uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal view returns (AppConfigV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (AppConfigV1));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal view returns (OptionsV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (OptionsV1));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(OPTIONS_V1, abi.encode(options));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/IAccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/IAccessControlEnumerable.sol)\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n// contracts/interfaces/IInterchainAppV1.sol\n\ninterface IInterchainAppV1 is IInterchainApp {\n    error InterchainApp__AppZeroAddress();\n    error InterchainApp__InvalidAppConfig(uint256 requiredResponses, uint256 optimisticPeriod);\n    error InterchainApp__ModuleAlreadyAdded(address module);\n    error InterchainApp__ModuleNotAdded(address module);\n    error InterchainApp__ModuleZeroAddress();\n    error InterchainApp__NotEVMLinkedApp(bytes32 linkedApp);\n\n    /// @notice Allows the owner to add the interchain client to the allowed clients set,\n    /// and optionally set the latest client to this one.\n    /// Note: only the allowed clients can send messages to this app.\n    /// Note: the latest client is used for sending messages from this app.\n    /// @param client       The address of the interchain client to add.\n    /// @param updateLatest Whether to set the latest client to this one.\n    function addInterchainClient(address client, bool updateLatest) external;\n\n    /// @notice Allows the owner to remove the interchain client from the allowed clients set.\n    /// If the client is the latest client, the latest client is set to the zero address.\n    /// @param client       The address of the interchain client to remove.\n    function removeInterchainClient(address client) external;\n\n    /// @notice Allows the owner to set the address of the latest interchain client.\n    /// @dev The new latest client must be an allowed client or zero address.\n    /// Setting the client to zero address effectively pauses the app ability to send messages,\n    /// while allowing to receive them.\n    /// @param client       The address of the latest interchain client.\n    function setLatestInterchainClient(address client) external;\n\n    /// @notice Allows the owner to link the remote app for the given chain ID.\n    /// - This address will be used as the receiver for the messages sent from this chain.\n    /// - This address will be the only trusted sender for the messages sent to this chain.\n    /// @param chainId      The remote chain ID.\n    /// @param remoteApp    The address of the remote app to link.\n    function linkRemoteApp(uint64 chainId, bytes32 remoteApp) external;\n\n    /// @notice Thin wrapper for `linkRemoteApp` to accept EVM address as a parameter.\n    function linkRemoteAppEVM(uint64 chainId, address remoteApp) external;\n\n    /// @notice Allows the owner to add the module to the trusted modules set.\n    /// - This set of modules will be used to verify both sent and received messages.\n    function addTrustedModule(address module) external;\n\n    /// @notice Allows the owner to remove the module from the trusted modules set.\n    function removeTrustedModule(address module) external;\n\n    /// @notice Allows the owner to set the app config for the current app. App config includes:\n    /// - requiredResponses: the number of module responses required for accepting the message\n    /// - optimisticPeriod: the minimum time after which the module responses are considered final\n    function setAppConfigV1(AppConfigV1 memory appConfig) external;\n\n    /// @notice Allows the owner to set the address of the Execution Service.\n    /// This address will be used to request execution of the messages sent from this chain,\n    /// by supplying the Service's execution fee.\n    function setExecutionService(address executionService) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Returns the app config for the current app: requiredResponses and optimisticPeriod.\n    function getAppConfigV1() external view returns (AppConfigV1 memory);\n\n    /// @notice Returns the address of the Execution Service used by this app for sending messages.\n    function getExecutionService() external view returns (address);\n\n    /// @notice Returns the list of Interchain Clients allowed to send messages to this app.\n    function getInterchainClients() external view returns (address[] memory);\n\n    /// @notice Returns the address of the latest interchain client.\n    /// This address is used for sending messages from this app.\n    function getLatestInterchainClient() external view returns (address);\n\n    /// @notice Returns the linked app address (as bytes32) for the given chain ID.\n    function getLinkedApp(uint64 chainId) external view returns (bytes32);\n\n    /// @notice Thin wrapper for `getLinkedApp` to return the linked app address as EVM address.\n    /// @dev Will revert if the linked app address is not an EVM address.\n    function getLinkedAppEVM(uint64 chainId) external view returns (address);\n\n    /// @notice Returns the list of Interchain Modules trusted by this app.\n    /// This set of modules will be used to verify both sent and received messages.\n    function getModules() external view returns (address[] memory);\n}\n\n// contracts/libs/InterchainTransaction.sol\n\ntype ICTxHeader is uint256;\n\nstruct InterchainTransaction {\n    uint64 srcChainId;\n    uint64 dstChainId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcSender;\n    bytes32 dstReceiver;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    using MathLib for uint256;\n    using VersionedPayloadLib for bytes;\n\n    function constructLocalTransaction(\n        address srcSender,\n        uint64 dstChainId,\n        bytes32 dstReceiver,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: SafeCast.toUint64(block.chainid),\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            encodeTxHeader(transaction.srcChainId, transaction.dstChainId, transaction.dbNonce, transaction.entryIndex),\n            transaction.srcSender,\n            transaction.dstReceiver,\n            transaction.options,\n            transaction.message\n        );\n    }\n\n    function decodeTransaction(bytes calldata transaction) internal pure returns (InterchainTransaction memory icTx) {\n        ICTxHeader header;\n        (header, icTx.srcSender, icTx.dstReceiver, icTx.options, icTx.message) =\n            abi.decode(transaction, (ICTxHeader, bytes32, bytes32, bytes, bytes));\n        (icTx.srcChainId, icTx.dstChainId, icTx.dbNonce, icTx.entryIndex) = decodeTxHeader(header);\n    }\n\n    function payloadSize(uint256 optionsLen, uint256 messageLen) internal pure returns (uint256) {\n        // 2 bytes are reserved for the transaction version\n        // + 5 fields * 32 bytes (3 values for static, 2 offsets for dynamic) + 2 * 32 bytes (lengths for dynamic) = 226\n        // (srcChainId, dstChainId, dbNonce, entryIndex) are merged into a single 32 bytes field\n        // Both options and message are dynamic fields, which are padded up to 32 bytes\n        return 226 + optionsLen.roundUpToWord() + messageLen.roundUpToWord();\n    }\n\n    function encodeTxHeader(\n        uint64 srcChainId,\n        uint64 dstChainId,\n        uint64 dbNonce,\n        uint64 entryIndex\n    )\n        internal\n        pure\n        returns (ICTxHeader)\n    {\n        return ICTxHeader.wrap(\n            (uint256(srcChainId) \u003c\u003c 192) | (uint256(dstChainId) \u003c\u003c 128) | (uint256(dbNonce) \u003c\u003c 64) | uint256(entryIndex)\n        );\n    }\n\n    function decodeTxHeader(ICTxHeader header)\n        internal\n        pure\n        returns (uint64 srcChainId, uint64 dstChainId, uint64 dbNonce, uint64 entryIndex)\n    {\n        srcChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 192);\n        dstChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 128);\n        dbNonce = uint64(ICTxHeader.unwrap(header) \u003e\u003e 64);\n        entryIndex = uint64(ICTxHeader.unwrap(header));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/AccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account =\u003e bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role =\u003e RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint64 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__InvalidTransactionVersion(uint16 version);\n    error InterchainClientV1__NoLinkedClient(uint64 chainId);\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint64 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint64 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint64 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint64 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param messageLen           The length of the message being sent.\n    function getInterchainFee(\n        uint64 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        uint256 messageLen\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint64 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint64 chainId) external view returns (address);\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/AccessControlEnumerable.sol)\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 role =\u003e EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {AccessControl-_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool granted = super._grantRole(role, account);\n        if (granted) {\n            _roleMembers[role].add(account);\n        }\n        return granted;\n    }\n\n    /**\n     * @dev Overload {AccessControl-_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool revoked = super._revokeRole(role, account);\n        if (revoked) {\n            _roleMembers[role].remove(account);\n        }\n        return revoked;\n    }\n}\n\n// contracts/apps/AbstractICApp.sol\n\nabstract contract AbstractICApp is AbstractICAppEvents, IInterchainApp {\n    using TypeCasts for address;\n\n    error InterchainApp__AlreadyLatestClient(address client);\n    error InterchainApp__BalanceTooLow(uint256 actual, uint256 required);\n    error InterchainApp__ClientAlreadyAdded(address client);\n    error InterchainApp__InterchainClientZeroAddress();\n    error InterchainApp__NotInterchainClient(address account);\n    error InterchainApp__ReceiverNotSet(uint64 chainId);\n    error InterchainApp__SameChainId(uint64 chainId);\n    error InterchainApp__SenderNotAllowed(uint64 srcChainId, bytes32 sender);\n\n    /// @inheritdoc IInterchainApp\n    function appReceive(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        if (!_isInterchainClient(msg.sender)) {\n            revert InterchainApp__NotInterchainClient(msg.sender);\n        }\n        if (srcChainId == block.chainid) {\n            revert InterchainApp__SameChainId(srcChainId);\n        }\n        if (!_isAllowedSender(srcChainId, sender)) {\n            revert InterchainApp__SenderNotAllowed(srcChainId, sender);\n        }\n        _receiveMessage(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n\n    /// @inheritdoc IInterchainApp\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules) {\n        appConfig = _getAppConfig();\n        modules = _getModules();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Performs necessary checks and adds an Interchain Client.\n    /// Optionally sets the latest client to this one.\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _addClient(address client, bool updateLatest) internal {\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (_isInterchainClient(client)) {\n            revert InterchainApp__ClientAlreadyAdded(client);\n        }\n        _toggleClientState(client, true);\n        emit InterchainClientAdded(client);\n        if (updateLatest) {\n            _setLatestClient(client);\n        }\n    }\n\n    /// @dev Performs necessary checks and removes an Interchain Client. If this client is the latest one,\n    /// the latest client is set to zero address (effectively pausing the app ability to send messages).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _removeClient(address client) internal {\n        if (!_isInterchainClient(client)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        _toggleClientState(client, false);\n        emit InterchainClientRemoved(client);\n        if (client == _getLatestClient()) {\n            _setLatestClient(address(0));\n        }\n    }\n\n    /// @dev Sets the latest Interchain Client to one of the allowed clients. Setting the client to zero address\n    /// is allowed and effectively pauses the app ability to send messages (but still allows to receive them).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _setLatestClient(address client) internal {\n        // New latest client must be an allowed client or zero address.\n        if (!_isInterchainClient(client) \u0026\u0026 client != address(0)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        if (client == _getLatestClient()) {\n            revert InterchainApp__AlreadyLatestClient(client);\n        }\n        _storeLatestClient(client);\n        emit LatestClientSet(client);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal virtual;\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal virtual;\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to accept EVM address as a parameter.\n    function _sendInterchainMessageEVM(\n        uint64 dstChainId,\n        address receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _sendInterchainMessage(dstChainId, receiver.addressToBytes32(), messageFee, options, message);\n    }\n\n    /// @dev Performs necessary checks and sends an interchain message.\n    function _sendInterchainMessage(\n        uint64 dstChainId,\n        bytes32 receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (dstChainId == block.chainid) {\n            revert InterchainApp__SameChainId(dstChainId);\n        }\n        if (receiver == 0) {\n            revert InterchainApp__ReceiverNotSet(dstChainId);\n        }\n        if (address(this).balance \u003c messageFee) {\n            revert InterchainApp__BalanceTooLow({actual: address(this).balance, required: messageFee});\n        }\n        return IInterchainClientV1(client).interchainSend{value: messageFee}(\n            dstChainId, receiver, _getExecutionService(), _getModules(), options, message\n        );\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        virtual;\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee for sending an Interchain message.\n    function _getInterchainFee(\n        uint64 dstChainId,\n        bytes memory options,\n        uint256 messageLen\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        return IInterchainClientV1(client).getInterchainFee(\n            dstChainId, _getExecutionService(), _getModules(), options, messageLen\n        );\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view virtual returns (bytes memory);\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view virtual returns (address);\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view virtual returns (address);\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view virtual returns (address[] memory);\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint64 srcChainId, bytes32 sender) internal view virtual returns (bool);\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view virtual returns (bool);\n}\n\n// contracts/apps/ICAppV1.sol\n\nabstract contract ICAppV1 is AbstractICApp, AccessControlEnumerable, InterchainAppV1Events, IInterchainAppV1 {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Role to manage the Interchain setup of the app.\n    bytes32 public constant IC_GOVERNOR_ROLE = keccak256(\"IC_GOVERNOR_ROLE\");\n\n    /// @dev Address of the latest Interchain Client, used for sending messages.\n    address private _latestClient;\n\n    /// @dev Required responses and optimistic period for the module responses.\n    AppConfigV1 private _appConfigV1;\n    /// @dev Address of the linked app deployed on the remote chain.\n    mapping(uint64 chainId =\u003e bytes32 remoteApp) private _linkedApp;\n    /// @dev Interchain Clients allowed to send messages to this app.\n    EnumerableSet.AddressSet private _interchainClients;\n    /// @dev Trusted Interchain modules.\n    EnumerableSet.AddressSet private _trustedModules;\n    /// @dev Execution Service to use for sending messages.\n    address private _executionService;\n\n    constructor(address admin) {\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addInterchainClient(address client, bool updateLatest) external onlyRole(IC_GOVERNOR_ROLE) {\n        _addClient(client, updateLatest);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _removeClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setLatestInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _setLatestClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteApp(uint64 chainId, bytes32 remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteAppEVM(uint64 chainId, address remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp.addressToBytes32());\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (module == address(0)) {\n            revert InterchainApp__ModuleZeroAddress();\n        }\n        bool added = _trustedModules.add(module);\n        if (!added) {\n            revert InterchainApp__ModuleAlreadyAdded(module);\n        }\n        emit TrustedModuleAdded(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        bool removed = _trustedModules.remove(module);\n        if (!removed) {\n            revert InterchainApp__ModuleNotAdded(module);\n        }\n        emit TrustedModuleRemoved(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setAppConfigV1(AppConfigV1 memory appConfig) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (appConfig.requiredResponses == 0 || appConfig.optimisticPeriod == 0) {\n            revert InterchainApp__InvalidAppConfig(appConfig.requiredResponses, appConfig.optimisticPeriod);\n        }\n        _appConfigV1 = appConfig;\n        emit AppConfigV1Set(appConfig.requiredResponses, appConfig.optimisticPeriod);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setExecutionService(address executionService) external onlyRole(IC_GOVERNOR_ROLE) {\n        _executionService = executionService;\n        emit ExecutionServiceSet(executionService);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainAppV1\n    function getAppConfigV1() external view returns (AppConfigV1 memory) {\n        return _appConfigV1;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getExecutionService() external view returns (address) {\n        return _executionService;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getInterchainClients() external view returns (address[] memory) {\n        return _interchainClients.values();\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLatestInterchainClient() external view returns (address) {\n        return _latestClient;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedApp(uint64 chainId) external view returns (bytes32) {\n        return _linkedApp[chainId];\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedAppEVM(uint64 chainId) external view returns (address linkedAppEVM) {\n        bytes32 linkedApp = _linkedApp[chainId];\n        linkedAppEVM = linkedApp.bytes32ToAddress();\n        if (linkedAppEVM.addressToBytes32() != linkedApp) {\n            revert InterchainApp__NotEVMLinkedApp(linkedApp);\n        }\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getModules() external view returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Links the remote app to the current app.\n    /// Will revert if the chainId is the same as the chainId of the local app.\n    /// Note: Should be guarded with permissions check.\n    function _linkRemoteApp(uint64 chainId, bytes32 remoteApp) internal {\n        if (chainId == block.chainid) {\n            revert InterchainApp__SameChainId(chainId);\n        }\n        if (remoteApp == 0) {\n            revert InterchainApp__AppZeroAddress();\n        }\n        _linkedApp[chainId] = remoteApp;\n        emit AppLinked(chainId, remoteApp);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal override {\n        _latestClient = client;\n    }\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal override {\n        if (allowed) {\n            _interchainClients.add(client);\n        } else {\n            _interchainClients.remove(client);\n        }\n    }\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to send the message to the linked app.\n    function _sendToLinkedApp(\n        uint64 dstChainId,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _sendInterchainMessage(dstChainId, _linkedApp[dstChainId], messageFee, encodedOptions, message);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee to send a message to the linked app on the remote chain.\n    function _getMessageFee(\n        uint64 dstChainId,\n        OptionsV1 memory options,\n        uint256 messageLen\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _getInterchainFee(dstChainId, encodedOptions, messageLen);\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view override returns (bytes memory) {\n        return _appConfigV1.encodeAppConfigV1();\n    }\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view override returns (address) {\n        return _executionService;\n    }\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view override returns (address) {\n        return _latestClient;\n    }\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view override returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint64 srcChainId, bytes32 sender) internal view override returns (bool) {\n        return _linkedApp[srcChainId] == sender;\n    }\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view override returns (bool) {\n        return _interchainClients.contains(caller);\n    }\n}\n\n// contracts/apps/examples/ExampleAppV1.sol\n\ncontract ExampleAppV1 is ICAppV1 {\n    event MessageReceived(uint64 srcChainId, bytes32 sender, uint64 dbNonce, uint64 entryIndex, bytes message);\n    event MessageSent(uint64 dstChainId, uint64 dbNonce, uint64 entryIndex, bytes32 transactionId);\n\n    constructor(address admin) ICAppV1(admin) {\n        _grantRole(IC_GOVERNOR_ROLE, admin);\n    }\n\n    /// @notice Allows the Admin to withdraw the native asset from the contract.\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        Address.sendValue(payable(msg.sender), address(this).balance);\n    }\n\n    /// @notice Sends a basic message to the destination chain.\n    function sendMessage(\n        uint64 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        InterchainTxDescriptor memory desc = _sendToLinkedApp({\n            dstChainId: dstChainId,\n            messageFee: msg.value,\n            options: OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}),\n            message: message\n        });\n        emit MessageSent(dstChainId, desc.dbNonce, desc.entryIndex, desc.transactionId);\n    }\n\n    /// @notice Returns the fee required to send a message using `sendMessage`.\n    function getMessageFee(\n        uint64 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes memory message\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _getMessageFee(dstChainId, OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}), message.length);\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        override\n    {\n        emit MessageReceived(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[],"name":"AccessControlBadConfirmation","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"bytes32","name":"neededRole","type":"bytes32"}],"name":"AccessControlUnauthorizedAccount","type":"error"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"bytes32","name":"previousAdminRole","type":"bytes32"},{"indexed":true,"internalType":"bytes32","name":"newAdminRole","type":"bytes32"}],"name":"RoleAdminChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":true,"internalType":"address","name":"sender","type":"address"}],"name":"RoleGranted","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":true,"internalType":"address","name":"sender","type":"address"}],"name":"RoleRevoked","type":"event"},{"inputs":[],"name":"DEFAULT_ADMIN_ROLE","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"}],"name":"getRoleAdmin","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"grantRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"hasRole","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"callerConfirmation","type":"address"}],"name":"renounceRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"revokeRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes4","name":"interfaceId","type":"bytes4"}],"name":"supportsInterface","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"details":"Contract module that allows children to implement role-based access control mechanisms. This is a lightweight version that doesn't allow enumerating role members except through off-chain means by accessing the contract event logs. Some applications may benefit from on-chain enumerability, for those cases see {AccessControlEnumerable}. Roles are referred to by their `bytes32` identifier. These should be exposed in the external API and be unique. The best way to achieve this is by using `public constant` hash digests: ```solidity bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\"); ``` Roles can be used to represent a set of permissions. To restrict access to a function call, use {hasRole}: ```solidity function foo() public {     require(hasRole(MY_ROLE, msg.sender));     ... } ``` Roles can be granted and revoked dynamically via the {grantRole} and {revokeRole} functions. Each role has an associated admin role, and only accounts that have a role's admin role can call {grantRole} and {revokeRole}. By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means that only accounts with this role will be able to grant or revoke other roles. More complex role relationships can be created by using {_setRoleAdmin}. WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to grant and revoke this role. Extra precautions should be taken to secure accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules} to enforce additional security measures for this role.","errors":{"AccessControlBadConfirmation()":[{"details":"The caller of a function is not the expected one. NOTE: Don't confuse with {AccessControlUnauthorizedAccount}."}],"AccessControlUnauthorizedAccount(address,bytes32)":[{"details":"The `account` is missing a role."}]},"events":{"RoleAdminChanged(bytes32,bytes32,bytes32)":{"details":"Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole` `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite {RoleAdminChanged} not being emitted signaling this."},"RoleGranted(bytes32,address,address)":{"details":"Emitted when `account` is granted `role`. `sender` is the account that originated the contract call, an admin role bearer except when using {AccessControl-_setupRole}."},"RoleRevoked(bytes32,address,address)":{"details":"Emitted when `account` is revoked `role`. `sender` is the account that originated the contract call:   - if using `revokeRole`, it is the admin role bearer   - if using `renounceRole`, it is the role bearer (i.e. `account`)"}},"kind":"dev","methods":{"getRoleAdmin(bytes32)":{"details":"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"grantRole(bytes32,address)":{"details":"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleGranted} event."},"hasRole(bytes32,address)":{"details":"Returns `true` if `account` has been granted `role`."},"renounceRole(bytes32,address)":{"details":"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `callerConfirmation`. May emit a {RoleRevoked} event."},"revokeRole(bytes32,address)":{"details":"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleRevoked} event."},"supportsInterface(bytes4)":{"details":"See {IERC165-supportsInterface}."}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"AccessControlBadConfirmation\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"neededRole\",\"type\":\"bytes32\"}],\"name\":\"AccessControlUnauthorizedAccount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"callerConfirmation\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Contract module that allows children to implement role-based access control mechanisms. This is a lightweight version that doesn't allow enumerating role members except through off-chain means by accessing the contract event logs. Some applications may benefit from on-chain enumerability, for those cases see {AccessControlEnumerable}. Roles are referred to by their `bytes32` identifier. These should be exposed in the external API and be unique. The best way to achieve this is by using `public constant` hash digests: ```solidity bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\"); ``` Roles can be used to represent a set of permissions. To restrict access to a function call, use {hasRole}: ```solidity function foo() public {     require(hasRole(MY_ROLE, msg.sender));     ... } ``` Roles can be granted and revoked dynamically via the {grantRole} and {revokeRole} functions. Each role has an associated admin role, and only accounts that have a role's admin role can call {grantRole} and {revokeRole}. By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means that only accounts with this role will be able to grant or revoke other roles. More complex role relationships can be created by using {_setRoleAdmin}. WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to grant and revoke this role. Extra precautions should be taken to secure accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules} to enforce additional security measures for this role.\",\"errors\":{\"AccessControlBadConfirmation()\":[{\"details\":\"The caller of a function is not the expected one. NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\"}],\"AccessControlUnauthorizedAccount(address,bytes32)\":[{\"details\":\"The `account` is missing a role.\"}]},\"events\":{\"RoleAdminChanged(bytes32,bytes32,bytes32)\":{\"details\":\"Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole` `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite {RoleAdminChanged} not being emitted signaling this.\"},\"RoleGranted(bytes32,address,address)\":{\"details\":\"Emitted when `account` is granted `role`. `sender` is the account that originated the contract call, an admin role bearer except when using {AccessControl-_setupRole}.\"},\"RoleRevoked(bytes32,address,address)\":{\"details\":\"Emitted when `account` is revoked `role`. `sender` is the account that originated the contract call:   - if using `revokeRole`, it is the admin role bearer   - if using `renounceRole`, it is the role bearer (i.e. `account`)\"}},\"kind\":\"dev\",\"methods\":{\"getRoleAdmin(bytes32)\":{\"details\":\"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.\"},\"grantRole(bytes32,address)\":{\"details\":\"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleGranted} event.\"},\"hasRole(bytes32,address)\":{\"details\":\"Returns `true` if `account` has been granted `role`.\"},\"renounceRole(bytes32,address)\":{\"details\":\"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `callerConfirmation`. May emit a {RoleRevoked} event.\"},\"revokeRole(bytes32,address)\":{\"details\":\"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleRevoked} event.\"},\"supportsInterface(bytes4)\":{\"details\":\"See {IERC165-supportsInterface}.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/ExampleAppV1.sol\":\"AccessControl\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/ExampleAppV1.sol\":{\"keccak256\":\"0xb1e9550aef785a0afc4e03fc843839919987ba4f906f09992c6788979c3c0396\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://0ede697223dfa3a2e23501efc1ed5926d5ff6458ee7b9ba833e0587162166c79\",\"dweb:/ipfs/QmUzgopL2ptWG5DYNdGAcoErPnBC4KCoRp8C61dkHHRaA6\"]}},\"version\":1}"},"hashes":{"DEFAULT_ADMIN_ROLE()":"a217fddf","getRoleAdmin(bytes32)":"248a9ca3","grantRole(bytes32,address)":"2f2ff15d","hasRole(bytes32,address)":"91d14854","renounceRole(bytes32,address)":"36568abe","revokeRole(bytes32,address)":"d547741f","supportsInterface(bytes4)":"01ffc9a7"}},"solidity/ExampleAppV1.sol:AccessControlEnumerable":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/AbstractICAppEvents.sol\n\nabstract contract AbstractICAppEvents {\n    event InterchainClientAdded(address client);\n    event InterchainClientRemoved(address client);\n    event LatestClientSet(address client);\n}\n\n// contracts/events/InterchainAppV1Events.sol\n\nabstract contract InterchainAppV1Events {\n    event AppConfigV1Set(uint256 requiredResponses, uint256 optimisticPeriod);\n    event AppLinked(uint256 indexed chainId, bytes32 indexed remoteApp);\n    event ExecutionServiceSet(address executionService);\n    event TrustedModuleAdded(address module);\n    event TrustedModuleRemoved(address module);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    /// @notice Allows the Interchain Client to pass the message to the Interchain App.\n    /// @dev App is responsible for keeping track of interchain clients, and must verify the message sender.\n    /// @param srcChainId   Chain ID of the source chain, where the message was sent from.\n    /// @param sender       Sender address on the source chain, as a bytes32 value.\n    /// @param dbNonce      The Interchain DB nonce of the batch containing the message entry.\n    /// @param entryIndex   The index of the message entry within the batch.\n    /// @param message      The message being sent.\n    function appReceive(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /// @notice Returns the verification configuration of the Interchain App.\n    /// @dev This configuration is used by the Interchain Client to verify that message has been confirmed\n    /// by the Interchain Modules on the destination chain.\n    /// Note: V1 version of AppConfig includes the required responses count, and optimistic period after which\n    /// the message is considered confirmed by the module. Following versions may include additional fields.\n    /// @return appConfig    The versioned configuration of the Interchain App, encoded as bytes.\n    /// @return modules      The list of Interchain Modules that app is trusting to confirm the messages.\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/Math.sol\n\nlibrary MathLib {\n    /// @notice Rounds up to the nearest multiple of 32.\n    /// Note: Returns zero on overflows instead of reverting. This is fine for practical\n    /// use cases, as this is used for determining the size of the payload in memory.\n    function roundUpToWord(uint256 x) internal pure returns (uint256) {\n        unchecked {\n            return (x + 31) \u0026 ~uint256(31);\n        }\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/VersionedPayload.sol\n\n// solhint-disable no-inline-assembly\n// solhint-disable ordering\nlibrary VersionedPayloadLib {\n    /// @notice Amount of bytes reserved for the version (uint16) in the versioned payload\n    uint256 internal constant VERSION_LENGTH = 2;\n\n    error VersionedPayload__TooShort(bytes versionedPayload);\n    error VersionedPayload__PrecompileFailed();\n\n    /// @notice Encodes the versioned payload into a single bytes array.\n    /// @param version  The payload's version.\n    /// @param payload  The payload to encode.\n    function encodeVersionedPayload(uint16 version, bytes memory payload) internal pure returns (bytes memory) {\n        return abi.encodePacked(version, payload);\n    }\n\n    /// @notice Extracts the version from the versioned payload (calldata reference).\n    /// @param versionedPayload     The versioned payload (calldata reference).\n    function getVersion(bytes calldata versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            version := shr(240, calldataload(versionedPayload.offset))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (calldata reference).\n    /// @dev The extracted payload is also returned as a calldata reference.\n    /// @param versionedPayload     The versioned payload.\n    function getPayload(bytes calldata versionedPayload) internal pure returns (bytes calldata) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        return versionedPayload[VERSION_LENGTH:];\n    }\n\n    /// @notice Extracts the version from the versioned payload (memory reference).\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getVersionFromMemory(bytes memory versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            // We add 0x20 to skip the length of the bytes array.\n            version := shr(240, mload(add(versionedPayload, 0x20)))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (memory reference).\n    /// @dev The extracted payload is copied into a new memory location. Use `getPayload` when possible\n    /// to avoid extra memory allocation.\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getPayloadFromMemory(bytes memory versionedPayload) internal view returns (bytes memory payload) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        // Figure how many bytes to copy and allocate the memory for the extracted payload.\n        uint256 toCopy;\n        unchecked {\n            toCopy = versionedPayload.length - VERSION_LENGTH;\n        }\n        payload = new bytes(toCopy);\n        // Use identity precompile (0x04) to copy the payload. Unlike MCOPY, this is available on all EVM chains.\n        bool res;\n        assembly {\n            // We add 0x20 to skip the length of the bytes array.\n            // We add 0x02 to skip the 2 bytes reserved for the version.\n            // Copy the payload to the previously allocated memory.\n            res := staticcall(gas(), 0x04, add(versionedPayload, 0x22), toCopy, add(payload, 0x20), toCopy)\n        }\n        if (!res) {\n            revert VersionedPayload__PrecompileFailed();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/IAccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n\n// node_modules/@openzeppelin/contracts/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance \u003c amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance \u003c value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 \u0026\u0026 target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SafeCast.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value \u003e type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value \u003e type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value \u003e type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value \u003e type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value \u003e type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value \u003e type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value \u003e type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value \u003e type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value \u003e type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value \u003e type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value \u003e type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value \u003e type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value \u003e type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value \u003e type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value \u003e type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value \u003e type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value \u003e type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value \u003e type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value \u003e type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value \u003e type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value \u003e type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value \u003e type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value \u003e type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value \u003e type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value \u003e type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value \u003e type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value \u003e type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value \u003e type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value \u003e type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value \u003e type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value \u003e type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value \u003c 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value \u003e uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal view returns (AppConfigV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (AppConfigV1));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal view returns (OptionsV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (OptionsV1));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(OPTIONS_V1, abi.encode(options));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/IAccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/IAccessControlEnumerable.sol)\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n// contracts/interfaces/IInterchainAppV1.sol\n\ninterface IInterchainAppV1 is IInterchainApp {\n    error InterchainApp__AppZeroAddress();\n    error InterchainApp__InvalidAppConfig(uint256 requiredResponses, uint256 optimisticPeriod);\n    error InterchainApp__ModuleAlreadyAdded(address module);\n    error InterchainApp__ModuleNotAdded(address module);\n    error InterchainApp__ModuleZeroAddress();\n    error InterchainApp__NotEVMLinkedApp(bytes32 linkedApp);\n\n    /// @notice Allows the owner to add the interchain client to the allowed clients set,\n    /// and optionally set the latest client to this one.\n    /// Note: only the allowed clients can send messages to this app.\n    /// Note: the latest client is used for sending messages from this app.\n    /// @param client       The address of the interchain client to add.\n    /// @param updateLatest Whether to set the latest client to this one.\n    function addInterchainClient(address client, bool updateLatest) external;\n\n    /// @notice Allows the owner to remove the interchain client from the allowed clients set.\n    /// If the client is the latest client, the latest client is set to the zero address.\n    /// @param client       The address of the interchain client to remove.\n    function removeInterchainClient(address client) external;\n\n    /// @notice Allows the owner to set the address of the latest interchain client.\n    /// @dev The new latest client must be an allowed client or zero address.\n    /// Setting the client to zero address effectively pauses the app ability to send messages,\n    /// while allowing to receive them.\n    /// @param client       The address of the latest interchain client.\n    function setLatestInterchainClient(address client) external;\n\n    /// @notice Allows the owner to link the remote app for the given chain ID.\n    /// - This address will be used as the receiver for the messages sent from this chain.\n    /// - This address will be the only trusted sender for the messages sent to this chain.\n    /// @param chainId      The remote chain ID.\n    /// @param remoteApp    The address of the remote app to link.\n    function linkRemoteApp(uint64 chainId, bytes32 remoteApp) external;\n\n    /// @notice Thin wrapper for `linkRemoteApp` to accept EVM address as a parameter.\n    function linkRemoteAppEVM(uint64 chainId, address remoteApp) external;\n\n    /// @notice Allows the owner to add the module to the trusted modules set.\n    /// - This set of modules will be used to verify both sent and received messages.\n    function addTrustedModule(address module) external;\n\n    /// @notice Allows the owner to remove the module from the trusted modules set.\n    function removeTrustedModule(address module) external;\n\n    /// @notice Allows the owner to set the app config for the current app. App config includes:\n    /// - requiredResponses: the number of module responses required for accepting the message\n    /// - optimisticPeriod: the minimum time after which the module responses are considered final\n    function setAppConfigV1(AppConfigV1 memory appConfig) external;\n\n    /// @notice Allows the owner to set the address of the Execution Service.\n    /// This address will be used to request execution of the messages sent from this chain,\n    /// by supplying the Service's execution fee.\n    function setExecutionService(address executionService) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Returns the app config for the current app: requiredResponses and optimisticPeriod.\n    function getAppConfigV1() external view returns (AppConfigV1 memory);\n\n    /// @notice Returns the address of the Execution Service used by this app for sending messages.\n    function getExecutionService() external view returns (address);\n\n    /// @notice Returns the list of Interchain Clients allowed to send messages to this app.\n    function getInterchainClients() external view returns (address[] memory);\n\n    /// @notice Returns the address of the latest interchain client.\n    /// This address is used for sending messages from this app.\n    function getLatestInterchainClient() external view returns (address);\n\n    /// @notice Returns the linked app address (as bytes32) for the given chain ID.\n    function getLinkedApp(uint64 chainId) external view returns (bytes32);\n\n    /// @notice Thin wrapper for `getLinkedApp` to return the linked app address as EVM address.\n    /// @dev Will revert if the linked app address is not an EVM address.\n    function getLinkedAppEVM(uint64 chainId) external view returns (address);\n\n    /// @notice Returns the list of Interchain Modules trusted by this app.\n    /// This set of modules will be used to verify both sent and received messages.\n    function getModules() external view returns (address[] memory);\n}\n\n// contracts/libs/InterchainTransaction.sol\n\ntype ICTxHeader is uint256;\n\nstruct InterchainTransaction {\n    uint64 srcChainId;\n    uint64 dstChainId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcSender;\n    bytes32 dstReceiver;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    using MathLib for uint256;\n    using VersionedPayloadLib for bytes;\n\n    function constructLocalTransaction(\n        address srcSender,\n        uint64 dstChainId,\n        bytes32 dstReceiver,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: SafeCast.toUint64(block.chainid),\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            encodeTxHeader(transaction.srcChainId, transaction.dstChainId, transaction.dbNonce, transaction.entryIndex),\n            transaction.srcSender,\n            transaction.dstReceiver,\n            transaction.options,\n            transaction.message\n        );\n    }\n\n    function decodeTransaction(bytes calldata transaction) internal pure returns (InterchainTransaction memory icTx) {\n        ICTxHeader header;\n        (header, icTx.srcSender, icTx.dstReceiver, icTx.options, icTx.message) =\n            abi.decode(transaction, (ICTxHeader, bytes32, bytes32, bytes, bytes));\n        (icTx.srcChainId, icTx.dstChainId, icTx.dbNonce, icTx.entryIndex) = decodeTxHeader(header);\n    }\n\n    function payloadSize(uint256 optionsLen, uint256 messageLen) internal pure returns (uint256) {\n        // 2 bytes are reserved for the transaction version\n        // + 5 fields * 32 bytes (3 values for static, 2 offsets for dynamic) + 2 * 32 bytes (lengths for dynamic) = 226\n        // (srcChainId, dstChainId, dbNonce, entryIndex) are merged into a single 32 bytes field\n        // Both options and message are dynamic fields, which are padded up to 32 bytes\n        return 226 + optionsLen.roundUpToWord() + messageLen.roundUpToWord();\n    }\n\n    function encodeTxHeader(\n        uint64 srcChainId,\n        uint64 dstChainId,\n        uint64 dbNonce,\n        uint64 entryIndex\n    )\n        internal\n        pure\n        returns (ICTxHeader)\n    {\n        return ICTxHeader.wrap(\n            (uint256(srcChainId) \u003c\u003c 192) | (uint256(dstChainId) \u003c\u003c 128) | (uint256(dbNonce) \u003c\u003c 64) | uint256(entryIndex)\n        );\n    }\n\n    function decodeTxHeader(ICTxHeader header)\n        internal\n        pure\n        returns (uint64 srcChainId, uint64 dstChainId, uint64 dbNonce, uint64 entryIndex)\n    {\n        srcChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 192);\n        dstChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 128);\n        dbNonce = uint64(ICTxHeader.unwrap(header) \u003e\u003e 64);\n        entryIndex = uint64(ICTxHeader.unwrap(header));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/AccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account =\u003e bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role =\u003e RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint64 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__InvalidTransactionVersion(uint16 version);\n    error InterchainClientV1__NoLinkedClient(uint64 chainId);\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint64 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint64 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint64 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint64 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param messageLen           The length of the message being sent.\n    function getInterchainFee(\n        uint64 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        uint256 messageLen\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint64 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint64 chainId) external view returns (address);\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/AccessControlEnumerable.sol)\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 role =\u003e EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {AccessControl-_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool granted = super._grantRole(role, account);\n        if (granted) {\n            _roleMembers[role].add(account);\n        }\n        return granted;\n    }\n\n    /**\n     * @dev Overload {AccessControl-_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool revoked = super._revokeRole(role, account);\n        if (revoked) {\n            _roleMembers[role].remove(account);\n        }\n        return revoked;\n    }\n}\n\n// contracts/apps/AbstractICApp.sol\n\nabstract contract AbstractICApp is AbstractICAppEvents, IInterchainApp {\n    using TypeCasts for address;\n\n    error InterchainApp__AlreadyLatestClient(address client);\n    error InterchainApp__BalanceTooLow(uint256 actual, uint256 required);\n    error InterchainApp__ClientAlreadyAdded(address client);\n    error InterchainApp__InterchainClientZeroAddress();\n    error InterchainApp__NotInterchainClient(address account);\n    error InterchainApp__ReceiverNotSet(uint64 chainId);\n    error InterchainApp__SameChainId(uint64 chainId);\n    error InterchainApp__SenderNotAllowed(uint64 srcChainId, bytes32 sender);\n\n    /// @inheritdoc IInterchainApp\n    function appReceive(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        if (!_isInterchainClient(msg.sender)) {\n            revert InterchainApp__NotInterchainClient(msg.sender);\n        }\n        if (srcChainId == block.chainid) {\n            revert InterchainApp__SameChainId(srcChainId);\n        }\n        if (!_isAllowedSender(srcChainId, sender)) {\n            revert InterchainApp__SenderNotAllowed(srcChainId, sender);\n        }\n        _receiveMessage(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n\n    /// @inheritdoc IInterchainApp\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules) {\n        appConfig = _getAppConfig();\n        modules = _getModules();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Performs necessary checks and adds an Interchain Client.\n    /// Optionally sets the latest client to this one.\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _addClient(address client, bool updateLatest) internal {\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (_isInterchainClient(client)) {\n            revert InterchainApp__ClientAlreadyAdded(client);\n        }\n        _toggleClientState(client, true);\n        emit InterchainClientAdded(client);\n        if (updateLatest) {\n            _setLatestClient(client);\n        }\n    }\n\n    /// @dev Performs necessary checks and removes an Interchain Client. If this client is the latest one,\n    /// the latest client is set to zero address (effectively pausing the app ability to send messages).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _removeClient(address client) internal {\n        if (!_isInterchainClient(client)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        _toggleClientState(client, false);\n        emit InterchainClientRemoved(client);\n        if (client == _getLatestClient()) {\n            _setLatestClient(address(0));\n        }\n    }\n\n    /// @dev Sets the latest Interchain Client to one of the allowed clients. Setting the client to zero address\n    /// is allowed and effectively pauses the app ability to send messages (but still allows to receive them).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _setLatestClient(address client) internal {\n        // New latest client must be an allowed client or zero address.\n        if (!_isInterchainClient(client) \u0026\u0026 client != address(0)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        if (client == _getLatestClient()) {\n            revert InterchainApp__AlreadyLatestClient(client);\n        }\n        _storeLatestClient(client);\n        emit LatestClientSet(client);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal virtual;\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal virtual;\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to accept EVM address as a parameter.\n    function _sendInterchainMessageEVM(\n        uint64 dstChainId,\n        address receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _sendInterchainMessage(dstChainId, receiver.addressToBytes32(), messageFee, options, message);\n    }\n\n    /// @dev Performs necessary checks and sends an interchain message.\n    function _sendInterchainMessage(\n        uint64 dstChainId,\n        bytes32 receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (dstChainId == block.chainid) {\n            revert InterchainApp__SameChainId(dstChainId);\n        }\n        if (receiver == 0) {\n            revert InterchainApp__ReceiverNotSet(dstChainId);\n        }\n        if (address(this).balance \u003c messageFee) {\n            revert InterchainApp__BalanceTooLow({actual: address(this).balance, required: messageFee});\n        }\n        return IInterchainClientV1(client).interchainSend{value: messageFee}(\n            dstChainId, receiver, _getExecutionService(), _getModules(), options, message\n        );\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        virtual;\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee for sending an Interchain message.\n    function _getInterchainFee(\n        uint64 dstChainId,\n        bytes memory options,\n        uint256 messageLen\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        return IInterchainClientV1(client).getInterchainFee(\n            dstChainId, _getExecutionService(), _getModules(), options, messageLen\n        );\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view virtual returns (bytes memory);\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view virtual returns (address);\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view virtual returns (address);\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view virtual returns (address[] memory);\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint64 srcChainId, bytes32 sender) internal view virtual returns (bool);\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view virtual returns (bool);\n}\n\n// contracts/apps/ICAppV1.sol\n\nabstract contract ICAppV1 is AbstractICApp, AccessControlEnumerable, InterchainAppV1Events, IInterchainAppV1 {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Role to manage the Interchain setup of the app.\n    bytes32 public constant IC_GOVERNOR_ROLE = keccak256(\"IC_GOVERNOR_ROLE\");\n\n    /// @dev Address of the latest Interchain Client, used for sending messages.\n    address private _latestClient;\n\n    /// @dev Required responses and optimistic period for the module responses.\n    AppConfigV1 private _appConfigV1;\n    /// @dev Address of the linked app deployed on the remote chain.\n    mapping(uint64 chainId =\u003e bytes32 remoteApp) private _linkedApp;\n    /// @dev Interchain Clients allowed to send messages to this app.\n    EnumerableSet.AddressSet private _interchainClients;\n    /// @dev Trusted Interchain modules.\n    EnumerableSet.AddressSet private _trustedModules;\n    /// @dev Execution Service to use for sending messages.\n    address private _executionService;\n\n    constructor(address admin) {\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addInterchainClient(address client, bool updateLatest) external onlyRole(IC_GOVERNOR_ROLE) {\n        _addClient(client, updateLatest);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _removeClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setLatestInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _setLatestClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteApp(uint64 chainId, bytes32 remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteAppEVM(uint64 chainId, address remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp.addressToBytes32());\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (module == address(0)) {\n            revert InterchainApp__ModuleZeroAddress();\n        }\n        bool added = _trustedModules.add(module);\n        if (!added) {\n            revert InterchainApp__ModuleAlreadyAdded(module);\n        }\n        emit TrustedModuleAdded(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        bool removed = _trustedModules.remove(module);\n        if (!removed) {\n            revert InterchainApp__ModuleNotAdded(module);\n        }\n        emit TrustedModuleRemoved(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setAppConfigV1(AppConfigV1 memory appConfig) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (appConfig.requiredResponses == 0 || appConfig.optimisticPeriod == 0) {\n            revert InterchainApp__InvalidAppConfig(appConfig.requiredResponses, appConfig.optimisticPeriod);\n        }\n        _appConfigV1 = appConfig;\n        emit AppConfigV1Set(appConfig.requiredResponses, appConfig.optimisticPeriod);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setExecutionService(address executionService) external onlyRole(IC_GOVERNOR_ROLE) {\n        _executionService = executionService;\n        emit ExecutionServiceSet(executionService);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainAppV1\n    function getAppConfigV1() external view returns (AppConfigV1 memory) {\n        return _appConfigV1;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getExecutionService() external view returns (address) {\n        return _executionService;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getInterchainClients() external view returns (address[] memory) {\n        return _interchainClients.values();\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLatestInterchainClient() external view returns (address) {\n        return _latestClient;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedApp(uint64 chainId) external view returns (bytes32) {\n        return _linkedApp[chainId];\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedAppEVM(uint64 chainId) external view returns (address linkedAppEVM) {\n        bytes32 linkedApp = _linkedApp[chainId];\n        linkedAppEVM = linkedApp.bytes32ToAddress();\n        if (linkedAppEVM.addressToBytes32() != linkedApp) {\n            revert InterchainApp__NotEVMLinkedApp(linkedApp);\n        }\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getModules() external view returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Links the remote app to the current app.\n    /// Will revert if the chainId is the same as the chainId of the local app.\n    /// Note: Should be guarded with permissions check.\n    function _linkRemoteApp(uint64 chainId, bytes32 remoteApp) internal {\n        if (chainId == block.chainid) {\n            revert InterchainApp__SameChainId(chainId);\n        }\n        if (remoteApp == 0) {\n            revert InterchainApp__AppZeroAddress();\n        }\n        _linkedApp[chainId] = remoteApp;\n        emit AppLinked(chainId, remoteApp);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal override {\n        _latestClient = client;\n    }\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal override {\n        if (allowed) {\n            _interchainClients.add(client);\n        } else {\n            _interchainClients.remove(client);\n        }\n    }\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to send the message to the linked app.\n    function _sendToLinkedApp(\n        uint64 dstChainId,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _sendInterchainMessage(dstChainId, _linkedApp[dstChainId], messageFee, encodedOptions, message);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee to send a message to the linked app on the remote chain.\n    function _getMessageFee(\n        uint64 dstChainId,\n        OptionsV1 memory options,\n        uint256 messageLen\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _getInterchainFee(dstChainId, encodedOptions, messageLen);\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view override returns (bytes memory) {\n        return _appConfigV1.encodeAppConfigV1();\n    }\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view override returns (address) {\n        return _executionService;\n    }\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view override returns (address) {\n        return _latestClient;\n    }\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view override returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint64 srcChainId, bytes32 sender) internal view override returns (bool) {\n        return _linkedApp[srcChainId] == sender;\n    }\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view override returns (bool) {\n        return _interchainClients.contains(caller);\n    }\n}\n\n// contracts/apps/examples/ExampleAppV1.sol\n\ncontract ExampleAppV1 is ICAppV1 {\n    event MessageReceived(uint64 srcChainId, bytes32 sender, uint64 dbNonce, uint64 entryIndex, bytes message);\n    event MessageSent(uint64 dstChainId, uint64 dbNonce, uint64 entryIndex, bytes32 transactionId);\n\n    constructor(address admin) ICAppV1(admin) {\n        _grantRole(IC_GOVERNOR_ROLE, admin);\n    }\n\n    /// @notice Allows the Admin to withdraw the native asset from the contract.\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        Address.sendValue(payable(msg.sender), address(this).balance);\n    }\n\n    /// @notice Sends a basic message to the destination chain.\n    function sendMessage(\n        uint64 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        InterchainTxDescriptor memory desc = _sendToLinkedApp({\n            dstChainId: dstChainId,\n            messageFee: msg.value,\n            options: OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}),\n            message: message\n        });\n        emit MessageSent(dstChainId, desc.dbNonce, desc.entryIndex, desc.transactionId);\n    }\n\n    /// @notice Returns the fee required to send a message using `sendMessage`.\n    function getMessageFee(\n        uint64 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes memory message\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _getMessageFee(dstChainId, OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}), message.length);\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        override\n    {\n        emit MessageReceived(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[],"name":"AccessControlBadConfirmation","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"bytes32","name":"neededRole","type":"bytes32"}],"name":"AccessControlUnauthorizedAccount","type":"error"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"bytes32","name":"previousAdminRole","type":"bytes32"},{"indexed":true,"internalType":"bytes32","name":"newAdminRole","type":"bytes32"}],"name":"RoleAdminChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":true,"internalType":"address","name":"sender","type":"address"}],"name":"RoleGranted","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":true,"internalType":"address","name":"sender","type":"address"}],"name":"RoleRevoked","type":"event"},{"inputs":[],"name":"DEFAULT_ADMIN_ROLE","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"}],"name":"getRoleAdmin","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"uint256","name":"index","type":"uint256"}],"name":"getRoleMember","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"}],"name":"getRoleMemberCount","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"grantRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"hasRole","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"callerConfirmation","type":"address"}],"name":"renounceRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"revokeRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes4","name":"interfaceId","type":"bytes4"}],"name":"supportsInterface","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"details":"Extension of {AccessControl} that allows enumerating the members of each role.","errors":{"AccessControlBadConfirmation()":[{"details":"The caller of a function is not the expected one. NOTE: Don't confuse with {AccessControlUnauthorizedAccount}."}],"AccessControlUnauthorizedAccount(address,bytes32)":[{"details":"The `account` is missing a role."}]},"events":{"RoleAdminChanged(bytes32,bytes32,bytes32)":{"details":"Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole` `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite {RoleAdminChanged} not being emitted signaling this."},"RoleGranted(bytes32,address,address)":{"details":"Emitted when `account` is granted `role`. `sender` is the account that originated the contract call, an admin role bearer except when using {AccessControl-_setupRole}."},"RoleRevoked(bytes32,address,address)":{"details":"Emitted when `account` is revoked `role`. `sender` is the account that originated the contract call:   - if using `revokeRole`, it is the admin role bearer   - if using `renounceRole`, it is the role bearer (i.e. `account`)"}},"kind":"dev","methods":{"getRoleAdmin(bytes32)":{"details":"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"getRoleMember(bytes32,uint256)":{"details":"Returns one of the accounts that have `role`. `index` must be a value between 0 and {getRoleMemberCount}, non-inclusive. Role bearers are not sorted in any particular way, and their ordering may change at any point. WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure you perform all queries on the same block. See the following https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post] for more information."},"getRoleMemberCount(bytes32)":{"details":"Returns the number of accounts that have `role`. Can be used together with {getRoleMember} to enumerate all bearers of a role."},"grantRole(bytes32,address)":{"details":"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleGranted} event."},"hasRole(bytes32,address)":{"details":"Returns `true` if `account` has been granted `role`."},"renounceRole(bytes32,address)":{"details":"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `callerConfirmation`. May emit a {RoleRevoked} event."},"revokeRole(bytes32,address)":{"details":"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleRevoked} event."},"supportsInterface(bytes4)":{"details":"See {IERC165-supportsInterface}."}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"AccessControlBadConfirmation\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"neededRole\",\"type\":\"bytes32\"}],\"name\":\"AccessControlUnauthorizedAccount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getRoleMember\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleMemberCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"callerConfirmation\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Extension of {AccessControl} that allows enumerating the members of each role.\",\"errors\":{\"AccessControlBadConfirmation()\":[{\"details\":\"The caller of a function is not the expected one. NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\"}],\"AccessControlUnauthorizedAccount(address,bytes32)\":[{\"details\":\"The `account` is missing a role.\"}]},\"events\":{\"RoleAdminChanged(bytes32,bytes32,bytes32)\":{\"details\":\"Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole` `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite {RoleAdminChanged} not being emitted signaling this.\"},\"RoleGranted(bytes32,address,address)\":{\"details\":\"Emitted when `account` is granted `role`. `sender` is the account that originated the contract call, an admin role bearer except when using {AccessControl-_setupRole}.\"},\"RoleRevoked(bytes32,address,address)\":{\"details\":\"Emitted when `account` is revoked `role`. `sender` is the account that originated the contract call:   - if using `revokeRole`, it is the admin role bearer   - if using `renounceRole`, it is the role bearer (i.e. `account`)\"}},\"kind\":\"dev\",\"methods\":{\"getRoleAdmin(bytes32)\":{\"details\":\"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.\"},\"getRoleMember(bytes32,uint256)\":{\"details\":\"Returns one of the accounts that have `role`. `index` must be a value between 0 and {getRoleMemberCount}, non-inclusive. Role bearers are not sorted in any particular way, and their ordering may change at any point. WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure you perform all queries on the same block. See the following https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post] for more information.\"},\"getRoleMemberCount(bytes32)\":{\"details\":\"Returns the number of accounts that have `role`. Can be used together with {getRoleMember} to enumerate all bearers of a role.\"},\"grantRole(bytes32,address)\":{\"details\":\"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleGranted} event.\"},\"hasRole(bytes32,address)\":{\"details\":\"Returns `true` if `account` has been granted `role`.\"},\"renounceRole(bytes32,address)\":{\"details\":\"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `callerConfirmation`. May emit a {RoleRevoked} event.\"},\"revokeRole(bytes32,address)\":{\"details\":\"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleRevoked} event.\"},\"supportsInterface(bytes4)\":{\"details\":\"See {IERC165-supportsInterface}.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/ExampleAppV1.sol\":\"AccessControlEnumerable\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/ExampleAppV1.sol\":{\"keccak256\":\"0xb1e9550aef785a0afc4e03fc843839919987ba4f906f09992c6788979c3c0396\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://0ede697223dfa3a2e23501efc1ed5926d5ff6458ee7b9ba833e0587162166c79\",\"dweb:/ipfs/QmUzgopL2ptWG5DYNdGAcoErPnBC4KCoRp8C61dkHHRaA6\"]}},\"version\":1}"},"hashes":{"DEFAULT_ADMIN_ROLE()":"a217fddf","getRoleAdmin(bytes32)":"248a9ca3","getRoleMember(bytes32,uint256)":"9010d07c","getRoleMemberCount(bytes32)":"ca15c873","grantRole(bytes32,address)":"2f2ff15d","hasRole(bytes32,address)":"91d14854","renounceRole(bytes32,address)":"36568abe","revokeRole(bytes32,address)":"d547741f","supportsInterface(bytes4)":"01ffc9a7"}},"solidity/ExampleAppV1.sol:Address":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220c86b5647abede2e95e02fb0563a3c31ebac92bddbcd7b17efb253d8fe49f8de464736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220c86b5647abede2e95e02fb0563a3c31ebac92bddbcd7b17efb253d8fe49f8de464736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/AbstractICAppEvents.sol\n\nabstract contract AbstractICAppEvents {\n    event InterchainClientAdded(address client);\n    event InterchainClientRemoved(address client);\n    event LatestClientSet(address client);\n}\n\n// contracts/events/InterchainAppV1Events.sol\n\nabstract contract InterchainAppV1Events {\n    event AppConfigV1Set(uint256 requiredResponses, uint256 optimisticPeriod);\n    event AppLinked(uint256 indexed chainId, bytes32 indexed remoteApp);\n    event ExecutionServiceSet(address executionService);\n    event TrustedModuleAdded(address module);\n    event TrustedModuleRemoved(address module);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    /// @notice Allows the Interchain Client to pass the message to the Interchain App.\n    /// @dev App is responsible for keeping track of interchain clients, and must verify the message sender.\n    /// @param srcChainId   Chain ID of the source chain, where the message was sent from.\n    /// @param sender       Sender address on the source chain, as a bytes32 value.\n    /// @param dbNonce      The Interchain DB nonce of the batch containing the message entry.\n    /// @param entryIndex   The index of the message entry within the batch.\n    /// @param message      The message being sent.\n    function appReceive(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /// @notice Returns the verification configuration of the Interchain App.\n    /// @dev This configuration is used by the Interchain Client to verify that message has been confirmed\n    /// by the Interchain Modules on the destination chain.\n    /// Note: V1 version of AppConfig includes the required responses count, and optimistic period after which\n    /// the message is considered confirmed by the module. Following versions may include additional fields.\n    /// @return appConfig    The versioned configuration of the Interchain App, encoded as bytes.\n    /// @return modules      The list of Interchain Modules that app is trusting to confirm the messages.\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/Math.sol\n\nlibrary MathLib {\n    /// @notice Rounds up to the nearest multiple of 32.\n    /// Note: Returns zero on overflows instead of reverting. This is fine for practical\n    /// use cases, as this is used for determining the size of the payload in memory.\n    function roundUpToWord(uint256 x) internal pure returns (uint256) {\n        unchecked {\n            return (x + 31) \u0026 ~uint256(31);\n        }\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/VersionedPayload.sol\n\n// solhint-disable no-inline-assembly\n// solhint-disable ordering\nlibrary VersionedPayloadLib {\n    /// @notice Amount of bytes reserved for the version (uint16) in the versioned payload\n    uint256 internal constant VERSION_LENGTH = 2;\n\n    error VersionedPayload__TooShort(bytes versionedPayload);\n    error VersionedPayload__PrecompileFailed();\n\n    /// @notice Encodes the versioned payload into a single bytes array.\n    /// @param version  The payload's version.\n    /// @param payload  The payload to encode.\n    function encodeVersionedPayload(uint16 version, bytes memory payload) internal pure returns (bytes memory) {\n        return abi.encodePacked(version, payload);\n    }\n\n    /// @notice Extracts the version from the versioned payload (calldata reference).\n    /// @param versionedPayload     The versioned payload (calldata reference).\n    function getVersion(bytes calldata versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            version := shr(240, calldataload(versionedPayload.offset))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (calldata reference).\n    /// @dev The extracted payload is also returned as a calldata reference.\n    /// @param versionedPayload     The versioned payload.\n    function getPayload(bytes calldata versionedPayload) internal pure returns (bytes calldata) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        return versionedPayload[VERSION_LENGTH:];\n    }\n\n    /// @notice Extracts the version from the versioned payload (memory reference).\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getVersionFromMemory(bytes memory versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            // We add 0x20 to skip the length of the bytes array.\n            version := shr(240, mload(add(versionedPayload, 0x20)))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (memory reference).\n    /// @dev The extracted payload is copied into a new memory location. Use `getPayload` when possible\n    /// to avoid extra memory allocation.\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getPayloadFromMemory(bytes memory versionedPayload) internal view returns (bytes memory payload) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        // Figure how many bytes to copy and allocate the memory for the extracted payload.\n        uint256 toCopy;\n        unchecked {\n            toCopy = versionedPayload.length - VERSION_LENGTH;\n        }\n        payload = new bytes(toCopy);\n        // Use identity precompile (0x04) to copy the payload. Unlike MCOPY, this is available on all EVM chains.\n        bool res;\n        assembly {\n            // We add 0x20 to skip the length of the bytes array.\n            // We add 0x02 to skip the 2 bytes reserved for the version.\n            // Copy the payload to the previously allocated memory.\n            res := staticcall(gas(), 0x04, add(versionedPayload, 0x22), toCopy, add(payload, 0x20), toCopy)\n        }\n        if (!res) {\n            revert VersionedPayload__PrecompileFailed();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/IAccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n\n// node_modules/@openzeppelin/contracts/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance \u003c amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance \u003c value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 \u0026\u0026 target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SafeCast.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value \u003e type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value \u003e type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value \u003e type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value \u003e type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value \u003e type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value \u003e type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value \u003e type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value \u003e type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value \u003e type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value \u003e type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value \u003e type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value \u003e type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value \u003e type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value \u003e type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value \u003e type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value \u003e type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value \u003e type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value \u003e type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value \u003e type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value \u003e type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value \u003e type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value \u003e type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value \u003e type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value \u003e type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value \u003e type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value \u003e type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value \u003e type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value \u003e type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value \u003e type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value \u003e type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value \u003e type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value \u003c 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value \u003e uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal view returns (AppConfigV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (AppConfigV1));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal view returns (OptionsV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (OptionsV1));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(OPTIONS_V1, abi.encode(options));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/IAccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/IAccessControlEnumerable.sol)\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n// contracts/interfaces/IInterchainAppV1.sol\n\ninterface IInterchainAppV1 is IInterchainApp {\n    error InterchainApp__AppZeroAddress();\n    error InterchainApp__InvalidAppConfig(uint256 requiredResponses, uint256 optimisticPeriod);\n    error InterchainApp__ModuleAlreadyAdded(address module);\n    error InterchainApp__ModuleNotAdded(address module);\n    error InterchainApp__ModuleZeroAddress();\n    error InterchainApp__NotEVMLinkedApp(bytes32 linkedApp);\n\n    /// @notice Allows the owner to add the interchain client to the allowed clients set,\n    /// and optionally set the latest client to this one.\n    /// Note: only the allowed clients can send messages to this app.\n    /// Note: the latest client is used for sending messages from this app.\n    /// @param client       The address of the interchain client to add.\n    /// @param updateLatest Whether to set the latest client to this one.\n    function addInterchainClient(address client, bool updateLatest) external;\n\n    /// @notice Allows the owner to remove the interchain client from the allowed clients set.\n    /// If the client is the latest client, the latest client is set to the zero address.\n    /// @param client       The address of the interchain client to remove.\n    function removeInterchainClient(address client) external;\n\n    /// @notice Allows the owner to set the address of the latest interchain client.\n    /// @dev The new latest client must be an allowed client or zero address.\n    /// Setting the client to zero address effectively pauses the app ability to send messages,\n    /// while allowing to receive them.\n    /// @param client       The address of the latest interchain client.\n    function setLatestInterchainClient(address client) external;\n\n    /// @notice Allows the owner to link the remote app for the given chain ID.\n    /// - This address will be used as the receiver for the messages sent from this chain.\n    /// - This address will be the only trusted sender for the messages sent to this chain.\n    /// @param chainId      The remote chain ID.\n    /// @param remoteApp    The address of the remote app to link.\n    function linkRemoteApp(uint64 chainId, bytes32 remoteApp) external;\n\n    /// @notice Thin wrapper for `linkRemoteApp` to accept EVM address as a parameter.\n    function linkRemoteAppEVM(uint64 chainId, address remoteApp) external;\n\n    /// @notice Allows the owner to add the module to the trusted modules set.\n    /// - This set of modules will be used to verify both sent and received messages.\n    function addTrustedModule(address module) external;\n\n    /// @notice Allows the owner to remove the module from the trusted modules set.\n    function removeTrustedModule(address module) external;\n\n    /// @notice Allows the owner to set the app config for the current app. App config includes:\n    /// - requiredResponses: the number of module responses required for accepting the message\n    /// - optimisticPeriod: the minimum time after which the module responses are considered final\n    function setAppConfigV1(AppConfigV1 memory appConfig) external;\n\n    /// @notice Allows the owner to set the address of the Execution Service.\n    /// This address will be used to request execution of the messages sent from this chain,\n    /// by supplying the Service's execution fee.\n    function setExecutionService(address executionService) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Returns the app config for the current app: requiredResponses and optimisticPeriod.\n    function getAppConfigV1() external view returns (AppConfigV1 memory);\n\n    /// @notice Returns the address of the Execution Service used by this app for sending messages.\n    function getExecutionService() external view returns (address);\n\n    /// @notice Returns the list of Interchain Clients allowed to send messages to this app.\n    function getInterchainClients() external view returns (address[] memory);\n\n    /// @notice Returns the address of the latest interchain client.\n    /// This address is used for sending messages from this app.\n    function getLatestInterchainClient() external view returns (address);\n\n    /// @notice Returns the linked app address (as bytes32) for the given chain ID.\n    function getLinkedApp(uint64 chainId) external view returns (bytes32);\n\n    /// @notice Thin wrapper for `getLinkedApp` to return the linked app address as EVM address.\n    /// @dev Will revert if the linked app address is not an EVM address.\n    function getLinkedAppEVM(uint64 chainId) external view returns (address);\n\n    /// @notice Returns the list of Interchain Modules trusted by this app.\n    /// This set of modules will be used to verify both sent and received messages.\n    function getModules() external view returns (address[] memory);\n}\n\n// contracts/libs/InterchainTransaction.sol\n\ntype ICTxHeader is uint256;\n\nstruct InterchainTransaction {\n    uint64 srcChainId;\n    uint64 dstChainId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcSender;\n    bytes32 dstReceiver;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    using MathLib for uint256;\n    using VersionedPayloadLib for bytes;\n\n    function constructLocalTransaction(\n        address srcSender,\n        uint64 dstChainId,\n        bytes32 dstReceiver,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: SafeCast.toUint64(block.chainid),\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            encodeTxHeader(transaction.srcChainId, transaction.dstChainId, transaction.dbNonce, transaction.entryIndex),\n            transaction.srcSender,\n            transaction.dstReceiver,\n            transaction.options,\n            transaction.message\n        );\n    }\n\n    function decodeTransaction(bytes calldata transaction) internal pure returns (InterchainTransaction memory icTx) {\n        ICTxHeader header;\n        (header, icTx.srcSender, icTx.dstReceiver, icTx.options, icTx.message) =\n            abi.decode(transaction, (ICTxHeader, bytes32, bytes32, bytes, bytes));\n        (icTx.srcChainId, icTx.dstChainId, icTx.dbNonce, icTx.entryIndex) = decodeTxHeader(header);\n    }\n\n    function payloadSize(uint256 optionsLen, uint256 messageLen) internal pure returns (uint256) {\n        // 2 bytes are reserved for the transaction version\n        // + 5 fields * 32 bytes (3 values for static, 2 offsets for dynamic) + 2 * 32 bytes (lengths for dynamic) = 226\n        // (srcChainId, dstChainId, dbNonce, entryIndex) are merged into a single 32 bytes field\n        // Both options and message are dynamic fields, which are padded up to 32 bytes\n        return 226 + optionsLen.roundUpToWord() + messageLen.roundUpToWord();\n    }\n\n    function encodeTxHeader(\n        uint64 srcChainId,\n        uint64 dstChainId,\n        uint64 dbNonce,\n        uint64 entryIndex\n    )\n        internal\n        pure\n        returns (ICTxHeader)\n    {\n        return ICTxHeader.wrap(\n            (uint256(srcChainId) \u003c\u003c 192) | (uint256(dstChainId) \u003c\u003c 128) | (uint256(dbNonce) \u003c\u003c 64) | uint256(entryIndex)\n        );\n    }\n\n    function decodeTxHeader(ICTxHeader header)\n        internal\n        pure\n        returns (uint64 srcChainId, uint64 dstChainId, uint64 dbNonce, uint64 entryIndex)\n    {\n        srcChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 192);\n        dstChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 128);\n        dbNonce = uint64(ICTxHeader.unwrap(header) \u003e\u003e 64);\n        entryIndex = uint64(ICTxHeader.unwrap(header));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/AccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account =\u003e bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role =\u003e RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint64 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__InvalidTransactionVersion(uint16 version);\n    error InterchainClientV1__NoLinkedClient(uint64 chainId);\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint64 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint64 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint64 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint64 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param messageLen           The length of the message being sent.\n    function getInterchainFee(\n        uint64 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        uint256 messageLen\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint64 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint64 chainId) external view returns (address);\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/AccessControlEnumerable.sol)\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 role =\u003e EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {AccessControl-_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool granted = super._grantRole(role, account);\n        if (granted) {\n            _roleMembers[role].add(account);\n        }\n        return granted;\n    }\n\n    /**\n     * @dev Overload {AccessControl-_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool revoked = super._revokeRole(role, account);\n        if (revoked) {\n            _roleMembers[role].remove(account);\n        }\n        return revoked;\n    }\n}\n\n// contracts/apps/AbstractICApp.sol\n\nabstract contract AbstractICApp is AbstractICAppEvents, IInterchainApp {\n    using TypeCasts for address;\n\n    error InterchainApp__AlreadyLatestClient(address client);\n    error InterchainApp__BalanceTooLow(uint256 actual, uint256 required);\n    error InterchainApp__ClientAlreadyAdded(address client);\n    error InterchainApp__InterchainClientZeroAddress();\n    error InterchainApp__NotInterchainClient(address account);\n    error InterchainApp__ReceiverNotSet(uint64 chainId);\n    error InterchainApp__SameChainId(uint64 chainId);\n    error InterchainApp__SenderNotAllowed(uint64 srcChainId, bytes32 sender);\n\n    /// @inheritdoc IInterchainApp\n    function appReceive(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        if (!_isInterchainClient(msg.sender)) {\n            revert InterchainApp__NotInterchainClient(msg.sender);\n        }\n        if (srcChainId == block.chainid) {\n            revert InterchainApp__SameChainId(srcChainId);\n        }\n        if (!_isAllowedSender(srcChainId, sender)) {\n            revert InterchainApp__SenderNotAllowed(srcChainId, sender);\n        }\n        _receiveMessage(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n\n    /// @inheritdoc IInterchainApp\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules) {\n        appConfig = _getAppConfig();\n        modules = _getModules();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Performs necessary checks and adds an Interchain Client.\n    /// Optionally sets the latest client to this one.\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _addClient(address client, bool updateLatest) internal {\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (_isInterchainClient(client)) {\n            revert InterchainApp__ClientAlreadyAdded(client);\n        }\n        _toggleClientState(client, true);\n        emit InterchainClientAdded(client);\n        if (updateLatest) {\n            _setLatestClient(client);\n        }\n    }\n\n    /// @dev Performs necessary checks and removes an Interchain Client. If this client is the latest one,\n    /// the latest client is set to zero address (effectively pausing the app ability to send messages).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _removeClient(address client) internal {\n        if (!_isInterchainClient(client)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        _toggleClientState(client, false);\n        emit InterchainClientRemoved(client);\n        if (client == _getLatestClient()) {\n            _setLatestClient(address(0));\n        }\n    }\n\n    /// @dev Sets the latest Interchain Client to one of the allowed clients. Setting the client to zero address\n    /// is allowed and effectively pauses the app ability to send messages (but still allows to receive them).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _setLatestClient(address client) internal {\n        // New latest client must be an allowed client or zero address.\n        if (!_isInterchainClient(client) \u0026\u0026 client != address(0)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        if (client == _getLatestClient()) {\n            revert InterchainApp__AlreadyLatestClient(client);\n        }\n        _storeLatestClient(client);\n        emit LatestClientSet(client);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal virtual;\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal virtual;\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to accept EVM address as a parameter.\n    function _sendInterchainMessageEVM(\n        uint64 dstChainId,\n        address receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _sendInterchainMessage(dstChainId, receiver.addressToBytes32(), messageFee, options, message);\n    }\n\n    /// @dev Performs necessary checks and sends an interchain message.\n    function _sendInterchainMessage(\n        uint64 dstChainId,\n        bytes32 receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (dstChainId == block.chainid) {\n            revert InterchainApp__SameChainId(dstChainId);\n        }\n        if (receiver == 0) {\n            revert InterchainApp__ReceiverNotSet(dstChainId);\n        }\n        if (address(this).balance \u003c messageFee) {\n            revert InterchainApp__BalanceTooLow({actual: address(this).balance, required: messageFee});\n        }\n        return IInterchainClientV1(client).interchainSend{value: messageFee}(\n            dstChainId, receiver, _getExecutionService(), _getModules(), options, message\n        );\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        virtual;\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee for sending an Interchain message.\n    function _getInterchainFee(\n        uint64 dstChainId,\n        bytes memory options,\n        uint256 messageLen\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        return IInterchainClientV1(client).getInterchainFee(\n            dstChainId, _getExecutionService(), _getModules(), options, messageLen\n        );\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view virtual returns (bytes memory);\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view virtual returns (address);\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view virtual returns (address);\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view virtual returns (address[] memory);\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint64 srcChainId, bytes32 sender) internal view virtual returns (bool);\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view virtual returns (bool);\n}\n\n// contracts/apps/ICAppV1.sol\n\nabstract contract ICAppV1 is AbstractICApp, AccessControlEnumerable, InterchainAppV1Events, IInterchainAppV1 {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Role to manage the Interchain setup of the app.\n    bytes32 public constant IC_GOVERNOR_ROLE = keccak256(\"IC_GOVERNOR_ROLE\");\n\n    /// @dev Address of the latest Interchain Client, used for sending messages.\n    address private _latestClient;\n\n    /// @dev Required responses and optimistic period for the module responses.\n    AppConfigV1 private _appConfigV1;\n    /// @dev Address of the linked app deployed on the remote chain.\n    mapping(uint64 chainId =\u003e bytes32 remoteApp) private _linkedApp;\n    /// @dev Interchain Clients allowed to send messages to this app.\n    EnumerableSet.AddressSet private _interchainClients;\n    /// @dev Trusted Interchain modules.\n    EnumerableSet.AddressSet private _trustedModules;\n    /// @dev Execution Service to use for sending messages.\n    address private _executionService;\n\n    constructor(address admin) {\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addInterchainClient(address client, bool updateLatest) external onlyRole(IC_GOVERNOR_ROLE) {\n        _addClient(client, updateLatest);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _removeClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setLatestInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _setLatestClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteApp(uint64 chainId, bytes32 remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteAppEVM(uint64 chainId, address remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp.addressToBytes32());\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (module == address(0)) {\n            revert InterchainApp__ModuleZeroAddress();\n        }\n        bool added = _trustedModules.add(module);\n        if (!added) {\n            revert InterchainApp__ModuleAlreadyAdded(module);\n        }\n        emit TrustedModuleAdded(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        bool removed = _trustedModules.remove(module);\n        if (!removed) {\n            revert InterchainApp__ModuleNotAdded(module);\n        }\n        emit TrustedModuleRemoved(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setAppConfigV1(AppConfigV1 memory appConfig) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (appConfig.requiredResponses == 0 || appConfig.optimisticPeriod == 0) {\n            revert InterchainApp__InvalidAppConfig(appConfig.requiredResponses, appConfig.optimisticPeriod);\n        }\n        _appConfigV1 = appConfig;\n        emit AppConfigV1Set(appConfig.requiredResponses, appConfig.optimisticPeriod);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setExecutionService(address executionService) external onlyRole(IC_GOVERNOR_ROLE) {\n        _executionService = executionService;\n        emit ExecutionServiceSet(executionService);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainAppV1\n    function getAppConfigV1() external view returns (AppConfigV1 memory) {\n        return _appConfigV1;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getExecutionService() external view returns (address) {\n        return _executionService;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getInterchainClients() external view returns (address[] memory) {\n        return _interchainClients.values();\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLatestInterchainClient() external view returns (address) {\n        return _latestClient;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedApp(uint64 chainId) external view returns (bytes32) {\n        return _linkedApp[chainId];\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedAppEVM(uint64 chainId) external view returns (address linkedAppEVM) {\n        bytes32 linkedApp = _linkedApp[chainId];\n        linkedAppEVM = linkedApp.bytes32ToAddress();\n        if (linkedAppEVM.addressToBytes32() != linkedApp) {\n            revert InterchainApp__NotEVMLinkedApp(linkedApp);\n        }\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getModules() external view returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Links the remote app to the current app.\n    /// Will revert if the chainId is the same as the chainId of the local app.\n    /// Note: Should be guarded with permissions check.\n    function _linkRemoteApp(uint64 chainId, bytes32 remoteApp) internal {\n        if (chainId == block.chainid) {\n            revert InterchainApp__SameChainId(chainId);\n        }\n        if (remoteApp == 0) {\n            revert InterchainApp__AppZeroAddress();\n        }\n        _linkedApp[chainId] = remoteApp;\n        emit AppLinked(chainId, remoteApp);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal override {\n        _latestClient = client;\n    }\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal override {\n        if (allowed) {\n            _interchainClients.add(client);\n        } else {\n            _interchainClients.remove(client);\n        }\n    }\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to send the message to the linked app.\n    function _sendToLinkedApp(\n        uint64 dstChainId,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _sendInterchainMessage(dstChainId, _linkedApp[dstChainId], messageFee, encodedOptions, message);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee to send a message to the linked app on the remote chain.\n    function _getMessageFee(\n        uint64 dstChainId,\n        OptionsV1 memory options,\n        uint256 messageLen\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _getInterchainFee(dstChainId, encodedOptions, messageLen);\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view override returns (bytes memory) {\n        return _appConfigV1.encodeAppConfigV1();\n    }\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view override returns (address) {\n        return _executionService;\n    }\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view override returns (address) {\n        return _latestClient;\n    }\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view override returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint64 srcChainId, bytes32 sender) internal view override returns (bool) {\n        return _linkedApp[srcChainId] == sender;\n    }\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view override returns (bool) {\n        return _interchainClients.contains(caller);\n    }\n}\n\n// contracts/apps/examples/ExampleAppV1.sol\n\ncontract ExampleAppV1 is ICAppV1 {\n    event MessageReceived(uint64 srcChainId, bytes32 sender, uint64 dbNonce, uint64 entryIndex, bytes message);\n    event MessageSent(uint64 dstChainId, uint64 dbNonce, uint64 entryIndex, bytes32 transactionId);\n\n    constructor(address admin) ICAppV1(admin) {\n        _grantRole(IC_GOVERNOR_ROLE, admin);\n    }\n\n    /// @notice Allows the Admin to withdraw the native asset from the contract.\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        Address.sendValue(payable(msg.sender), address(this).balance);\n    }\n\n    /// @notice Sends a basic message to the destination chain.\n    function sendMessage(\n        uint64 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        InterchainTxDescriptor memory desc = _sendToLinkedApp({\n            dstChainId: dstChainId,\n            messageFee: msg.value,\n            options: OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}),\n            message: message\n        });\n        emit MessageSent(dstChainId, desc.dbNonce, desc.entryIndex, desc.transactionId);\n    }\n\n    /// @notice Returns the fee required to send a message using `sendMessage`.\n    function getMessageFee(\n        uint64 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes memory message\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _getMessageFee(dstChainId, OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}), message.length);\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        override\n    {\n        emit MessageReceived(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"10520:6066:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;10520:6066:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"10520:6066:0:-:0;;;;;;;;","abiDefinition":[{"inputs":[{"internalType":"address","name":"target","type":"address"}],"name":"AddressEmptyCode","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"AddressInsufficientBalance","type":"error"},{"inputs":[],"name":"FailedInnerCall","type":"error"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"details":"Collection of functions related to the address type","errors":{"AddressEmptyCode(address)":[{"details":"There's no code at `target` (it is not a contract)."}],"AddressInsufficientBalance(address)":[{"details":"The ETH balance of the account is not enough to perform the operation."}],"FailedInnerCall()":[{"details":"A call to an address target failed. The target may have reverted."}]},"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"AddressEmptyCode\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AddressInsufficientBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FailedInnerCall\",\"type\":\"error\"}],\"devdoc\":{\"details\":\"Collection of functions related to the address type\",\"errors\":{\"AddressEmptyCode(address)\":[{\"details\":\"There's no code at `target` (it is not a contract).\"}],\"AddressInsufficientBalance(address)\":[{\"details\":\"The ETH balance of the account is not enough to perform the operation.\"}],\"FailedInnerCall()\":[{\"details\":\"A call to an address target failed. The target may have reverted.\"}]},\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/ExampleAppV1.sol\":\"Address\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/ExampleAppV1.sol\":{\"keccak256\":\"0xb1e9550aef785a0afc4e03fc843839919987ba4f906f09992c6788979c3c0396\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://0ede697223dfa3a2e23501efc1ed5926d5ff6458ee7b9ba833e0587162166c79\",\"dweb:/ipfs/QmUzgopL2ptWG5DYNdGAcoErPnBC4KCoRp8C61dkHHRaA6\"]}},\"version\":1}"},"hashes":{}},"solidity/ExampleAppV1.sol:AppConfigLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212207f5a5fc2b1b57d902f5269f0f64b9691427845200fda18736bce7a8f8b0c461f64736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212207f5a5fc2b1b57d902f5269f0f64b9691427845200fda18736bce7a8f8b0c461f64736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/AbstractICAppEvents.sol\n\nabstract contract AbstractICAppEvents {\n    event InterchainClientAdded(address client);\n    event InterchainClientRemoved(address client);\n    event LatestClientSet(address client);\n}\n\n// contracts/events/InterchainAppV1Events.sol\n\nabstract contract InterchainAppV1Events {\n    event AppConfigV1Set(uint256 requiredResponses, uint256 optimisticPeriod);\n    event AppLinked(uint256 indexed chainId, bytes32 indexed remoteApp);\n    event ExecutionServiceSet(address executionService);\n    event TrustedModuleAdded(address module);\n    event TrustedModuleRemoved(address module);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    /// @notice Allows the Interchain Client to pass the message to the Interchain App.\n    /// @dev App is responsible for keeping track of interchain clients, and must verify the message sender.\n    /// @param srcChainId   Chain ID of the source chain, where the message was sent from.\n    /// @param sender       Sender address on the source chain, as a bytes32 value.\n    /// @param dbNonce      The Interchain DB nonce of the batch containing the message entry.\n    /// @param entryIndex   The index of the message entry within the batch.\n    /// @param message      The message being sent.\n    function appReceive(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /// @notice Returns the verification configuration of the Interchain App.\n    /// @dev This configuration is used by the Interchain Client to verify that message has been confirmed\n    /// by the Interchain Modules on the destination chain.\n    /// Note: V1 version of AppConfig includes the required responses count, and optimistic period after which\n    /// the message is considered confirmed by the module. Following versions may include additional fields.\n    /// @return appConfig    The versioned configuration of the Interchain App, encoded as bytes.\n    /// @return modules      The list of Interchain Modules that app is trusting to confirm the messages.\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/Math.sol\n\nlibrary MathLib {\n    /// @notice Rounds up to the nearest multiple of 32.\n    /// Note: Returns zero on overflows instead of reverting. This is fine for practical\n    /// use cases, as this is used for determining the size of the payload in memory.\n    function roundUpToWord(uint256 x) internal pure returns (uint256) {\n        unchecked {\n            return (x + 31) \u0026 ~uint256(31);\n        }\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/VersionedPayload.sol\n\n// solhint-disable no-inline-assembly\n// solhint-disable ordering\nlibrary VersionedPayloadLib {\n    /// @notice Amount of bytes reserved for the version (uint16) in the versioned payload\n    uint256 internal constant VERSION_LENGTH = 2;\n\n    error VersionedPayload__TooShort(bytes versionedPayload);\n    error VersionedPayload__PrecompileFailed();\n\n    /// @notice Encodes the versioned payload into a single bytes array.\n    /// @param version  The payload's version.\n    /// @param payload  The payload to encode.\n    function encodeVersionedPayload(uint16 version, bytes memory payload) internal pure returns (bytes memory) {\n        return abi.encodePacked(version, payload);\n    }\n\n    /// @notice Extracts the version from the versioned payload (calldata reference).\n    /// @param versionedPayload     The versioned payload (calldata reference).\n    function getVersion(bytes calldata versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            version := shr(240, calldataload(versionedPayload.offset))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (calldata reference).\n    /// @dev The extracted payload is also returned as a calldata reference.\n    /// @param versionedPayload     The versioned payload.\n    function getPayload(bytes calldata versionedPayload) internal pure returns (bytes calldata) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        return versionedPayload[VERSION_LENGTH:];\n    }\n\n    /// @notice Extracts the version from the versioned payload (memory reference).\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getVersionFromMemory(bytes memory versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            // We add 0x20 to skip the length of the bytes array.\n            version := shr(240, mload(add(versionedPayload, 0x20)))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (memory reference).\n    /// @dev The extracted payload is copied into a new memory location. Use `getPayload` when possible\n    /// to avoid extra memory allocation.\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getPayloadFromMemory(bytes memory versionedPayload) internal view returns (bytes memory payload) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        // Figure how many bytes to copy and allocate the memory for the extracted payload.\n        uint256 toCopy;\n        unchecked {\n            toCopy = versionedPayload.length - VERSION_LENGTH;\n        }\n        payload = new bytes(toCopy);\n        // Use identity precompile (0x04) to copy the payload. Unlike MCOPY, this is available on all EVM chains.\n        bool res;\n        assembly {\n            // We add 0x20 to skip the length of the bytes array.\n            // We add 0x02 to skip the 2 bytes reserved for the version.\n            // Copy the payload to the previously allocated memory.\n            res := staticcall(gas(), 0x04, add(versionedPayload, 0x22), toCopy, add(payload, 0x20), toCopy)\n        }\n        if (!res) {\n            revert VersionedPayload__PrecompileFailed();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/IAccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n\n// node_modules/@openzeppelin/contracts/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance \u003c amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance \u003c value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 \u0026\u0026 target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SafeCast.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value \u003e type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value \u003e type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value \u003e type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value \u003e type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value \u003e type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value \u003e type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value \u003e type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value \u003e type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value \u003e type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value \u003e type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value \u003e type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value \u003e type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value \u003e type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value \u003e type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value \u003e type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value \u003e type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value \u003e type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value \u003e type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value \u003e type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value \u003e type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value \u003e type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value \u003e type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value \u003e type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value \u003e type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value \u003e type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value \u003e type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value \u003e type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value \u003e type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value \u003e type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value \u003e type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value \u003e type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value \u003c 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value \u003e uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal view returns (AppConfigV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (AppConfigV1));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal view returns (OptionsV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (OptionsV1));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(OPTIONS_V1, abi.encode(options));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/IAccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/IAccessControlEnumerable.sol)\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n// contracts/interfaces/IInterchainAppV1.sol\n\ninterface IInterchainAppV1 is IInterchainApp {\n    error InterchainApp__AppZeroAddress();\n    error InterchainApp__InvalidAppConfig(uint256 requiredResponses, uint256 optimisticPeriod);\n    error InterchainApp__ModuleAlreadyAdded(address module);\n    error InterchainApp__ModuleNotAdded(address module);\n    error InterchainApp__ModuleZeroAddress();\n    error InterchainApp__NotEVMLinkedApp(bytes32 linkedApp);\n\n    /// @notice Allows the owner to add the interchain client to the allowed clients set,\n    /// and optionally set the latest client to this one.\n    /// Note: only the allowed clients can send messages to this app.\n    /// Note: the latest client is used for sending messages from this app.\n    /// @param client       The address of the interchain client to add.\n    /// @param updateLatest Whether to set the latest client to this one.\n    function addInterchainClient(address client, bool updateLatest) external;\n\n    /// @notice Allows the owner to remove the interchain client from the allowed clients set.\n    /// If the client is the latest client, the latest client is set to the zero address.\n    /// @param client       The address of the interchain client to remove.\n    function removeInterchainClient(address client) external;\n\n    /// @notice Allows the owner to set the address of the latest interchain client.\n    /// @dev The new latest client must be an allowed client or zero address.\n    /// Setting the client to zero address effectively pauses the app ability to send messages,\n    /// while allowing to receive them.\n    /// @param client       The address of the latest interchain client.\n    function setLatestInterchainClient(address client) external;\n\n    /// @notice Allows the owner to link the remote app for the given chain ID.\n    /// - This address will be used as the receiver for the messages sent from this chain.\n    /// - This address will be the only trusted sender for the messages sent to this chain.\n    /// @param chainId      The remote chain ID.\n    /// @param remoteApp    The address of the remote app to link.\n    function linkRemoteApp(uint64 chainId, bytes32 remoteApp) external;\n\n    /// @notice Thin wrapper for `linkRemoteApp` to accept EVM address as a parameter.\n    function linkRemoteAppEVM(uint64 chainId, address remoteApp) external;\n\n    /// @notice Allows the owner to add the module to the trusted modules set.\n    /// - This set of modules will be used to verify both sent and received messages.\n    function addTrustedModule(address module) external;\n\n    /// @notice Allows the owner to remove the module from the trusted modules set.\n    function removeTrustedModule(address module) external;\n\n    /// @notice Allows the owner to set the app config for the current app. App config includes:\n    /// - requiredResponses: the number of module responses required for accepting the message\n    /// - optimisticPeriod: the minimum time after which the module responses are considered final\n    function setAppConfigV1(AppConfigV1 memory appConfig) external;\n\n    /// @notice Allows the owner to set the address of the Execution Service.\n    /// This address will be used to request execution of the messages sent from this chain,\n    /// by supplying the Service's execution fee.\n    function setExecutionService(address executionService) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Returns the app config for the current app: requiredResponses and optimisticPeriod.\n    function getAppConfigV1() external view returns (AppConfigV1 memory);\n\n    /// @notice Returns the address of the Execution Service used by this app for sending messages.\n    function getExecutionService() external view returns (address);\n\n    /// @notice Returns the list of Interchain Clients allowed to send messages to this app.\n    function getInterchainClients() external view returns (address[] memory);\n\n    /// @notice Returns the address of the latest interchain client.\n    /// This address is used for sending messages from this app.\n    function getLatestInterchainClient() external view returns (address);\n\n    /// @notice Returns the linked app address (as bytes32) for the given chain ID.\n    function getLinkedApp(uint64 chainId) external view returns (bytes32);\n\n    /// @notice Thin wrapper for `getLinkedApp` to return the linked app address as EVM address.\n    /// @dev Will revert if the linked app address is not an EVM address.\n    function getLinkedAppEVM(uint64 chainId) external view returns (address);\n\n    /// @notice Returns the list of Interchain Modules trusted by this app.\n    /// This set of modules will be used to verify both sent and received messages.\n    function getModules() external view returns (address[] memory);\n}\n\n// contracts/libs/InterchainTransaction.sol\n\ntype ICTxHeader is uint256;\n\nstruct InterchainTransaction {\n    uint64 srcChainId;\n    uint64 dstChainId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcSender;\n    bytes32 dstReceiver;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    using MathLib for uint256;\n    using VersionedPayloadLib for bytes;\n\n    function constructLocalTransaction(\n        address srcSender,\n        uint64 dstChainId,\n        bytes32 dstReceiver,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: SafeCast.toUint64(block.chainid),\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            encodeTxHeader(transaction.srcChainId, transaction.dstChainId, transaction.dbNonce, transaction.entryIndex),\n            transaction.srcSender,\n            transaction.dstReceiver,\n            transaction.options,\n            transaction.message\n        );\n    }\n\n    function decodeTransaction(bytes calldata transaction) internal pure returns (InterchainTransaction memory icTx) {\n        ICTxHeader header;\n        (header, icTx.srcSender, icTx.dstReceiver, icTx.options, icTx.message) =\n            abi.decode(transaction, (ICTxHeader, bytes32, bytes32, bytes, bytes));\n        (icTx.srcChainId, icTx.dstChainId, icTx.dbNonce, icTx.entryIndex) = decodeTxHeader(header);\n    }\n\n    function payloadSize(uint256 optionsLen, uint256 messageLen) internal pure returns (uint256) {\n        // 2 bytes are reserved for the transaction version\n        // + 5 fields * 32 bytes (3 values for static, 2 offsets for dynamic) + 2 * 32 bytes (lengths for dynamic) = 226\n        // (srcChainId, dstChainId, dbNonce, entryIndex) are merged into a single 32 bytes field\n        // Both options and message are dynamic fields, which are padded up to 32 bytes\n        return 226 + optionsLen.roundUpToWord() + messageLen.roundUpToWord();\n    }\n\n    function encodeTxHeader(\n        uint64 srcChainId,\n        uint64 dstChainId,\n        uint64 dbNonce,\n        uint64 entryIndex\n    )\n        internal\n        pure\n        returns (ICTxHeader)\n    {\n        return ICTxHeader.wrap(\n            (uint256(srcChainId) \u003c\u003c 192) | (uint256(dstChainId) \u003c\u003c 128) | (uint256(dbNonce) \u003c\u003c 64) | uint256(entryIndex)\n        );\n    }\n\n    function decodeTxHeader(ICTxHeader header)\n        internal\n        pure\n        returns (uint64 srcChainId, uint64 dstChainId, uint64 dbNonce, uint64 entryIndex)\n    {\n        srcChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 192);\n        dstChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 128);\n        dbNonce = uint64(ICTxHeader.unwrap(header) \u003e\u003e 64);\n        entryIndex = uint64(ICTxHeader.unwrap(header));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/AccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account =\u003e bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role =\u003e RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint64 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__InvalidTransactionVersion(uint16 version);\n    error InterchainClientV1__NoLinkedClient(uint64 chainId);\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint64 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint64 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint64 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint64 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param messageLen           The length of the message being sent.\n    function getInterchainFee(\n        uint64 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        uint256 messageLen\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint64 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint64 chainId) external view returns (address);\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/AccessControlEnumerable.sol)\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 role =\u003e EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {AccessControl-_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool granted = super._grantRole(role, account);\n        if (granted) {\n            _roleMembers[role].add(account);\n        }\n        return granted;\n    }\n\n    /**\n     * @dev Overload {AccessControl-_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool revoked = super._revokeRole(role, account);\n        if (revoked) {\n            _roleMembers[role].remove(account);\n        }\n        return revoked;\n    }\n}\n\n// contracts/apps/AbstractICApp.sol\n\nabstract contract AbstractICApp is AbstractICAppEvents, IInterchainApp {\n    using TypeCasts for address;\n\n    error InterchainApp__AlreadyLatestClient(address client);\n    error InterchainApp__BalanceTooLow(uint256 actual, uint256 required);\n    error InterchainApp__ClientAlreadyAdded(address client);\n    error InterchainApp__InterchainClientZeroAddress();\n    error InterchainApp__NotInterchainClient(address account);\n    error InterchainApp__ReceiverNotSet(uint64 chainId);\n    error InterchainApp__SameChainId(uint64 chainId);\n    error InterchainApp__SenderNotAllowed(uint64 srcChainId, bytes32 sender);\n\n    /// @inheritdoc IInterchainApp\n    function appReceive(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        if (!_isInterchainClient(msg.sender)) {\n            revert InterchainApp__NotInterchainClient(msg.sender);\n        }\n        if (srcChainId == block.chainid) {\n            revert InterchainApp__SameChainId(srcChainId);\n        }\n        if (!_isAllowedSender(srcChainId, sender)) {\n            revert InterchainApp__SenderNotAllowed(srcChainId, sender);\n        }\n        _receiveMessage(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n\n    /// @inheritdoc IInterchainApp\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules) {\n        appConfig = _getAppConfig();\n        modules = _getModules();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Performs necessary checks and adds an Interchain Client.\n    /// Optionally sets the latest client to this one.\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _addClient(address client, bool updateLatest) internal {\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (_isInterchainClient(client)) {\n            revert InterchainApp__ClientAlreadyAdded(client);\n        }\n        _toggleClientState(client, true);\n        emit InterchainClientAdded(client);\n        if (updateLatest) {\n            _setLatestClient(client);\n        }\n    }\n\n    /// @dev Performs necessary checks and removes an Interchain Client. If this client is the latest one,\n    /// the latest client is set to zero address (effectively pausing the app ability to send messages).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _removeClient(address client) internal {\n        if (!_isInterchainClient(client)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        _toggleClientState(client, false);\n        emit InterchainClientRemoved(client);\n        if (client == _getLatestClient()) {\n            _setLatestClient(address(0));\n        }\n    }\n\n    /// @dev Sets the latest Interchain Client to one of the allowed clients. Setting the client to zero address\n    /// is allowed and effectively pauses the app ability to send messages (but still allows to receive them).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _setLatestClient(address client) internal {\n        // New latest client must be an allowed client or zero address.\n        if (!_isInterchainClient(client) \u0026\u0026 client != address(0)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        if (client == _getLatestClient()) {\n            revert InterchainApp__AlreadyLatestClient(client);\n        }\n        _storeLatestClient(client);\n        emit LatestClientSet(client);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal virtual;\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal virtual;\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to accept EVM address as a parameter.\n    function _sendInterchainMessageEVM(\n        uint64 dstChainId,\n        address receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _sendInterchainMessage(dstChainId, receiver.addressToBytes32(), messageFee, options, message);\n    }\n\n    /// @dev Performs necessary checks and sends an interchain message.\n    function _sendInterchainMessage(\n        uint64 dstChainId,\n        bytes32 receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (dstChainId == block.chainid) {\n            revert InterchainApp__SameChainId(dstChainId);\n        }\n        if (receiver == 0) {\n            revert InterchainApp__ReceiverNotSet(dstChainId);\n        }\n        if (address(this).balance \u003c messageFee) {\n            revert InterchainApp__BalanceTooLow({actual: address(this).balance, required: messageFee});\n        }\n        return IInterchainClientV1(client).interchainSend{value: messageFee}(\n            dstChainId, receiver, _getExecutionService(), _getModules(), options, message\n        );\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        virtual;\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee for sending an Interchain message.\n    function _getInterchainFee(\n        uint64 dstChainId,\n        bytes memory options,\n        uint256 messageLen\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        return IInterchainClientV1(client).getInterchainFee(\n            dstChainId, _getExecutionService(), _getModules(), options, messageLen\n        );\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view virtual returns (bytes memory);\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view virtual returns (address);\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view virtual returns (address);\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view virtual returns (address[] memory);\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint64 srcChainId, bytes32 sender) internal view virtual returns (bool);\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view virtual returns (bool);\n}\n\n// contracts/apps/ICAppV1.sol\n\nabstract contract ICAppV1 is AbstractICApp, AccessControlEnumerable, InterchainAppV1Events, IInterchainAppV1 {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Role to manage the Interchain setup of the app.\n    bytes32 public constant IC_GOVERNOR_ROLE = keccak256(\"IC_GOVERNOR_ROLE\");\n\n    /// @dev Address of the latest Interchain Client, used for sending messages.\n    address private _latestClient;\n\n    /// @dev Required responses and optimistic period for the module responses.\n    AppConfigV1 private _appConfigV1;\n    /// @dev Address of the linked app deployed on the remote chain.\n    mapping(uint64 chainId =\u003e bytes32 remoteApp) private _linkedApp;\n    /// @dev Interchain Clients allowed to send messages to this app.\n    EnumerableSet.AddressSet private _interchainClients;\n    /// @dev Trusted Interchain modules.\n    EnumerableSet.AddressSet private _trustedModules;\n    /// @dev Execution Service to use for sending messages.\n    address private _executionService;\n\n    constructor(address admin) {\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addInterchainClient(address client, bool updateLatest) external onlyRole(IC_GOVERNOR_ROLE) {\n        _addClient(client, updateLatest);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _removeClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setLatestInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _setLatestClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteApp(uint64 chainId, bytes32 remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteAppEVM(uint64 chainId, address remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp.addressToBytes32());\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (module == address(0)) {\n            revert InterchainApp__ModuleZeroAddress();\n        }\n        bool added = _trustedModules.add(module);\n        if (!added) {\n            revert InterchainApp__ModuleAlreadyAdded(module);\n        }\n        emit TrustedModuleAdded(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        bool removed = _trustedModules.remove(module);\n        if (!removed) {\n            revert InterchainApp__ModuleNotAdded(module);\n        }\n        emit TrustedModuleRemoved(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setAppConfigV1(AppConfigV1 memory appConfig) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (appConfig.requiredResponses == 0 || appConfig.optimisticPeriod == 0) {\n            revert InterchainApp__InvalidAppConfig(appConfig.requiredResponses, appConfig.optimisticPeriod);\n        }\n        _appConfigV1 = appConfig;\n        emit AppConfigV1Set(appConfig.requiredResponses, appConfig.optimisticPeriod);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setExecutionService(address executionService) external onlyRole(IC_GOVERNOR_ROLE) {\n        _executionService = executionService;\n        emit ExecutionServiceSet(executionService);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainAppV1\n    function getAppConfigV1() external view returns (AppConfigV1 memory) {\n        return _appConfigV1;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getExecutionService() external view returns (address) {\n        return _executionService;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getInterchainClients() external view returns (address[] memory) {\n        return _interchainClients.values();\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLatestInterchainClient() external view returns (address) {\n        return _latestClient;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedApp(uint64 chainId) external view returns (bytes32) {\n        return _linkedApp[chainId];\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedAppEVM(uint64 chainId) external view returns (address linkedAppEVM) {\n        bytes32 linkedApp = _linkedApp[chainId];\n        linkedAppEVM = linkedApp.bytes32ToAddress();\n        if (linkedAppEVM.addressToBytes32() != linkedApp) {\n            revert InterchainApp__NotEVMLinkedApp(linkedApp);\n        }\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getModules() external view returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Links the remote app to the current app.\n    /// Will revert if the chainId is the same as the chainId of the local app.\n    /// Note: Should be guarded with permissions check.\n    function _linkRemoteApp(uint64 chainId, bytes32 remoteApp) internal {\n        if (chainId == block.chainid) {\n            revert InterchainApp__SameChainId(chainId);\n        }\n        if (remoteApp == 0) {\n            revert InterchainApp__AppZeroAddress();\n        }\n        _linkedApp[chainId] = remoteApp;\n        emit AppLinked(chainId, remoteApp);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal override {\n        _latestClient = client;\n    }\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal override {\n        if (allowed) {\n            _interchainClients.add(client);\n        } else {\n            _interchainClients.remove(client);\n        }\n    }\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to send the message to the linked app.\n    function _sendToLinkedApp(\n        uint64 dstChainId,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _sendInterchainMessage(dstChainId, _linkedApp[dstChainId], messageFee, encodedOptions, message);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee to send a message to the linked app on the remote chain.\n    function _getMessageFee(\n        uint64 dstChainId,\n        OptionsV1 memory options,\n        uint256 messageLen\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _getInterchainFee(dstChainId, encodedOptions, messageLen);\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view override returns (bytes memory) {\n        return _appConfigV1.encodeAppConfigV1();\n    }\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view override returns (address) {\n        return _executionService;\n    }\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view override returns (address) {\n        return _latestClient;\n    }\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view override returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint64 srcChainId, bytes32 sender) internal view override returns (bool) {\n        return _linkedApp[srcChainId] == sender;\n    }\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view override returns (bool) {\n        return _interchainClients.contains(caller);\n    }\n}\n\n// contracts/apps/examples/ExampleAppV1.sol\n\ncontract ExampleAppV1 is ICAppV1 {\n    event MessageReceived(uint64 srcChainId, bytes32 sender, uint64 dbNonce, uint64 entryIndex, bytes message);\n    event MessageSent(uint64 dstChainId, uint64 dbNonce, uint64 entryIndex, bytes32 transactionId);\n\n    constructor(address admin) ICAppV1(admin) {\n        _grantRole(IC_GOVERNOR_ROLE, admin);\n    }\n\n    /// @notice Allows the Admin to withdraw the native asset from the contract.\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        Address.sendValue(payable(msg.sender), address(this).balance);\n    }\n\n    /// @notice Sends a basic message to the destination chain.\n    function sendMessage(\n        uint64 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        InterchainTxDescriptor memory desc = _sendToLinkedApp({\n            dstChainId: dstChainId,\n            messageFee: msg.value,\n            options: OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}),\n            message: message\n        });\n        emit MessageSent(dstChainId, desc.dbNonce, desc.entryIndex, desc.transactionId);\n    }\n\n    /// @notice Returns the fee required to send a message using `sendMessage`.\n    function getMessageFee(\n        uint64 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes memory message\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _getMessageFee(dstChainId, OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}), message.length);\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        override\n    {\n        emit MessageReceived(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"66287:1275:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;66287:1275:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"66287:1275:0:-:0;;;;;;;;","abiDefinition":[{"inputs":[{"internalType":"uint16","name":"version","type":"uint16"}],"name":"AppConfigLib__IncorrectVersion","type":"error"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"version\",\"type\":\"uint16\"}],\"name\":\"AppConfigLib__IncorrectVersion\",\"type\":\"error\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/ExampleAppV1.sol\":\"AppConfigLib\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/ExampleAppV1.sol\":{\"keccak256\":\"0xb1e9550aef785a0afc4e03fc843839919987ba4f906f09992c6788979c3c0396\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://0ede697223dfa3a2e23501efc1ed5926d5ff6458ee7b9ba833e0587162166c79\",\"dweb:/ipfs/QmUzgopL2ptWG5DYNdGAcoErPnBC4KCoRp8C61dkHHRaA6\"]}},\"version\":1}"},"hashes":{}},"solidity/ExampleAppV1.sol:Context":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/AbstractICAppEvents.sol\n\nabstract contract AbstractICAppEvents {\n    event InterchainClientAdded(address client);\n    event InterchainClientRemoved(address client);\n    event LatestClientSet(address client);\n}\n\n// contracts/events/InterchainAppV1Events.sol\n\nabstract contract InterchainAppV1Events {\n    event AppConfigV1Set(uint256 requiredResponses, uint256 optimisticPeriod);\n    event AppLinked(uint256 indexed chainId, bytes32 indexed remoteApp);\n    event ExecutionServiceSet(address executionService);\n    event TrustedModuleAdded(address module);\n    event TrustedModuleRemoved(address module);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    /// @notice Allows the Interchain Client to pass the message to the Interchain App.\n    /// @dev App is responsible for keeping track of interchain clients, and must verify the message sender.\n    /// @param srcChainId   Chain ID of the source chain, where the message was sent from.\n    /// @param sender       Sender address on the source chain, as a bytes32 value.\n    /// @param dbNonce      The Interchain DB nonce of the batch containing the message entry.\n    /// @param entryIndex   The index of the message entry within the batch.\n    /// @param message      The message being sent.\n    function appReceive(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /// @notice Returns the verification configuration of the Interchain App.\n    /// @dev This configuration is used by the Interchain Client to verify that message has been confirmed\n    /// by the Interchain Modules on the destination chain.\n    /// Note: V1 version of AppConfig includes the required responses count, and optimistic period after which\n    /// the message is considered confirmed by the module. Following versions may include additional fields.\n    /// @return appConfig    The versioned configuration of the Interchain App, encoded as bytes.\n    /// @return modules      The list of Interchain Modules that app is trusting to confirm the messages.\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/Math.sol\n\nlibrary MathLib {\n    /// @notice Rounds up to the nearest multiple of 32.\n    /// Note: Returns zero on overflows instead of reverting. This is fine for practical\n    /// use cases, as this is used for determining the size of the payload in memory.\n    function roundUpToWord(uint256 x) internal pure returns (uint256) {\n        unchecked {\n            return (x + 31) \u0026 ~uint256(31);\n        }\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/VersionedPayload.sol\n\n// solhint-disable no-inline-assembly\n// solhint-disable ordering\nlibrary VersionedPayloadLib {\n    /// @notice Amount of bytes reserved for the version (uint16) in the versioned payload\n    uint256 internal constant VERSION_LENGTH = 2;\n\n    error VersionedPayload__TooShort(bytes versionedPayload);\n    error VersionedPayload__PrecompileFailed();\n\n    /// @notice Encodes the versioned payload into a single bytes array.\n    /// @param version  The payload's version.\n    /// @param payload  The payload to encode.\n    function encodeVersionedPayload(uint16 version, bytes memory payload) internal pure returns (bytes memory) {\n        return abi.encodePacked(version, payload);\n    }\n\n    /// @notice Extracts the version from the versioned payload (calldata reference).\n    /// @param versionedPayload     The versioned payload (calldata reference).\n    function getVersion(bytes calldata versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            version := shr(240, calldataload(versionedPayload.offset))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (calldata reference).\n    /// @dev The extracted payload is also returned as a calldata reference.\n    /// @param versionedPayload     The versioned payload.\n    function getPayload(bytes calldata versionedPayload) internal pure returns (bytes calldata) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        return versionedPayload[VERSION_LENGTH:];\n    }\n\n    /// @notice Extracts the version from the versioned payload (memory reference).\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getVersionFromMemory(bytes memory versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            // We add 0x20 to skip the length of the bytes array.\n            version := shr(240, mload(add(versionedPayload, 0x20)))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (memory reference).\n    /// @dev The extracted payload is copied into a new memory location. Use `getPayload` when possible\n    /// to avoid extra memory allocation.\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getPayloadFromMemory(bytes memory versionedPayload) internal view returns (bytes memory payload) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        // Figure how many bytes to copy and allocate the memory for the extracted payload.\n        uint256 toCopy;\n        unchecked {\n            toCopy = versionedPayload.length - VERSION_LENGTH;\n        }\n        payload = new bytes(toCopy);\n        // Use identity precompile (0x04) to copy the payload. Unlike MCOPY, this is available on all EVM chains.\n        bool res;\n        assembly {\n            // We add 0x20 to skip the length of the bytes array.\n            // We add 0x02 to skip the 2 bytes reserved for the version.\n            // Copy the payload to the previously allocated memory.\n            res := staticcall(gas(), 0x04, add(versionedPayload, 0x22), toCopy, add(payload, 0x20), toCopy)\n        }\n        if (!res) {\n            revert VersionedPayload__PrecompileFailed();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/IAccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n\n// node_modules/@openzeppelin/contracts/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance \u003c amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance \u003c value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 \u0026\u0026 target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SafeCast.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value \u003e type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value \u003e type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value \u003e type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value \u003e type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value \u003e type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value \u003e type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value \u003e type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value \u003e type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value \u003e type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value \u003e type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value \u003e type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value \u003e type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value \u003e type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value \u003e type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value \u003e type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value \u003e type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value \u003e type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value \u003e type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value \u003e type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value \u003e type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value \u003e type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value \u003e type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value \u003e type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value \u003e type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value \u003e type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value \u003e type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value \u003e type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value \u003e type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value \u003e type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value \u003e type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value \u003e type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value \u003c 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value \u003e uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal view returns (AppConfigV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (AppConfigV1));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal view returns (OptionsV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (OptionsV1));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(OPTIONS_V1, abi.encode(options));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/IAccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/IAccessControlEnumerable.sol)\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n// contracts/interfaces/IInterchainAppV1.sol\n\ninterface IInterchainAppV1 is IInterchainApp {\n    error InterchainApp__AppZeroAddress();\n    error InterchainApp__InvalidAppConfig(uint256 requiredResponses, uint256 optimisticPeriod);\n    error InterchainApp__ModuleAlreadyAdded(address module);\n    error InterchainApp__ModuleNotAdded(address module);\n    error InterchainApp__ModuleZeroAddress();\n    error InterchainApp__NotEVMLinkedApp(bytes32 linkedApp);\n\n    /// @notice Allows the owner to add the interchain client to the allowed clients set,\n    /// and optionally set the latest client to this one.\n    /// Note: only the allowed clients can send messages to this app.\n    /// Note: the latest client is used for sending messages from this app.\n    /// @param client       The address of the interchain client to add.\n    /// @param updateLatest Whether to set the latest client to this one.\n    function addInterchainClient(address client, bool updateLatest) external;\n\n    /// @notice Allows the owner to remove the interchain client from the allowed clients set.\n    /// If the client is the latest client, the latest client is set to the zero address.\n    /// @param client       The address of the interchain client to remove.\n    function removeInterchainClient(address client) external;\n\n    /// @notice Allows the owner to set the address of the latest interchain client.\n    /// @dev The new latest client must be an allowed client or zero address.\n    /// Setting the client to zero address effectively pauses the app ability to send messages,\n    /// while allowing to receive them.\n    /// @param client       The address of the latest interchain client.\n    function setLatestInterchainClient(address client) external;\n\n    /// @notice Allows the owner to link the remote app for the given chain ID.\n    /// - This address will be used as the receiver for the messages sent from this chain.\n    /// - This address will be the only trusted sender for the messages sent to this chain.\n    /// @param chainId      The remote chain ID.\n    /// @param remoteApp    The address of the remote app to link.\n    function linkRemoteApp(uint64 chainId, bytes32 remoteApp) external;\n\n    /// @notice Thin wrapper for `linkRemoteApp` to accept EVM address as a parameter.\n    function linkRemoteAppEVM(uint64 chainId, address remoteApp) external;\n\n    /// @notice Allows the owner to add the module to the trusted modules set.\n    /// - This set of modules will be used to verify both sent and received messages.\n    function addTrustedModule(address module) external;\n\n    /// @notice Allows the owner to remove the module from the trusted modules set.\n    function removeTrustedModule(address module) external;\n\n    /// @notice Allows the owner to set the app config for the current app. App config includes:\n    /// - requiredResponses: the number of module responses required for accepting the message\n    /// - optimisticPeriod: the minimum time after which the module responses are considered final\n    function setAppConfigV1(AppConfigV1 memory appConfig) external;\n\n    /// @notice Allows the owner to set the address of the Execution Service.\n    /// This address will be used to request execution of the messages sent from this chain,\n    /// by supplying the Service's execution fee.\n    function setExecutionService(address executionService) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Returns the app config for the current app: requiredResponses and optimisticPeriod.\n    function getAppConfigV1() external view returns (AppConfigV1 memory);\n\n    /// @notice Returns the address of the Execution Service used by this app for sending messages.\n    function getExecutionService() external view returns (address);\n\n    /// @notice Returns the list of Interchain Clients allowed to send messages to this app.\n    function getInterchainClients() external view returns (address[] memory);\n\n    /// @notice Returns the address of the latest interchain client.\n    /// This address is used for sending messages from this app.\n    function getLatestInterchainClient() external view returns (address);\n\n    /// @notice Returns the linked app address (as bytes32) for the given chain ID.\n    function getLinkedApp(uint64 chainId) external view returns (bytes32);\n\n    /// @notice Thin wrapper for `getLinkedApp` to return the linked app address as EVM address.\n    /// @dev Will revert if the linked app address is not an EVM address.\n    function getLinkedAppEVM(uint64 chainId) external view returns (address);\n\n    /// @notice Returns the list of Interchain Modules trusted by this app.\n    /// This set of modules will be used to verify both sent and received messages.\n    function getModules() external view returns (address[] memory);\n}\n\n// contracts/libs/InterchainTransaction.sol\n\ntype ICTxHeader is uint256;\n\nstruct InterchainTransaction {\n    uint64 srcChainId;\n    uint64 dstChainId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcSender;\n    bytes32 dstReceiver;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    using MathLib for uint256;\n    using VersionedPayloadLib for bytes;\n\n    function constructLocalTransaction(\n        address srcSender,\n        uint64 dstChainId,\n        bytes32 dstReceiver,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: SafeCast.toUint64(block.chainid),\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            encodeTxHeader(transaction.srcChainId, transaction.dstChainId, transaction.dbNonce, transaction.entryIndex),\n            transaction.srcSender,\n            transaction.dstReceiver,\n            transaction.options,\n            transaction.message\n        );\n    }\n\n    function decodeTransaction(bytes calldata transaction) internal pure returns (InterchainTransaction memory icTx) {\n        ICTxHeader header;\n        (header, icTx.srcSender, icTx.dstReceiver, icTx.options, icTx.message) =\n            abi.decode(transaction, (ICTxHeader, bytes32, bytes32, bytes, bytes));\n        (icTx.srcChainId, icTx.dstChainId, icTx.dbNonce, icTx.entryIndex) = decodeTxHeader(header);\n    }\n\n    function payloadSize(uint256 optionsLen, uint256 messageLen) internal pure returns (uint256) {\n        // 2 bytes are reserved for the transaction version\n        // + 5 fields * 32 bytes (3 values for static, 2 offsets for dynamic) + 2 * 32 bytes (lengths for dynamic) = 226\n        // (srcChainId, dstChainId, dbNonce, entryIndex) are merged into a single 32 bytes field\n        // Both options and message are dynamic fields, which are padded up to 32 bytes\n        return 226 + optionsLen.roundUpToWord() + messageLen.roundUpToWord();\n    }\n\n    function encodeTxHeader(\n        uint64 srcChainId,\n        uint64 dstChainId,\n        uint64 dbNonce,\n        uint64 entryIndex\n    )\n        internal\n        pure\n        returns (ICTxHeader)\n    {\n        return ICTxHeader.wrap(\n            (uint256(srcChainId) \u003c\u003c 192) | (uint256(dstChainId) \u003c\u003c 128) | (uint256(dbNonce) \u003c\u003c 64) | uint256(entryIndex)\n        );\n    }\n\n    function decodeTxHeader(ICTxHeader header)\n        internal\n        pure\n        returns (uint64 srcChainId, uint64 dstChainId, uint64 dbNonce, uint64 entryIndex)\n    {\n        srcChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 192);\n        dstChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 128);\n        dbNonce = uint64(ICTxHeader.unwrap(header) \u003e\u003e 64);\n        entryIndex = uint64(ICTxHeader.unwrap(header));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/AccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account =\u003e bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role =\u003e RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint64 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__InvalidTransactionVersion(uint16 version);\n    error InterchainClientV1__NoLinkedClient(uint64 chainId);\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint64 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint64 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint64 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint64 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param messageLen           The length of the message being sent.\n    function getInterchainFee(\n        uint64 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        uint256 messageLen\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint64 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint64 chainId) external view returns (address);\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/AccessControlEnumerable.sol)\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 role =\u003e EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {AccessControl-_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool granted = super._grantRole(role, account);\n        if (granted) {\n            _roleMembers[role].add(account);\n        }\n        return granted;\n    }\n\n    /**\n     * @dev Overload {AccessControl-_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool revoked = super._revokeRole(role, account);\n        if (revoked) {\n            _roleMembers[role].remove(account);\n        }\n        return revoked;\n    }\n}\n\n// contracts/apps/AbstractICApp.sol\n\nabstract contract AbstractICApp is AbstractICAppEvents, IInterchainApp {\n    using TypeCasts for address;\n\n    error InterchainApp__AlreadyLatestClient(address client);\n    error InterchainApp__BalanceTooLow(uint256 actual, uint256 required);\n    error InterchainApp__ClientAlreadyAdded(address client);\n    error InterchainApp__InterchainClientZeroAddress();\n    error InterchainApp__NotInterchainClient(address account);\n    error InterchainApp__ReceiverNotSet(uint64 chainId);\n    error InterchainApp__SameChainId(uint64 chainId);\n    error InterchainApp__SenderNotAllowed(uint64 srcChainId, bytes32 sender);\n\n    /// @inheritdoc IInterchainApp\n    function appReceive(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        if (!_isInterchainClient(msg.sender)) {\n            revert InterchainApp__NotInterchainClient(msg.sender);\n        }\n        if (srcChainId == block.chainid) {\n            revert InterchainApp__SameChainId(srcChainId);\n        }\n        if (!_isAllowedSender(srcChainId, sender)) {\n            revert InterchainApp__SenderNotAllowed(srcChainId, sender);\n        }\n        _receiveMessage(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n\n    /// @inheritdoc IInterchainApp\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules) {\n        appConfig = _getAppConfig();\n        modules = _getModules();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Performs necessary checks and adds an Interchain Client.\n    /// Optionally sets the latest client to this one.\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _addClient(address client, bool updateLatest) internal {\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (_isInterchainClient(client)) {\n            revert InterchainApp__ClientAlreadyAdded(client);\n        }\n        _toggleClientState(client, true);\n        emit InterchainClientAdded(client);\n        if (updateLatest) {\n            _setLatestClient(client);\n        }\n    }\n\n    /// @dev Performs necessary checks and removes an Interchain Client. If this client is the latest one,\n    /// the latest client is set to zero address (effectively pausing the app ability to send messages).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _removeClient(address client) internal {\n        if (!_isInterchainClient(client)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        _toggleClientState(client, false);\n        emit InterchainClientRemoved(client);\n        if (client == _getLatestClient()) {\n            _setLatestClient(address(0));\n        }\n    }\n\n    /// @dev Sets the latest Interchain Client to one of the allowed clients. Setting the client to zero address\n    /// is allowed and effectively pauses the app ability to send messages (but still allows to receive them).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _setLatestClient(address client) internal {\n        // New latest client must be an allowed client or zero address.\n        if (!_isInterchainClient(client) \u0026\u0026 client != address(0)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        if (client == _getLatestClient()) {\n            revert InterchainApp__AlreadyLatestClient(client);\n        }\n        _storeLatestClient(client);\n        emit LatestClientSet(client);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal virtual;\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal virtual;\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to accept EVM address as a parameter.\n    function _sendInterchainMessageEVM(\n        uint64 dstChainId,\n        address receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _sendInterchainMessage(dstChainId, receiver.addressToBytes32(), messageFee, options, message);\n    }\n\n    /// @dev Performs necessary checks and sends an interchain message.\n    function _sendInterchainMessage(\n        uint64 dstChainId,\n        bytes32 receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (dstChainId == block.chainid) {\n            revert InterchainApp__SameChainId(dstChainId);\n        }\n        if (receiver == 0) {\n            revert InterchainApp__ReceiverNotSet(dstChainId);\n        }\n        if (address(this).balance \u003c messageFee) {\n            revert InterchainApp__BalanceTooLow({actual: address(this).balance, required: messageFee});\n        }\n        return IInterchainClientV1(client).interchainSend{value: messageFee}(\n            dstChainId, receiver, _getExecutionService(), _getModules(), options, message\n        );\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        virtual;\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee for sending an Interchain message.\n    function _getInterchainFee(\n        uint64 dstChainId,\n        bytes memory options,\n        uint256 messageLen\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        return IInterchainClientV1(client).getInterchainFee(\n            dstChainId, _getExecutionService(), _getModules(), options, messageLen\n        );\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view virtual returns (bytes memory);\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view virtual returns (address);\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view virtual returns (address);\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view virtual returns (address[] memory);\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint64 srcChainId, bytes32 sender) internal view virtual returns (bool);\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view virtual returns (bool);\n}\n\n// contracts/apps/ICAppV1.sol\n\nabstract contract ICAppV1 is AbstractICApp, AccessControlEnumerable, InterchainAppV1Events, IInterchainAppV1 {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Role to manage the Interchain setup of the app.\n    bytes32 public constant IC_GOVERNOR_ROLE = keccak256(\"IC_GOVERNOR_ROLE\");\n\n    /// @dev Address of the latest Interchain Client, used for sending messages.\n    address private _latestClient;\n\n    /// @dev Required responses and optimistic period for the module responses.\n    AppConfigV1 private _appConfigV1;\n    /// @dev Address of the linked app deployed on the remote chain.\n    mapping(uint64 chainId =\u003e bytes32 remoteApp) private _linkedApp;\n    /// @dev Interchain Clients allowed to send messages to this app.\n    EnumerableSet.AddressSet private _interchainClients;\n    /// @dev Trusted Interchain modules.\n    EnumerableSet.AddressSet private _trustedModules;\n    /// @dev Execution Service to use for sending messages.\n    address private _executionService;\n\n    constructor(address admin) {\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addInterchainClient(address client, bool updateLatest) external onlyRole(IC_GOVERNOR_ROLE) {\n        _addClient(client, updateLatest);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _removeClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setLatestInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _setLatestClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteApp(uint64 chainId, bytes32 remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteAppEVM(uint64 chainId, address remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp.addressToBytes32());\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (module == address(0)) {\n            revert InterchainApp__ModuleZeroAddress();\n        }\n        bool added = _trustedModules.add(module);\n        if (!added) {\n            revert InterchainApp__ModuleAlreadyAdded(module);\n        }\n        emit TrustedModuleAdded(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        bool removed = _trustedModules.remove(module);\n        if (!removed) {\n            revert InterchainApp__ModuleNotAdded(module);\n        }\n        emit TrustedModuleRemoved(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setAppConfigV1(AppConfigV1 memory appConfig) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (appConfig.requiredResponses == 0 || appConfig.optimisticPeriod == 0) {\n            revert InterchainApp__InvalidAppConfig(appConfig.requiredResponses, appConfig.optimisticPeriod);\n        }\n        _appConfigV1 = appConfig;\n        emit AppConfigV1Set(appConfig.requiredResponses, appConfig.optimisticPeriod);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setExecutionService(address executionService) external onlyRole(IC_GOVERNOR_ROLE) {\n        _executionService = executionService;\n        emit ExecutionServiceSet(executionService);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainAppV1\n    function getAppConfigV1() external view returns (AppConfigV1 memory) {\n        return _appConfigV1;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getExecutionService() external view returns (address) {\n        return _executionService;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getInterchainClients() external view returns (address[] memory) {\n        return _interchainClients.values();\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLatestInterchainClient() external view returns (address) {\n        return _latestClient;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedApp(uint64 chainId) external view returns (bytes32) {\n        return _linkedApp[chainId];\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedAppEVM(uint64 chainId) external view returns (address linkedAppEVM) {\n        bytes32 linkedApp = _linkedApp[chainId];\n        linkedAppEVM = linkedApp.bytes32ToAddress();\n        if (linkedAppEVM.addressToBytes32() != linkedApp) {\n            revert InterchainApp__NotEVMLinkedApp(linkedApp);\n        }\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getModules() external view returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Links the remote app to the current app.\n    /// Will revert if the chainId is the same as the chainId of the local app.\n    /// Note: Should be guarded with permissions check.\n    function _linkRemoteApp(uint64 chainId, bytes32 remoteApp) internal {\n        if (chainId == block.chainid) {\n            revert InterchainApp__SameChainId(chainId);\n        }\n        if (remoteApp == 0) {\n            revert InterchainApp__AppZeroAddress();\n        }\n        _linkedApp[chainId] = remoteApp;\n        emit AppLinked(chainId, remoteApp);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal override {\n        _latestClient = client;\n    }\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal override {\n        if (allowed) {\n            _interchainClients.add(client);\n        } else {\n            _interchainClients.remove(client);\n        }\n    }\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to send the message to the linked app.\n    function _sendToLinkedApp(\n        uint64 dstChainId,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _sendInterchainMessage(dstChainId, _linkedApp[dstChainId], messageFee, encodedOptions, message);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee to send a message to the linked app on the remote chain.\n    function _getMessageFee(\n        uint64 dstChainId,\n        OptionsV1 memory options,\n        uint256 messageLen\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _getInterchainFee(dstChainId, encodedOptions, messageLen);\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view override returns (bytes memory) {\n        return _appConfigV1.encodeAppConfigV1();\n    }\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view override returns (address) {\n        return _executionService;\n    }\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view override returns (address) {\n        return _latestClient;\n    }\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view override returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint64 srcChainId, bytes32 sender) internal view override returns (bool) {\n        return _linkedApp[srcChainId] == sender;\n    }\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view override returns (bool) {\n        return _interchainClients.contains(caller);\n    }\n}\n\n// contracts/apps/examples/ExampleAppV1.sol\n\ncontract ExampleAppV1 is ICAppV1 {\n    event MessageReceived(uint64 srcChainId, bytes32 sender, uint64 dbNonce, uint64 entryIndex, bytes message);\n    event MessageSent(uint64 dstChainId, uint64 dbNonce, uint64 entryIndex, bytes32 transactionId);\n\n    constructor(address admin) ICAppV1(admin) {\n        _grantRole(IC_GOVERNOR_ROLE, admin);\n    }\n\n    /// @notice Allows the Admin to withdraw the native asset from the contract.\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        Address.sendValue(payable(msg.sender), address(this).balance);\n    }\n\n    /// @notice Sends a basic message to the destination chain.\n    function sendMessage(\n        uint64 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        InterchainTxDescriptor memory desc = _sendToLinkedApp({\n            dstChainId: dstChainId,\n            messageFee: msg.value,\n            options: OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}),\n            message: message\n        });\n        emit MessageSent(dstChainId, desc.dbNonce, desc.entryIndex, desc.transactionId);\n    }\n\n    /// @notice Returns the fee required to send a message using `sendMessage`.\n    function getMessageFee(\n        uint64 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes memory message\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _getMessageFee(dstChainId, OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}), message.length);\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        override\n    {\n        emit MessageReceived(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"details":"Provides information about the current execution context, including the sender of the transaction and its data. While these are generally available via msg.sender and msg.data, they should not be accessed in such a direct manner, since when dealing with meta-transactions the account sending and paying for execution may not be the actual sender (as far as an application is concerned). This contract is only required for intermediate, library-like contracts.","kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"details\":\"Provides information about the current execution context, including the sender of the transaction and its data. While these are generally available via msg.sender and msg.data, they should not be accessed in such a direct manner, since when dealing with meta-transactions the account sending and paying for execution may not be the actual sender (as far as an application is concerned). This contract is only required for intermediate, library-like contracts.\",\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/ExampleAppV1.sol\":\"Context\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/ExampleAppV1.sol\":{\"keccak256\":\"0xb1e9550aef785a0afc4e03fc843839919987ba4f906f09992c6788979c3c0396\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://0ede697223dfa3a2e23501efc1ed5926d5ff6458ee7b9ba833e0587162166c79\",\"dweb:/ipfs/QmUzgopL2ptWG5DYNdGAcoErPnBC4KCoRp8C61dkHHRaA6\"]}},\"version\":1}"},"hashes":{}},"solidity/ExampleAppV1.sol:ERC165":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/AbstractICAppEvents.sol\n\nabstract contract AbstractICAppEvents {\n    event InterchainClientAdded(address client);\n    event InterchainClientRemoved(address client);\n    event LatestClientSet(address client);\n}\n\n// contracts/events/InterchainAppV1Events.sol\n\nabstract contract InterchainAppV1Events {\n    event AppConfigV1Set(uint256 requiredResponses, uint256 optimisticPeriod);\n    event AppLinked(uint256 indexed chainId, bytes32 indexed remoteApp);\n    event ExecutionServiceSet(address executionService);\n    event TrustedModuleAdded(address module);\n    event TrustedModuleRemoved(address module);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    /// @notice Allows the Interchain Client to pass the message to the Interchain App.\n    /// @dev App is responsible for keeping track of interchain clients, and must verify the message sender.\n    /// @param srcChainId   Chain ID of the source chain, where the message was sent from.\n    /// @param sender       Sender address on the source chain, as a bytes32 value.\n    /// @param dbNonce      The Interchain DB nonce of the batch containing the message entry.\n    /// @param entryIndex   The index of the message entry within the batch.\n    /// @param message      The message being sent.\n    function appReceive(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /// @notice Returns the verification configuration of the Interchain App.\n    /// @dev This configuration is used by the Interchain Client to verify that message has been confirmed\n    /// by the Interchain Modules on the destination chain.\n    /// Note: V1 version of AppConfig includes the required responses count, and optimistic period after which\n    /// the message is considered confirmed by the module. Following versions may include additional fields.\n    /// @return appConfig    The versioned configuration of the Interchain App, encoded as bytes.\n    /// @return modules      The list of Interchain Modules that app is trusting to confirm the messages.\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/Math.sol\n\nlibrary MathLib {\n    /// @notice Rounds up to the nearest multiple of 32.\n    /// Note: Returns zero on overflows instead of reverting. This is fine for practical\n    /// use cases, as this is used for determining the size of the payload in memory.\n    function roundUpToWord(uint256 x) internal pure returns (uint256) {\n        unchecked {\n            return (x + 31) \u0026 ~uint256(31);\n        }\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/VersionedPayload.sol\n\n// solhint-disable no-inline-assembly\n// solhint-disable ordering\nlibrary VersionedPayloadLib {\n    /// @notice Amount of bytes reserved for the version (uint16) in the versioned payload\n    uint256 internal constant VERSION_LENGTH = 2;\n\n    error VersionedPayload__TooShort(bytes versionedPayload);\n    error VersionedPayload__PrecompileFailed();\n\n    /// @notice Encodes the versioned payload into a single bytes array.\n    /// @param version  The payload's version.\n    /// @param payload  The payload to encode.\n    function encodeVersionedPayload(uint16 version, bytes memory payload) internal pure returns (bytes memory) {\n        return abi.encodePacked(version, payload);\n    }\n\n    /// @notice Extracts the version from the versioned payload (calldata reference).\n    /// @param versionedPayload     The versioned payload (calldata reference).\n    function getVersion(bytes calldata versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            version := shr(240, calldataload(versionedPayload.offset))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (calldata reference).\n    /// @dev The extracted payload is also returned as a calldata reference.\n    /// @param versionedPayload     The versioned payload.\n    function getPayload(bytes calldata versionedPayload) internal pure returns (bytes calldata) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        return versionedPayload[VERSION_LENGTH:];\n    }\n\n    /// @notice Extracts the version from the versioned payload (memory reference).\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getVersionFromMemory(bytes memory versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            // We add 0x20 to skip the length of the bytes array.\n            version := shr(240, mload(add(versionedPayload, 0x20)))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (memory reference).\n    /// @dev The extracted payload is copied into a new memory location. Use `getPayload` when possible\n    /// to avoid extra memory allocation.\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getPayloadFromMemory(bytes memory versionedPayload) internal view returns (bytes memory payload) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        // Figure how many bytes to copy and allocate the memory for the extracted payload.\n        uint256 toCopy;\n        unchecked {\n            toCopy = versionedPayload.length - VERSION_LENGTH;\n        }\n        payload = new bytes(toCopy);\n        // Use identity precompile (0x04) to copy the payload. Unlike MCOPY, this is available on all EVM chains.\n        bool res;\n        assembly {\n            // We add 0x20 to skip the length of the bytes array.\n            // We add 0x02 to skip the 2 bytes reserved for the version.\n            // Copy the payload to the previously allocated memory.\n            res := staticcall(gas(), 0x04, add(versionedPayload, 0x22), toCopy, add(payload, 0x20), toCopy)\n        }\n        if (!res) {\n            revert VersionedPayload__PrecompileFailed();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/IAccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n\n// node_modules/@openzeppelin/contracts/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance \u003c amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance \u003c value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 \u0026\u0026 target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SafeCast.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value \u003e type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value \u003e type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value \u003e type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value \u003e type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value \u003e type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value \u003e type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value \u003e type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value \u003e type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value \u003e type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value \u003e type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value \u003e type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value \u003e type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value \u003e type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value \u003e type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value \u003e type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value \u003e type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value \u003e type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value \u003e type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value \u003e type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value \u003e type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value \u003e type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value \u003e type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value \u003e type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value \u003e type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value \u003e type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value \u003e type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value \u003e type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value \u003e type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value \u003e type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value \u003e type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value \u003e type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value \u003c 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value \u003e uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal view returns (AppConfigV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (AppConfigV1));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal view returns (OptionsV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (OptionsV1));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(OPTIONS_V1, abi.encode(options));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/IAccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/IAccessControlEnumerable.sol)\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n// contracts/interfaces/IInterchainAppV1.sol\n\ninterface IInterchainAppV1 is IInterchainApp {\n    error InterchainApp__AppZeroAddress();\n    error InterchainApp__InvalidAppConfig(uint256 requiredResponses, uint256 optimisticPeriod);\n    error InterchainApp__ModuleAlreadyAdded(address module);\n    error InterchainApp__ModuleNotAdded(address module);\n    error InterchainApp__ModuleZeroAddress();\n    error InterchainApp__NotEVMLinkedApp(bytes32 linkedApp);\n\n    /// @notice Allows the owner to add the interchain client to the allowed clients set,\n    /// and optionally set the latest client to this one.\n    /// Note: only the allowed clients can send messages to this app.\n    /// Note: the latest client is used for sending messages from this app.\n    /// @param client       The address of the interchain client to add.\n    /// @param updateLatest Whether to set the latest client to this one.\n    function addInterchainClient(address client, bool updateLatest) external;\n\n    /// @notice Allows the owner to remove the interchain client from the allowed clients set.\n    /// If the client is the latest client, the latest client is set to the zero address.\n    /// @param client       The address of the interchain client to remove.\n    function removeInterchainClient(address client) external;\n\n    /// @notice Allows the owner to set the address of the latest interchain client.\n    /// @dev The new latest client must be an allowed client or zero address.\n    /// Setting the client to zero address effectively pauses the app ability to send messages,\n    /// while allowing to receive them.\n    /// @param client       The address of the latest interchain client.\n    function setLatestInterchainClient(address client) external;\n\n    /// @notice Allows the owner to link the remote app for the given chain ID.\n    /// - This address will be used as the receiver for the messages sent from this chain.\n    /// - This address will be the only trusted sender for the messages sent to this chain.\n    /// @param chainId      The remote chain ID.\n    /// @param remoteApp    The address of the remote app to link.\n    function linkRemoteApp(uint64 chainId, bytes32 remoteApp) external;\n\n    /// @notice Thin wrapper for `linkRemoteApp` to accept EVM address as a parameter.\n    function linkRemoteAppEVM(uint64 chainId, address remoteApp) external;\n\n    /// @notice Allows the owner to add the module to the trusted modules set.\n    /// - This set of modules will be used to verify both sent and received messages.\n    function addTrustedModule(address module) external;\n\n    /// @notice Allows the owner to remove the module from the trusted modules set.\n    function removeTrustedModule(address module) external;\n\n    /// @notice Allows the owner to set the app config for the current app. App config includes:\n    /// - requiredResponses: the number of module responses required for accepting the message\n    /// - optimisticPeriod: the minimum time after which the module responses are considered final\n    function setAppConfigV1(AppConfigV1 memory appConfig) external;\n\n    /// @notice Allows the owner to set the address of the Execution Service.\n    /// This address will be used to request execution of the messages sent from this chain,\n    /// by supplying the Service's execution fee.\n    function setExecutionService(address executionService) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Returns the app config for the current app: requiredResponses and optimisticPeriod.\n    function getAppConfigV1() external view returns (AppConfigV1 memory);\n\n    /// @notice Returns the address of the Execution Service used by this app for sending messages.\n    function getExecutionService() external view returns (address);\n\n    /// @notice Returns the list of Interchain Clients allowed to send messages to this app.\n    function getInterchainClients() external view returns (address[] memory);\n\n    /// @notice Returns the address of the latest interchain client.\n    /// This address is used for sending messages from this app.\n    function getLatestInterchainClient() external view returns (address);\n\n    /// @notice Returns the linked app address (as bytes32) for the given chain ID.\n    function getLinkedApp(uint64 chainId) external view returns (bytes32);\n\n    /// @notice Thin wrapper for `getLinkedApp` to return the linked app address as EVM address.\n    /// @dev Will revert if the linked app address is not an EVM address.\n    function getLinkedAppEVM(uint64 chainId) external view returns (address);\n\n    /// @notice Returns the list of Interchain Modules trusted by this app.\n    /// This set of modules will be used to verify both sent and received messages.\n    function getModules() external view returns (address[] memory);\n}\n\n// contracts/libs/InterchainTransaction.sol\n\ntype ICTxHeader is uint256;\n\nstruct InterchainTransaction {\n    uint64 srcChainId;\n    uint64 dstChainId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcSender;\n    bytes32 dstReceiver;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    using MathLib for uint256;\n    using VersionedPayloadLib for bytes;\n\n    function constructLocalTransaction(\n        address srcSender,\n        uint64 dstChainId,\n        bytes32 dstReceiver,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: SafeCast.toUint64(block.chainid),\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            encodeTxHeader(transaction.srcChainId, transaction.dstChainId, transaction.dbNonce, transaction.entryIndex),\n            transaction.srcSender,\n            transaction.dstReceiver,\n            transaction.options,\n            transaction.message\n        );\n    }\n\n    function decodeTransaction(bytes calldata transaction) internal pure returns (InterchainTransaction memory icTx) {\n        ICTxHeader header;\n        (header, icTx.srcSender, icTx.dstReceiver, icTx.options, icTx.message) =\n            abi.decode(transaction, (ICTxHeader, bytes32, bytes32, bytes, bytes));\n        (icTx.srcChainId, icTx.dstChainId, icTx.dbNonce, icTx.entryIndex) = decodeTxHeader(header);\n    }\n\n    function payloadSize(uint256 optionsLen, uint256 messageLen) internal pure returns (uint256) {\n        // 2 bytes are reserved for the transaction version\n        // + 5 fields * 32 bytes (3 values for static, 2 offsets for dynamic) + 2 * 32 bytes (lengths for dynamic) = 226\n        // (srcChainId, dstChainId, dbNonce, entryIndex) are merged into a single 32 bytes field\n        // Both options and message are dynamic fields, which are padded up to 32 bytes\n        return 226 + optionsLen.roundUpToWord() + messageLen.roundUpToWord();\n    }\n\n    function encodeTxHeader(\n        uint64 srcChainId,\n        uint64 dstChainId,\n        uint64 dbNonce,\n        uint64 entryIndex\n    )\n        internal\n        pure\n        returns (ICTxHeader)\n    {\n        return ICTxHeader.wrap(\n            (uint256(srcChainId) \u003c\u003c 192) | (uint256(dstChainId) \u003c\u003c 128) | (uint256(dbNonce) \u003c\u003c 64) | uint256(entryIndex)\n        );\n    }\n\n    function decodeTxHeader(ICTxHeader header)\n        internal\n        pure\n        returns (uint64 srcChainId, uint64 dstChainId, uint64 dbNonce, uint64 entryIndex)\n    {\n        srcChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 192);\n        dstChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 128);\n        dbNonce = uint64(ICTxHeader.unwrap(header) \u003e\u003e 64);\n        entryIndex = uint64(ICTxHeader.unwrap(header));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/AccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account =\u003e bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role =\u003e RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint64 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__InvalidTransactionVersion(uint16 version);\n    error InterchainClientV1__NoLinkedClient(uint64 chainId);\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint64 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint64 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint64 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint64 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param messageLen           The length of the message being sent.\n    function getInterchainFee(\n        uint64 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        uint256 messageLen\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint64 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint64 chainId) external view returns (address);\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/AccessControlEnumerable.sol)\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 role =\u003e EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {AccessControl-_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool granted = super._grantRole(role, account);\n        if (granted) {\n            _roleMembers[role].add(account);\n        }\n        return granted;\n    }\n\n    /**\n     * @dev Overload {AccessControl-_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool revoked = super._revokeRole(role, account);\n        if (revoked) {\n            _roleMembers[role].remove(account);\n        }\n        return revoked;\n    }\n}\n\n// contracts/apps/AbstractICApp.sol\n\nabstract contract AbstractICApp is AbstractICAppEvents, IInterchainApp {\n    using TypeCasts for address;\n\n    error InterchainApp__AlreadyLatestClient(address client);\n    error InterchainApp__BalanceTooLow(uint256 actual, uint256 required);\n    error InterchainApp__ClientAlreadyAdded(address client);\n    error InterchainApp__InterchainClientZeroAddress();\n    error InterchainApp__NotInterchainClient(address account);\n    error InterchainApp__ReceiverNotSet(uint64 chainId);\n    error InterchainApp__SameChainId(uint64 chainId);\n    error InterchainApp__SenderNotAllowed(uint64 srcChainId, bytes32 sender);\n\n    /// @inheritdoc IInterchainApp\n    function appReceive(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        if (!_isInterchainClient(msg.sender)) {\n            revert InterchainApp__NotInterchainClient(msg.sender);\n        }\n        if (srcChainId == block.chainid) {\n            revert InterchainApp__SameChainId(srcChainId);\n        }\n        if (!_isAllowedSender(srcChainId, sender)) {\n            revert InterchainApp__SenderNotAllowed(srcChainId, sender);\n        }\n        _receiveMessage(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n\n    /// @inheritdoc IInterchainApp\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules) {\n        appConfig = _getAppConfig();\n        modules = _getModules();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Performs necessary checks and adds an Interchain Client.\n    /// Optionally sets the latest client to this one.\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _addClient(address client, bool updateLatest) internal {\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (_isInterchainClient(client)) {\n            revert InterchainApp__ClientAlreadyAdded(client);\n        }\n        _toggleClientState(client, true);\n        emit InterchainClientAdded(client);\n        if (updateLatest) {\n            _setLatestClient(client);\n        }\n    }\n\n    /// @dev Performs necessary checks and removes an Interchain Client. If this client is the latest one,\n    /// the latest client is set to zero address (effectively pausing the app ability to send messages).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _removeClient(address client) internal {\n        if (!_isInterchainClient(client)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        _toggleClientState(client, false);\n        emit InterchainClientRemoved(client);\n        if (client == _getLatestClient()) {\n            _setLatestClient(address(0));\n        }\n    }\n\n    /// @dev Sets the latest Interchain Client to one of the allowed clients. Setting the client to zero address\n    /// is allowed and effectively pauses the app ability to send messages (but still allows to receive them).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _setLatestClient(address client) internal {\n        // New latest client must be an allowed client or zero address.\n        if (!_isInterchainClient(client) \u0026\u0026 client != address(0)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        if (client == _getLatestClient()) {\n            revert InterchainApp__AlreadyLatestClient(client);\n        }\n        _storeLatestClient(client);\n        emit LatestClientSet(client);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal virtual;\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal virtual;\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to accept EVM address as a parameter.\n    function _sendInterchainMessageEVM(\n        uint64 dstChainId,\n        address receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _sendInterchainMessage(dstChainId, receiver.addressToBytes32(), messageFee, options, message);\n    }\n\n    /// @dev Performs necessary checks and sends an interchain message.\n    function _sendInterchainMessage(\n        uint64 dstChainId,\n        bytes32 receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (dstChainId == block.chainid) {\n            revert InterchainApp__SameChainId(dstChainId);\n        }\n        if (receiver == 0) {\n            revert InterchainApp__ReceiverNotSet(dstChainId);\n        }\n        if (address(this).balance \u003c messageFee) {\n            revert InterchainApp__BalanceTooLow({actual: address(this).balance, required: messageFee});\n        }\n        return IInterchainClientV1(client).interchainSend{value: messageFee}(\n            dstChainId, receiver, _getExecutionService(), _getModules(), options, message\n        );\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        virtual;\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee for sending an Interchain message.\n    function _getInterchainFee(\n        uint64 dstChainId,\n        bytes memory options,\n        uint256 messageLen\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        return IInterchainClientV1(client).getInterchainFee(\n            dstChainId, _getExecutionService(), _getModules(), options, messageLen\n        );\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view virtual returns (bytes memory);\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view virtual returns (address);\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view virtual returns (address);\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view virtual returns (address[] memory);\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint64 srcChainId, bytes32 sender) internal view virtual returns (bool);\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view virtual returns (bool);\n}\n\n// contracts/apps/ICAppV1.sol\n\nabstract contract ICAppV1 is AbstractICApp, AccessControlEnumerable, InterchainAppV1Events, IInterchainAppV1 {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Role to manage the Interchain setup of the app.\n    bytes32 public constant IC_GOVERNOR_ROLE = keccak256(\"IC_GOVERNOR_ROLE\");\n\n    /// @dev Address of the latest Interchain Client, used for sending messages.\n    address private _latestClient;\n\n    /// @dev Required responses and optimistic period for the module responses.\n    AppConfigV1 private _appConfigV1;\n    /// @dev Address of the linked app deployed on the remote chain.\n    mapping(uint64 chainId =\u003e bytes32 remoteApp) private _linkedApp;\n    /// @dev Interchain Clients allowed to send messages to this app.\n    EnumerableSet.AddressSet private _interchainClients;\n    /// @dev Trusted Interchain modules.\n    EnumerableSet.AddressSet private _trustedModules;\n    /// @dev Execution Service to use for sending messages.\n    address private _executionService;\n\n    constructor(address admin) {\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addInterchainClient(address client, bool updateLatest) external onlyRole(IC_GOVERNOR_ROLE) {\n        _addClient(client, updateLatest);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _removeClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setLatestInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _setLatestClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteApp(uint64 chainId, bytes32 remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteAppEVM(uint64 chainId, address remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp.addressToBytes32());\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (module == address(0)) {\n            revert InterchainApp__ModuleZeroAddress();\n        }\n        bool added = _trustedModules.add(module);\n        if (!added) {\n            revert InterchainApp__ModuleAlreadyAdded(module);\n        }\n        emit TrustedModuleAdded(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        bool removed = _trustedModules.remove(module);\n        if (!removed) {\n            revert InterchainApp__ModuleNotAdded(module);\n        }\n        emit TrustedModuleRemoved(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setAppConfigV1(AppConfigV1 memory appConfig) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (appConfig.requiredResponses == 0 || appConfig.optimisticPeriod == 0) {\n            revert InterchainApp__InvalidAppConfig(appConfig.requiredResponses, appConfig.optimisticPeriod);\n        }\n        _appConfigV1 = appConfig;\n        emit AppConfigV1Set(appConfig.requiredResponses, appConfig.optimisticPeriod);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setExecutionService(address executionService) external onlyRole(IC_GOVERNOR_ROLE) {\n        _executionService = executionService;\n        emit ExecutionServiceSet(executionService);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainAppV1\n    function getAppConfigV1() external view returns (AppConfigV1 memory) {\n        return _appConfigV1;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getExecutionService() external view returns (address) {\n        return _executionService;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getInterchainClients() external view returns (address[] memory) {\n        return _interchainClients.values();\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLatestInterchainClient() external view returns (address) {\n        return _latestClient;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedApp(uint64 chainId) external view returns (bytes32) {\n        return _linkedApp[chainId];\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedAppEVM(uint64 chainId) external view returns (address linkedAppEVM) {\n        bytes32 linkedApp = _linkedApp[chainId];\n        linkedAppEVM = linkedApp.bytes32ToAddress();\n        if (linkedAppEVM.addressToBytes32() != linkedApp) {\n            revert InterchainApp__NotEVMLinkedApp(linkedApp);\n        }\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getModules() external view returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Links the remote app to the current app.\n    /// Will revert if the chainId is the same as the chainId of the local app.\n    /// Note: Should be guarded with permissions check.\n    function _linkRemoteApp(uint64 chainId, bytes32 remoteApp) internal {\n        if (chainId == block.chainid) {\n            revert InterchainApp__SameChainId(chainId);\n        }\n        if (remoteApp == 0) {\n            revert InterchainApp__AppZeroAddress();\n        }\n        _linkedApp[chainId] = remoteApp;\n        emit AppLinked(chainId, remoteApp);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal override {\n        _latestClient = client;\n    }\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal override {\n        if (allowed) {\n            _interchainClients.add(client);\n        } else {\n            _interchainClients.remove(client);\n        }\n    }\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to send the message to the linked app.\n    function _sendToLinkedApp(\n        uint64 dstChainId,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _sendInterchainMessage(dstChainId, _linkedApp[dstChainId], messageFee, encodedOptions, message);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee to send a message to the linked app on the remote chain.\n    function _getMessageFee(\n        uint64 dstChainId,\n        OptionsV1 memory options,\n        uint256 messageLen\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _getInterchainFee(dstChainId, encodedOptions, messageLen);\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view override returns (bytes memory) {\n        return _appConfigV1.encodeAppConfigV1();\n    }\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view override returns (address) {\n        return _executionService;\n    }\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view override returns (address) {\n        return _latestClient;\n    }\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view override returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint64 srcChainId, bytes32 sender) internal view override returns (bool) {\n        return _linkedApp[srcChainId] == sender;\n    }\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view override returns (bool) {\n        return _interchainClients.contains(caller);\n    }\n}\n\n// contracts/apps/examples/ExampleAppV1.sol\n\ncontract ExampleAppV1 is ICAppV1 {\n    event MessageReceived(uint64 srcChainId, bytes32 sender, uint64 dbNonce, uint64 entryIndex, bytes message);\n    event MessageSent(uint64 dstChainId, uint64 dbNonce, uint64 entryIndex, bytes32 transactionId);\n\n    constructor(address admin) ICAppV1(admin) {\n        _grantRole(IC_GOVERNOR_ROLE, admin);\n    }\n\n    /// @notice Allows the Admin to withdraw the native asset from the contract.\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        Address.sendValue(payable(msg.sender), address(this).balance);\n    }\n\n    /// @notice Sends a basic message to the destination chain.\n    function sendMessage(\n        uint64 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        InterchainTxDescriptor memory desc = _sendToLinkedApp({\n            dstChainId: dstChainId,\n            messageFee: msg.value,\n            options: OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}),\n            message: message\n        });\n        emit MessageSent(dstChainId, desc.dbNonce, desc.entryIndex, desc.transactionId);\n    }\n\n    /// @notice Returns the fee required to send a message using `sendMessage`.\n    function getMessageFee(\n        uint64 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes memory message\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _getMessageFee(dstChainId, OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}), message.length);\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        override\n    {\n        emit MessageReceived(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"bytes4","name":"interfaceId","type":"bytes4"}],"name":"supportsInterface","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"details":"Implementation of the {IERC165} interface. Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check for the additional interface id that will be supported. For example: ```solidity function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId); } ```","kind":"dev","methods":{"supportsInterface(bytes4)":{"details":"See {IERC165-supportsInterface}."}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Implementation of the {IERC165} interface. Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check for the additional interface id that will be supported. For example: ```solidity function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId); } ```\",\"kind\":\"dev\",\"methods\":{\"supportsInterface(bytes4)\":{\"details\":\"See {IERC165-supportsInterface}.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/ExampleAppV1.sol\":\"ERC165\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/ExampleAppV1.sol\":{\"keccak256\":\"0xb1e9550aef785a0afc4e03fc843839919987ba4f906f09992c6788979c3c0396\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://0ede697223dfa3a2e23501efc1ed5926d5ff6458ee7b9ba833e0587162166c79\",\"dweb:/ipfs/QmUzgopL2ptWG5DYNdGAcoErPnBC4KCoRp8C61dkHHRaA6\"]}},\"version\":1}"},"hashes":{"supportsInterface(bytes4)":"01ffc9a7"}},"solidity/ExampleAppV1.sol:EnumerableSet":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220b18aa442994ad0e61023595a84bece6378adb1ce15152b78d6c2b3089764558b64736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220b18aa442994ad0e61023595a84bece6378adb1ce15152b78d6c2b3089764558b64736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/AbstractICAppEvents.sol\n\nabstract contract AbstractICAppEvents {\n    event InterchainClientAdded(address client);\n    event InterchainClientRemoved(address client);\n    event LatestClientSet(address client);\n}\n\n// contracts/events/InterchainAppV1Events.sol\n\nabstract contract InterchainAppV1Events {\n    event AppConfigV1Set(uint256 requiredResponses, uint256 optimisticPeriod);\n    event AppLinked(uint256 indexed chainId, bytes32 indexed remoteApp);\n    event ExecutionServiceSet(address executionService);\n    event TrustedModuleAdded(address module);\n    event TrustedModuleRemoved(address module);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    /// @notice Allows the Interchain Client to pass the message to the Interchain App.\n    /// @dev App is responsible for keeping track of interchain clients, and must verify the message sender.\n    /// @param srcChainId   Chain ID of the source chain, where the message was sent from.\n    /// @param sender       Sender address on the source chain, as a bytes32 value.\n    /// @param dbNonce      The Interchain DB nonce of the batch containing the message entry.\n    /// @param entryIndex   The index of the message entry within the batch.\n    /// @param message      The message being sent.\n    function appReceive(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /// @notice Returns the verification configuration of the Interchain App.\n    /// @dev This configuration is used by the Interchain Client to verify that message has been confirmed\n    /// by the Interchain Modules on the destination chain.\n    /// Note: V1 version of AppConfig includes the required responses count, and optimistic period after which\n    /// the message is considered confirmed by the module. Following versions may include additional fields.\n    /// @return appConfig    The versioned configuration of the Interchain App, encoded as bytes.\n    /// @return modules      The list of Interchain Modules that app is trusting to confirm the messages.\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/Math.sol\n\nlibrary MathLib {\n    /// @notice Rounds up to the nearest multiple of 32.\n    /// Note: Returns zero on overflows instead of reverting. This is fine for practical\n    /// use cases, as this is used for determining the size of the payload in memory.\n    function roundUpToWord(uint256 x) internal pure returns (uint256) {\n        unchecked {\n            return (x + 31) \u0026 ~uint256(31);\n        }\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/VersionedPayload.sol\n\n// solhint-disable no-inline-assembly\n// solhint-disable ordering\nlibrary VersionedPayloadLib {\n    /// @notice Amount of bytes reserved for the version (uint16) in the versioned payload\n    uint256 internal constant VERSION_LENGTH = 2;\n\n    error VersionedPayload__TooShort(bytes versionedPayload);\n    error VersionedPayload__PrecompileFailed();\n\n    /// @notice Encodes the versioned payload into a single bytes array.\n    /// @param version  The payload's version.\n    /// @param payload  The payload to encode.\n    function encodeVersionedPayload(uint16 version, bytes memory payload) internal pure returns (bytes memory) {\n        return abi.encodePacked(version, payload);\n    }\n\n    /// @notice Extracts the version from the versioned payload (calldata reference).\n    /// @param versionedPayload     The versioned payload (calldata reference).\n    function getVersion(bytes calldata versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            version := shr(240, calldataload(versionedPayload.offset))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (calldata reference).\n    /// @dev The extracted payload is also returned as a calldata reference.\n    /// @param versionedPayload     The versioned payload.\n    function getPayload(bytes calldata versionedPayload) internal pure returns (bytes calldata) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        return versionedPayload[VERSION_LENGTH:];\n    }\n\n    /// @notice Extracts the version from the versioned payload (memory reference).\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getVersionFromMemory(bytes memory versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            // We add 0x20 to skip the length of the bytes array.\n            version := shr(240, mload(add(versionedPayload, 0x20)))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (memory reference).\n    /// @dev The extracted payload is copied into a new memory location. Use `getPayload` when possible\n    /// to avoid extra memory allocation.\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getPayloadFromMemory(bytes memory versionedPayload) internal view returns (bytes memory payload) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        // Figure how many bytes to copy and allocate the memory for the extracted payload.\n        uint256 toCopy;\n        unchecked {\n            toCopy = versionedPayload.length - VERSION_LENGTH;\n        }\n        payload = new bytes(toCopy);\n        // Use identity precompile (0x04) to copy the payload. Unlike MCOPY, this is available on all EVM chains.\n        bool res;\n        assembly {\n            // We add 0x20 to skip the length of the bytes array.\n            // We add 0x02 to skip the 2 bytes reserved for the version.\n            // Copy the payload to the previously allocated memory.\n            res := staticcall(gas(), 0x04, add(versionedPayload, 0x22), toCopy, add(payload, 0x20), toCopy)\n        }\n        if (!res) {\n            revert VersionedPayload__PrecompileFailed();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/IAccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n\n// node_modules/@openzeppelin/contracts/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance \u003c amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance \u003c value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 \u0026\u0026 target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SafeCast.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value \u003e type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value \u003e type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value \u003e type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value \u003e type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value \u003e type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value \u003e type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value \u003e type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value \u003e type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value \u003e type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value \u003e type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value \u003e type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value \u003e type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value \u003e type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value \u003e type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value \u003e type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value \u003e type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value \u003e type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value \u003e type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value \u003e type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value \u003e type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value \u003e type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value \u003e type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value \u003e type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value \u003e type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value \u003e type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value \u003e type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value \u003e type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value \u003e type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value \u003e type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value \u003e type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value \u003e type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value \u003c 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value \u003e uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal view returns (AppConfigV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (AppConfigV1));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal view returns (OptionsV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (OptionsV1));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(OPTIONS_V1, abi.encode(options));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/IAccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/IAccessControlEnumerable.sol)\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n// contracts/interfaces/IInterchainAppV1.sol\n\ninterface IInterchainAppV1 is IInterchainApp {\n    error InterchainApp__AppZeroAddress();\n    error InterchainApp__InvalidAppConfig(uint256 requiredResponses, uint256 optimisticPeriod);\n    error InterchainApp__ModuleAlreadyAdded(address module);\n    error InterchainApp__ModuleNotAdded(address module);\n    error InterchainApp__ModuleZeroAddress();\n    error InterchainApp__NotEVMLinkedApp(bytes32 linkedApp);\n\n    /// @notice Allows the owner to add the interchain client to the allowed clients set,\n    /// and optionally set the latest client to this one.\n    /// Note: only the allowed clients can send messages to this app.\n    /// Note: the latest client is used for sending messages from this app.\n    /// @param client       The address of the interchain client to add.\n    /// @param updateLatest Whether to set the latest client to this one.\n    function addInterchainClient(address client, bool updateLatest) external;\n\n    /// @notice Allows the owner to remove the interchain client from the allowed clients set.\n    /// If the client is the latest client, the latest client is set to the zero address.\n    /// @param client       The address of the interchain client to remove.\n    function removeInterchainClient(address client) external;\n\n    /// @notice Allows the owner to set the address of the latest interchain client.\n    /// @dev The new latest client must be an allowed client or zero address.\n    /// Setting the client to zero address effectively pauses the app ability to send messages,\n    /// while allowing to receive them.\n    /// @param client       The address of the latest interchain client.\n    function setLatestInterchainClient(address client) external;\n\n    /// @notice Allows the owner to link the remote app for the given chain ID.\n    /// - This address will be used as the receiver for the messages sent from this chain.\n    /// - This address will be the only trusted sender for the messages sent to this chain.\n    /// @param chainId      The remote chain ID.\n    /// @param remoteApp    The address of the remote app to link.\n    function linkRemoteApp(uint64 chainId, bytes32 remoteApp) external;\n\n    /// @notice Thin wrapper for `linkRemoteApp` to accept EVM address as a parameter.\n    function linkRemoteAppEVM(uint64 chainId, address remoteApp) external;\n\n    /// @notice Allows the owner to add the module to the trusted modules set.\n    /// - This set of modules will be used to verify both sent and received messages.\n    function addTrustedModule(address module) external;\n\n    /// @notice Allows the owner to remove the module from the trusted modules set.\n    function removeTrustedModule(address module) external;\n\n    /// @notice Allows the owner to set the app config for the current app. App config includes:\n    /// - requiredResponses: the number of module responses required for accepting the message\n    /// - optimisticPeriod: the minimum time after which the module responses are considered final\n    function setAppConfigV1(AppConfigV1 memory appConfig) external;\n\n    /// @notice Allows the owner to set the address of the Execution Service.\n    /// This address will be used to request execution of the messages sent from this chain,\n    /// by supplying the Service's execution fee.\n    function setExecutionService(address executionService) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Returns the app config for the current app: requiredResponses and optimisticPeriod.\n    function getAppConfigV1() external view returns (AppConfigV1 memory);\n\n    /// @notice Returns the address of the Execution Service used by this app for sending messages.\n    function getExecutionService() external view returns (address);\n\n    /// @notice Returns the list of Interchain Clients allowed to send messages to this app.\n    function getInterchainClients() external view returns (address[] memory);\n\n    /// @notice Returns the address of the latest interchain client.\n    /// This address is used for sending messages from this app.\n    function getLatestInterchainClient() external view returns (address);\n\n    /// @notice Returns the linked app address (as bytes32) for the given chain ID.\n    function getLinkedApp(uint64 chainId) external view returns (bytes32);\n\n    /// @notice Thin wrapper for `getLinkedApp` to return the linked app address as EVM address.\n    /// @dev Will revert if the linked app address is not an EVM address.\n    function getLinkedAppEVM(uint64 chainId) external view returns (address);\n\n    /// @notice Returns the list of Interchain Modules trusted by this app.\n    /// This set of modules will be used to verify both sent and received messages.\n    function getModules() external view returns (address[] memory);\n}\n\n// contracts/libs/InterchainTransaction.sol\n\ntype ICTxHeader is uint256;\n\nstruct InterchainTransaction {\n    uint64 srcChainId;\n    uint64 dstChainId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcSender;\n    bytes32 dstReceiver;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    using MathLib for uint256;\n    using VersionedPayloadLib for bytes;\n\n    function constructLocalTransaction(\n        address srcSender,\n        uint64 dstChainId,\n        bytes32 dstReceiver,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: SafeCast.toUint64(block.chainid),\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            encodeTxHeader(transaction.srcChainId, transaction.dstChainId, transaction.dbNonce, transaction.entryIndex),\n            transaction.srcSender,\n            transaction.dstReceiver,\n            transaction.options,\n            transaction.message\n        );\n    }\n\n    function decodeTransaction(bytes calldata transaction) internal pure returns (InterchainTransaction memory icTx) {\n        ICTxHeader header;\n        (header, icTx.srcSender, icTx.dstReceiver, icTx.options, icTx.message) =\n            abi.decode(transaction, (ICTxHeader, bytes32, bytes32, bytes, bytes));\n        (icTx.srcChainId, icTx.dstChainId, icTx.dbNonce, icTx.entryIndex) = decodeTxHeader(header);\n    }\n\n    function payloadSize(uint256 optionsLen, uint256 messageLen) internal pure returns (uint256) {\n        // 2 bytes are reserved for the transaction version\n        // + 5 fields * 32 bytes (3 values for static, 2 offsets for dynamic) + 2 * 32 bytes (lengths for dynamic) = 226\n        // (srcChainId, dstChainId, dbNonce, entryIndex) are merged into a single 32 bytes field\n        // Both options and message are dynamic fields, which are padded up to 32 bytes\n        return 226 + optionsLen.roundUpToWord() + messageLen.roundUpToWord();\n    }\n\n    function encodeTxHeader(\n        uint64 srcChainId,\n        uint64 dstChainId,\n        uint64 dbNonce,\n        uint64 entryIndex\n    )\n        internal\n        pure\n        returns (ICTxHeader)\n    {\n        return ICTxHeader.wrap(\n            (uint256(srcChainId) \u003c\u003c 192) | (uint256(dstChainId) \u003c\u003c 128) | (uint256(dbNonce) \u003c\u003c 64) | uint256(entryIndex)\n        );\n    }\n\n    function decodeTxHeader(ICTxHeader header)\n        internal\n        pure\n        returns (uint64 srcChainId, uint64 dstChainId, uint64 dbNonce, uint64 entryIndex)\n    {\n        srcChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 192);\n        dstChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 128);\n        dbNonce = uint64(ICTxHeader.unwrap(header) \u003e\u003e 64);\n        entryIndex = uint64(ICTxHeader.unwrap(header));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/AccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account =\u003e bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role =\u003e RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint64 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__InvalidTransactionVersion(uint16 version);\n    error InterchainClientV1__NoLinkedClient(uint64 chainId);\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint64 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint64 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint64 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint64 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param messageLen           The length of the message being sent.\n    function getInterchainFee(\n        uint64 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        uint256 messageLen\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint64 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint64 chainId) external view returns (address);\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/AccessControlEnumerable.sol)\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 role =\u003e EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {AccessControl-_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool granted = super._grantRole(role, account);\n        if (granted) {\n            _roleMembers[role].add(account);\n        }\n        return granted;\n    }\n\n    /**\n     * @dev Overload {AccessControl-_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool revoked = super._revokeRole(role, account);\n        if (revoked) {\n            _roleMembers[role].remove(account);\n        }\n        return revoked;\n    }\n}\n\n// contracts/apps/AbstractICApp.sol\n\nabstract contract AbstractICApp is AbstractICAppEvents, IInterchainApp {\n    using TypeCasts for address;\n\n    error InterchainApp__AlreadyLatestClient(address client);\n    error InterchainApp__BalanceTooLow(uint256 actual, uint256 required);\n    error InterchainApp__ClientAlreadyAdded(address client);\n    error InterchainApp__InterchainClientZeroAddress();\n    error InterchainApp__NotInterchainClient(address account);\n    error InterchainApp__ReceiverNotSet(uint64 chainId);\n    error InterchainApp__SameChainId(uint64 chainId);\n    error InterchainApp__SenderNotAllowed(uint64 srcChainId, bytes32 sender);\n\n    /// @inheritdoc IInterchainApp\n    function appReceive(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        if (!_isInterchainClient(msg.sender)) {\n            revert InterchainApp__NotInterchainClient(msg.sender);\n        }\n        if (srcChainId == block.chainid) {\n            revert InterchainApp__SameChainId(srcChainId);\n        }\n        if (!_isAllowedSender(srcChainId, sender)) {\n            revert InterchainApp__SenderNotAllowed(srcChainId, sender);\n        }\n        _receiveMessage(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n\n    /// @inheritdoc IInterchainApp\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules) {\n        appConfig = _getAppConfig();\n        modules = _getModules();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Performs necessary checks and adds an Interchain Client.\n    /// Optionally sets the latest client to this one.\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _addClient(address client, bool updateLatest) internal {\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (_isInterchainClient(client)) {\n            revert InterchainApp__ClientAlreadyAdded(client);\n        }\n        _toggleClientState(client, true);\n        emit InterchainClientAdded(client);\n        if (updateLatest) {\n            _setLatestClient(client);\n        }\n    }\n\n    /// @dev Performs necessary checks and removes an Interchain Client. If this client is the latest one,\n    /// the latest client is set to zero address (effectively pausing the app ability to send messages).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _removeClient(address client) internal {\n        if (!_isInterchainClient(client)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        _toggleClientState(client, false);\n        emit InterchainClientRemoved(client);\n        if (client == _getLatestClient()) {\n            _setLatestClient(address(0));\n        }\n    }\n\n    /// @dev Sets the latest Interchain Client to one of the allowed clients. Setting the client to zero address\n    /// is allowed and effectively pauses the app ability to send messages (but still allows to receive them).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _setLatestClient(address client) internal {\n        // New latest client must be an allowed client or zero address.\n        if (!_isInterchainClient(client) \u0026\u0026 client != address(0)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        if (client == _getLatestClient()) {\n            revert InterchainApp__AlreadyLatestClient(client);\n        }\n        _storeLatestClient(client);\n        emit LatestClientSet(client);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal virtual;\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal virtual;\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to accept EVM address as a parameter.\n    function _sendInterchainMessageEVM(\n        uint64 dstChainId,\n        address receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _sendInterchainMessage(dstChainId, receiver.addressToBytes32(), messageFee, options, message);\n    }\n\n    /// @dev Performs necessary checks and sends an interchain message.\n    function _sendInterchainMessage(\n        uint64 dstChainId,\n        bytes32 receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (dstChainId == block.chainid) {\n            revert InterchainApp__SameChainId(dstChainId);\n        }\n        if (receiver == 0) {\n            revert InterchainApp__ReceiverNotSet(dstChainId);\n        }\n        if (address(this).balance \u003c messageFee) {\n            revert InterchainApp__BalanceTooLow({actual: address(this).balance, required: messageFee});\n        }\n        return IInterchainClientV1(client).interchainSend{value: messageFee}(\n            dstChainId, receiver, _getExecutionService(), _getModules(), options, message\n        );\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        virtual;\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee for sending an Interchain message.\n    function _getInterchainFee(\n        uint64 dstChainId,\n        bytes memory options,\n        uint256 messageLen\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        return IInterchainClientV1(client).getInterchainFee(\n            dstChainId, _getExecutionService(), _getModules(), options, messageLen\n        );\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view virtual returns (bytes memory);\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view virtual returns (address);\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view virtual returns (address);\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view virtual returns (address[] memory);\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint64 srcChainId, bytes32 sender) internal view virtual returns (bool);\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view virtual returns (bool);\n}\n\n// contracts/apps/ICAppV1.sol\n\nabstract contract ICAppV1 is AbstractICApp, AccessControlEnumerable, InterchainAppV1Events, IInterchainAppV1 {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Role to manage the Interchain setup of the app.\n    bytes32 public constant IC_GOVERNOR_ROLE = keccak256(\"IC_GOVERNOR_ROLE\");\n\n    /// @dev Address of the latest Interchain Client, used for sending messages.\n    address private _latestClient;\n\n    /// @dev Required responses and optimistic period for the module responses.\n    AppConfigV1 private _appConfigV1;\n    /// @dev Address of the linked app deployed on the remote chain.\n    mapping(uint64 chainId =\u003e bytes32 remoteApp) private _linkedApp;\n    /// @dev Interchain Clients allowed to send messages to this app.\n    EnumerableSet.AddressSet private _interchainClients;\n    /// @dev Trusted Interchain modules.\n    EnumerableSet.AddressSet private _trustedModules;\n    /// @dev Execution Service to use for sending messages.\n    address private _executionService;\n\n    constructor(address admin) {\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addInterchainClient(address client, bool updateLatest) external onlyRole(IC_GOVERNOR_ROLE) {\n        _addClient(client, updateLatest);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _removeClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setLatestInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _setLatestClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteApp(uint64 chainId, bytes32 remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteAppEVM(uint64 chainId, address remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp.addressToBytes32());\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (module == address(0)) {\n            revert InterchainApp__ModuleZeroAddress();\n        }\n        bool added = _trustedModules.add(module);\n        if (!added) {\n            revert InterchainApp__ModuleAlreadyAdded(module);\n        }\n        emit TrustedModuleAdded(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        bool removed = _trustedModules.remove(module);\n        if (!removed) {\n            revert InterchainApp__ModuleNotAdded(module);\n        }\n        emit TrustedModuleRemoved(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setAppConfigV1(AppConfigV1 memory appConfig) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (appConfig.requiredResponses == 0 || appConfig.optimisticPeriod == 0) {\n            revert InterchainApp__InvalidAppConfig(appConfig.requiredResponses, appConfig.optimisticPeriod);\n        }\n        _appConfigV1 = appConfig;\n        emit AppConfigV1Set(appConfig.requiredResponses, appConfig.optimisticPeriod);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setExecutionService(address executionService) external onlyRole(IC_GOVERNOR_ROLE) {\n        _executionService = executionService;\n        emit ExecutionServiceSet(executionService);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainAppV1\n    function getAppConfigV1() external view returns (AppConfigV1 memory) {\n        return _appConfigV1;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getExecutionService() external view returns (address) {\n        return _executionService;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getInterchainClients() external view returns (address[] memory) {\n        return _interchainClients.values();\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLatestInterchainClient() external view returns (address) {\n        return _latestClient;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedApp(uint64 chainId) external view returns (bytes32) {\n        return _linkedApp[chainId];\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedAppEVM(uint64 chainId) external view returns (address linkedAppEVM) {\n        bytes32 linkedApp = _linkedApp[chainId];\n        linkedAppEVM = linkedApp.bytes32ToAddress();\n        if (linkedAppEVM.addressToBytes32() != linkedApp) {\n            revert InterchainApp__NotEVMLinkedApp(linkedApp);\n        }\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getModules() external view returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Links the remote app to the current app.\n    /// Will revert if the chainId is the same as the chainId of the local app.\n    /// Note: Should be guarded with permissions check.\n    function _linkRemoteApp(uint64 chainId, bytes32 remoteApp) internal {\n        if (chainId == block.chainid) {\n            revert InterchainApp__SameChainId(chainId);\n        }\n        if (remoteApp == 0) {\n            revert InterchainApp__AppZeroAddress();\n        }\n        _linkedApp[chainId] = remoteApp;\n        emit AppLinked(chainId, remoteApp);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal override {\n        _latestClient = client;\n    }\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal override {\n        if (allowed) {\n            _interchainClients.add(client);\n        } else {\n            _interchainClients.remove(client);\n        }\n    }\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to send the message to the linked app.\n    function _sendToLinkedApp(\n        uint64 dstChainId,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _sendInterchainMessage(dstChainId, _linkedApp[dstChainId], messageFee, encodedOptions, message);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee to send a message to the linked app on the remote chain.\n    function _getMessageFee(\n        uint64 dstChainId,\n        OptionsV1 memory options,\n        uint256 messageLen\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _getInterchainFee(dstChainId, encodedOptions, messageLen);\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view override returns (bytes memory) {\n        return _appConfigV1.encodeAppConfigV1();\n    }\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view override returns (address) {\n        return _executionService;\n    }\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view override returns (address) {\n        return _latestClient;\n    }\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view override returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint64 srcChainId, bytes32 sender) internal view override returns (bool) {\n        return _linkedApp[srcChainId] == sender;\n    }\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view override returns (bool) {\n        return _interchainClients.contains(caller);\n    }\n}\n\n// contracts/apps/examples/ExampleAppV1.sol\n\ncontract ExampleAppV1 is ICAppV1 {\n    event MessageReceived(uint64 srcChainId, bytes32 sender, uint64 dbNonce, uint64 entryIndex, bytes message);\n    event MessageSent(uint64 dstChainId, uint64 dbNonce, uint64 entryIndex, bytes32 transactionId);\n\n    constructor(address admin) ICAppV1(admin) {\n        _grantRole(IC_GOVERNOR_ROLE, admin);\n    }\n\n    /// @notice Allows the Admin to withdraw the native asset from the contract.\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        Address.sendValue(payable(msg.sender), address(this).balance);\n    }\n\n    /// @notice Sends a basic message to the destination chain.\n    function sendMessage(\n        uint64 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        InterchainTxDescriptor memory desc = _sendToLinkedApp({\n            dstChainId: dstChainId,\n            messageFee: msg.value,\n            options: OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}),\n            message: message\n        });\n        emit MessageSent(dstChainId, desc.dbNonce, desc.entryIndex, desc.transactionId);\n    }\n\n    /// @notice Returns the fee required to send a message using `sendMessage`.\n    function getMessageFee(\n        uint64 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes memory message\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _getMessageFee(dstChainId, OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}), message.length);\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        override\n    {\n        emit MessageReceived(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"54483:11640:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;54483:11640:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"54483:11640:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"details":"Library for managing https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive types. Sets have the following properties: - Elements are added, removed, and checked for existence in constant time (O(1)). - Elements are enumerated in O(n). No guarantees are made on the ordering. ```solidity contract Example {     // Add the library methods     using EnumerableSet for EnumerableSet.AddressSet;     // Declare a set state variable     EnumerableSet.AddressSet private mySet; } ``` As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`) and `uint256` (`UintSet`) are supported. [WARNING] ==== Trying to delete such a structure from storage will likely result in data corruption, rendering the structure unusable. See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info. In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an array of EnumerableSet. ====","kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"details\":\"Library for managing https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive types. Sets have the following properties: - Elements are added, removed, and checked for existence in constant time (O(1)). - Elements are enumerated in O(n). No guarantees are made on the ordering. ```solidity contract Example {     // Add the library methods     using EnumerableSet for EnumerableSet.AddressSet;     // Declare a set state variable     EnumerableSet.AddressSet private mySet; } ``` As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`) and `uint256` (`UintSet`) are supported. [WARNING] ==== Trying to delete such a structure from storage will likely result in data corruption, rendering the structure unusable. See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info. In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an array of EnumerableSet. ====\",\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/ExampleAppV1.sol\":\"EnumerableSet\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/ExampleAppV1.sol\":{\"keccak256\":\"0xb1e9550aef785a0afc4e03fc843839919987ba4f906f09992c6788979c3c0396\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://0ede697223dfa3a2e23501efc1ed5926d5ff6458ee7b9ba833e0587162166c79\",\"dweb:/ipfs/QmUzgopL2ptWG5DYNdGAcoErPnBC4KCoRp8C61dkHHRaA6\"]}},\"version\":1}"},"hashes":{}},"solidity/ExampleAppV1.sol:ExampleAppV1":{"code":"0x60806040523480156200001157600080fd5b5060405162002632380380620026328339810160408190526200003491620001be565b806200004260008262000079565b506200007190507f67458b9c8206fd7556afadce1bc8e28c7a8942ecb92d9d9fad69bb6c8cf75c848262000079565b5050620001e9565b600080620000888484620000b6565b90508015620000ad576000848152600160205260409020620000ab908462000164565b505b90505b92915050565b6000828152602081815260408083206001600160a01b038516845290915281205460ff166200015b576000838152602081815260408083206001600160a01b03861684529091529020805460ff19166001179055620001123390565b6001600160a01b0316826001600160a01b0316847f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d60405160405180910390a4506001620000b0565b506000620000b0565b6000620000ad836001600160a01b03841660008181526001830160205260408120546200015b57508154600181810184556000848152602080822090930184905584548482528286019093526040902091909155620000b0565b600060208284031215620001d157600080fd5b81516001600160a01b0381168114620000ad57600080fd5b61243980620001f96000396000f3fe6080604052600436106101d85760003560e01c80638b41db0411610102578063bc0d912c11610095578063d547741f11610064578063d547741f146105c1578063eb53b44e146105e1578063f22ba23d14610601578063f6b266fd1461062157600080fd5b8063bc0d912c14610545578063c313c80714610563578063ca15c87314610581578063cb5038fb146105a157600080fd5b8063a1aa5d68116100d1578063a1aa5d68146104d9578063a217fddf146104fb578063b2494df314610510578063b70c40b31461052557600080fd5b80638b41db041461041d5780639010d07c1461043d57806390a92c161461047557806391d148541461049557600080fd5b8063287bc0571161017a578063496774b111610149578063496774b1146103715780634e6427e7146103915780636e9fd609146103c85780637717a647146103db57600080fd5b8063287bc057146102f95780632f2ff15d1461031c57806336568abe1461033c5780633ccfd60b1461035c57600080fd5b80630fb59156116101b65780630fb59156146102475780631856ddfe146102675780631c489e4f14610287578063248a9ca3146102c957600080fd5b806301ffc9a7146101dd57806306039e4b146102125780630d32b50514610227575b600080fd5b3480156101e957600080fd5b506101fd6101f8366004611bda565b610641565b60405190151581526020015b60405180910390f35b610225610220366004611c7b565b61069d565b005b34801561023357600080fd5b50610225610242366004611d63565b610761565b34801561025357600080fd5b50610225610262366004611dce565b610834565b34801561027357600080fd5b50610225610282366004611de9565b61086b565b34801561029357600080fd5b506102bb7f67458b9c8206fd7556afadce1bc8e28c7a8942ecb92d9d9fad69bb6c8cf75c8481565b604051908152602001610209565b3480156102d557600080fd5b506102bb6102e4366004611e1e565b60009081526020819052604090206001015490565b34801561030557600080fd5b5061030e6108ad565b604051610209929190611ee9565b34801561032857600080fd5b50610225610337366004611f0e565b6108c8565b34801561034857600080fd5b50610225610357366004611f0e565b6108f3565b34801561036857600080fd5b5061022561093f565b34801561037d57600080fd5b5061022561038c366004611dce565b610957565b34801561039d57600080fd5b506102bb6103ac366004611f31565b67ffffffffffffffff1660009081526005602052604090205490565b6102256103d6366004611f4e565b6109e7565b3480156103e757600080fd5b50604080518082018252600080825260209182015281518083019092526003548252600454908201526040516102099190611fd3565b34801561042957600080fd5b506102bb610438366004611fea565b610af2565b34801561044957600080fd5b5061045d6104583660046120c3565b610b1d565b6040516001600160a01b039091168152602001610209565b34801561048157600080fd5b5061045d610490366004611f31565b610b3c565b3480156104a157600080fd5b506101fd6104b0366004611f0e565b6000918252602082815260408084206001600160a01b0393909316845291905290205460ff1690565b3480156104e557600080fd5b506104ee610ba2565b60405161020991906120e5565b34801561050757600080fd5b506102bb600081565b34801561051c57600080fd5b506104ee610bb3565b34801561053157600080fd5b50610225610540366004611dce565b610bbf565b34801561055157600080fd5b506002546001600160a01b031661045d565b34801561056f57600080fd5b50600a546001600160a01b031661045d565b34801561058d57600080fd5b506102bb61059c366004611e1e565b610c7c565b3480156105ad57600080fd5b506102256105bc366004611dce565b610c93565b3480156105cd57600080fd5b506102256105dc366004611f0e565b610d87565b3480156105ed57600080fd5b506102256105fc366004611dce565b610dac565b34801561060d57600080fd5b5061022561061c3660046120f8565b610ddf565b34801561062d57600080fd5b5061022561063c366004612134565b610e13565b60007fffffffff0000000000000000000000000000000000000000000000000000000082167f5a05180f000000000000000000000000000000000000000000000000000000001480610697575061069782610e47565b92915050565b60006106f5863460405180604001604052808981526020018881525086868080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250610ede92505050565b6020808201516040808401518451825167ffffffffffffffff808e1682529485169581019590955292169083015260608201529091507facd206517737a1387f9ae09d956edd387fd49c710ac2d4c72993f67fffb06aa8906080015b60405180910390a1505050505050565b7f67458b9c8206fd7556afadce1bc8e28c7a8942ecb92d9d9fad69bb6c8cf75c8461078b81610f39565b8151158061079b57506020820151155b156107e757815160208301516040517f8bdc31dd000000000000000000000000000000000000000000000000000000008152600481019290925260248201526044015b60405180910390fd5b81516003819055602080840151600481905560408051938452918301527f156e53f21add5e964d33e39e015675e24d4568202b47744bd8cc6080f76deabf91015b60405180910390a15050565b7f67458b9c8206fd7556afadce1bc8e28c7a8942ecb92d9d9fad69bb6c8cf75c8461085e81610f39565b61086782610f43565b5050565b7f67458b9c8206fd7556afadce1bc8e28c7a8942ecb92d9d9fad69bb6c8cf75c8461089581610f39565b6108a8836001600160a01b038416611002565b505050565b6060806108b86110d4565b91506108c2610bb3565b90509091565b6000828152602081905260409020600101546108e381610f39565b6108ed83836110f7565b50505050565b6001600160a01b0381163314610935576040517f6697b23200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6108a8828261112c565b600061094a81610f39565b6109543347611159565b50565b7f67458b9c8206fd7556afadce1bc8e28c7a8942ecb92d9d9fad69bb6c8cf75c8461098181610f39565b600a80547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b0384169081179091556040519081527f56f2046f579030345e1c12cfd7e2d297e4059c24d30ac1a5cb27a8ee1d53526e90602001610828565b6109f033611222565b610a28576040517f0578f6950000000000000000000000000000000000000000000000000000000081523360048201526024016107de565b468667ffffffffffffffff1603610a77576040517fc1888df600000000000000000000000000000000000000000000000000000000815267ffffffffffffffff871660048201526024016107de565b67ffffffffffffffff86166000908152600560205260409020548514610adc576040517f69b2b5e400000000000000000000000000000000000000000000000000000000815267ffffffffffffffff87166004820152602481018690526044016107de565b610aea86868686868661122f565b505050505050565b6000610b14856040518060400160405280878152602001868152508451611268565b95945050505050565b6000828152600160205260408120610b359083611281565b9392505050565b67ffffffffffffffff8116600090815260056020526040902054806001600160a01b0381168114610b9c576040517ff04c4a45000000000000000000000000000000000000000000000000000000008152600481018290526024016107de565b50919050565b6060610bae600661128d565b905090565b6060610bae600861128d565b7f67458b9c8206fd7556afadce1bc8e28c7a8942ecb92d9d9fad69bb6c8cf75c84610be981610f39565b6000610bf660088461129a565b905080610c3a576040517fb12a48e60000000000000000000000000000000000000000000000000000000081526001600160a01b03841660048201526024016107de565b6040516001600160a01b03841681527f91071153b5721fdadecd5ab74cedca9c0faa62c94f02ef659df2241602698385906020015b60405180910390a1505050565b6000818152600160205260408120610697906112af565b7f67458b9c8206fd7556afadce1bc8e28c7a8942ecb92d9d9fad69bb6c8cf75c84610cbd81610f39565b6001600160a01b038216610cfd576040517fa8ce0c2e00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6000610d0a6008846112b9565b905080610d4e576040517f856e38ac0000000000000000000000000000000000000000000000000000000081526001600160a01b03841660048201526024016107de565b6040516001600160a01b03841681527f0f92a0308a1fb283891a96a4cf077b8499cca0159d8e6ccc8d12096a5011750990602001610c6f565b600082815260208190526040902060010154610da281610f39565b6108ed838361112c565b7f67458b9c8206fd7556afadce1bc8e28c7a8942ecb92d9d9fad69bb6c8cf75c84610dd681610f39565b610867826112ce565b7f67458b9c8206fd7556afadce1bc8e28c7a8942ecb92d9d9fad69bb6c8cf75c84610e0981610f39565b6108a88383611401565b7f67458b9c8206fd7556afadce1bc8e28c7a8942ecb92d9d9fad69bb6c8cf75c84610e3d81610f39565b6108a88383611002565b60007fffffffff0000000000000000000000000000000000000000000000000000000082167f7965db0b00000000000000000000000000000000000000000000000000000000148061069757507f01ffc9a7000000000000000000000000000000000000000000000000000000007fffffffff00000000000000000000000000000000000000000000000000000000831614610697565b6040805160608101825260008082526020820181905291810182905290610f04846114e2565b67ffffffffffffffff8716600090815260056020526040902054909150610f2f90879087848761150e565b9695505050505050565b61095481336116f7565b610f4c81611222565b610f8d576040517f0578f6950000000000000000000000000000000000000000000000000000000081526001600160a01b03821660048201526024016107de565b610f98816000611763565b6040516001600160a01b03821681527fc0d64f9e088893f1e4aea6d42c0e815f158ca62962029260f3c2b079d97feccc9060200160405180910390a16002546001600160a01b03166001600160a01b0316816001600160a01b0316036109545761095460006112ce565b468267ffffffffffffffff1603611051576040517fc1888df600000000000000000000000000000000000000000000000000000000815267ffffffffffffffff831660048201526024016107de565b600081900361108c576040517fe04fb69600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b67ffffffffffffffff8216600081815260056020526040808220849055518392917f622d488f4fb24881af2fe5b552b249253a21e4a6fa77d12e69f61ee0fdfb9a3191a35050565b6040805180820190915260035481526004546020820152606090610bae906114e2565b600080611104848461177f565b90508015610b3557600084815260016020526040902061112490846112b9565b509392505050565b6000806111398484611847565b90508015610b35576000848152600160205260409020611124908461129a565b80471015611195576040517fcd7860590000000000000000000000000000000000000000000000000000000081523060048201526024016107de565b6000826001600160a01b03168260405160006040518083038185875af1925050503d80600081146111e2576040519150601f19603f3d011682016040523d82523d6000602084013e6111e7565b606091505b50509050806108a8576040517f1425ea4200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60006106976006836118e8565b7faab00190e6c2e4b0ef940711bb1674ed236de699daf36f611aaf834f3d8eb00286868686868660405161075196959493929190612160565b600080611274846114e2565b9050610b1485828561190a565b6000610b3583836119ee565b60606000610b3583611a18565b6000610b35836001600160a01b038416611a74565b6000610697825490565b6000610b35836001600160a01b038416611b67565b6112d781611222565b1580156112ec57506001600160a01b03811615155b1561132e576040517f0578f6950000000000000000000000000000000000000000000000000000000081526001600160a01b03821660048201526024016107de565b6002546001600160a01b03166001600160a01b0316816001600160a01b03160361138f576040517f56c309440000000000000000000000000000000000000000000000000000000081526001600160a01b03821660048201526024016107de565b600280547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b0383161790556040516001600160a01b03821681527fd6c4ff3ce819d1fe47a30bb776376d847d8085a73ebf92dbf4058c36fdd5c1699060200160405180910390a150565b6001600160a01b038216611441576040517f6be4ac5200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b61144a82611222565b1561148c576040517f4ea647680000000000000000000000000000000000000000000000000000000081526001600160a01b03831660048201526024016107de565b611497826001611763565b6040516001600160a01b03831681527f9963c5d146abd18838e0638ea82ec86b9a726e15fd852cab94aeebcd8bf438d19060200160405180910390a1801561086757610867826112ce565b60606106976001836040516020016114fa9190611fd3565b604051602081830303815290604052611bae565b6040805160608101825260008082526020820181905291810191909152600061153f6002546001600160a01b031690565b90506001600160a01b038116611581576040517f6be4ac5200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b468767ffffffffffffffff16036115d0576040517fc1888df600000000000000000000000000000000000000000000000000000000815267ffffffffffffffff881660048201526024016107de565b6000869003611617576040517f95ccdac900000000000000000000000000000000000000000000000000000000815267ffffffffffffffff881660048201526024016107de565b8447101561165a576040517f5b59cdf2000000000000000000000000000000000000000000000000000000008152476004820152602481018690526044016107de565b806001600160a01b031663547efb8486898961167e600a546001600160a01b031690565b611686610bb3565b8a8a6040518863ffffffff1660e01b81526004016116a9969594939291906121dc565b60606040518083038185885af11580156116c7573d6000803e3d6000fd5b50505050506040513d601f19601f820116820180604052508101906116ec9190612247565b979650505050505050565b6000828152602081815260408083206001600160a01b038516845290915290205460ff16610867576040517fe2517d3f0000000000000000000000000000000000000000000000000000000081526001600160a01b0382166004820152602481018390526044016107de565b8015611774576108a86006836112b9565b6108a860068361129a565b6000828152602081815260408083206001600160a01b038516845290915281205460ff1661183f576000838152602081815260408083206001600160a01b0386168452909152902080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff001660011790556117f73390565b6001600160a01b0316826001600160a01b0316847f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d60405160405180910390a4506001610697565b506000610697565b6000828152602081815260408083206001600160a01b038516845290915281205460ff161561183f576000838152602081815260408083206001600160a01b038616808552925280832080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0016905551339286917ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b9190a4506001610697565b6001600160a01b03811660009081526001830160205260408120541515610b35565b60008061191f6002546001600160a01b031690565b90506001600160a01b038116611961576040517f6be4ac5200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b806001600160a01b031663cbb3c63186611983600a546001600160a01b031690565b61198b610bb3565b88886040518663ffffffff1660e01b81526004016119ad9594939291906122b0565b602060405180830381865afa1580156119ca573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b149190612307565b6000826000018281548110611a0557611a05612320565b9060005260206000200154905092915050565b606081600001805480602002602001604051908101604052809291908181526020018280548015611a6857602002820191906000526020600020905b815481526020019060010190808311611a54575b50505050509050919050565b60008181526001830160205260408120548015611b5d576000611a9860018361234f565b8554909150600090611aac9060019061234f565b9050808214611b11576000866000018281548110611acc57611acc612320565b9060005260206000200154905080876000018481548110611aef57611aef612320565b6000918252602080832090910192909255918252600188019052604090208390555b8554869080611b2257611b22612389565b600190038181906000526020600020016000905590558560010160008681526020019081526020016000206000905560019350505050610697565b6000915050610697565b600081815260018301602052604081205461183f57508154600181810184556000848152602080822090930184905584548482528286019093526040902091909155610697565b60608282604051602001611bc39291906123b8565b604051602081830303815290604052905092915050565b600060208284031215611bec57600080fd5b81357fffffffff0000000000000000000000000000000000000000000000000000000081168114610b3557600080fd5b67ffffffffffffffff8116811461095457600080fd5b60008083601f840112611c4457600080fd5b50813567ffffffffffffffff811115611c5c57600080fd5b602083019150836020828501011115611c7457600080fd5b9250929050565b600080600080600060808688031215611c9357600080fd5b8535611c9e81611c1c565b94506020860135935060408601359250606086013567ffffffffffffffff811115611cc857600080fd5b611cd488828901611c32565b969995985093965092949392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff81118282101715611d5b57611d5b611ce5565b604052919050565b600060408284031215611d7557600080fd5b6040516040810181811067ffffffffffffffff82111715611d9857611d98611ce5565b604052823581526020928301359281019290925250919050565b80356001600160a01b0381168114611dc957600080fd5b919050565b600060208284031215611de057600080fd5b610b3582611db2565b60008060408385031215611dfc57600080fd5b8235611e0781611c1c565b9150611e1560208401611db2565b90509250929050565b600060208284031215611e3057600080fd5b5035919050565b60005b83811015611e52578181015183820152602001611e3a565b50506000910152565b60008151808452611e73816020860160208601611e37565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b600081518084526020808501945080840160005b83811015611ede5781516001600160a01b031687529582019590820190600101611eb9565b509495945050505050565b604081526000611efc6040830185611e5b565b8281036020840152610b148185611ea5565b60008060408385031215611f2157600080fd5b82359150611e1560208401611db2565b600060208284031215611f4357600080fd5b8135610b3581611c1c565b60008060008060008060a08789031215611f6757600080fd5b8635611f7281611c1c565b9550602087013594506040870135611f8981611c1c565b93506060870135611f9981611c1c565b9250608087013567ffffffffffffffff811115611fb557600080fd5b611fc189828a01611c32565b979a9699509497509295939492505050565b815181526020808301519082015260408101610697565b6000806000806080858703121561200057600080fd5b843561200b81611c1c565b9350602085810135935060408601359250606086013567ffffffffffffffff8082111561203757600080fd5b818801915088601f83011261204b57600080fd5b81358181111561205d5761205d611ce5565b61208d847fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f84011601611d14565b915080825289848285010111156120a357600080fd5b808484018584013760008482840101525080935050505092959194509250565b600080604083850312156120d657600080fd5b50508035926020909101359150565b602081526000610b356020830184611ea5565b6000806040838503121561210b57600080fd5b61211483611db2565b91506020830135801515811461212957600080fd5b809150509250929050565b6000806040838503121561214757600080fd5b823561215281611c1c565b946020939093013593505050565b600067ffffffffffffffff8089168352876020840152808716604084015280861660608401525060a060808301528260a0830152828460c0840137600060c0848401015260c07fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f8501168301019050979650505050505050565b67ffffffffffffffff871681528560208201526001600160a01b038516604082015260c06060820152600061221460c0830186611ea5565b82810360808401526122268186611e5b565b905082810360a084015261223a8185611e5b565b9998505050505050505050565b60006060828403121561225957600080fd5b6040516060810181811067ffffffffffffffff8211171561227c5761227c611ce5565b60405282518152602083015161229181611c1c565b602082015260408301516122a481611c1c565b60408201529392505050565b67ffffffffffffffff861681526001600160a01b038516602082015260a0604082015260006122e260a0830186611ea5565b82810360608401526122f48186611e5b565b9150508260808301529695505050505050565b60006020828403121561231957600080fd5b5051919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b81810381811115610697577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603160045260246000fd5b7fffff0000000000000000000000000000000000000000000000000000000000008360f01b168152600082516123f5816002850160208701611e37565b91909101600201939250505056fea2646970667358221220267a48a849f4a04b1bee6e7e913f0ea0f8fed75ffdb9d9070b2602219e5b031b64736f6c63430008140033","runtime-code":"0x6080604052600436106101d85760003560e01c80638b41db0411610102578063bc0d912c11610095578063d547741f11610064578063d547741f146105c1578063eb53b44e146105e1578063f22ba23d14610601578063f6b266fd1461062157600080fd5b8063bc0d912c14610545578063c313c80714610563578063ca15c87314610581578063cb5038fb146105a157600080fd5b8063a1aa5d68116100d1578063a1aa5d68146104d9578063a217fddf146104fb578063b2494df314610510578063b70c40b31461052557600080fd5b80638b41db041461041d5780639010d07c1461043d57806390a92c161461047557806391d148541461049557600080fd5b8063287bc0571161017a578063496774b111610149578063496774b1146103715780634e6427e7146103915780636e9fd609146103c85780637717a647146103db57600080fd5b8063287bc057146102f95780632f2ff15d1461031c57806336568abe1461033c5780633ccfd60b1461035c57600080fd5b80630fb59156116101b65780630fb59156146102475780631856ddfe146102675780631c489e4f14610287578063248a9ca3146102c957600080fd5b806301ffc9a7146101dd57806306039e4b146102125780630d32b50514610227575b600080fd5b3480156101e957600080fd5b506101fd6101f8366004611bda565b610641565b60405190151581526020015b60405180910390f35b610225610220366004611c7b565b61069d565b005b34801561023357600080fd5b50610225610242366004611d63565b610761565b34801561025357600080fd5b50610225610262366004611dce565b610834565b34801561027357600080fd5b50610225610282366004611de9565b61086b565b34801561029357600080fd5b506102bb7f67458b9c8206fd7556afadce1bc8e28c7a8942ecb92d9d9fad69bb6c8cf75c8481565b604051908152602001610209565b3480156102d557600080fd5b506102bb6102e4366004611e1e565b60009081526020819052604090206001015490565b34801561030557600080fd5b5061030e6108ad565b604051610209929190611ee9565b34801561032857600080fd5b50610225610337366004611f0e565b6108c8565b34801561034857600080fd5b50610225610357366004611f0e565b6108f3565b34801561036857600080fd5b5061022561093f565b34801561037d57600080fd5b5061022561038c366004611dce565b610957565b34801561039d57600080fd5b506102bb6103ac366004611f31565b67ffffffffffffffff1660009081526005602052604090205490565b6102256103d6366004611f4e565b6109e7565b3480156103e757600080fd5b50604080518082018252600080825260209182015281518083019092526003548252600454908201526040516102099190611fd3565b34801561042957600080fd5b506102bb610438366004611fea565b610af2565b34801561044957600080fd5b5061045d6104583660046120c3565b610b1d565b6040516001600160a01b039091168152602001610209565b34801561048157600080fd5b5061045d610490366004611f31565b610b3c565b3480156104a157600080fd5b506101fd6104b0366004611f0e565b6000918252602082815260408084206001600160a01b0393909316845291905290205460ff1690565b3480156104e557600080fd5b506104ee610ba2565b60405161020991906120e5565b34801561050757600080fd5b506102bb600081565b34801561051c57600080fd5b506104ee610bb3565b34801561053157600080fd5b50610225610540366004611dce565b610bbf565b34801561055157600080fd5b506002546001600160a01b031661045d565b34801561056f57600080fd5b50600a546001600160a01b031661045d565b34801561058d57600080fd5b506102bb61059c366004611e1e565b610c7c565b3480156105ad57600080fd5b506102256105bc366004611dce565b610c93565b3480156105cd57600080fd5b506102256105dc366004611f0e565b610d87565b3480156105ed57600080fd5b506102256105fc366004611dce565b610dac565b34801561060d57600080fd5b5061022561061c3660046120f8565b610ddf565b34801561062d57600080fd5b5061022561063c366004612134565b610e13565b60007fffffffff0000000000000000000000000000000000000000000000000000000082167f5a05180f000000000000000000000000000000000000000000000000000000001480610697575061069782610e47565b92915050565b60006106f5863460405180604001604052808981526020018881525086868080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250610ede92505050565b6020808201516040808401518451825167ffffffffffffffff808e1682529485169581019590955292169083015260608201529091507facd206517737a1387f9ae09d956edd387fd49c710ac2d4c72993f67fffb06aa8906080015b60405180910390a1505050505050565b7f67458b9c8206fd7556afadce1bc8e28c7a8942ecb92d9d9fad69bb6c8cf75c8461078b81610f39565b8151158061079b57506020820151155b156107e757815160208301516040517f8bdc31dd000000000000000000000000000000000000000000000000000000008152600481019290925260248201526044015b60405180910390fd5b81516003819055602080840151600481905560408051938452918301527f156e53f21add5e964d33e39e015675e24d4568202b47744bd8cc6080f76deabf91015b60405180910390a15050565b7f67458b9c8206fd7556afadce1bc8e28c7a8942ecb92d9d9fad69bb6c8cf75c8461085e81610f39565b61086782610f43565b5050565b7f67458b9c8206fd7556afadce1bc8e28c7a8942ecb92d9d9fad69bb6c8cf75c8461089581610f39565b6108a8836001600160a01b038416611002565b505050565b6060806108b86110d4565b91506108c2610bb3565b90509091565b6000828152602081905260409020600101546108e381610f39565b6108ed83836110f7565b50505050565b6001600160a01b0381163314610935576040517f6697b23200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6108a8828261112c565b600061094a81610f39565b6109543347611159565b50565b7f67458b9c8206fd7556afadce1bc8e28c7a8942ecb92d9d9fad69bb6c8cf75c8461098181610f39565b600a80547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b0384169081179091556040519081527f56f2046f579030345e1c12cfd7e2d297e4059c24d30ac1a5cb27a8ee1d53526e90602001610828565b6109f033611222565b610a28576040517f0578f6950000000000000000000000000000000000000000000000000000000081523360048201526024016107de565b468667ffffffffffffffff1603610a77576040517fc1888df600000000000000000000000000000000000000000000000000000000815267ffffffffffffffff871660048201526024016107de565b67ffffffffffffffff86166000908152600560205260409020548514610adc576040517f69b2b5e400000000000000000000000000000000000000000000000000000000815267ffffffffffffffff87166004820152602481018690526044016107de565b610aea86868686868661122f565b505050505050565b6000610b14856040518060400160405280878152602001868152508451611268565b95945050505050565b6000828152600160205260408120610b359083611281565b9392505050565b67ffffffffffffffff8116600090815260056020526040902054806001600160a01b0381168114610b9c576040517ff04c4a45000000000000000000000000000000000000000000000000000000008152600481018290526024016107de565b50919050565b6060610bae600661128d565b905090565b6060610bae600861128d565b7f67458b9c8206fd7556afadce1bc8e28c7a8942ecb92d9d9fad69bb6c8cf75c84610be981610f39565b6000610bf660088461129a565b905080610c3a576040517fb12a48e60000000000000000000000000000000000000000000000000000000081526001600160a01b03841660048201526024016107de565b6040516001600160a01b03841681527f91071153b5721fdadecd5ab74cedca9c0faa62c94f02ef659df2241602698385906020015b60405180910390a1505050565b6000818152600160205260408120610697906112af565b7f67458b9c8206fd7556afadce1bc8e28c7a8942ecb92d9d9fad69bb6c8cf75c84610cbd81610f39565b6001600160a01b038216610cfd576040517fa8ce0c2e00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6000610d0a6008846112b9565b905080610d4e576040517f856e38ac0000000000000000000000000000000000000000000000000000000081526001600160a01b03841660048201526024016107de565b6040516001600160a01b03841681527f0f92a0308a1fb283891a96a4cf077b8499cca0159d8e6ccc8d12096a5011750990602001610c6f565b600082815260208190526040902060010154610da281610f39565b6108ed838361112c565b7f67458b9c8206fd7556afadce1bc8e28c7a8942ecb92d9d9fad69bb6c8cf75c84610dd681610f39565b610867826112ce565b7f67458b9c8206fd7556afadce1bc8e28c7a8942ecb92d9d9fad69bb6c8cf75c84610e0981610f39565b6108a88383611401565b7f67458b9c8206fd7556afadce1bc8e28c7a8942ecb92d9d9fad69bb6c8cf75c84610e3d81610f39565b6108a88383611002565b60007fffffffff0000000000000000000000000000000000000000000000000000000082167f7965db0b00000000000000000000000000000000000000000000000000000000148061069757507f01ffc9a7000000000000000000000000000000000000000000000000000000007fffffffff00000000000000000000000000000000000000000000000000000000831614610697565b6040805160608101825260008082526020820181905291810182905290610f04846114e2565b67ffffffffffffffff8716600090815260056020526040902054909150610f2f90879087848761150e565b9695505050505050565b61095481336116f7565b610f4c81611222565b610f8d576040517f0578f6950000000000000000000000000000000000000000000000000000000081526001600160a01b03821660048201526024016107de565b610f98816000611763565b6040516001600160a01b03821681527fc0d64f9e088893f1e4aea6d42c0e815f158ca62962029260f3c2b079d97feccc9060200160405180910390a16002546001600160a01b03166001600160a01b0316816001600160a01b0316036109545761095460006112ce565b468267ffffffffffffffff1603611051576040517fc1888df600000000000000000000000000000000000000000000000000000000815267ffffffffffffffff831660048201526024016107de565b600081900361108c576040517fe04fb69600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b67ffffffffffffffff8216600081815260056020526040808220849055518392917f622d488f4fb24881af2fe5b552b249253a21e4a6fa77d12e69f61ee0fdfb9a3191a35050565b6040805180820190915260035481526004546020820152606090610bae906114e2565b600080611104848461177f565b90508015610b3557600084815260016020526040902061112490846112b9565b509392505050565b6000806111398484611847565b90508015610b35576000848152600160205260409020611124908461129a565b80471015611195576040517fcd7860590000000000000000000000000000000000000000000000000000000081523060048201526024016107de565b6000826001600160a01b03168260405160006040518083038185875af1925050503d80600081146111e2576040519150601f19603f3d011682016040523d82523d6000602084013e6111e7565b606091505b50509050806108a8576040517f1425ea4200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60006106976006836118e8565b7faab00190e6c2e4b0ef940711bb1674ed236de699daf36f611aaf834f3d8eb00286868686868660405161075196959493929190612160565b600080611274846114e2565b9050610b1485828561190a565b6000610b3583836119ee565b60606000610b3583611a18565b6000610b35836001600160a01b038416611a74565b6000610697825490565b6000610b35836001600160a01b038416611b67565b6112d781611222565b1580156112ec57506001600160a01b03811615155b1561132e576040517f0578f6950000000000000000000000000000000000000000000000000000000081526001600160a01b03821660048201526024016107de565b6002546001600160a01b03166001600160a01b0316816001600160a01b03160361138f576040517f56c309440000000000000000000000000000000000000000000000000000000081526001600160a01b03821660048201526024016107de565b600280547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b0383161790556040516001600160a01b03821681527fd6c4ff3ce819d1fe47a30bb776376d847d8085a73ebf92dbf4058c36fdd5c1699060200160405180910390a150565b6001600160a01b038216611441576040517f6be4ac5200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b61144a82611222565b1561148c576040517f4ea647680000000000000000000000000000000000000000000000000000000081526001600160a01b03831660048201526024016107de565b611497826001611763565b6040516001600160a01b03831681527f9963c5d146abd18838e0638ea82ec86b9a726e15fd852cab94aeebcd8bf438d19060200160405180910390a1801561086757610867826112ce565b60606106976001836040516020016114fa9190611fd3565b604051602081830303815290604052611bae565b6040805160608101825260008082526020820181905291810191909152600061153f6002546001600160a01b031690565b90506001600160a01b038116611581576040517f6be4ac5200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b468767ffffffffffffffff16036115d0576040517fc1888df600000000000000000000000000000000000000000000000000000000815267ffffffffffffffff881660048201526024016107de565b6000869003611617576040517f95ccdac900000000000000000000000000000000000000000000000000000000815267ffffffffffffffff881660048201526024016107de565b8447101561165a576040517f5b59cdf2000000000000000000000000000000000000000000000000000000008152476004820152602481018690526044016107de565b806001600160a01b031663547efb8486898961167e600a546001600160a01b031690565b611686610bb3565b8a8a6040518863ffffffff1660e01b81526004016116a9969594939291906121dc565b60606040518083038185885af11580156116c7573d6000803e3d6000fd5b50505050506040513d601f19601f820116820180604052508101906116ec9190612247565b979650505050505050565b6000828152602081815260408083206001600160a01b038516845290915290205460ff16610867576040517fe2517d3f0000000000000000000000000000000000000000000000000000000081526001600160a01b0382166004820152602481018390526044016107de565b8015611774576108a86006836112b9565b6108a860068361129a565b6000828152602081815260408083206001600160a01b038516845290915281205460ff1661183f576000838152602081815260408083206001600160a01b0386168452909152902080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff001660011790556117f73390565b6001600160a01b0316826001600160a01b0316847f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d60405160405180910390a4506001610697565b506000610697565b6000828152602081815260408083206001600160a01b038516845290915281205460ff161561183f576000838152602081815260408083206001600160a01b038616808552925280832080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0016905551339286917ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b9190a4506001610697565b6001600160a01b03811660009081526001830160205260408120541515610b35565b60008061191f6002546001600160a01b031690565b90506001600160a01b038116611961576040517f6be4ac5200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b806001600160a01b031663cbb3c63186611983600a546001600160a01b031690565b61198b610bb3565b88886040518663ffffffff1660e01b81526004016119ad9594939291906122b0565b602060405180830381865afa1580156119ca573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b149190612307565b6000826000018281548110611a0557611a05612320565b9060005260206000200154905092915050565b606081600001805480602002602001604051908101604052809291908181526020018280548015611a6857602002820191906000526020600020905b815481526020019060010190808311611a54575b50505050509050919050565b60008181526001830160205260408120548015611b5d576000611a9860018361234f565b8554909150600090611aac9060019061234f565b9050808214611b11576000866000018281548110611acc57611acc612320565b9060005260206000200154905080876000018481548110611aef57611aef612320565b6000918252602080832090910192909255918252600188019052604090208390555b8554869080611b2257611b22612389565b600190038181906000526020600020016000905590558560010160008681526020019081526020016000206000905560019350505050610697565b6000915050610697565b600081815260018301602052604081205461183f57508154600181810184556000848152602080822090930184905584548482528286019093526040902091909155610697565b60608282604051602001611bc39291906123b8565b604051602081830303815290604052905092915050565b600060208284031215611bec57600080fd5b81357fffffffff0000000000000000000000000000000000000000000000000000000081168114610b3557600080fd5b67ffffffffffffffff8116811461095457600080fd5b60008083601f840112611c4457600080fd5b50813567ffffffffffffffff811115611c5c57600080fd5b602083019150836020828501011115611c7457600080fd5b9250929050565b600080600080600060808688031215611c9357600080fd5b8535611c9e81611c1c565b94506020860135935060408601359250606086013567ffffffffffffffff811115611cc857600080fd5b611cd488828901611c32565b969995985093965092949392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff81118282101715611d5b57611d5b611ce5565b604052919050565b600060408284031215611d7557600080fd5b6040516040810181811067ffffffffffffffff82111715611d9857611d98611ce5565b604052823581526020928301359281019290925250919050565b80356001600160a01b0381168114611dc957600080fd5b919050565b600060208284031215611de057600080fd5b610b3582611db2565b60008060408385031215611dfc57600080fd5b8235611e0781611c1c565b9150611e1560208401611db2565b90509250929050565b600060208284031215611e3057600080fd5b5035919050565b60005b83811015611e52578181015183820152602001611e3a565b50506000910152565b60008151808452611e73816020860160208601611e37565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b600081518084526020808501945080840160005b83811015611ede5781516001600160a01b031687529582019590820190600101611eb9565b509495945050505050565b604081526000611efc6040830185611e5b565b8281036020840152610b148185611ea5565b60008060408385031215611f2157600080fd5b82359150611e1560208401611db2565b600060208284031215611f4357600080fd5b8135610b3581611c1c565b60008060008060008060a08789031215611f6757600080fd5b8635611f7281611c1c565b9550602087013594506040870135611f8981611c1c565b93506060870135611f9981611c1c565b9250608087013567ffffffffffffffff811115611fb557600080fd5b611fc189828a01611c32565b979a9699509497509295939492505050565b815181526020808301519082015260408101610697565b6000806000806080858703121561200057600080fd5b843561200b81611c1c565b9350602085810135935060408601359250606086013567ffffffffffffffff8082111561203757600080fd5b818801915088601f83011261204b57600080fd5b81358181111561205d5761205d611ce5565b61208d847fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f84011601611d14565b915080825289848285010111156120a357600080fd5b808484018584013760008482840101525080935050505092959194509250565b600080604083850312156120d657600080fd5b50508035926020909101359150565b602081526000610b356020830184611ea5565b6000806040838503121561210b57600080fd5b61211483611db2565b91506020830135801515811461212957600080fd5b809150509250929050565b6000806040838503121561214757600080fd5b823561215281611c1c565b946020939093013593505050565b600067ffffffffffffffff8089168352876020840152808716604084015280861660608401525060a060808301528260a0830152828460c0840137600060c0848401015260c07fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f8501168301019050979650505050505050565b67ffffffffffffffff871681528560208201526001600160a01b038516604082015260c06060820152600061221460c0830186611ea5565b82810360808401526122268186611e5b565b905082810360a084015261223a8185611e5b565b9998505050505050505050565b60006060828403121561225957600080fd5b6040516060810181811067ffffffffffffffff8211171561227c5761227c611ce5565b60405282518152602083015161229181611c1c565b602082015260408301516122a481611c1c565b60408201529392505050565b67ffffffffffffffff861681526001600160a01b038516602082015260a0604082015260006122e260a0830186611ea5565b82810360608401526122f48186611e5b565b9150508260808301529695505050505050565b60006020828403121561231957600080fd5b5051919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b81810381811115610697577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603160045260246000fd5b7fffff0000000000000000000000000000000000000000000000000000000000008360f01b168152600082516123f5816002850160208701611e37565b91909101600201939250505056fea2646970667358221220267a48a849f4a04b1bee6e7e913f0ea0f8fed75ffdb9d9070b2602219e5b031b64736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/AbstractICAppEvents.sol\n\nabstract contract AbstractICAppEvents {\n    event InterchainClientAdded(address client);\n    event InterchainClientRemoved(address client);\n    event LatestClientSet(address client);\n}\n\n// contracts/events/InterchainAppV1Events.sol\n\nabstract contract InterchainAppV1Events {\n    event AppConfigV1Set(uint256 requiredResponses, uint256 optimisticPeriod);\n    event AppLinked(uint256 indexed chainId, bytes32 indexed remoteApp);\n    event ExecutionServiceSet(address executionService);\n    event TrustedModuleAdded(address module);\n    event TrustedModuleRemoved(address module);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    /// @notice Allows the Interchain Client to pass the message to the Interchain App.\n    /// @dev App is responsible for keeping track of interchain clients, and must verify the message sender.\n    /// @param srcChainId   Chain ID of the source chain, where the message was sent from.\n    /// @param sender       Sender address on the source chain, as a bytes32 value.\n    /// @param dbNonce      The Interchain DB nonce of the batch containing the message entry.\n    /// @param entryIndex   The index of the message entry within the batch.\n    /// @param message      The message being sent.\n    function appReceive(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /// @notice Returns the verification configuration of the Interchain App.\n    /// @dev This configuration is used by the Interchain Client to verify that message has been confirmed\n    /// by the Interchain Modules on the destination chain.\n    /// Note: V1 version of AppConfig includes the required responses count, and optimistic period after which\n    /// the message is considered confirmed by the module. Following versions may include additional fields.\n    /// @return appConfig    The versioned configuration of the Interchain App, encoded as bytes.\n    /// @return modules      The list of Interchain Modules that app is trusting to confirm the messages.\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/Math.sol\n\nlibrary MathLib {\n    /// @notice Rounds up to the nearest multiple of 32.\n    /// Note: Returns zero on overflows instead of reverting. This is fine for practical\n    /// use cases, as this is used for determining the size of the payload in memory.\n    function roundUpToWord(uint256 x) internal pure returns (uint256) {\n        unchecked {\n            return (x + 31) \u0026 ~uint256(31);\n        }\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/VersionedPayload.sol\n\n// solhint-disable no-inline-assembly\n// solhint-disable ordering\nlibrary VersionedPayloadLib {\n    /// @notice Amount of bytes reserved for the version (uint16) in the versioned payload\n    uint256 internal constant VERSION_LENGTH = 2;\n\n    error VersionedPayload__TooShort(bytes versionedPayload);\n    error VersionedPayload__PrecompileFailed();\n\n    /// @notice Encodes the versioned payload into a single bytes array.\n    /// @param version  The payload's version.\n    /// @param payload  The payload to encode.\n    function encodeVersionedPayload(uint16 version, bytes memory payload) internal pure returns (bytes memory) {\n        return abi.encodePacked(version, payload);\n    }\n\n    /// @notice Extracts the version from the versioned payload (calldata reference).\n    /// @param versionedPayload     The versioned payload (calldata reference).\n    function getVersion(bytes calldata versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            version := shr(240, calldataload(versionedPayload.offset))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (calldata reference).\n    /// @dev The extracted payload is also returned as a calldata reference.\n    /// @param versionedPayload     The versioned payload.\n    function getPayload(bytes calldata versionedPayload) internal pure returns (bytes calldata) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        return versionedPayload[VERSION_LENGTH:];\n    }\n\n    /// @notice Extracts the version from the versioned payload (memory reference).\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getVersionFromMemory(bytes memory versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            // We add 0x20 to skip the length of the bytes array.\n            version := shr(240, mload(add(versionedPayload, 0x20)))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (memory reference).\n    /// @dev The extracted payload is copied into a new memory location. Use `getPayload` when possible\n    /// to avoid extra memory allocation.\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getPayloadFromMemory(bytes memory versionedPayload) internal view returns (bytes memory payload) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        // Figure how many bytes to copy and allocate the memory for the extracted payload.\n        uint256 toCopy;\n        unchecked {\n            toCopy = versionedPayload.length - VERSION_LENGTH;\n        }\n        payload = new bytes(toCopy);\n        // Use identity precompile (0x04) to copy the payload. Unlike MCOPY, this is available on all EVM chains.\n        bool res;\n        assembly {\n            // We add 0x20 to skip the length of the bytes array.\n            // We add 0x02 to skip the 2 bytes reserved for the version.\n            // Copy the payload to the previously allocated memory.\n            res := staticcall(gas(), 0x04, add(versionedPayload, 0x22), toCopy, add(payload, 0x20), toCopy)\n        }\n        if (!res) {\n            revert VersionedPayload__PrecompileFailed();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/IAccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n\n// node_modules/@openzeppelin/contracts/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance \u003c amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance \u003c value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 \u0026\u0026 target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SafeCast.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value \u003e type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value \u003e type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value \u003e type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value \u003e type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value \u003e type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value \u003e type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value \u003e type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value \u003e type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value \u003e type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value \u003e type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value \u003e type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value \u003e type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value \u003e type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value \u003e type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value \u003e type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value \u003e type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value \u003e type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value \u003e type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value \u003e type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value \u003e type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value \u003e type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value \u003e type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value \u003e type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value \u003e type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value \u003e type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value \u003e type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value \u003e type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value \u003e type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value \u003e type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value \u003e type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value \u003e type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value \u003c 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value \u003e uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal view returns (AppConfigV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (AppConfigV1));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal view returns (OptionsV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (OptionsV1));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(OPTIONS_V1, abi.encode(options));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/IAccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/IAccessControlEnumerable.sol)\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n// contracts/interfaces/IInterchainAppV1.sol\n\ninterface IInterchainAppV1 is IInterchainApp {\n    error InterchainApp__AppZeroAddress();\n    error InterchainApp__InvalidAppConfig(uint256 requiredResponses, uint256 optimisticPeriod);\n    error InterchainApp__ModuleAlreadyAdded(address module);\n    error InterchainApp__ModuleNotAdded(address module);\n    error InterchainApp__ModuleZeroAddress();\n    error InterchainApp__NotEVMLinkedApp(bytes32 linkedApp);\n\n    /// @notice Allows the owner to add the interchain client to the allowed clients set,\n    /// and optionally set the latest client to this one.\n    /// Note: only the allowed clients can send messages to this app.\n    /// Note: the latest client is used for sending messages from this app.\n    /// @param client       The address of the interchain client to add.\n    /// @param updateLatest Whether to set the latest client to this one.\n    function addInterchainClient(address client, bool updateLatest) external;\n\n    /// @notice Allows the owner to remove the interchain client from the allowed clients set.\n    /// If the client is the latest client, the latest client is set to the zero address.\n    /// @param client       The address of the interchain client to remove.\n    function removeInterchainClient(address client) external;\n\n    /// @notice Allows the owner to set the address of the latest interchain client.\n    /// @dev The new latest client must be an allowed client or zero address.\n    /// Setting the client to zero address effectively pauses the app ability to send messages,\n    /// while allowing to receive them.\n    /// @param client       The address of the latest interchain client.\n    function setLatestInterchainClient(address client) external;\n\n    /// @notice Allows the owner to link the remote app for the given chain ID.\n    /// - This address will be used as the receiver for the messages sent from this chain.\n    /// - This address will be the only trusted sender for the messages sent to this chain.\n    /// @param chainId      The remote chain ID.\n    /// @param remoteApp    The address of the remote app to link.\n    function linkRemoteApp(uint64 chainId, bytes32 remoteApp) external;\n\n    /// @notice Thin wrapper for `linkRemoteApp` to accept EVM address as a parameter.\n    function linkRemoteAppEVM(uint64 chainId, address remoteApp) external;\n\n    /// @notice Allows the owner to add the module to the trusted modules set.\n    /// - This set of modules will be used to verify both sent and received messages.\n    function addTrustedModule(address module) external;\n\n    /// @notice Allows the owner to remove the module from the trusted modules set.\n    function removeTrustedModule(address module) external;\n\n    /// @notice Allows the owner to set the app config for the current app. App config includes:\n    /// - requiredResponses: the number of module responses required for accepting the message\n    /// - optimisticPeriod: the minimum time after which the module responses are considered final\n    function setAppConfigV1(AppConfigV1 memory appConfig) external;\n\n    /// @notice Allows the owner to set the address of the Execution Service.\n    /// This address will be used to request execution of the messages sent from this chain,\n    /// by supplying the Service's execution fee.\n    function setExecutionService(address executionService) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Returns the app config for the current app: requiredResponses and optimisticPeriod.\n    function getAppConfigV1() external view returns (AppConfigV1 memory);\n\n    /// @notice Returns the address of the Execution Service used by this app for sending messages.\n    function getExecutionService() external view returns (address);\n\n    /// @notice Returns the list of Interchain Clients allowed to send messages to this app.\n    function getInterchainClients() external view returns (address[] memory);\n\n    /// @notice Returns the address of the latest interchain client.\n    /// This address is used for sending messages from this app.\n    function getLatestInterchainClient() external view returns (address);\n\n    /// @notice Returns the linked app address (as bytes32) for the given chain ID.\n    function getLinkedApp(uint64 chainId) external view returns (bytes32);\n\n    /// @notice Thin wrapper for `getLinkedApp` to return the linked app address as EVM address.\n    /// @dev Will revert if the linked app address is not an EVM address.\n    function getLinkedAppEVM(uint64 chainId) external view returns (address);\n\n    /// @notice Returns the list of Interchain Modules trusted by this app.\n    /// This set of modules will be used to verify both sent and received messages.\n    function getModules() external view returns (address[] memory);\n}\n\n// contracts/libs/InterchainTransaction.sol\n\ntype ICTxHeader is uint256;\n\nstruct InterchainTransaction {\n    uint64 srcChainId;\n    uint64 dstChainId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcSender;\n    bytes32 dstReceiver;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    using MathLib for uint256;\n    using VersionedPayloadLib for bytes;\n\n    function constructLocalTransaction(\n        address srcSender,\n        uint64 dstChainId,\n        bytes32 dstReceiver,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: SafeCast.toUint64(block.chainid),\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            encodeTxHeader(transaction.srcChainId, transaction.dstChainId, transaction.dbNonce, transaction.entryIndex),\n            transaction.srcSender,\n            transaction.dstReceiver,\n            transaction.options,\n            transaction.message\n        );\n    }\n\n    function decodeTransaction(bytes calldata transaction) internal pure returns (InterchainTransaction memory icTx) {\n        ICTxHeader header;\n        (header, icTx.srcSender, icTx.dstReceiver, icTx.options, icTx.message) =\n            abi.decode(transaction, (ICTxHeader, bytes32, bytes32, bytes, bytes));\n        (icTx.srcChainId, icTx.dstChainId, icTx.dbNonce, icTx.entryIndex) = decodeTxHeader(header);\n    }\n\n    function payloadSize(uint256 optionsLen, uint256 messageLen) internal pure returns (uint256) {\n        // 2 bytes are reserved for the transaction version\n        // + 5 fields * 32 bytes (3 values for static, 2 offsets for dynamic) + 2 * 32 bytes (lengths for dynamic) = 226\n        // (srcChainId, dstChainId, dbNonce, entryIndex) are merged into a single 32 bytes field\n        // Both options and message are dynamic fields, which are padded up to 32 bytes\n        return 226 + optionsLen.roundUpToWord() + messageLen.roundUpToWord();\n    }\n\n    function encodeTxHeader(\n        uint64 srcChainId,\n        uint64 dstChainId,\n        uint64 dbNonce,\n        uint64 entryIndex\n    )\n        internal\n        pure\n        returns (ICTxHeader)\n    {\n        return ICTxHeader.wrap(\n            (uint256(srcChainId) \u003c\u003c 192) | (uint256(dstChainId) \u003c\u003c 128) | (uint256(dbNonce) \u003c\u003c 64) | uint256(entryIndex)\n        );\n    }\n\n    function decodeTxHeader(ICTxHeader header)\n        internal\n        pure\n        returns (uint64 srcChainId, uint64 dstChainId, uint64 dbNonce, uint64 entryIndex)\n    {\n        srcChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 192);\n        dstChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 128);\n        dbNonce = uint64(ICTxHeader.unwrap(header) \u003e\u003e 64);\n        entryIndex = uint64(ICTxHeader.unwrap(header));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/AccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account =\u003e bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role =\u003e RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint64 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__InvalidTransactionVersion(uint16 version);\n    error InterchainClientV1__NoLinkedClient(uint64 chainId);\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint64 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint64 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint64 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint64 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param messageLen           The length of the message being sent.\n    function getInterchainFee(\n        uint64 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        uint256 messageLen\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint64 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint64 chainId) external view returns (address);\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/AccessControlEnumerable.sol)\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 role =\u003e EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {AccessControl-_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool granted = super._grantRole(role, account);\n        if (granted) {\n            _roleMembers[role].add(account);\n        }\n        return granted;\n    }\n\n    /**\n     * @dev Overload {AccessControl-_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool revoked = super._revokeRole(role, account);\n        if (revoked) {\n            _roleMembers[role].remove(account);\n        }\n        return revoked;\n    }\n}\n\n// contracts/apps/AbstractICApp.sol\n\nabstract contract AbstractICApp is AbstractICAppEvents, IInterchainApp {\n    using TypeCasts for address;\n\n    error InterchainApp__AlreadyLatestClient(address client);\n    error InterchainApp__BalanceTooLow(uint256 actual, uint256 required);\n    error InterchainApp__ClientAlreadyAdded(address client);\n    error InterchainApp__InterchainClientZeroAddress();\n    error InterchainApp__NotInterchainClient(address account);\n    error InterchainApp__ReceiverNotSet(uint64 chainId);\n    error InterchainApp__SameChainId(uint64 chainId);\n    error InterchainApp__SenderNotAllowed(uint64 srcChainId, bytes32 sender);\n\n    /// @inheritdoc IInterchainApp\n    function appReceive(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        if (!_isInterchainClient(msg.sender)) {\n            revert InterchainApp__NotInterchainClient(msg.sender);\n        }\n        if (srcChainId == block.chainid) {\n            revert InterchainApp__SameChainId(srcChainId);\n        }\n        if (!_isAllowedSender(srcChainId, sender)) {\n            revert InterchainApp__SenderNotAllowed(srcChainId, sender);\n        }\n        _receiveMessage(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n\n    /// @inheritdoc IInterchainApp\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules) {\n        appConfig = _getAppConfig();\n        modules = _getModules();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Performs necessary checks and adds an Interchain Client.\n    /// Optionally sets the latest client to this one.\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _addClient(address client, bool updateLatest) internal {\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (_isInterchainClient(client)) {\n            revert InterchainApp__ClientAlreadyAdded(client);\n        }\n        _toggleClientState(client, true);\n        emit InterchainClientAdded(client);\n        if (updateLatest) {\n            _setLatestClient(client);\n        }\n    }\n\n    /// @dev Performs necessary checks and removes an Interchain Client. If this client is the latest one,\n    /// the latest client is set to zero address (effectively pausing the app ability to send messages).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _removeClient(address client) internal {\n        if (!_isInterchainClient(client)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        _toggleClientState(client, false);\n        emit InterchainClientRemoved(client);\n        if (client == _getLatestClient()) {\n            _setLatestClient(address(0));\n        }\n    }\n\n    /// @dev Sets the latest Interchain Client to one of the allowed clients. Setting the client to zero address\n    /// is allowed and effectively pauses the app ability to send messages (but still allows to receive them).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _setLatestClient(address client) internal {\n        // New latest client must be an allowed client or zero address.\n        if (!_isInterchainClient(client) \u0026\u0026 client != address(0)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        if (client == _getLatestClient()) {\n            revert InterchainApp__AlreadyLatestClient(client);\n        }\n        _storeLatestClient(client);\n        emit LatestClientSet(client);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal virtual;\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal virtual;\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to accept EVM address as a parameter.\n    function _sendInterchainMessageEVM(\n        uint64 dstChainId,\n        address receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _sendInterchainMessage(dstChainId, receiver.addressToBytes32(), messageFee, options, message);\n    }\n\n    /// @dev Performs necessary checks and sends an interchain message.\n    function _sendInterchainMessage(\n        uint64 dstChainId,\n        bytes32 receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (dstChainId == block.chainid) {\n            revert InterchainApp__SameChainId(dstChainId);\n        }\n        if (receiver == 0) {\n            revert InterchainApp__ReceiverNotSet(dstChainId);\n        }\n        if (address(this).balance \u003c messageFee) {\n            revert InterchainApp__BalanceTooLow({actual: address(this).balance, required: messageFee});\n        }\n        return IInterchainClientV1(client).interchainSend{value: messageFee}(\n            dstChainId, receiver, _getExecutionService(), _getModules(), options, message\n        );\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        virtual;\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee for sending an Interchain message.\n    function _getInterchainFee(\n        uint64 dstChainId,\n        bytes memory options,\n        uint256 messageLen\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        return IInterchainClientV1(client).getInterchainFee(\n            dstChainId, _getExecutionService(), _getModules(), options, messageLen\n        );\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view virtual returns (bytes memory);\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view virtual returns (address);\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view virtual returns (address);\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view virtual returns (address[] memory);\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint64 srcChainId, bytes32 sender) internal view virtual returns (bool);\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view virtual returns (bool);\n}\n\n// contracts/apps/ICAppV1.sol\n\nabstract contract ICAppV1 is AbstractICApp, AccessControlEnumerable, InterchainAppV1Events, IInterchainAppV1 {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Role to manage the Interchain setup of the app.\n    bytes32 public constant IC_GOVERNOR_ROLE = keccak256(\"IC_GOVERNOR_ROLE\");\n\n    /// @dev Address of the latest Interchain Client, used for sending messages.\n    address private _latestClient;\n\n    /// @dev Required responses and optimistic period for the module responses.\n    AppConfigV1 private _appConfigV1;\n    /// @dev Address of the linked app deployed on the remote chain.\n    mapping(uint64 chainId =\u003e bytes32 remoteApp) private _linkedApp;\n    /// @dev Interchain Clients allowed to send messages to this app.\n    EnumerableSet.AddressSet private _interchainClients;\n    /// @dev Trusted Interchain modules.\n    EnumerableSet.AddressSet private _trustedModules;\n    /// @dev Execution Service to use for sending messages.\n    address private _executionService;\n\n    constructor(address admin) {\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addInterchainClient(address client, bool updateLatest) external onlyRole(IC_GOVERNOR_ROLE) {\n        _addClient(client, updateLatest);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _removeClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setLatestInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _setLatestClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteApp(uint64 chainId, bytes32 remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteAppEVM(uint64 chainId, address remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp.addressToBytes32());\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (module == address(0)) {\n            revert InterchainApp__ModuleZeroAddress();\n        }\n        bool added = _trustedModules.add(module);\n        if (!added) {\n            revert InterchainApp__ModuleAlreadyAdded(module);\n        }\n        emit TrustedModuleAdded(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        bool removed = _trustedModules.remove(module);\n        if (!removed) {\n            revert InterchainApp__ModuleNotAdded(module);\n        }\n        emit TrustedModuleRemoved(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setAppConfigV1(AppConfigV1 memory appConfig) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (appConfig.requiredResponses == 0 || appConfig.optimisticPeriod == 0) {\n            revert InterchainApp__InvalidAppConfig(appConfig.requiredResponses, appConfig.optimisticPeriod);\n        }\n        _appConfigV1 = appConfig;\n        emit AppConfigV1Set(appConfig.requiredResponses, appConfig.optimisticPeriod);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setExecutionService(address executionService) external onlyRole(IC_GOVERNOR_ROLE) {\n        _executionService = executionService;\n        emit ExecutionServiceSet(executionService);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainAppV1\n    function getAppConfigV1() external view returns (AppConfigV1 memory) {\n        return _appConfigV1;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getExecutionService() external view returns (address) {\n        return _executionService;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getInterchainClients() external view returns (address[] memory) {\n        return _interchainClients.values();\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLatestInterchainClient() external view returns (address) {\n        return _latestClient;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedApp(uint64 chainId) external view returns (bytes32) {\n        return _linkedApp[chainId];\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedAppEVM(uint64 chainId) external view returns (address linkedAppEVM) {\n        bytes32 linkedApp = _linkedApp[chainId];\n        linkedAppEVM = linkedApp.bytes32ToAddress();\n        if (linkedAppEVM.addressToBytes32() != linkedApp) {\n            revert InterchainApp__NotEVMLinkedApp(linkedApp);\n        }\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getModules() external view returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Links the remote app to the current app.\n    /// Will revert if the chainId is the same as the chainId of the local app.\n    /// Note: Should be guarded with permissions check.\n    function _linkRemoteApp(uint64 chainId, bytes32 remoteApp) internal {\n        if (chainId == block.chainid) {\n            revert InterchainApp__SameChainId(chainId);\n        }\n        if (remoteApp == 0) {\n            revert InterchainApp__AppZeroAddress();\n        }\n        _linkedApp[chainId] = remoteApp;\n        emit AppLinked(chainId, remoteApp);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal override {\n        _latestClient = client;\n    }\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal override {\n        if (allowed) {\n            _interchainClients.add(client);\n        } else {\n            _interchainClients.remove(client);\n        }\n    }\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to send the message to the linked app.\n    function _sendToLinkedApp(\n        uint64 dstChainId,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _sendInterchainMessage(dstChainId, _linkedApp[dstChainId], messageFee, encodedOptions, message);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee to send a message to the linked app on the remote chain.\n    function _getMessageFee(\n        uint64 dstChainId,\n        OptionsV1 memory options,\n        uint256 messageLen\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _getInterchainFee(dstChainId, encodedOptions, messageLen);\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view override returns (bytes memory) {\n        return _appConfigV1.encodeAppConfigV1();\n    }\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view override returns (address) {\n        return _executionService;\n    }\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view override returns (address) {\n        return _latestClient;\n    }\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view override returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint64 srcChainId, bytes32 sender) internal view override returns (bool) {\n        return _linkedApp[srcChainId] == sender;\n    }\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view override returns (bool) {\n        return _interchainClients.contains(caller);\n    }\n}\n\n// contracts/apps/examples/ExampleAppV1.sol\n\ncontract ExampleAppV1 is ICAppV1 {\n    event MessageReceived(uint64 srcChainId, bytes32 sender, uint64 dbNonce, uint64 entryIndex, bytes message);\n    event MessageSent(uint64 dstChainId, uint64 dbNonce, uint64 entryIndex, bytes32 transactionId);\n\n    constructor(address admin) ICAppV1(admin) {\n        _grantRole(IC_GOVERNOR_ROLE, admin);\n    }\n\n    /// @notice Allows the Admin to withdraw the native asset from the contract.\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        Address.sendValue(payable(msg.sender), address(this).balance);\n    }\n\n    /// @notice Sends a basic message to the destination chain.\n    function sendMessage(\n        uint64 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        InterchainTxDescriptor memory desc = _sendToLinkedApp({\n            dstChainId: dstChainId,\n            messageFee: msg.value,\n            options: OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}),\n            message: message\n        });\n        emit MessageSent(dstChainId, desc.dbNonce, desc.entryIndex, desc.transactionId);\n    }\n\n    /// @notice Returns the fee required to send a message using `sendMessage`.\n    function getMessageFee(\n        uint64 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes memory message\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _getMessageFee(dstChainId, OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}), message.length);\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        override\n    {\n        emit MessageReceived(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"115847:1987:0:-:0;;;116099:94;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;116134:5;106923:37;82063:4;116134:5;106923:10;:37::i;:::-;-1:-1:-1;116151:35:0::1;::::0;-1:-1:-1;106155:29:0::1;116180:5:::0;116151:10:::1;:35::i;:::-;;116099:94:::0;115847:1987;;96207:257;96293:4;;96324:31;96341:4;96347:7;96324:16;:31::i;:::-;96309:46;;96369:7;96365:69;;;96392:18;;;;:12;:18;;;;;:31;;96415:7;96392:22;:31::i;:::-;;96365:69;96450:7;-1:-1:-1;96207:257:0;;;;;:::o;86010:316::-;86087:4;82785:12;;;;;;;;;;;-1:-1:-1;;;;;82785:29:0;;;;;;;;;;;;86103:217;;86146:6;:12;;;;;;;;;;;-1:-1:-1;;;;;86146:29:0;;;;;;;;;:36;;-1:-1:-1;;86146:36:0;86178:4;86146:36;;;86228:12;17324:10;;17245:96;86228:12;-1:-1:-1;;;;;86201:40:0;86219:7;-1:-1:-1;;;;;86201:40:0;86213:4;86201:40;;;;;;;;;;-1:-1:-1;86262:4:0;86255:11;;86103:217;-1:-1:-1;86304:5:0;86297:12;;61469:150;61539:4;61562:50;61567:3;-1:-1:-1;;;;;61587:23:0;;55457:4;57513:21;;;:14;;;:21;;;;;;55473:321;;-1:-1:-1;55515:23:0;;;;;;;;:11;:23;;;;;;;;;;;;;55697:18;;55673:21;;;:14;;;:21;;;;;;:42;;;;55729:11;;14:290:1;84:6;137:2;125:9;116:7;112:23;108:32;105:52;;;153:1;150;143:12;105:52;179:16;;-1:-1:-1;;;;;224:31:1;;214:42;;204:70;;270:1;267;260:12;14:290;115847:1987:0;;;;;;","srcMapRuntime":"115847:1987:0:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;94867:212;;;;;;;;;;-1:-1:-1;94867:212:0;;;;;:::i;:::-;;:::i;:::-;;;516:14:1;;509:22;491:41;;479:2;464:18;94867:212:0;;;;;;;;116486:527;;;;;;:::i;:::-;;:::i;:::-;;108671:419;;;;;;;;;;-1:-1:-1;108671:419:0;;;;;:::i;:::-;;:::i;107202:122::-;;;;;;;;;;-1:-1:-1;107202:122:0;;;;;:::i;:::-;;:::i;107726:167::-;;;;;;;;;;-1:-1:-1;107726:167:0;;;;;:::i;:::-;;:::i;106112:72::-;;;;;;;;;;;;106155:29;106112:72;;;;;3616:25:1;;;3604:2;3589:18;106112:72:0;3470:177:1;83641:120:0;;;;;;;;;;-1:-1:-1;83641:120:0;;;;;:::i;:::-;83706:7;83732:12;;;;;;;;;;:22;;;;83641:120;98214:180;;;;;;;;;;;;;:::i;:::-;;;;;;;;:::i;84057:136::-;;;;;;;;;;-1:-1:-1;84057:136:0;;;;;:::i;:::-;;:::i;85159:245::-;;;;;;;;;;-1:-1:-1;85159:245:0;;;;;:::i;:::-;;:::i;116280:136::-;;;;;;;;;;;;;:::i;109133:196::-;;;;;;;;;;-1:-1:-1;109133:196:0;;;;;:::i;:::-;;:::i;110317:113::-;;;;;;;;;;-1:-1:-1;110317:113:0;;;;;:::i;:::-;110404:19;;110378:7;110404:19;;;:10;:19;;;;;;;110317:113;97522:651;;;;;;:::i;:::-;;:::i;109706:105::-;;;;;;;;;;-1:-1:-1;;;;;;;;;;;;;;;;;;109785:19:0;;;;;;;;109792:12;109785:19;;;;;;;;;109706:105;;;;;;:::i;117099:323::-;;;;;;;;;;-1:-1:-1;117099:323:0;;;;;:::i;:::-;;:::i;95664:142::-;;;;;;;;;;-1:-1:-1;95664:142:0;;;;;:::i;:::-;;:::i;:::-;;;-1:-1:-1;;;;;8861:55:1;;;8843:74;;8831:2;8816:18;95664:142:0;8697:226:1;110473:327:0;;;;;;;;;;-1:-1:-1;110473:327:0;;;;;:::i;:::-;;:::i;82685:136::-;;;;;;;;;;-1:-1:-1;82685:136:0;;;;;:::i;:::-;82762:4;82785:12;;;;;;;;;;;-1:-1:-1;;;;;82785:29:0;;;;;;;;;;;;;;;82685:136;110001:124;;;;;;;;;;;;;:::i;:::-;;;;;;;:::i;82018:49::-;;;;;;;;;;-1:-1:-1;82018:49:0;82063:4;82018:49;;110843:111;;;;;;;;;;;;;:::i;108350:278::-;;;;;;;;;;-1:-1:-1;108350:278:0;;;;;:::i;:::-;;:::i;110168:106::-;;;;;;;;;;-1:-1:-1;110254:13:0;;-1:-1:-1;;;;;110254:13:0;110168:106;;109854:104;;;;;;;;;;-1:-1:-1;109934:17:0;;-1:-1:-1;;;;;109934:17:0;109854:104;;95974:131;;;;;;;;;;-1:-1:-1;95974:131:0;;;;;:::i;:::-;;:::i;107936:371::-;;;;;;;;;;-1:-1:-1;107936:371:0;;;;;:::i;:::-;;:::i;84473:138::-;;;;;;;;;;-1:-1:-1;84473:138:0;;;;;:::i;:::-;;:::i;107367:128::-;;;;;;;;;;-1:-1:-1;107367:128:0;;;;;:::i;:::-;;:::i;107010:149::-;;;;;;;;;;-1:-1:-1;107010:149:0;;;;;:::i;:::-;;:::i;107538:145::-;;;;;;;;;;-1:-1:-1;107538:145:0;;;;;:::i;:::-;;:::i;94867:212::-;94952:4;94975:57;;;94990:42;94975:57;;:97;;;95036:36;95060:11;95036:23;:36::i;:::-;94968:104;94867:212;-1:-1:-1;;94867:212:0:o;116486:527::-;116673:34;116710:207;116753:10;116789:9;116821:55;;;;;;;;116842:8;116821:55;;;;116864:10;116821:55;;;116899:7;;116710:207;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;116710:16:0;;-1:-1:-1;;;116710:207:0:i;:::-;116956:12;;;;;116970:15;;;;;116987:18;;116932:74;;10099:18:1;10144:15;;;10126:34;;10196:15;;;10176:18;;;10169:43;;;;10248:15;;10228:18;;;10221:43;10295:2;10280:18;;10273:34;116673:244:0;;-1:-1:-1;116932:74:0;;10076:3:1;10061:19;116932:74:0;;;;;;;;116663:350;116486:527;;;;;:::o;108671:419::-;106155:29;82295:16;82306:4;82295:10;:16::i;:::-;108775:27;;:32;;:67:::1;;-1:-1:-1::0;108811:26:0::1;::::0;::::1;::::0;:31;108775:67:::1;108771:193;;;108897:27:::0;;108926:26:::1;::::0;::::1;::::0;108865:88:::1;::::0;::::1;::::0;;::::1;::::0;::::1;10492:25:1::0;;;;10533:18;;;10526:34;10465:18;;108865:88:0::1;;;;;;;;108771:193;108973:24:::0;;:12:::1;:24:::0;;;::::1;::::0;;::::1;::::0;;;;;109012:71:::1;::::0;;10492:25:1;;;10533:18;;;10526:34;109012:71:0::1;::::0;10465:18:1;109012:71:0::1;;;;;;;;108671:419:::0;;:::o;107202:122::-;106155:29;82295:16;82306:4;82295:10;:16::i;:::-;107296:21:::1;107310:6;107296:13;:21::i;:::-;107202:122:::0;;:::o;107726:167::-;106155:29;82295:16;82306:4;82295:10;:16::i;:::-;107833:53:::1;107848:7:::0;-1:-1:-1;;;;;107857:26:0;::::1;107833:14;:53::i;:::-;107726:167:::0;;;:::o;98214:180::-;98267:22;98291:24;98339:15;:13;:15::i;:::-;98327:27;;98374:13;:11;:13::i;:::-;98364:23;;98214:180;;:::o;84057:136::-;83706:7;83732:12;;;;;;;;;;:22;;;82295:16;82306:4;82295:10;:16::i;:::-;84161:25:::1;84172:4;84178:7;84161:10;:25::i;:::-;;84057:136:::0;;;:::o;85159:245::-;-1:-1:-1;;;;;85252:34:0;;17324:10;85252:34;85248:102;;85309:30;;;;;;;;;;;;;;85248:102;85360:37;85372:4;85378:18;85360:11;:37::i;116280:136::-;82063:4;82295:16;82063:4;82295:10;:16::i;:::-;116348:61:::1;116374:10;116387:21;116348:17;:61::i;:::-;116280:136:::0;:::o;109133:196::-;106155:29;82295:16;82306:4;82295:10;:16::i;:::-;109234:17:::1;:36:::0;;;::::1;-1:-1:-1::0;;;;;109234:36:0;::::1;::::0;;::::1;::::0;;;109285:37:::1;::::0;8843:74:1;;;109285:37:0::1;::::0;8831:2:1;8816:18;109285:37:0::1;8697:226:1::0;97522:651:0;97734:31;97754:10;97734:19;:31::i;:::-;97729:116;;97788:46;;;;;97823:10;97788:46;;;8843:74:1;8816:18;;97788:46:0;8697:226:1;97729:116:0;97872:13;97858:10;:27;;;97854:103;;97908:38;;;;;10745:18:1;10733:31;;97908:38:0;;;10715:50:1;10688:18;;97908:38:0;10571:200:1;97854:103:0;115468:22;;;115445:4;115468:22;;;:10;:22;;;;;;:32;;97966:126;;98030:51;;;;;10978:18:1;10966:31;;98030:51:0;;;10948:50:1;11014:18;;;11007:34;;;10921:18;;98030:51:0;10776:271:1;97966:126:0;98101:65;98117:10;98129:6;98137:7;98146:10;98158:7;;98101:15;:65::i;:::-;97522:651;;;;;;:::o;117099:323::-;117286:7;117316:99;117331:10;117343:55;;;;;;;;117364:8;117343:55;;;;117386:10;117343:55;;;117400:7;:14;117316;:99::i;:::-;117309:106;117099:323;-1:-1:-1;;;;;117099:323:0:o;95664:142::-;95745:7;95771:18;;;:12;:18;;;;;:28;;95793:5;95771:21;:28::i;:::-;95764:35;95664:142;-1:-1:-1;;;95664:142:0:o;110473:327::-;110589:19;;;110537:20;110589:19;;;:10;:19;;;;;;;-1:-1:-1;;;;;110675:29:0;;:44;;110671:123;;110742:41;;;;;;;;3616:25:1;;;3589:18;;110742:41:0;3470:177:1;110671:123:0;110559:241;110473:327;;;:::o;110001:124::-;110056:16;110091:27;:18;:25;:27::i;:::-;110084:34;;110001:124;:::o;110843:111::-;110888:16;110923:24;:15;:22;:24::i;108350:278::-;106155:29;82295:16;82306:4;82295:10;:16::i;:::-;108441:12:::1;108456:30;:15;108479:6:::0;108456:22:::1;:30::i;:::-;108441:45;;108501:7;108496:83;;108531:37;::::0;::::1;::::0;;-1:-1:-1;;;;;8861:55:1;;108531:37:0::1;::::0;::::1;8843:74:1::0;8816:18;;108531:37:0::1;8697:226:1::0;108496:83:0::1;108593:28;::::0;-1:-1:-1;;;;;8861:55:1;;8843:74;;108593:28:0::1;::::0;8831:2:1;8816:18;108593:28:0::1;;;;;;;;108431:197;108350:278:::0;;:::o;95974:131::-;96045:7;96071:18;;;:12;:18;;;;;:27;;:25;:27::i;107936:371::-;106155:29;82295:16;82306:4;82295:10;:16::i;:::-;-1:-1:-1;;;;;108028:20:0;::::1;108024:92;;108071:34;;;;;;;;;;;;;;108024:92;108125:10;108138:27;:15;108158:6:::0;108138:19:::1;:27::i;:::-;108125:40;;108180:5;108175:85;;108208:41;::::0;::::1;::::0;;-1:-1:-1;;;;;8861:55:1;;108208:41:0::1;::::0;::::1;8843:74:1::0;8816:18;;108208:41:0::1;8697:226:1::0;108175:85:0::1;108274:26;::::0;-1:-1:-1;;;;;8861:55:1;;8843:74;;108274:26:0::1;::::0;8831:2:1;8816:18;108274:26:0::1;8697:226:1::0;84473:138:0;83706:7;83732:12;;;;;;;;;;:22;;;82295:16;82306:4;82295:10;:16::i;:::-;84578:26:::1;84590:4;84596:7;84578:11;:26::i;107367:128::-:0;106155:29;82295:16;82306:4;82295:10;:16::i;:::-;107464:24:::1;107481:6;107464:16;:24::i;107010:149::-:0;106155:29;82295:16;82306:4;82295:10;:16::i;:::-;107120:32:::1;107131:6;107139:12;107120:10;:32::i;107538:145::-:0;106155:29;82295:16;82306:4;82295:10;:16::i;:::-;107642:34:::1;107657:7;107666:9;107642:14;:34::i;82396:202::-:0;82481:4;82504:47;;;82519:32;82504:47;;:87;;-1:-1:-1;71420:25:0;71405:40;;;;82555:36;71306:146;113247:404;-1:-1:-1;;;;;;;;;;;;;;;;;;;;;;;;;113507:25:0;:7;:23;:25::i;:::-;113584:22;;;;;;;:10;:22;;;;;;113477:55;;-1:-1:-1;113549:95:0;;113572:10;;113608;113477:55;113636:7;113549:22;:95::i;:::-;113542:102;113247:404;-1:-1:-1;;;;;;113247:404:0:o;83030:103::-;83096:30;83107:4;17324:10;83096;:30::i;99668:357::-;99731:27;99751:6;99731:19;:27::i;:::-;99726:108;;99781:42;;;;;-1:-1:-1;;;;;8861:55:1;;99781:42:0;;;8843:74:1;8816:18;;99781:42:0;8697:226:1;99726:108:0;99843:33;99862:6;99870:5;99843:18;:33::i;:::-;99891:31;;-1:-1:-1;;;;;8861:55:1;;8843:74;;99891:31:0;;8831:2:1;8816:18;99891:31:0;;;;;;;110254:13;;-1:-1:-1;;;;;110254:13:0;-1:-1:-1;;;;;99936:28:0;:6;-1:-1:-1;;;;;99936:28:0;;99932:87;;99980:28;100005:1;99980:16;:28::i;111454:358::-;111547:13;111536:7;:24;;;111532:97;;111583:35;;;;;10745:18:1;10733:31;;111583:35:0;;;10715:50:1;10688:18;;111583:35:0;10571:200:1;111532:97:0;111655:1;111642:14;;;111638:83;;111679:31;;;;;;;;;;;;;;111638:83;111730:19;;;;;;;:10;:19;;;;;;:31;;;111776:29;111752:9;;111730:19;111776:29;;;111454:358;;:::o;114478:127::-;114566:30;;;;;;;;;:12;:30;;;;;;;;;114535:12;;114566:32;;:30;:32::i;96207:257::-;96293:4;96309:12;96324:31;96341:4;96347:7;96324:16;:31::i;:::-;96309:46;;96369:7;96365:69;;;96392:18;;;;:12;:18;;;;;:31;;96415:7;96392:22;:31::i;:::-;;96450:7;96207:257;-1:-1:-1;;;96207:257:0:o;96567:262::-;96654:4;96670:12;96685:32;96703:4;96709:7;96685:17;:32::i;:::-;96670:47;;96731:7;96727:72;;;96754:18;;;;:12;:18;;;;;:34;;96780:7;96754:25;:34::i;11856:331::-;11965:6;11941:21;:30;11937:109;;;11994:41;;;;;12029:4;11994:41;;;8843:74:1;8816:18;;11994:41:0;8697:226:1;11937:109:0;12057:12;12075:9;-1:-1:-1;;;;;12075:14:0;12097:6;12075:33;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;12056:52;;;12123:7;12118:63;;12153:17;;;;;;;;;;;;;;115656:142;115733:4;115756:35;:18;115784:6;115756:27;:35::i;117542:290::-;117760:65;117776:10;117788:6;117796:7;117805:10;117817:7;;117760:65;;;;;;;;;;;:::i;114059:325::-;114225:7;114248:27;114278:25;:7;:23;:25::i;:::-;114248:55;;114320:57;114338:10;114350:14;114366:10;114320:17;:57::i;62727:156::-;62801:7;62851:22;62855:3;62867:5;62851:3;:22::i;63423:300::-;63486:16;63514:22;63539:19;63547:3;63539:7;:19::i;61787:156::-;61860:4;61883:53;61891:3;-1:-1:-1;;;;;61911:23:0;;61883:7;:53::i;62270:115::-;62333:7;62359:19;62367:3;57709:18;;57627:107;61469:150;61539:4;61562:50;61567:3;-1:-1:-1;;;;;61587:23:0;;61562:4;:50::i;100336:462::-;100474:27;100494:6;100474:19;:27::i;:::-;100473:28;:52;;;;-1:-1:-1;;;;;;100505:20:0;;;;100473:52;100469:132;;;100548:42;;;;;-1:-1:-1;;;;;8861:55:1;;100548:42:0;;;8843:74:1;8816:18;;100548:42:0;8697:226:1;100469:132:0;110254:13;;-1:-1:-1;;;;;110254:13:0;-1:-1:-1;;;;;100614:28:0;:6;-1:-1:-1;;;;;100614:28:0;;100610:108;;100665:42;;;;;-1:-1:-1;;;;;8861:55:1;;100665:42:0;;;8843:74:1;8816:18;;100665:42:0;8697:226:1;100610:108:0;112168:13;:22;;;;-1:-1:-1;;;;;112168:22:0;;;;;100768:23;;-1:-1:-1;;;;;8861:55:1;;8843:74;;100768:23:0;;8831:2:1;8816:18;100768:23:0;;;;;;;100336:462;:::o;98910:459::-;-1:-1:-1;;;;;98988:20:0;;98984:102;;99031:44;;;;;;;;;;;;;;98984:102;99099:27;99119:6;99099:19;:27::i;:::-;99095:106;;;99149:41;;;;;-1:-1:-1;;;;;8861:55:1;;99149:41:0;;;8843:74:1;8816:18;;99149:41:0;8697:226:1;99095:106:0;99210:32;99229:6;99237:4;99210:18;:32::i;:::-;99257:29;;-1:-1:-1;;;;;8861:55:1;;8843:74;;99257:29:0;;8831:2:1;8816:18;99257:29:0;;;;;;;99300:12;99296:67;;;99328:24;99345:6;99328:16;:24::i;69125:187::-;69199:12;69230:75;68186:1;69296:7;69285:19;;;;;;;;:::i;:::-;;;;;;;;;;;;;69230:42;:75::i;102494:972::-;-1:-1:-1;;;;;;;;;;;;;;;;;;;;;;;;;102757:14:0;102774:18;110254:13;;-1:-1:-1;;;;;110254:13:0;;110168:106;102774:18;102757:35;-1:-1:-1;;;;;;102806:20:0;;102802:102;;102849:44;;;;;;;;;;;;;;102802:102;102931:13;102917:10;:27;;;102913:103;;102967:38;;;;;10745:18:1;10733:31;;102967:38:0;;;10715:50:1;10688:18;;102967:38:0;10571:200:1;102913:103:0;103041:1;103029:13;;;103025:92;;103065:41;;;;;10745:18:1;10733:31;;103065:41:0;;;10715:50:1;10688:18;;103065:41:0;10571:200:1;103025:92:0;103154:10;103130:21;:34;103126:155;;;103187:83;;;;;103225:21;103187:83;;;10492:25:1;10533:18;;;10526:34;;;10465:18;;103187:83:0;10318:248:1;103126:155:0;103317:6;-1:-1:-1;;;;;103297:42:0;;103347:10;103372;103384:8;103394:22;109934:17;;-1:-1:-1;;;;;109934:17:0;;109854:104;103394:22;103418:13;:11;:13::i;:::-;103433:7;103442;103297:162;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;103290:169;102494:972;-1:-1:-1;;;;;;;102494:972:0:o;83263:197::-;82762:4;82785:12;;;;;;;;;;;-1:-1:-1;;;;;82785:29:0;;;;;;;;;;;;83346:108;;83396:47;;;;;-1:-1:-1;;;;;14106:55:1;;83396:47:0;;;14088:74:1;14178:18;;;14171:34;;;14061:18;;83396:47:0;13914:297:1;112616:224:0;112706:7;112702:132;;;112729:30;:18;112752:6;112729:22;:30::i;112702:132::-;112790:33;:18;112816:6;112790:25;:33::i;86010:316::-;86087:4;82785:12;;;;;;;;;;;-1:-1:-1;;;;;82785:29:0;;;;;;;;;;;;86103:217;;86146:6;:12;;;;;;;;;;;-1:-1:-1;;;;;86146:29:0;;;;;;;;;:36;;;;86178:4;86146:36;;;86228:12;17324:10;;17245:96;86228:12;-1:-1:-1;;;;;86201:40:0;86219:7;-1:-1:-1;;;;;86201:40:0;86213:4;86201:40;;;;;;;;;;-1:-1:-1;86262:4:0;86255:11;;86103:217;-1:-1:-1;86304:5:0;86297:12;;86561:317;86639:4;82785:12;;;;;;;;;;;-1:-1:-1;;;;;82785:29:0;;;;;;;;;;;;86655:217;;;86729:5;86697:12;;;;;;;;;;;-1:-1:-1;;;;;86697:29:0;;;;;;;;;;:37;;;;;;86753:40;17324:10;;86697:12;;86753:40;;86729:5;86753:40;-1:-1:-1;86814:4:0;86807:11;;62024:165;-1:-1:-1;;;;;62157:23:0;;62104:4;57513:21;;;:14;;;:21;;;;;;:26;;62127:55;57417:129;104170:496;104335:7;104358:14;104375:18;110254:13;;-1:-1:-1;;;;;110254:13:0;;110168:106;104375:18;104358:35;-1:-1:-1;;;;;;104407:20:0;;104403:102;;104450:44;;;;;;;;;;;;;;104403:102;104541:6;-1:-1:-1;;;;;104521:44:0;;104579:10;104591:22;109934:17;;-1:-1:-1;;;;;109934:17:0;;109854:104;104591:22;104615:13;:11;:13::i;:::-;104630:7;104639:10;104521:138;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;58076:118::-;58143:7;58169:3;:11;;58181:5;58169:18;;;;;;;;:::i;:::-;;;;;;;;;58162:25;;58076:118;;;;:::o;58734:109::-;58790:16;58825:3;:11;;58818:18;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;58734:109;;;:::o;55968:1368::-;56034:4;56163:21;;;:14;;;:21;;;;;;56199:13;;56195:1135;;56566:18;56587:12;56598:1;56587:8;:12;:::i;:::-;56633:18;;56566:33;;-1:-1:-1;56613:17:0;;56633:22;;56654:1;;56633:22;:::i;:::-;56613:42;;56688:9;56674:10;:23;56670:378;;56717:17;56737:3;:11;;56749:9;56737:22;;;;;;;;:::i;:::-;;;;;;;;;56717:42;;56884:9;56858:3;:11;;56870:10;56858:23;;;;;;;;:::i;:::-;;;;;;;;;;;;:35;;;;56997:25;;;:14;;;:25;;;;;:36;;;56670:378;57126:17;;:3;;:17;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;57229:3;:14;;:21;57244:5;57229:21;;;;;;;;;;;57222:28;;;57272:4;57265:11;;;;;;;56195:1135;57314:5;57307:12;;;;;55394:406;55457:4;57513:21;;;:14;;;:21;;;;;;55473:321;;-1:-1:-1;55515:23:0;;;;;;;;:11;:23;;;;;;;;;;;;;55697:18;;55673:21;;;:14;;;:21;;;;;;:42;;;;55729:11;;3750:165;3843:12;3891:7;3900;3874:34;;;;;;;;;:::i;:::-;;;;;;;;;;;;;3867:41;;3750:165;;;;:::o;14:332:1:-;72:6;125:2;113:9;104:7;100:23;96:32;93:52;;;141:1;138;131:12;93:52;180:9;167:23;230:66;223:5;219:78;212:5;209:89;199:117;;312:1;309;302:12;543:129;628:18;621:5;617:30;610:5;607:41;597:69;;662:1;659;652:12;677:347;728:8;738:6;792:3;785:4;777:6;773:17;769:27;759:55;;810:1;807;800:12;759:55;-1:-1:-1;833:20:1;;876:18;865:30;;862:50;;;908:1;905;898:12;862:50;945:4;937:6;933:17;921:29;;997:3;990:4;981:6;973;969:19;965:30;962:39;959:59;;;1014:1;1011;1004:12;959:59;677:347;;;;;:::o;1029:679::-;1125:6;1133;1141;1149;1157;1210:3;1198:9;1189:7;1185:23;1181:33;1178:53;;;1227:1;1224;1217:12;1178:53;1266:9;1253:23;1285:30;1309:5;1285:30;:::i;:::-;1334:5;-1:-1:-1;1386:2:1;1371:18;;1358:32;;-1:-1:-1;1437:2:1;1422:18;;1409:32;;-1:-1:-1;1492:2:1;1477:18;;1464:32;1519:18;1508:30;;1505:50;;;1551:1;1548;1541:12;1505:50;1590:58;1640:7;1631:6;1620:9;1616:22;1590:58;:::i;:::-;1029:679;;;;-1:-1:-1;1029:679:1;;-1:-1:-1;1667:8:1;;1564:84;1029:679;-1:-1:-1;;;1029:679:1:o;1713:184::-;1765:77;1762:1;1755:88;1862:4;1859:1;1852:15;1886:4;1883:1;1876:15;1902:334;1973:2;1967:9;2029:2;2019:13;;2034:66;2015:86;2003:99;;2132:18;2117:34;;2153:22;;;2114:62;2111:88;;;2179:18;;:::i;:::-;2215:2;2208:22;1902:334;;-1:-1:-1;1902:334:1:o;2241:508::-;2329:6;2382:2;2370:9;2361:7;2357:23;2353:32;2350:52;;;2398:1;2395;2388:12;2350:52;2431:2;2425:9;2473:2;2465:6;2461:15;2542:6;2530:10;2527:22;2506:18;2494:10;2491:34;2488:62;2485:88;;;2553:18;;:::i;:::-;2589:2;2582:22;2628:23;;2613:39;;2713:2;2698:18;;;2685:32;2668:15;;;2661:57;;;;-1:-1:-1;2620:6:1;2241:508;-1:-1:-1;2241:508:1:o;2754:196::-;2822:20;;-1:-1:-1;;;;;2871:54:1;;2861:65;;2851:93;;2940:1;2937;2930:12;2851:93;2754:196;;;:::o;2955:186::-;3014:6;3067:2;3055:9;3046:7;3042:23;3038:32;3035:52;;;3083:1;3080;3073:12;3035:52;3106:29;3125:9;3106:29;:::i;3146:319::-;3213:6;3221;3274:2;3262:9;3253:7;3249:23;3245:32;3242:52;;;3290:1;3287;3280:12;3242:52;3329:9;3316:23;3348:30;3372:5;3348:30;:::i;:::-;3397:5;-1:-1:-1;3421:38:1;3455:2;3440:18;;3421:38;:::i;:::-;3411:48;;3146:319;;;;;:::o;3652:180::-;3711:6;3764:2;3752:9;3743:7;3739:23;3735:32;3732:52;;;3780:1;3777;3770:12;3732:52;-1:-1:-1;3803:23:1;;3652:180;-1:-1:-1;3652:180:1:o;3837:250::-;3922:1;3932:113;3946:6;3943:1;3940:13;3932:113;;;4022:11;;;4016:18;4003:11;;;3996:39;3968:2;3961:10;3932:113;;;-1:-1:-1;;4079:1:1;4061:16;;4054:27;3837:250::o;4092:329::-;4133:3;4171:5;4165:12;4198:6;4193:3;4186:19;4214:76;4283:6;4276:4;4271:3;4267:14;4260:4;4253:5;4249:16;4214:76;:::i;:::-;4335:2;4323:15;4340:66;4319:88;4310:98;;;;4410:4;4306:109;;4092:329;-1:-1:-1;;4092:329:1:o;4426:484::-;4479:3;4517:5;4511:12;4544:6;4539:3;4532:19;4570:4;4599:2;4594:3;4590:12;4583:19;;4636:2;4629:5;4625:14;4657:1;4667:218;4681:6;4678:1;4675:13;4667:218;;;4746:13;;-1:-1:-1;;;;;4742:62:1;4730:75;;4825:12;;;;4860:15;;;;4703:1;4696:9;4667:218;;;-1:-1:-1;4901:3:1;;4426:484;-1:-1:-1;;;;;4426:484:1:o;4915:421::-;5140:2;5129:9;5122:21;5103:4;5166:44;5206:2;5195:9;5191:18;5183:6;5166:44;:::i;:::-;5258:9;5250:6;5246:22;5241:2;5230:9;5226:18;5219:50;5286:44;5323:6;5315;5286:44;:::i;5341:254::-;5409:6;5417;5470:2;5458:9;5449:7;5445:23;5441:32;5438:52;;;5486:1;5483;5476:12;5438:52;5522:9;5509:23;5499:33;;5551:38;5585:2;5574:9;5570:18;5551:38;:::i;5600:245::-;5658:6;5711:2;5699:9;5690:7;5686:23;5682:32;5679:52;;;5727:1;5724;5717:12;5679:52;5766:9;5753:23;5785:30;5809:5;5785:30;:::i;5850:890::-;5953:6;5961;5969;5977;5985;5993;6046:3;6034:9;6025:7;6021:23;6017:33;6014:53;;;6063:1;6060;6053:12;6014:53;6102:9;6089:23;6121:30;6145:5;6121:30;:::i;:::-;6170:5;-1:-1:-1;6222:2:1;6207:18;;6194:32;;-1:-1:-1;6278:2:1;6263:18;;6250:32;6291;6250;6291;:::i;:::-;6342:7;-1:-1:-1;6401:2:1;6386:18;;6373:32;6414;6373;6414;:::i;:::-;6465:7;-1:-1:-1;6523:3:1;6508:19;;6495:33;6551:18;6540:30;;6537:50;;;6583:1;6580;6573:12;6537:50;6622:58;6672:7;6663:6;6652:9;6648:22;6622:58;:::i;:::-;5850:890;;;;-1:-1:-1;5850:890:1;;-1:-1:-1;5850:890:1;;6699:8;;5850:890;-1:-1:-1;;;5850:890:1:o;6902:258::-;6822:12;;6810:25;;6884:4;6873:16;;;6867:23;6851:14;;;6844:47;7094:2;7079:18;;7106:48;6745:152;7165:1092;7259:6;7267;7275;7283;7336:3;7324:9;7315:7;7311:23;7307:33;7304:53;;;7353:1;7350;7343:12;7304:53;7392:9;7379:23;7411:30;7435:5;7411:30;:::i;:::-;7460:5;-1:-1:-1;7484:2:1;7518:18;;;7505:32;;-1:-1:-1;7584:2:1;7569:18;;7556:32;;-1:-1:-1;7639:2:1;7624:18;;7611:32;7662:18;7692:14;;;7689:34;;;7719:1;7716;7709:12;7689:34;7757:6;7746:9;7742:22;7732:32;;7802:7;7795:4;7791:2;7787:13;7783:27;7773:55;;7824:1;7821;7814:12;7773:55;7860:2;7847:16;7882:2;7878;7875:10;7872:36;;;7888:18;;:::i;:::-;7930:112;8038:2;7969:66;7962:4;7958:2;7954:13;7950:86;7946:95;7930:112;:::i;:::-;7917:125;;8065:2;8058:5;8051:17;8105:7;8100:2;8095;8091;8087:11;8083:20;8080:33;8077:53;;;8126:1;8123;8116:12;8077:53;8181:2;8176;8172;8168:11;8163:2;8156:5;8152:14;8139:45;8225:1;8220:2;8215;8208:5;8204:14;8200:23;8193:34;;8246:5;8236:15;;;;;7165:1092;;;;;;;:::o;8444:248::-;8512:6;8520;8573:2;8561:9;8552:7;8548:23;8544:32;8541:52;;;8589:1;8586;8579:12;8541:52;-1:-1:-1;;8612:23:1;;;8682:2;8667:18;;;8654:32;;-1:-1:-1;8444:248:1:o;8928:261::-;9107:2;9096:9;9089:21;9070:4;9127:56;9179:2;9168:9;9164:18;9156:6;9127:56;:::i;9194:347::-;9259:6;9267;9320:2;9308:9;9299:7;9295:23;9291:32;9288:52;;;9336:1;9333;9326:12;9288:52;9359:29;9378:9;9359:29;:::i;:::-;9349:39;;9438:2;9427:9;9423:18;9410:32;9485:5;9478:13;9471:21;9464:5;9461:32;9451:60;;9507:1;9504;9497:12;9451:60;9530:5;9520:15;;;9194:347;;;;;:::o;9546:313::-;9613:6;9621;9674:2;9662:9;9653:7;9649:23;9645:32;9642:52;;;9690:1;9687;9680:12;9642:52;9729:9;9716:23;9748:30;9772:5;9748:30;:::i;:::-;9797:5;9849:2;9834:18;;;;9821:32;;-1:-1:-1;;;9546:313:1:o;11262:795::-;11488:4;11517:18;11574:2;11566:6;11562:15;11551:9;11544:34;11614:6;11609:2;11598:9;11594:18;11587:34;11669:2;11661:6;11657:15;11652:2;11641:9;11637:18;11630:43;11721:2;11713:6;11709:15;11704:2;11693:9;11689:18;11682:43;;11762:3;11756;11745:9;11741:19;11734:32;11803:6;11797:3;11786:9;11782:19;11775:35;11861:6;11853;11847:3;11836:9;11832:19;11819:49;11918:1;11912:3;11903:6;11892:9;11888:22;11884:32;11877:43;12047:3;11977:66;11972:2;11964:6;11960:15;11956:88;11945:9;11941:104;11937:114;11929:122;;11262:795;;;;;;;;;:::o;12321:870::-;12686:18;12678:6;12674:31;12663:9;12656:50;12742:6;12737:2;12726:9;12722:18;12715:34;-1:-1:-1;;;;;12789:6:1;12785:55;12780:2;12769:9;12765:18;12758:83;12877:3;12872:2;12861:9;12857:18;12850:31;12637:4;12904:57;12956:3;12945:9;12941:19;12933:6;12904:57;:::i;:::-;13010:9;13002:6;12998:22;12992:3;12981:9;12977:19;12970:51;13044:32;13069:6;13061;13044:32;:::i;:::-;13030:46;;13125:9;13117:6;13113:22;13107:3;13096:9;13092:19;13085:51;13153:32;13178:6;13170;13153:32;:::i;:::-;13145:40;12321:870;-1:-1:-1;;;;;;;;;12321:870:1:o;13196:713::-;13306:6;13359:2;13347:9;13338:7;13334:23;13330:32;13327:52;;;13375:1;13372;13365:12;13327:52;13408:2;13402:9;13450:2;13442:6;13438:15;13519:6;13507:10;13504:22;13483:18;13471:10;13468:34;13465:62;13462:88;;;13530:18;;:::i;:::-;13566:2;13559:22;13605:16;;13590:32;;13665:2;13650:18;;13644:25;13678:30;13644:25;13678:30;:::i;:::-;13736:2;13724:15;;13717:30;13792:2;13777:18;;13771:25;13805:32;13771:25;13805:32;:::i;:::-;13865:2;13853:15;;13846:32;13857:6;13196:713;-1:-1:-1;;;13196:713:1:o;14216:709::-;14535:18;14527:6;14523:31;14512:9;14505:50;-1:-1:-1;;;;;14595:6:1;14591:55;14586:2;14575:9;14571:18;14564:83;14683:3;14678:2;14667:9;14663:18;14656:31;14486:4;14710:57;14762:3;14751:9;14747:19;14739:6;14710:57;:::i;:::-;14815:9;14807:6;14803:22;14798:2;14787:9;14783:18;14776:50;14843:32;14868:6;14860;14843:32;:::i;:::-;14835:40;;;14912:6;14906:3;14895:9;14891:19;14884:35;14216:709;;;;;;;;:::o;14930:184::-;15000:6;15053:2;15041:9;15032:7;15028:23;15024:32;15021:52;;;15069:1;15066;15059:12;15021:52;-1:-1:-1;15092:16:1;;14930:184;-1:-1:-1;14930:184:1:o;15119:::-;15171:77;15168:1;15161:88;15268:4;15265:1;15258:15;15292:4;15289:1;15282:15;15308:282;15375:9;;;15396:11;;;15393:191;;;15440:77;15437:1;15430:88;15541:4;15538:1;15531:15;15569:4;15566:1;15559:15;15595:184;15647:77;15644:1;15637:88;15744:4;15741:1;15734:15;15768:4;15765:1;15758:15;15784:440;15991:66;15982:6;15977:3;15973:16;15969:89;15964:3;15957:102;15939:3;16088:6;16082:13;16104:74;16171:6;16167:1;16162:3;16158:11;16151:4;16143:6;16139:17;16104:74;:::i;:::-;16198:16;;;;16216:1;16194:24;;15784:440;-1:-1:-1;;;15784:440:1:o","abiDefinition":[{"inputs":[{"internalType":"address","name":"admin","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"inputs":[],"name":"AccessControlBadConfirmation","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"bytes32","name":"neededRole","type":"bytes32"}],"name":"AccessControlUnauthorizedAccount","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"AddressInsufficientBalance","type":"error"},{"inputs":[],"name":"FailedInnerCall","type":"error"},{"inputs":[{"internalType":"address","name":"client","type":"address"}],"name":"InterchainApp__AlreadyLatestClient","type":"error"},{"inputs":[],"name":"InterchainApp__AppZeroAddress","type":"error"},{"inputs":[{"internalType":"uint256","name":"actual","type":"uint256"},{"internalType":"uint256","name":"required","type":"uint256"}],"name":"InterchainApp__BalanceTooLow","type":"error"},{"inputs":[{"internalType":"address","name":"client","type":"address"}],"name":"InterchainApp__ClientAlreadyAdded","type":"error"},{"inputs":[],"name":"InterchainApp__InterchainClientZeroAddress","type":"error"},{"inputs":[{"internalType":"uint256","name":"requiredResponses","type":"uint256"},{"internalType":"uint256","name":"optimisticPeriod","type":"uint256"}],"name":"InterchainApp__InvalidAppConfig","type":"error"},{"inputs":[{"internalType":"address","name":"module","type":"address"}],"name":"InterchainApp__ModuleAlreadyAdded","type":"error"},{"inputs":[{"internalType":"address","name":"module","type":"address"}],"name":"InterchainApp__ModuleNotAdded","type":"error"},{"inputs":[],"name":"InterchainApp__ModuleZeroAddress","type":"error"},{"inputs":[{"internalType":"bytes32","name":"linkedApp","type":"bytes32"}],"name":"InterchainApp__NotEVMLinkedApp","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"InterchainApp__NotInterchainClient","type":"error"},{"inputs":[{"internalType":"uint64","name":"chainId","type":"uint64"}],"name":"InterchainApp__ReceiverNotSet","type":"error"},{"inputs":[{"internalType":"uint64","name":"chainId","type":"uint64"}],"name":"InterchainApp__SameChainId","type":"error"},{"inputs":[{"internalType":"uint64","name":"srcChainId","type":"uint64"},{"internalType":"bytes32","name":"sender","type":"bytes32"}],"name":"InterchainApp__SenderNotAllowed","type":"error"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"requiredResponses","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"optimisticPeriod","type":"uint256"}],"name":"AppConfigV1Set","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"chainId","type":"uint256"},{"indexed":true,"internalType":"bytes32","name":"remoteApp","type":"bytes32"}],"name":"AppLinked","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"executionService","type":"address"}],"name":"ExecutionServiceSet","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"client","type":"address"}],"name":"InterchainClientAdded","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"client","type":"address"}],"name":"InterchainClientRemoved","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"client","type":"address"}],"name":"LatestClientSet","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint64","name":"srcChainId","type":"uint64"},{"indexed":false,"internalType":"bytes32","name":"sender","type":"bytes32"},{"indexed":false,"internalType":"uint64","name":"dbNonce","type":"uint64"},{"indexed":false,"internalType":"uint64","name":"entryIndex","type":"uint64"},{"indexed":false,"internalType":"bytes","name":"message","type":"bytes"}],"name":"MessageReceived","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint64","name":"dstChainId","type":"uint64"},{"indexed":false,"internalType":"uint64","name":"dbNonce","type":"uint64"},{"indexed":false,"internalType":"uint64","name":"entryIndex","type":"uint64"},{"indexed":false,"internalType":"bytes32","name":"transactionId","type":"bytes32"}],"name":"MessageSent","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"bytes32","name":"previousAdminRole","type":"bytes32"},{"indexed":true,"internalType":"bytes32","name":"newAdminRole","type":"bytes32"}],"name":"RoleAdminChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":true,"internalType":"address","name":"sender","type":"address"}],"name":"RoleGranted","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":true,"internalType":"address","name":"sender","type":"address"}],"name":"RoleRevoked","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"module","type":"address"}],"name":"TrustedModuleAdded","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"module","type":"address"}],"name":"TrustedModuleRemoved","type":"event"},{"inputs":[],"name":"DEFAULT_ADMIN_ROLE","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"IC_GOVERNOR_ROLE","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"client","type":"address"},{"internalType":"bool","name":"updateLatest","type":"bool"}],"name":"addInterchainClient","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"module","type":"address"}],"name":"addTrustedModule","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint64","name":"srcChainId","type":"uint64"},{"internalType":"bytes32","name":"sender","type":"bytes32"},{"internalType":"uint64","name":"dbNonce","type":"uint64"},{"internalType":"uint64","name":"entryIndex","type":"uint64"},{"internalType":"bytes","name":"message","type":"bytes"}],"name":"appReceive","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"getAppConfigV1","outputs":[{"components":[{"internalType":"uint256","name":"requiredResponses","type":"uint256"},{"internalType":"uint256","name":"optimisticPeriod","type":"uint256"}],"internalType":"struct AppConfigV1","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getExecutionService","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getInterchainClients","outputs":[{"internalType":"address[]","name":"","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getLatestInterchainClient","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint64","name":"chainId","type":"uint64"}],"name":"getLinkedApp","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint64","name":"chainId","type":"uint64"}],"name":"getLinkedAppEVM","outputs":[{"internalType":"address","name":"linkedAppEVM","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint64","name":"dstChainId","type":"uint64"},{"internalType":"uint256","name":"gasLimit","type":"uint256"},{"internalType":"uint256","name":"gasAirdrop","type":"uint256"},{"internalType":"bytes","name":"message","type":"bytes"}],"name":"getMessageFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getModules","outputs":[{"internalType":"address[]","name":"","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getReceivingConfig","outputs":[{"internalType":"bytes","name":"appConfig","type":"bytes"},{"internalType":"address[]","name":"modules","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"}],"name":"getRoleAdmin","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"uint256","name":"index","type":"uint256"}],"name":"getRoleMember","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"}],"name":"getRoleMemberCount","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"grantRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"hasRole","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint64","name":"chainId","type":"uint64"},{"internalType":"bytes32","name":"remoteApp","type":"bytes32"}],"name":"linkRemoteApp","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint64","name":"chainId","type":"uint64"},{"internalType":"address","name":"remoteApp","type":"address"}],"name":"linkRemoteAppEVM","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"client","type":"address"}],"name":"removeInterchainClient","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"module","type":"address"}],"name":"removeTrustedModule","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"callerConfirmation","type":"address"}],"name":"renounceRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"revokeRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint64","name":"dstChainId","type":"uint64"},{"internalType":"uint256","name":"gasLimit","type":"uint256"},{"internalType":"uint256","name":"gasAirdrop","type":"uint256"},{"internalType":"bytes","name":"message","type":"bytes"}],"name":"sendMessage","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"components":[{"internalType":"uint256","name":"requiredResponses","type":"uint256"},{"internalType":"uint256","name":"optimisticPeriod","type":"uint256"}],"internalType":"struct AppConfigV1","name":"appConfig","type":"tuple"}],"name":"setAppConfigV1","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"executionService","type":"address"}],"name":"setExecutionService","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"client","type":"address"}],"name":"setLatestInterchainClient","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes4","name":"interfaceId","type":"bytes4"}],"name":"supportsInterface","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"withdraw","outputs":[],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{"IC_GOVERNOR_ROLE()":{"notice":"Role to manage the Interchain setup of the app."},"addInterchainClient(address,bool)":{"notice":"Allows the owner to add the interchain client to the allowed clients set, and optionally set the latest client to this one. Note: only the allowed clients can send messages to this app. Note: the latest client is used for sending messages from this app."},"addTrustedModule(address)":{"notice":"Allows the owner to add the module to the trusted modules set. - This set of modules will be used to verify both sent and received messages."},"appReceive(uint64,bytes32,uint64,uint64,bytes)":{"notice":"Allows the Interchain Client to pass the message to the Interchain App."},"getAppConfigV1()":{"notice":"Returns the app config for the current app: requiredResponses and optimisticPeriod."},"getExecutionService()":{"notice":"Returns the address of the Execution Service used by this app for sending messages."},"getInterchainClients()":{"notice":"Returns the list of Interchain Clients allowed to send messages to this app."},"getLatestInterchainClient()":{"notice":"Returns the address of the latest interchain client. This address is used for sending messages from this app."},"getLinkedApp(uint64)":{"notice":"Returns the linked app address (as bytes32) for the given chain ID."},"getLinkedAppEVM(uint64)":{"notice":"Thin wrapper for `getLinkedApp` to return the linked app address as EVM address."},"getMessageFee(uint64,uint256,uint256,bytes)":{"notice":"Returns the fee required to send a message using `sendMessage`."},"getModules()":{"notice":"Returns the list of Interchain Modules trusted by this app. This set of modules will be used to verify both sent and received messages."},"getReceivingConfig()":{"notice":"Returns the verification configuration of the Interchain App."},"linkRemoteApp(uint64,bytes32)":{"notice":"Allows the owner to link the remote app for the given chain ID. - This address will be used as the receiver for the messages sent from this chain. - This address will be the only trusted sender for the messages sent to this chain."},"linkRemoteAppEVM(uint64,address)":{"notice":"Thin wrapper for `linkRemoteApp` to accept EVM address as a parameter."},"removeInterchainClient(address)":{"notice":"Allows the owner to remove the interchain client from the allowed clients set. If the client is the latest client, the latest client is set to the zero address."},"removeTrustedModule(address)":{"notice":"Allows the owner to remove the module from the trusted modules set."},"sendMessage(uint64,uint256,uint256,bytes)":{"notice":"Sends a basic message to the destination chain."},"setAppConfigV1((uint256,uint256))":{"notice":"Allows the owner to set the app config for the current app. App config includes: - requiredResponses: the number of module responses required for accepting the message - optimisticPeriod: the minimum time after which the module responses are considered final"},"setExecutionService(address)":{"notice":"Allows the owner to set the address of the Execution Service. This address will be used to request execution of the messages sent from this chain, by supplying the Service's execution fee."},"setLatestInterchainClient(address)":{"notice":"Allows the owner to set the address of the latest interchain client."},"withdraw()":{"notice":"Allows the Admin to withdraw the native asset from the contract."}},"version":1},"developerDoc":{"errors":{"AccessControlBadConfirmation()":[{"details":"The caller of a function is not the expected one. NOTE: Don't confuse with {AccessControlUnauthorizedAccount}."}],"AccessControlUnauthorizedAccount(address,bytes32)":[{"details":"The `account` is missing a role."}],"AddressInsufficientBalance(address)":[{"details":"The ETH balance of the account is not enough to perform the operation."}],"FailedInnerCall()":[{"details":"A call to an address target failed. The target may have reverted."}]},"events":{"RoleAdminChanged(bytes32,bytes32,bytes32)":{"details":"Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole` `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite {RoleAdminChanged} not being emitted signaling this."},"RoleGranted(bytes32,address,address)":{"details":"Emitted when `account` is granted `role`. `sender` is the account that originated the contract call, an admin role bearer except when using {AccessControl-_setupRole}."},"RoleRevoked(bytes32,address,address)":{"details":"Emitted when `account` is revoked `role`. `sender` is the account that originated the contract call:   - if using `revokeRole`, it is the admin role bearer   - if using `renounceRole`, it is the role bearer (i.e. `account`)"}},"kind":"dev","methods":{"addInterchainClient(address,bool)":{"params":{"client":"The address of the interchain client to add.","updateLatest":"Whether to set the latest client to this one."}},"appReceive(uint64,bytes32,uint64,uint64,bytes)":{"details":"App is responsible for keeping track of interchain clients, and must verify the message sender.","params":{"dbNonce":"The Interchain DB nonce of the batch containing the message entry.","entryIndex":"The index of the message entry within the batch.","message":"The message being sent.","sender":"Sender address on the source chain, as a bytes32 value.","srcChainId":"Chain ID of the source chain, where the message was sent from."}},"getLinkedAppEVM(uint64)":{"details":"Will revert if the linked app address is not an EVM address."},"getReceivingConfig()":{"details":"This configuration is used by the Interchain Client to verify that message has been confirmed by the Interchain Modules on the destination chain. Note: V1 version of AppConfig includes the required responses count, and optimistic period after which the message is considered confirmed by the module. Following versions may include additional fields.","returns":{"appConfig":"   The versioned configuration of the Interchain App, encoded as bytes.","modules":"     The list of Interchain Modules that app is trusting to confirm the messages."}},"getRoleAdmin(bytes32)":{"details":"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"getRoleMember(bytes32,uint256)":{"details":"Returns one of the accounts that have `role`. `index` must be a value between 0 and {getRoleMemberCount}, non-inclusive. Role bearers are not sorted in any particular way, and their ordering may change at any point. WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure you perform all queries on the same block. See the following https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post] for more information."},"getRoleMemberCount(bytes32)":{"details":"Returns the number of accounts that have `role`. Can be used together with {getRoleMember} to enumerate all bearers of a role."},"grantRole(bytes32,address)":{"details":"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleGranted} event."},"hasRole(bytes32,address)":{"details":"Returns `true` if `account` has been granted `role`."},"linkRemoteApp(uint64,bytes32)":{"params":{"chainId":"The remote chain ID.","remoteApp":"The address of the remote app to link."}},"removeInterchainClient(address)":{"params":{"client":"The address of the interchain client to remove."}},"renounceRole(bytes32,address)":{"details":"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `callerConfirmation`. May emit a {RoleRevoked} event."},"revokeRole(bytes32,address)":{"details":"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleRevoked} event."},"setLatestInterchainClient(address)":{"details":"The new latest client must be an allowed client or zero address. Setting the client to zero address effectively pauses the app ability to send messages, while allowing to receive them.","params":{"client":"The address of the latest interchain client."}},"supportsInterface(bytes4)":{"details":"See {IERC165-supportsInterface}."}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AccessControlBadConfirmation\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"neededRole\",\"type\":\"bytes32\"}],\"name\":\"AccessControlUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AddressInsufficientBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FailedInnerCall\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"}],\"name\":\"InterchainApp__AlreadyLatestClient\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InterchainApp__AppZeroAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"required\",\"type\":\"uint256\"}],\"name\":\"InterchainApp__BalanceTooLow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"}],\"name\":\"InterchainApp__ClientAlreadyAdded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InterchainApp__InterchainClientZeroAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requiredResponses\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"optimisticPeriod\",\"type\":\"uint256\"}],\"name\":\"InterchainApp__InvalidAppConfig\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"InterchainApp__ModuleAlreadyAdded\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"InterchainApp__ModuleNotAdded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InterchainApp__ModuleZeroAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"linkedApp\",\"type\":\"bytes32\"}],\"name\":\"InterchainApp__NotEVMLinkedApp\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"InterchainApp__NotInterchainClient\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"}],\"name\":\"InterchainApp__ReceiverNotSet\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"}],\"name\":\"InterchainApp__SameChainId\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"srcChainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"}],\"name\":\"InterchainApp__SenderNotAllowed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requiredResponses\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"optimisticPeriod\",\"type\":\"uint256\"}],\"name\":\"AppConfigV1Set\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"remoteApp\",\"type\":\"bytes32\"}],\"name\":\"AppLinked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"executionService\",\"type\":\"address\"}],\"name\":\"ExecutionServiceSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"}],\"name\":\"InterchainClientAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"}],\"name\":\"InterchainClientRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"}],\"name\":\"LatestClientSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"srcChainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"MessageReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"dstChainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"}],\"name\":\"MessageSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"TrustedModuleAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"TrustedModuleRemoved\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"IC_GOVERNOR_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"updateLatest\",\"type\":\"bool\"}],\"name\":\"addInterchainClient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"addTrustedModule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"srcChainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"appReceive\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAppConfigV1\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"requiredResponses\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"optimisticPeriod\",\"type\":\"uint256\"}],\"internalType\":\"struct AppConfigV1\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getExecutionService\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getInterchainClients\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLatestInterchainClient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"}],\"name\":\"getLinkedApp\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"}],\"name\":\"getLinkedAppEVM\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"linkedAppEVM\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"dstChainId\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasAirdrop\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"getMessageFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getModules\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReceivingConfig\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"appConfig\",\"type\":\"bytes\"},{\"internalType\":\"address[]\",\"name\":\"modules\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getRoleMember\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleMemberCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"remoteApp\",\"type\":\"bytes32\"}],\"name\":\"linkRemoteApp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"remoteApp\",\"type\":\"address\"}],\"name\":\"linkRemoteAppEVM\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"}],\"name\":\"removeInterchainClient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"removeTrustedModule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"callerConfirmation\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"dstChainId\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasAirdrop\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"sendMessage\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"requiredResponses\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"optimisticPeriod\",\"type\":\"uint256\"}],\"internalType\":\"struct AppConfigV1\",\"name\":\"appConfig\",\"type\":\"tuple\"}],\"name\":\"setAppConfigV1\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"executionService\",\"type\":\"address\"}],\"name\":\"setExecutionService\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"}],\"name\":\"setLatestInterchainClient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"errors\":{\"AccessControlBadConfirmation()\":[{\"details\":\"The caller of a function is not the expected one. NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\"}],\"AccessControlUnauthorizedAccount(address,bytes32)\":[{\"details\":\"The `account` is missing a role.\"}],\"AddressInsufficientBalance(address)\":[{\"details\":\"The ETH balance of the account is not enough to perform the operation.\"}],\"FailedInnerCall()\":[{\"details\":\"A call to an address target failed. The target may have reverted.\"}]},\"events\":{\"RoleAdminChanged(bytes32,bytes32,bytes32)\":{\"details\":\"Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole` `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite {RoleAdminChanged} not being emitted signaling this.\"},\"RoleGranted(bytes32,address,address)\":{\"details\":\"Emitted when `account` is granted `role`. `sender` is the account that originated the contract call, an admin role bearer except when using {AccessControl-_setupRole}.\"},\"RoleRevoked(bytes32,address,address)\":{\"details\":\"Emitted when `account` is revoked `role`. `sender` is the account that originated the contract call:   - if using `revokeRole`, it is the admin role bearer   - if using `renounceRole`, it is the role bearer (i.e. `account`)\"}},\"kind\":\"dev\",\"methods\":{\"addInterchainClient(address,bool)\":{\"params\":{\"client\":\"The address of the interchain client to add.\",\"updateLatest\":\"Whether to set the latest client to this one.\"}},\"appReceive(uint64,bytes32,uint64,uint64,bytes)\":{\"details\":\"App is responsible for keeping track of interchain clients, and must verify the message sender.\",\"params\":{\"dbNonce\":\"The Interchain DB nonce of the batch containing the message entry.\",\"entryIndex\":\"The index of the message entry within the batch.\",\"message\":\"The message being sent.\",\"sender\":\"Sender address on the source chain, as a bytes32 value.\",\"srcChainId\":\"Chain ID of the source chain, where the message was sent from.\"}},\"getLinkedAppEVM(uint64)\":{\"details\":\"Will revert if the linked app address is not an EVM address.\"},\"getReceivingConfig()\":{\"details\":\"This configuration is used by the Interchain Client to verify that message has been confirmed by the Interchain Modules on the destination chain. Note: V1 version of AppConfig includes the required responses count, and optimistic period after which the message is considered confirmed by the module. Following versions may include additional fields.\",\"returns\":{\"appConfig\":\"   The versioned configuration of the Interchain App, encoded as bytes.\",\"modules\":\"     The list of Interchain Modules that app is trusting to confirm the messages.\"}},\"getRoleAdmin(bytes32)\":{\"details\":\"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.\"},\"getRoleMember(bytes32,uint256)\":{\"details\":\"Returns one of the accounts that have `role`. `index` must be a value between 0 and {getRoleMemberCount}, non-inclusive. Role bearers are not sorted in any particular way, and their ordering may change at any point. WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure you perform all queries on the same block. See the following https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post] for more information.\"},\"getRoleMemberCount(bytes32)\":{\"details\":\"Returns the number of accounts that have `role`. Can be used together with {getRoleMember} to enumerate all bearers of a role.\"},\"grantRole(bytes32,address)\":{\"details\":\"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleGranted} event.\"},\"hasRole(bytes32,address)\":{\"details\":\"Returns `true` if `account` has been granted `role`.\"},\"linkRemoteApp(uint64,bytes32)\":{\"params\":{\"chainId\":\"The remote chain ID.\",\"remoteApp\":\"The address of the remote app to link.\"}},\"removeInterchainClient(address)\":{\"params\":{\"client\":\"The address of the interchain client to remove.\"}},\"renounceRole(bytes32,address)\":{\"details\":\"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `callerConfirmation`. May emit a {RoleRevoked} event.\"},\"revokeRole(bytes32,address)\":{\"details\":\"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleRevoked} event.\"},\"setLatestInterchainClient(address)\":{\"details\":\"The new latest client must be an allowed client or zero address. Setting the client to zero address effectively pauses the app ability to send messages, while allowing to receive them.\",\"params\":{\"client\":\"The address of the latest interchain client.\"}},\"supportsInterface(bytes4)\":{\"details\":\"See {IERC165-supportsInterface}.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"IC_GOVERNOR_ROLE()\":{\"notice\":\"Role to manage the Interchain setup of the app.\"},\"addInterchainClient(address,bool)\":{\"notice\":\"Allows the owner to add the interchain client to the allowed clients set, and optionally set the latest client to this one. Note: only the allowed clients can send messages to this app. Note: the latest client is used for sending messages from this app.\"},\"addTrustedModule(address)\":{\"notice\":\"Allows the owner to add the module to the trusted modules set. - This set of modules will be used to verify both sent and received messages.\"},\"appReceive(uint64,bytes32,uint64,uint64,bytes)\":{\"notice\":\"Allows the Interchain Client to pass the message to the Interchain App.\"},\"getAppConfigV1()\":{\"notice\":\"Returns the app config for the current app: requiredResponses and optimisticPeriod.\"},\"getExecutionService()\":{\"notice\":\"Returns the address of the Execution Service used by this app for sending messages.\"},\"getInterchainClients()\":{\"notice\":\"Returns the list of Interchain Clients allowed to send messages to this app.\"},\"getLatestInterchainClient()\":{\"notice\":\"Returns the address of the latest interchain client. This address is used for sending messages from this app.\"},\"getLinkedApp(uint64)\":{\"notice\":\"Returns the linked app address (as bytes32) for the given chain ID.\"},\"getLinkedAppEVM(uint64)\":{\"notice\":\"Thin wrapper for `getLinkedApp` to return the linked app address as EVM address.\"},\"getMessageFee(uint64,uint256,uint256,bytes)\":{\"notice\":\"Returns the fee required to send a message using `sendMessage`.\"},\"getModules()\":{\"notice\":\"Returns the list of Interchain Modules trusted by this app. This set of modules will be used to verify both sent and received messages.\"},\"getReceivingConfig()\":{\"notice\":\"Returns the verification configuration of the Interchain App.\"},\"linkRemoteApp(uint64,bytes32)\":{\"notice\":\"Allows the owner to link the remote app for the given chain ID. - This address will be used as the receiver for the messages sent from this chain. - This address will be the only trusted sender for the messages sent to this chain.\"},\"linkRemoteAppEVM(uint64,address)\":{\"notice\":\"Thin wrapper for `linkRemoteApp` to accept EVM address as a parameter.\"},\"removeInterchainClient(address)\":{\"notice\":\"Allows the owner to remove the interchain client from the allowed clients set. If the client is the latest client, the latest client is set to the zero address.\"},\"removeTrustedModule(address)\":{\"notice\":\"Allows the owner to remove the module from the trusted modules set.\"},\"sendMessage(uint64,uint256,uint256,bytes)\":{\"notice\":\"Sends a basic message to the destination chain.\"},\"setAppConfigV1((uint256,uint256))\":{\"notice\":\"Allows the owner to set the app config for the current app. App config includes: - requiredResponses: the number of module responses required for accepting the message - optimisticPeriod: the minimum time after which the module responses are considered final\"},\"setExecutionService(address)\":{\"notice\":\"Allows the owner to set the address of the Execution Service. This address will be used to request execution of the messages sent from this chain, by supplying the Service's execution fee.\"},\"setLatestInterchainClient(address)\":{\"notice\":\"Allows the owner to set the address of the latest interchain client.\"},\"withdraw()\":{\"notice\":\"Allows the Admin to withdraw the native asset from the contract.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/ExampleAppV1.sol\":\"ExampleAppV1\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/ExampleAppV1.sol\":{\"keccak256\":\"0xb1e9550aef785a0afc4e03fc843839919987ba4f906f09992c6788979c3c0396\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://0ede697223dfa3a2e23501efc1ed5926d5ff6458ee7b9ba833e0587162166c79\",\"dweb:/ipfs/QmUzgopL2ptWG5DYNdGAcoErPnBC4KCoRp8C61dkHHRaA6\"]}},\"version\":1}"},"hashes":{"DEFAULT_ADMIN_ROLE()":"a217fddf","IC_GOVERNOR_ROLE()":"1c489e4f","addInterchainClient(address,bool)":"f22ba23d","addTrustedModule(address)":"cb5038fb","appReceive(uint64,bytes32,uint64,uint64,bytes)":"6e9fd609","getAppConfigV1()":"7717a647","getExecutionService()":"c313c807","getInterchainClients()":"a1aa5d68","getLatestInterchainClient()":"bc0d912c","getLinkedApp(uint64)":"4e6427e7","getLinkedAppEVM(uint64)":"90a92c16","getMessageFee(uint64,uint256,uint256,bytes)":"8b41db04","getModules()":"b2494df3","getReceivingConfig()":"287bc057","getRoleAdmin(bytes32)":"248a9ca3","getRoleMember(bytes32,uint256)":"9010d07c","getRoleMemberCount(bytes32)":"ca15c873","grantRole(bytes32,address)":"2f2ff15d","hasRole(bytes32,address)":"91d14854","linkRemoteApp(uint64,bytes32)":"f6b266fd","linkRemoteAppEVM(uint64,address)":"1856ddfe","removeInterchainClient(address)":"0fb59156","removeTrustedModule(address)":"b70c40b3","renounceRole(bytes32,address)":"36568abe","revokeRole(bytes32,address)":"d547741f","sendMessage(uint64,uint256,uint256,bytes)":"06039e4b","setAppConfigV1((uint256,uint256))":"0d32b505","setExecutionService(address)":"496774b1","setLatestInterchainClient(address)":"eb53b44e","supportsInterface(bytes4)":"01ffc9a7","withdraw()":"3ccfd60b"}},"solidity/ExampleAppV1.sol:IAccessControl":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/AbstractICAppEvents.sol\n\nabstract contract AbstractICAppEvents {\n    event InterchainClientAdded(address client);\n    event InterchainClientRemoved(address client);\n    event LatestClientSet(address client);\n}\n\n// contracts/events/InterchainAppV1Events.sol\n\nabstract contract InterchainAppV1Events {\n    event AppConfigV1Set(uint256 requiredResponses, uint256 optimisticPeriod);\n    event AppLinked(uint256 indexed chainId, bytes32 indexed remoteApp);\n    event ExecutionServiceSet(address executionService);\n    event TrustedModuleAdded(address module);\n    event TrustedModuleRemoved(address module);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    /// @notice Allows the Interchain Client to pass the message to the Interchain App.\n    /// @dev App is responsible for keeping track of interchain clients, and must verify the message sender.\n    /// @param srcChainId   Chain ID of the source chain, where the message was sent from.\n    /// @param sender       Sender address on the source chain, as a bytes32 value.\n    /// @param dbNonce      The Interchain DB nonce of the batch containing the message entry.\n    /// @param entryIndex   The index of the message entry within the batch.\n    /// @param message      The message being sent.\n    function appReceive(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /// @notice Returns the verification configuration of the Interchain App.\n    /// @dev This configuration is used by the Interchain Client to verify that message has been confirmed\n    /// by the Interchain Modules on the destination chain.\n    /// Note: V1 version of AppConfig includes the required responses count, and optimistic period after which\n    /// the message is considered confirmed by the module. Following versions may include additional fields.\n    /// @return appConfig    The versioned configuration of the Interchain App, encoded as bytes.\n    /// @return modules      The list of Interchain Modules that app is trusting to confirm the messages.\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/Math.sol\n\nlibrary MathLib {\n    /// @notice Rounds up to the nearest multiple of 32.\n    /// Note: Returns zero on overflows instead of reverting. This is fine for practical\n    /// use cases, as this is used for determining the size of the payload in memory.\n    function roundUpToWord(uint256 x) internal pure returns (uint256) {\n        unchecked {\n            return (x + 31) \u0026 ~uint256(31);\n        }\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/VersionedPayload.sol\n\n// solhint-disable no-inline-assembly\n// solhint-disable ordering\nlibrary VersionedPayloadLib {\n    /// @notice Amount of bytes reserved for the version (uint16) in the versioned payload\n    uint256 internal constant VERSION_LENGTH = 2;\n\n    error VersionedPayload__TooShort(bytes versionedPayload);\n    error VersionedPayload__PrecompileFailed();\n\n    /// @notice Encodes the versioned payload into a single bytes array.\n    /// @param version  The payload's version.\n    /// @param payload  The payload to encode.\n    function encodeVersionedPayload(uint16 version, bytes memory payload) internal pure returns (bytes memory) {\n        return abi.encodePacked(version, payload);\n    }\n\n    /// @notice Extracts the version from the versioned payload (calldata reference).\n    /// @param versionedPayload     The versioned payload (calldata reference).\n    function getVersion(bytes calldata versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            version := shr(240, calldataload(versionedPayload.offset))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (calldata reference).\n    /// @dev The extracted payload is also returned as a calldata reference.\n    /// @param versionedPayload     The versioned payload.\n    function getPayload(bytes calldata versionedPayload) internal pure returns (bytes calldata) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        return versionedPayload[VERSION_LENGTH:];\n    }\n\n    /// @notice Extracts the version from the versioned payload (memory reference).\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getVersionFromMemory(bytes memory versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            // We add 0x20 to skip the length of the bytes array.\n            version := shr(240, mload(add(versionedPayload, 0x20)))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (memory reference).\n    /// @dev The extracted payload is copied into a new memory location. Use `getPayload` when possible\n    /// to avoid extra memory allocation.\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getPayloadFromMemory(bytes memory versionedPayload) internal view returns (bytes memory payload) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        // Figure how many bytes to copy and allocate the memory for the extracted payload.\n        uint256 toCopy;\n        unchecked {\n            toCopy = versionedPayload.length - VERSION_LENGTH;\n        }\n        payload = new bytes(toCopy);\n        // Use identity precompile (0x04) to copy the payload. Unlike MCOPY, this is available on all EVM chains.\n        bool res;\n        assembly {\n            // We add 0x20 to skip the length of the bytes array.\n            // We add 0x02 to skip the 2 bytes reserved for the version.\n            // Copy the payload to the previously allocated memory.\n            res := staticcall(gas(), 0x04, add(versionedPayload, 0x22), toCopy, add(payload, 0x20), toCopy)\n        }\n        if (!res) {\n            revert VersionedPayload__PrecompileFailed();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/IAccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n\n// node_modules/@openzeppelin/contracts/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance \u003c amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance \u003c value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 \u0026\u0026 target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SafeCast.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value \u003e type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value \u003e type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value \u003e type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value \u003e type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value \u003e type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value \u003e type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value \u003e type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value \u003e type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value \u003e type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value \u003e type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value \u003e type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value \u003e type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value \u003e type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value \u003e type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value \u003e type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value \u003e type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value \u003e type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value \u003e type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value \u003e type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value \u003e type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value \u003e type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value \u003e type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value \u003e type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value \u003e type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value \u003e type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value \u003e type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value \u003e type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value \u003e type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value \u003e type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value \u003e type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value \u003e type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value \u003c 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value \u003e uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal view returns (AppConfigV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (AppConfigV1));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal view returns (OptionsV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (OptionsV1));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(OPTIONS_V1, abi.encode(options));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/IAccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/IAccessControlEnumerable.sol)\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n// contracts/interfaces/IInterchainAppV1.sol\n\ninterface IInterchainAppV1 is IInterchainApp {\n    error InterchainApp__AppZeroAddress();\n    error InterchainApp__InvalidAppConfig(uint256 requiredResponses, uint256 optimisticPeriod);\n    error InterchainApp__ModuleAlreadyAdded(address module);\n    error InterchainApp__ModuleNotAdded(address module);\n    error InterchainApp__ModuleZeroAddress();\n    error InterchainApp__NotEVMLinkedApp(bytes32 linkedApp);\n\n    /// @notice Allows the owner to add the interchain client to the allowed clients set,\n    /// and optionally set the latest client to this one.\n    /// Note: only the allowed clients can send messages to this app.\n    /// Note: the latest client is used for sending messages from this app.\n    /// @param client       The address of the interchain client to add.\n    /// @param updateLatest Whether to set the latest client to this one.\n    function addInterchainClient(address client, bool updateLatest) external;\n\n    /// @notice Allows the owner to remove the interchain client from the allowed clients set.\n    /// If the client is the latest client, the latest client is set to the zero address.\n    /// @param client       The address of the interchain client to remove.\n    function removeInterchainClient(address client) external;\n\n    /// @notice Allows the owner to set the address of the latest interchain client.\n    /// @dev The new latest client must be an allowed client or zero address.\n    /// Setting the client to zero address effectively pauses the app ability to send messages,\n    /// while allowing to receive them.\n    /// @param client       The address of the latest interchain client.\n    function setLatestInterchainClient(address client) external;\n\n    /// @notice Allows the owner to link the remote app for the given chain ID.\n    /// - This address will be used as the receiver for the messages sent from this chain.\n    /// - This address will be the only trusted sender for the messages sent to this chain.\n    /// @param chainId      The remote chain ID.\n    /// @param remoteApp    The address of the remote app to link.\n    function linkRemoteApp(uint64 chainId, bytes32 remoteApp) external;\n\n    /// @notice Thin wrapper for `linkRemoteApp` to accept EVM address as a parameter.\n    function linkRemoteAppEVM(uint64 chainId, address remoteApp) external;\n\n    /// @notice Allows the owner to add the module to the trusted modules set.\n    /// - This set of modules will be used to verify both sent and received messages.\n    function addTrustedModule(address module) external;\n\n    /// @notice Allows the owner to remove the module from the trusted modules set.\n    function removeTrustedModule(address module) external;\n\n    /// @notice Allows the owner to set the app config for the current app. App config includes:\n    /// - requiredResponses: the number of module responses required for accepting the message\n    /// - optimisticPeriod: the minimum time after which the module responses are considered final\n    function setAppConfigV1(AppConfigV1 memory appConfig) external;\n\n    /// @notice Allows the owner to set the address of the Execution Service.\n    /// This address will be used to request execution of the messages sent from this chain,\n    /// by supplying the Service's execution fee.\n    function setExecutionService(address executionService) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Returns the app config for the current app: requiredResponses and optimisticPeriod.\n    function getAppConfigV1() external view returns (AppConfigV1 memory);\n\n    /// @notice Returns the address of the Execution Service used by this app for sending messages.\n    function getExecutionService() external view returns (address);\n\n    /// @notice Returns the list of Interchain Clients allowed to send messages to this app.\n    function getInterchainClients() external view returns (address[] memory);\n\n    /// @notice Returns the address of the latest interchain client.\n    /// This address is used for sending messages from this app.\n    function getLatestInterchainClient() external view returns (address);\n\n    /// @notice Returns the linked app address (as bytes32) for the given chain ID.\n    function getLinkedApp(uint64 chainId) external view returns (bytes32);\n\n    /// @notice Thin wrapper for `getLinkedApp` to return the linked app address as EVM address.\n    /// @dev Will revert if the linked app address is not an EVM address.\n    function getLinkedAppEVM(uint64 chainId) external view returns (address);\n\n    /// @notice Returns the list of Interchain Modules trusted by this app.\n    /// This set of modules will be used to verify both sent and received messages.\n    function getModules() external view returns (address[] memory);\n}\n\n// contracts/libs/InterchainTransaction.sol\n\ntype ICTxHeader is uint256;\n\nstruct InterchainTransaction {\n    uint64 srcChainId;\n    uint64 dstChainId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcSender;\n    bytes32 dstReceiver;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    using MathLib for uint256;\n    using VersionedPayloadLib for bytes;\n\n    function constructLocalTransaction(\n        address srcSender,\n        uint64 dstChainId,\n        bytes32 dstReceiver,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: SafeCast.toUint64(block.chainid),\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            encodeTxHeader(transaction.srcChainId, transaction.dstChainId, transaction.dbNonce, transaction.entryIndex),\n            transaction.srcSender,\n            transaction.dstReceiver,\n            transaction.options,\n            transaction.message\n        );\n    }\n\n    function decodeTransaction(bytes calldata transaction) internal pure returns (InterchainTransaction memory icTx) {\n        ICTxHeader header;\n        (header, icTx.srcSender, icTx.dstReceiver, icTx.options, icTx.message) =\n            abi.decode(transaction, (ICTxHeader, bytes32, bytes32, bytes, bytes));\n        (icTx.srcChainId, icTx.dstChainId, icTx.dbNonce, icTx.entryIndex) = decodeTxHeader(header);\n    }\n\n    function payloadSize(uint256 optionsLen, uint256 messageLen) internal pure returns (uint256) {\n        // 2 bytes are reserved for the transaction version\n        // + 5 fields * 32 bytes (3 values for static, 2 offsets for dynamic) + 2 * 32 bytes (lengths for dynamic) = 226\n        // (srcChainId, dstChainId, dbNonce, entryIndex) are merged into a single 32 bytes field\n        // Both options and message are dynamic fields, which are padded up to 32 bytes\n        return 226 + optionsLen.roundUpToWord() + messageLen.roundUpToWord();\n    }\n\n    function encodeTxHeader(\n        uint64 srcChainId,\n        uint64 dstChainId,\n        uint64 dbNonce,\n        uint64 entryIndex\n    )\n        internal\n        pure\n        returns (ICTxHeader)\n    {\n        return ICTxHeader.wrap(\n            (uint256(srcChainId) \u003c\u003c 192) | (uint256(dstChainId) \u003c\u003c 128) | (uint256(dbNonce) \u003c\u003c 64) | uint256(entryIndex)\n        );\n    }\n\n    function decodeTxHeader(ICTxHeader header)\n        internal\n        pure\n        returns (uint64 srcChainId, uint64 dstChainId, uint64 dbNonce, uint64 entryIndex)\n    {\n        srcChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 192);\n        dstChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 128);\n        dbNonce = uint64(ICTxHeader.unwrap(header) \u003e\u003e 64);\n        entryIndex = uint64(ICTxHeader.unwrap(header));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/AccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account =\u003e bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role =\u003e RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint64 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__InvalidTransactionVersion(uint16 version);\n    error InterchainClientV1__NoLinkedClient(uint64 chainId);\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint64 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint64 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint64 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint64 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param messageLen           The length of the message being sent.\n    function getInterchainFee(\n        uint64 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        uint256 messageLen\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint64 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint64 chainId) external view returns (address);\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/AccessControlEnumerable.sol)\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 role =\u003e EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {AccessControl-_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool granted = super._grantRole(role, account);\n        if (granted) {\n            _roleMembers[role].add(account);\n        }\n        return granted;\n    }\n\n    /**\n     * @dev Overload {AccessControl-_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool revoked = super._revokeRole(role, account);\n        if (revoked) {\n            _roleMembers[role].remove(account);\n        }\n        return revoked;\n    }\n}\n\n// contracts/apps/AbstractICApp.sol\n\nabstract contract AbstractICApp is AbstractICAppEvents, IInterchainApp {\n    using TypeCasts for address;\n\n    error InterchainApp__AlreadyLatestClient(address client);\n    error InterchainApp__BalanceTooLow(uint256 actual, uint256 required);\n    error InterchainApp__ClientAlreadyAdded(address client);\n    error InterchainApp__InterchainClientZeroAddress();\n    error InterchainApp__NotInterchainClient(address account);\n    error InterchainApp__ReceiverNotSet(uint64 chainId);\n    error InterchainApp__SameChainId(uint64 chainId);\n    error InterchainApp__SenderNotAllowed(uint64 srcChainId, bytes32 sender);\n\n    /// @inheritdoc IInterchainApp\n    function appReceive(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        if (!_isInterchainClient(msg.sender)) {\n            revert InterchainApp__NotInterchainClient(msg.sender);\n        }\n        if (srcChainId == block.chainid) {\n            revert InterchainApp__SameChainId(srcChainId);\n        }\n        if (!_isAllowedSender(srcChainId, sender)) {\n            revert InterchainApp__SenderNotAllowed(srcChainId, sender);\n        }\n        _receiveMessage(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n\n    /// @inheritdoc IInterchainApp\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules) {\n        appConfig = _getAppConfig();\n        modules = _getModules();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Performs necessary checks and adds an Interchain Client.\n    /// Optionally sets the latest client to this one.\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _addClient(address client, bool updateLatest) internal {\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (_isInterchainClient(client)) {\n            revert InterchainApp__ClientAlreadyAdded(client);\n        }\n        _toggleClientState(client, true);\n        emit InterchainClientAdded(client);\n        if (updateLatest) {\n            _setLatestClient(client);\n        }\n    }\n\n    /// @dev Performs necessary checks and removes an Interchain Client. If this client is the latest one,\n    /// the latest client is set to zero address (effectively pausing the app ability to send messages).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _removeClient(address client) internal {\n        if (!_isInterchainClient(client)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        _toggleClientState(client, false);\n        emit InterchainClientRemoved(client);\n        if (client == _getLatestClient()) {\n            _setLatestClient(address(0));\n        }\n    }\n\n    /// @dev Sets the latest Interchain Client to one of the allowed clients. Setting the client to zero address\n    /// is allowed and effectively pauses the app ability to send messages (but still allows to receive them).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _setLatestClient(address client) internal {\n        // New latest client must be an allowed client or zero address.\n        if (!_isInterchainClient(client) \u0026\u0026 client != address(0)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        if (client == _getLatestClient()) {\n            revert InterchainApp__AlreadyLatestClient(client);\n        }\n        _storeLatestClient(client);\n        emit LatestClientSet(client);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal virtual;\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal virtual;\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to accept EVM address as a parameter.\n    function _sendInterchainMessageEVM(\n        uint64 dstChainId,\n        address receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _sendInterchainMessage(dstChainId, receiver.addressToBytes32(), messageFee, options, message);\n    }\n\n    /// @dev Performs necessary checks and sends an interchain message.\n    function _sendInterchainMessage(\n        uint64 dstChainId,\n        bytes32 receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (dstChainId == block.chainid) {\n            revert InterchainApp__SameChainId(dstChainId);\n        }\n        if (receiver == 0) {\n            revert InterchainApp__ReceiverNotSet(dstChainId);\n        }\n        if (address(this).balance \u003c messageFee) {\n            revert InterchainApp__BalanceTooLow({actual: address(this).balance, required: messageFee});\n        }\n        return IInterchainClientV1(client).interchainSend{value: messageFee}(\n            dstChainId, receiver, _getExecutionService(), _getModules(), options, message\n        );\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        virtual;\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee for sending an Interchain message.\n    function _getInterchainFee(\n        uint64 dstChainId,\n        bytes memory options,\n        uint256 messageLen\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        return IInterchainClientV1(client).getInterchainFee(\n            dstChainId, _getExecutionService(), _getModules(), options, messageLen\n        );\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view virtual returns (bytes memory);\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view virtual returns (address);\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view virtual returns (address);\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view virtual returns (address[] memory);\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint64 srcChainId, bytes32 sender) internal view virtual returns (bool);\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view virtual returns (bool);\n}\n\n// contracts/apps/ICAppV1.sol\n\nabstract contract ICAppV1 is AbstractICApp, AccessControlEnumerable, InterchainAppV1Events, IInterchainAppV1 {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Role to manage the Interchain setup of the app.\n    bytes32 public constant IC_GOVERNOR_ROLE = keccak256(\"IC_GOVERNOR_ROLE\");\n\n    /// @dev Address of the latest Interchain Client, used for sending messages.\n    address private _latestClient;\n\n    /// @dev Required responses and optimistic period for the module responses.\n    AppConfigV1 private _appConfigV1;\n    /// @dev Address of the linked app deployed on the remote chain.\n    mapping(uint64 chainId =\u003e bytes32 remoteApp) private _linkedApp;\n    /// @dev Interchain Clients allowed to send messages to this app.\n    EnumerableSet.AddressSet private _interchainClients;\n    /// @dev Trusted Interchain modules.\n    EnumerableSet.AddressSet private _trustedModules;\n    /// @dev Execution Service to use for sending messages.\n    address private _executionService;\n\n    constructor(address admin) {\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addInterchainClient(address client, bool updateLatest) external onlyRole(IC_GOVERNOR_ROLE) {\n        _addClient(client, updateLatest);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _removeClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setLatestInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _setLatestClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteApp(uint64 chainId, bytes32 remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteAppEVM(uint64 chainId, address remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp.addressToBytes32());\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (module == address(0)) {\n            revert InterchainApp__ModuleZeroAddress();\n        }\n        bool added = _trustedModules.add(module);\n        if (!added) {\n            revert InterchainApp__ModuleAlreadyAdded(module);\n        }\n        emit TrustedModuleAdded(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        bool removed = _trustedModules.remove(module);\n        if (!removed) {\n            revert InterchainApp__ModuleNotAdded(module);\n        }\n        emit TrustedModuleRemoved(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setAppConfigV1(AppConfigV1 memory appConfig) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (appConfig.requiredResponses == 0 || appConfig.optimisticPeriod == 0) {\n            revert InterchainApp__InvalidAppConfig(appConfig.requiredResponses, appConfig.optimisticPeriod);\n        }\n        _appConfigV1 = appConfig;\n        emit AppConfigV1Set(appConfig.requiredResponses, appConfig.optimisticPeriod);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setExecutionService(address executionService) external onlyRole(IC_GOVERNOR_ROLE) {\n        _executionService = executionService;\n        emit ExecutionServiceSet(executionService);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainAppV1\n    function getAppConfigV1() external view returns (AppConfigV1 memory) {\n        return _appConfigV1;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getExecutionService() external view returns (address) {\n        return _executionService;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getInterchainClients() external view returns (address[] memory) {\n        return _interchainClients.values();\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLatestInterchainClient() external view returns (address) {\n        return _latestClient;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedApp(uint64 chainId) external view returns (bytes32) {\n        return _linkedApp[chainId];\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedAppEVM(uint64 chainId) external view returns (address linkedAppEVM) {\n        bytes32 linkedApp = _linkedApp[chainId];\n        linkedAppEVM = linkedApp.bytes32ToAddress();\n        if (linkedAppEVM.addressToBytes32() != linkedApp) {\n            revert InterchainApp__NotEVMLinkedApp(linkedApp);\n        }\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getModules() external view returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Links the remote app to the current app.\n    /// Will revert if the chainId is the same as the chainId of the local app.\n    /// Note: Should be guarded with permissions check.\n    function _linkRemoteApp(uint64 chainId, bytes32 remoteApp) internal {\n        if (chainId == block.chainid) {\n            revert InterchainApp__SameChainId(chainId);\n        }\n        if (remoteApp == 0) {\n            revert InterchainApp__AppZeroAddress();\n        }\n        _linkedApp[chainId] = remoteApp;\n        emit AppLinked(chainId, remoteApp);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal override {\n        _latestClient = client;\n    }\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal override {\n        if (allowed) {\n            _interchainClients.add(client);\n        } else {\n            _interchainClients.remove(client);\n        }\n    }\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to send the message to the linked app.\n    function _sendToLinkedApp(\n        uint64 dstChainId,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _sendInterchainMessage(dstChainId, _linkedApp[dstChainId], messageFee, encodedOptions, message);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee to send a message to the linked app on the remote chain.\n    function _getMessageFee(\n        uint64 dstChainId,\n        OptionsV1 memory options,\n        uint256 messageLen\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _getInterchainFee(dstChainId, encodedOptions, messageLen);\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view override returns (bytes memory) {\n        return _appConfigV1.encodeAppConfigV1();\n    }\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view override returns (address) {\n        return _executionService;\n    }\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view override returns (address) {\n        return _latestClient;\n    }\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view override returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint64 srcChainId, bytes32 sender) internal view override returns (bool) {\n        return _linkedApp[srcChainId] == sender;\n    }\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view override returns (bool) {\n        return _interchainClients.contains(caller);\n    }\n}\n\n// contracts/apps/examples/ExampleAppV1.sol\n\ncontract ExampleAppV1 is ICAppV1 {\n    event MessageReceived(uint64 srcChainId, bytes32 sender, uint64 dbNonce, uint64 entryIndex, bytes message);\n    event MessageSent(uint64 dstChainId, uint64 dbNonce, uint64 entryIndex, bytes32 transactionId);\n\n    constructor(address admin) ICAppV1(admin) {\n        _grantRole(IC_GOVERNOR_ROLE, admin);\n    }\n\n    /// @notice Allows the Admin to withdraw the native asset from the contract.\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        Address.sendValue(payable(msg.sender), address(this).balance);\n    }\n\n    /// @notice Sends a basic message to the destination chain.\n    function sendMessage(\n        uint64 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        InterchainTxDescriptor memory desc = _sendToLinkedApp({\n            dstChainId: dstChainId,\n            messageFee: msg.value,\n            options: OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}),\n            message: message\n        });\n        emit MessageSent(dstChainId, desc.dbNonce, desc.entryIndex, desc.transactionId);\n    }\n\n    /// @notice Returns the fee required to send a message using `sendMessage`.\n    function getMessageFee(\n        uint64 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes memory message\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _getMessageFee(dstChainId, OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}), message.length);\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        override\n    {\n        emit MessageReceived(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[],"name":"AccessControlBadConfirmation","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"bytes32","name":"neededRole","type":"bytes32"}],"name":"AccessControlUnauthorizedAccount","type":"error"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"bytes32","name":"previousAdminRole","type":"bytes32"},{"indexed":true,"internalType":"bytes32","name":"newAdminRole","type":"bytes32"}],"name":"RoleAdminChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":true,"internalType":"address","name":"sender","type":"address"}],"name":"RoleGranted","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":true,"internalType":"address","name":"sender","type":"address"}],"name":"RoleRevoked","type":"event"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"}],"name":"getRoleAdmin","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"grantRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"hasRole","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"callerConfirmation","type":"address"}],"name":"renounceRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"revokeRole","outputs":[],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"details":"External interface of AccessControl declared to support ERC165 detection.","errors":{"AccessControlBadConfirmation()":[{"details":"The caller of a function is not the expected one. NOTE: Don't confuse with {AccessControlUnauthorizedAccount}."}],"AccessControlUnauthorizedAccount(address,bytes32)":[{"details":"The `account` is missing a role."}]},"events":{"RoleAdminChanged(bytes32,bytes32,bytes32)":{"details":"Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole` `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite {RoleAdminChanged} not being emitted signaling this."},"RoleGranted(bytes32,address,address)":{"details":"Emitted when `account` is granted `role`. `sender` is the account that originated the contract call, an admin role bearer except when using {AccessControl-_setupRole}."},"RoleRevoked(bytes32,address,address)":{"details":"Emitted when `account` is revoked `role`. `sender` is the account that originated the contract call:   - if using `revokeRole`, it is the admin role bearer   - if using `renounceRole`, it is the role bearer (i.e. `account`)"}},"kind":"dev","methods":{"getRoleAdmin(bytes32)":{"details":"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {AccessControl-_setRoleAdmin}."},"grantRole(bytes32,address)":{"details":"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role."},"hasRole(bytes32,address)":{"details":"Returns `true` if `account` has been granted `role`."},"renounceRole(bytes32,address)":{"details":"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `callerConfirmation`."},"revokeRole(bytes32,address)":{"details":"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role."}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"AccessControlBadConfirmation\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"neededRole\",\"type\":\"bytes32\"}],\"name\":\"AccessControlUnauthorizedAccount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"callerConfirmation\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"External interface of AccessControl declared to support ERC165 detection.\",\"errors\":{\"AccessControlBadConfirmation()\":[{\"details\":\"The caller of a function is not the expected one. NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\"}],\"AccessControlUnauthorizedAccount(address,bytes32)\":[{\"details\":\"The `account` is missing a role.\"}]},\"events\":{\"RoleAdminChanged(bytes32,bytes32,bytes32)\":{\"details\":\"Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole` `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite {RoleAdminChanged} not being emitted signaling this.\"},\"RoleGranted(bytes32,address,address)\":{\"details\":\"Emitted when `account` is granted `role`. `sender` is the account that originated the contract call, an admin role bearer except when using {AccessControl-_setupRole}.\"},\"RoleRevoked(bytes32,address,address)\":{\"details\":\"Emitted when `account` is revoked `role`. `sender` is the account that originated the contract call:   - if using `revokeRole`, it is the admin role bearer   - if using `renounceRole`, it is the role bearer (i.e. `account`)\"}},\"kind\":\"dev\",\"methods\":{\"getRoleAdmin(bytes32)\":{\"details\":\"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {AccessControl-_setRoleAdmin}.\"},\"grantRole(bytes32,address)\":{\"details\":\"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.\"},\"hasRole(bytes32,address)\":{\"details\":\"Returns `true` if `account` has been granted `role`.\"},\"renounceRole(bytes32,address)\":{\"details\":\"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `callerConfirmation`.\"},\"revokeRole(bytes32,address)\":{\"details\":\"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/ExampleAppV1.sol\":\"IAccessControl\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/ExampleAppV1.sol\":{\"keccak256\":\"0xb1e9550aef785a0afc4e03fc843839919987ba4f906f09992c6788979c3c0396\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://0ede697223dfa3a2e23501efc1ed5926d5ff6458ee7b9ba833e0587162166c79\",\"dweb:/ipfs/QmUzgopL2ptWG5DYNdGAcoErPnBC4KCoRp8C61dkHHRaA6\"]}},\"version\":1}"},"hashes":{"getRoleAdmin(bytes32)":"248a9ca3","grantRole(bytes32,address)":"2f2ff15d","hasRole(bytes32,address)":"91d14854","renounceRole(bytes32,address)":"36568abe","revokeRole(bytes32,address)":"d547741f"}},"solidity/ExampleAppV1.sol:IAccessControlEnumerable":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/AbstractICAppEvents.sol\n\nabstract contract AbstractICAppEvents {\n    event InterchainClientAdded(address client);\n    event InterchainClientRemoved(address client);\n    event LatestClientSet(address client);\n}\n\n// contracts/events/InterchainAppV1Events.sol\n\nabstract contract InterchainAppV1Events {\n    event AppConfigV1Set(uint256 requiredResponses, uint256 optimisticPeriod);\n    event AppLinked(uint256 indexed chainId, bytes32 indexed remoteApp);\n    event ExecutionServiceSet(address executionService);\n    event TrustedModuleAdded(address module);\n    event TrustedModuleRemoved(address module);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    /// @notice Allows the Interchain Client to pass the message to the Interchain App.\n    /// @dev App is responsible for keeping track of interchain clients, and must verify the message sender.\n    /// @param srcChainId   Chain ID of the source chain, where the message was sent from.\n    /// @param sender       Sender address on the source chain, as a bytes32 value.\n    /// @param dbNonce      The Interchain DB nonce of the batch containing the message entry.\n    /// @param entryIndex   The index of the message entry within the batch.\n    /// @param message      The message being sent.\n    function appReceive(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /// @notice Returns the verification configuration of the Interchain App.\n    /// @dev This configuration is used by the Interchain Client to verify that message has been confirmed\n    /// by the Interchain Modules on the destination chain.\n    /// Note: V1 version of AppConfig includes the required responses count, and optimistic period after which\n    /// the message is considered confirmed by the module. Following versions may include additional fields.\n    /// @return appConfig    The versioned configuration of the Interchain App, encoded as bytes.\n    /// @return modules      The list of Interchain Modules that app is trusting to confirm the messages.\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/Math.sol\n\nlibrary MathLib {\n    /// @notice Rounds up to the nearest multiple of 32.\n    /// Note: Returns zero on overflows instead of reverting. This is fine for practical\n    /// use cases, as this is used for determining the size of the payload in memory.\n    function roundUpToWord(uint256 x) internal pure returns (uint256) {\n        unchecked {\n            return (x + 31) \u0026 ~uint256(31);\n        }\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/VersionedPayload.sol\n\n// solhint-disable no-inline-assembly\n// solhint-disable ordering\nlibrary VersionedPayloadLib {\n    /// @notice Amount of bytes reserved for the version (uint16) in the versioned payload\n    uint256 internal constant VERSION_LENGTH = 2;\n\n    error VersionedPayload__TooShort(bytes versionedPayload);\n    error VersionedPayload__PrecompileFailed();\n\n    /// @notice Encodes the versioned payload into a single bytes array.\n    /// @param version  The payload's version.\n    /// @param payload  The payload to encode.\n    function encodeVersionedPayload(uint16 version, bytes memory payload) internal pure returns (bytes memory) {\n        return abi.encodePacked(version, payload);\n    }\n\n    /// @notice Extracts the version from the versioned payload (calldata reference).\n    /// @param versionedPayload     The versioned payload (calldata reference).\n    function getVersion(bytes calldata versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            version := shr(240, calldataload(versionedPayload.offset))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (calldata reference).\n    /// @dev The extracted payload is also returned as a calldata reference.\n    /// @param versionedPayload     The versioned payload.\n    function getPayload(bytes calldata versionedPayload) internal pure returns (bytes calldata) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        return versionedPayload[VERSION_LENGTH:];\n    }\n\n    /// @notice Extracts the version from the versioned payload (memory reference).\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getVersionFromMemory(bytes memory versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            // We add 0x20 to skip the length of the bytes array.\n            version := shr(240, mload(add(versionedPayload, 0x20)))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (memory reference).\n    /// @dev The extracted payload is copied into a new memory location. Use `getPayload` when possible\n    /// to avoid extra memory allocation.\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getPayloadFromMemory(bytes memory versionedPayload) internal view returns (bytes memory payload) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        // Figure how many bytes to copy and allocate the memory for the extracted payload.\n        uint256 toCopy;\n        unchecked {\n            toCopy = versionedPayload.length - VERSION_LENGTH;\n        }\n        payload = new bytes(toCopy);\n        // Use identity precompile (0x04) to copy the payload. Unlike MCOPY, this is available on all EVM chains.\n        bool res;\n        assembly {\n            // We add 0x20 to skip the length of the bytes array.\n            // We add 0x02 to skip the 2 bytes reserved for the version.\n            // Copy the payload to the previously allocated memory.\n            res := staticcall(gas(), 0x04, add(versionedPayload, 0x22), toCopy, add(payload, 0x20), toCopy)\n        }\n        if (!res) {\n            revert VersionedPayload__PrecompileFailed();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/IAccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n\n// node_modules/@openzeppelin/contracts/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance \u003c amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance \u003c value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 \u0026\u0026 target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SafeCast.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value \u003e type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value \u003e type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value \u003e type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value \u003e type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value \u003e type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value \u003e type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value \u003e type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value \u003e type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value \u003e type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value \u003e type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value \u003e type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value \u003e type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value \u003e type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value \u003e type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value \u003e type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value \u003e type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value \u003e type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value \u003e type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value \u003e type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value \u003e type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value \u003e type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value \u003e type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value \u003e type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value \u003e type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value \u003e type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value \u003e type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value \u003e type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value \u003e type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value \u003e type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value \u003e type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value \u003e type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value \u003c 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value \u003e uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal view returns (AppConfigV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (AppConfigV1));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal view returns (OptionsV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (OptionsV1));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(OPTIONS_V1, abi.encode(options));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/IAccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/IAccessControlEnumerable.sol)\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n// contracts/interfaces/IInterchainAppV1.sol\n\ninterface IInterchainAppV1 is IInterchainApp {\n    error InterchainApp__AppZeroAddress();\n    error InterchainApp__InvalidAppConfig(uint256 requiredResponses, uint256 optimisticPeriod);\n    error InterchainApp__ModuleAlreadyAdded(address module);\n    error InterchainApp__ModuleNotAdded(address module);\n    error InterchainApp__ModuleZeroAddress();\n    error InterchainApp__NotEVMLinkedApp(bytes32 linkedApp);\n\n    /// @notice Allows the owner to add the interchain client to the allowed clients set,\n    /// and optionally set the latest client to this one.\n    /// Note: only the allowed clients can send messages to this app.\n    /// Note: the latest client is used for sending messages from this app.\n    /// @param client       The address of the interchain client to add.\n    /// @param updateLatest Whether to set the latest client to this one.\n    function addInterchainClient(address client, bool updateLatest) external;\n\n    /// @notice Allows the owner to remove the interchain client from the allowed clients set.\n    /// If the client is the latest client, the latest client is set to the zero address.\n    /// @param client       The address of the interchain client to remove.\n    function removeInterchainClient(address client) external;\n\n    /// @notice Allows the owner to set the address of the latest interchain client.\n    /// @dev The new latest client must be an allowed client or zero address.\n    /// Setting the client to zero address effectively pauses the app ability to send messages,\n    /// while allowing to receive them.\n    /// @param client       The address of the latest interchain client.\n    function setLatestInterchainClient(address client) external;\n\n    /// @notice Allows the owner to link the remote app for the given chain ID.\n    /// - This address will be used as the receiver for the messages sent from this chain.\n    /// - This address will be the only trusted sender for the messages sent to this chain.\n    /// @param chainId      The remote chain ID.\n    /// @param remoteApp    The address of the remote app to link.\n    function linkRemoteApp(uint64 chainId, bytes32 remoteApp) external;\n\n    /// @notice Thin wrapper for `linkRemoteApp` to accept EVM address as a parameter.\n    function linkRemoteAppEVM(uint64 chainId, address remoteApp) external;\n\n    /// @notice Allows the owner to add the module to the trusted modules set.\n    /// - This set of modules will be used to verify both sent and received messages.\n    function addTrustedModule(address module) external;\n\n    /// @notice Allows the owner to remove the module from the trusted modules set.\n    function removeTrustedModule(address module) external;\n\n    /// @notice Allows the owner to set the app config for the current app. App config includes:\n    /// - requiredResponses: the number of module responses required for accepting the message\n    /// - optimisticPeriod: the minimum time after which the module responses are considered final\n    function setAppConfigV1(AppConfigV1 memory appConfig) external;\n\n    /// @notice Allows the owner to set the address of the Execution Service.\n    /// This address will be used to request execution of the messages sent from this chain,\n    /// by supplying the Service's execution fee.\n    function setExecutionService(address executionService) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Returns the app config for the current app: requiredResponses and optimisticPeriod.\n    function getAppConfigV1() external view returns (AppConfigV1 memory);\n\n    /// @notice Returns the address of the Execution Service used by this app for sending messages.\n    function getExecutionService() external view returns (address);\n\n    /// @notice Returns the list of Interchain Clients allowed to send messages to this app.\n    function getInterchainClients() external view returns (address[] memory);\n\n    /// @notice Returns the address of the latest interchain client.\n    /// This address is used for sending messages from this app.\n    function getLatestInterchainClient() external view returns (address);\n\n    /// @notice Returns the linked app address (as bytes32) for the given chain ID.\n    function getLinkedApp(uint64 chainId) external view returns (bytes32);\n\n    /// @notice Thin wrapper for `getLinkedApp` to return the linked app address as EVM address.\n    /// @dev Will revert if the linked app address is not an EVM address.\n    function getLinkedAppEVM(uint64 chainId) external view returns (address);\n\n    /// @notice Returns the list of Interchain Modules trusted by this app.\n    /// This set of modules will be used to verify both sent and received messages.\n    function getModules() external view returns (address[] memory);\n}\n\n// contracts/libs/InterchainTransaction.sol\n\ntype ICTxHeader is uint256;\n\nstruct InterchainTransaction {\n    uint64 srcChainId;\n    uint64 dstChainId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcSender;\n    bytes32 dstReceiver;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    using MathLib for uint256;\n    using VersionedPayloadLib for bytes;\n\n    function constructLocalTransaction(\n        address srcSender,\n        uint64 dstChainId,\n        bytes32 dstReceiver,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: SafeCast.toUint64(block.chainid),\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            encodeTxHeader(transaction.srcChainId, transaction.dstChainId, transaction.dbNonce, transaction.entryIndex),\n            transaction.srcSender,\n            transaction.dstReceiver,\n            transaction.options,\n            transaction.message\n        );\n    }\n\n    function decodeTransaction(bytes calldata transaction) internal pure returns (InterchainTransaction memory icTx) {\n        ICTxHeader header;\n        (header, icTx.srcSender, icTx.dstReceiver, icTx.options, icTx.message) =\n            abi.decode(transaction, (ICTxHeader, bytes32, bytes32, bytes, bytes));\n        (icTx.srcChainId, icTx.dstChainId, icTx.dbNonce, icTx.entryIndex) = decodeTxHeader(header);\n    }\n\n    function payloadSize(uint256 optionsLen, uint256 messageLen) internal pure returns (uint256) {\n        // 2 bytes are reserved for the transaction version\n        // + 5 fields * 32 bytes (3 values for static, 2 offsets for dynamic) + 2 * 32 bytes (lengths for dynamic) = 226\n        // (srcChainId, dstChainId, dbNonce, entryIndex) are merged into a single 32 bytes field\n        // Both options and message are dynamic fields, which are padded up to 32 bytes\n        return 226 + optionsLen.roundUpToWord() + messageLen.roundUpToWord();\n    }\n\n    function encodeTxHeader(\n        uint64 srcChainId,\n        uint64 dstChainId,\n        uint64 dbNonce,\n        uint64 entryIndex\n    )\n        internal\n        pure\n        returns (ICTxHeader)\n    {\n        return ICTxHeader.wrap(\n            (uint256(srcChainId) \u003c\u003c 192) | (uint256(dstChainId) \u003c\u003c 128) | (uint256(dbNonce) \u003c\u003c 64) | uint256(entryIndex)\n        );\n    }\n\n    function decodeTxHeader(ICTxHeader header)\n        internal\n        pure\n        returns (uint64 srcChainId, uint64 dstChainId, uint64 dbNonce, uint64 entryIndex)\n    {\n        srcChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 192);\n        dstChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 128);\n        dbNonce = uint64(ICTxHeader.unwrap(header) \u003e\u003e 64);\n        entryIndex = uint64(ICTxHeader.unwrap(header));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/AccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account =\u003e bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role =\u003e RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint64 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__InvalidTransactionVersion(uint16 version);\n    error InterchainClientV1__NoLinkedClient(uint64 chainId);\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint64 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint64 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint64 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint64 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param messageLen           The length of the message being sent.\n    function getInterchainFee(\n        uint64 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        uint256 messageLen\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint64 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint64 chainId) external view returns (address);\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/AccessControlEnumerable.sol)\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 role =\u003e EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {AccessControl-_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool granted = super._grantRole(role, account);\n        if (granted) {\n            _roleMembers[role].add(account);\n        }\n        return granted;\n    }\n\n    /**\n     * @dev Overload {AccessControl-_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool revoked = super._revokeRole(role, account);\n        if (revoked) {\n            _roleMembers[role].remove(account);\n        }\n        return revoked;\n    }\n}\n\n// contracts/apps/AbstractICApp.sol\n\nabstract contract AbstractICApp is AbstractICAppEvents, IInterchainApp {\n    using TypeCasts for address;\n\n    error InterchainApp__AlreadyLatestClient(address client);\n    error InterchainApp__BalanceTooLow(uint256 actual, uint256 required);\n    error InterchainApp__ClientAlreadyAdded(address client);\n    error InterchainApp__InterchainClientZeroAddress();\n    error InterchainApp__NotInterchainClient(address account);\n    error InterchainApp__ReceiverNotSet(uint64 chainId);\n    error InterchainApp__SameChainId(uint64 chainId);\n    error InterchainApp__SenderNotAllowed(uint64 srcChainId, bytes32 sender);\n\n    /// @inheritdoc IInterchainApp\n    function appReceive(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        if (!_isInterchainClient(msg.sender)) {\n            revert InterchainApp__NotInterchainClient(msg.sender);\n        }\n        if (srcChainId == block.chainid) {\n            revert InterchainApp__SameChainId(srcChainId);\n        }\n        if (!_isAllowedSender(srcChainId, sender)) {\n            revert InterchainApp__SenderNotAllowed(srcChainId, sender);\n        }\n        _receiveMessage(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n\n    /// @inheritdoc IInterchainApp\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules) {\n        appConfig = _getAppConfig();\n        modules = _getModules();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Performs necessary checks and adds an Interchain Client.\n    /// Optionally sets the latest client to this one.\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _addClient(address client, bool updateLatest) internal {\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (_isInterchainClient(client)) {\n            revert InterchainApp__ClientAlreadyAdded(client);\n        }\n        _toggleClientState(client, true);\n        emit InterchainClientAdded(client);\n        if (updateLatest) {\n            _setLatestClient(client);\n        }\n    }\n\n    /// @dev Performs necessary checks and removes an Interchain Client. If this client is the latest one,\n    /// the latest client is set to zero address (effectively pausing the app ability to send messages).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _removeClient(address client) internal {\n        if (!_isInterchainClient(client)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        _toggleClientState(client, false);\n        emit InterchainClientRemoved(client);\n        if (client == _getLatestClient()) {\n            _setLatestClient(address(0));\n        }\n    }\n\n    /// @dev Sets the latest Interchain Client to one of the allowed clients. Setting the client to zero address\n    /// is allowed and effectively pauses the app ability to send messages (but still allows to receive them).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _setLatestClient(address client) internal {\n        // New latest client must be an allowed client or zero address.\n        if (!_isInterchainClient(client) \u0026\u0026 client != address(0)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        if (client == _getLatestClient()) {\n            revert InterchainApp__AlreadyLatestClient(client);\n        }\n        _storeLatestClient(client);\n        emit LatestClientSet(client);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal virtual;\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal virtual;\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to accept EVM address as a parameter.\n    function _sendInterchainMessageEVM(\n        uint64 dstChainId,\n        address receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _sendInterchainMessage(dstChainId, receiver.addressToBytes32(), messageFee, options, message);\n    }\n\n    /// @dev Performs necessary checks and sends an interchain message.\n    function _sendInterchainMessage(\n        uint64 dstChainId,\n        bytes32 receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (dstChainId == block.chainid) {\n            revert InterchainApp__SameChainId(dstChainId);\n        }\n        if (receiver == 0) {\n            revert InterchainApp__ReceiverNotSet(dstChainId);\n        }\n        if (address(this).balance \u003c messageFee) {\n            revert InterchainApp__BalanceTooLow({actual: address(this).balance, required: messageFee});\n        }\n        return IInterchainClientV1(client).interchainSend{value: messageFee}(\n            dstChainId, receiver, _getExecutionService(), _getModules(), options, message\n        );\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        virtual;\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee for sending an Interchain message.\n    function _getInterchainFee(\n        uint64 dstChainId,\n        bytes memory options,\n        uint256 messageLen\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        return IInterchainClientV1(client).getInterchainFee(\n            dstChainId, _getExecutionService(), _getModules(), options, messageLen\n        );\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view virtual returns (bytes memory);\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view virtual returns (address);\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view virtual returns (address);\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view virtual returns (address[] memory);\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint64 srcChainId, bytes32 sender) internal view virtual returns (bool);\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view virtual returns (bool);\n}\n\n// contracts/apps/ICAppV1.sol\n\nabstract contract ICAppV1 is AbstractICApp, AccessControlEnumerable, InterchainAppV1Events, IInterchainAppV1 {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Role to manage the Interchain setup of the app.\n    bytes32 public constant IC_GOVERNOR_ROLE = keccak256(\"IC_GOVERNOR_ROLE\");\n\n    /// @dev Address of the latest Interchain Client, used for sending messages.\n    address private _latestClient;\n\n    /// @dev Required responses and optimistic period for the module responses.\n    AppConfigV1 private _appConfigV1;\n    /// @dev Address of the linked app deployed on the remote chain.\n    mapping(uint64 chainId =\u003e bytes32 remoteApp) private _linkedApp;\n    /// @dev Interchain Clients allowed to send messages to this app.\n    EnumerableSet.AddressSet private _interchainClients;\n    /// @dev Trusted Interchain modules.\n    EnumerableSet.AddressSet private _trustedModules;\n    /// @dev Execution Service to use for sending messages.\n    address private _executionService;\n\n    constructor(address admin) {\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addInterchainClient(address client, bool updateLatest) external onlyRole(IC_GOVERNOR_ROLE) {\n        _addClient(client, updateLatest);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _removeClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setLatestInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _setLatestClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteApp(uint64 chainId, bytes32 remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteAppEVM(uint64 chainId, address remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp.addressToBytes32());\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (module == address(0)) {\n            revert InterchainApp__ModuleZeroAddress();\n        }\n        bool added = _trustedModules.add(module);\n        if (!added) {\n            revert InterchainApp__ModuleAlreadyAdded(module);\n        }\n        emit TrustedModuleAdded(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        bool removed = _trustedModules.remove(module);\n        if (!removed) {\n            revert InterchainApp__ModuleNotAdded(module);\n        }\n        emit TrustedModuleRemoved(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setAppConfigV1(AppConfigV1 memory appConfig) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (appConfig.requiredResponses == 0 || appConfig.optimisticPeriod == 0) {\n            revert InterchainApp__InvalidAppConfig(appConfig.requiredResponses, appConfig.optimisticPeriod);\n        }\n        _appConfigV1 = appConfig;\n        emit AppConfigV1Set(appConfig.requiredResponses, appConfig.optimisticPeriod);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setExecutionService(address executionService) external onlyRole(IC_GOVERNOR_ROLE) {\n        _executionService = executionService;\n        emit ExecutionServiceSet(executionService);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainAppV1\n    function getAppConfigV1() external view returns (AppConfigV1 memory) {\n        return _appConfigV1;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getExecutionService() external view returns (address) {\n        return _executionService;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getInterchainClients() external view returns (address[] memory) {\n        return _interchainClients.values();\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLatestInterchainClient() external view returns (address) {\n        return _latestClient;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedApp(uint64 chainId) external view returns (bytes32) {\n        return _linkedApp[chainId];\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedAppEVM(uint64 chainId) external view returns (address linkedAppEVM) {\n        bytes32 linkedApp = _linkedApp[chainId];\n        linkedAppEVM = linkedApp.bytes32ToAddress();\n        if (linkedAppEVM.addressToBytes32() != linkedApp) {\n            revert InterchainApp__NotEVMLinkedApp(linkedApp);\n        }\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getModules() external view returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Links the remote app to the current app.\n    /// Will revert if the chainId is the same as the chainId of the local app.\n    /// Note: Should be guarded with permissions check.\n    function _linkRemoteApp(uint64 chainId, bytes32 remoteApp) internal {\n        if (chainId == block.chainid) {\n            revert InterchainApp__SameChainId(chainId);\n        }\n        if (remoteApp == 0) {\n            revert InterchainApp__AppZeroAddress();\n        }\n        _linkedApp[chainId] = remoteApp;\n        emit AppLinked(chainId, remoteApp);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal override {\n        _latestClient = client;\n    }\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal override {\n        if (allowed) {\n            _interchainClients.add(client);\n        } else {\n            _interchainClients.remove(client);\n        }\n    }\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to send the message to the linked app.\n    function _sendToLinkedApp(\n        uint64 dstChainId,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _sendInterchainMessage(dstChainId, _linkedApp[dstChainId], messageFee, encodedOptions, message);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee to send a message to the linked app on the remote chain.\n    function _getMessageFee(\n        uint64 dstChainId,\n        OptionsV1 memory options,\n        uint256 messageLen\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _getInterchainFee(dstChainId, encodedOptions, messageLen);\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view override returns (bytes memory) {\n        return _appConfigV1.encodeAppConfigV1();\n    }\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view override returns (address) {\n        return _executionService;\n    }\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view override returns (address) {\n        return _latestClient;\n    }\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view override returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint64 srcChainId, bytes32 sender) internal view override returns (bool) {\n        return _linkedApp[srcChainId] == sender;\n    }\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view override returns (bool) {\n        return _interchainClients.contains(caller);\n    }\n}\n\n// contracts/apps/examples/ExampleAppV1.sol\n\ncontract ExampleAppV1 is ICAppV1 {\n    event MessageReceived(uint64 srcChainId, bytes32 sender, uint64 dbNonce, uint64 entryIndex, bytes message);\n    event MessageSent(uint64 dstChainId, uint64 dbNonce, uint64 entryIndex, bytes32 transactionId);\n\n    constructor(address admin) ICAppV1(admin) {\n        _grantRole(IC_GOVERNOR_ROLE, admin);\n    }\n\n    /// @notice Allows the Admin to withdraw the native asset from the contract.\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        Address.sendValue(payable(msg.sender), address(this).balance);\n    }\n\n    /// @notice Sends a basic message to the destination chain.\n    function sendMessage(\n        uint64 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        InterchainTxDescriptor memory desc = _sendToLinkedApp({\n            dstChainId: dstChainId,\n            messageFee: msg.value,\n            options: OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}),\n            message: message\n        });\n        emit MessageSent(dstChainId, desc.dbNonce, desc.entryIndex, desc.transactionId);\n    }\n\n    /// @notice Returns the fee required to send a message using `sendMessage`.\n    function getMessageFee(\n        uint64 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes memory message\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _getMessageFee(dstChainId, OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}), message.length);\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        override\n    {\n        emit MessageReceived(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[],"name":"AccessControlBadConfirmation","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"bytes32","name":"neededRole","type":"bytes32"}],"name":"AccessControlUnauthorizedAccount","type":"error"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"bytes32","name":"previousAdminRole","type":"bytes32"},{"indexed":true,"internalType":"bytes32","name":"newAdminRole","type":"bytes32"}],"name":"RoleAdminChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":true,"internalType":"address","name":"sender","type":"address"}],"name":"RoleGranted","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":true,"internalType":"address","name":"sender","type":"address"}],"name":"RoleRevoked","type":"event"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"}],"name":"getRoleAdmin","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"uint256","name":"index","type":"uint256"}],"name":"getRoleMember","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"}],"name":"getRoleMemberCount","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"grantRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"hasRole","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"callerConfirmation","type":"address"}],"name":"renounceRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"revokeRole","outputs":[],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"details":"External interface of AccessControlEnumerable declared to support ERC165 detection.","errors":{"AccessControlBadConfirmation()":[{"details":"The caller of a function is not the expected one. NOTE: Don't confuse with {AccessControlUnauthorizedAccount}."}],"AccessControlUnauthorizedAccount(address,bytes32)":[{"details":"The `account` is missing a role."}]},"events":{"RoleAdminChanged(bytes32,bytes32,bytes32)":{"details":"Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole` `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite {RoleAdminChanged} not being emitted signaling this."},"RoleGranted(bytes32,address,address)":{"details":"Emitted when `account` is granted `role`. `sender` is the account that originated the contract call, an admin role bearer except when using {AccessControl-_setupRole}."},"RoleRevoked(bytes32,address,address)":{"details":"Emitted when `account` is revoked `role`. `sender` is the account that originated the contract call:   - if using `revokeRole`, it is the admin role bearer   - if using `renounceRole`, it is the role bearer (i.e. `account`)"}},"kind":"dev","methods":{"getRoleAdmin(bytes32)":{"details":"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {AccessControl-_setRoleAdmin}."},"getRoleMember(bytes32,uint256)":{"details":"Returns one of the accounts that have `role`. `index` must be a value between 0 and {getRoleMemberCount}, non-inclusive. Role bearers are not sorted in any particular way, and their ordering may change at any point. WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure you perform all queries on the same block. See the following https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post] for more information."},"getRoleMemberCount(bytes32)":{"details":"Returns the number of accounts that have `role`. Can be used together with {getRoleMember} to enumerate all bearers of a role."},"grantRole(bytes32,address)":{"details":"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role."},"hasRole(bytes32,address)":{"details":"Returns `true` if `account` has been granted `role`."},"renounceRole(bytes32,address)":{"details":"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `callerConfirmation`."},"revokeRole(bytes32,address)":{"details":"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role."}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"AccessControlBadConfirmation\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"neededRole\",\"type\":\"bytes32\"}],\"name\":\"AccessControlUnauthorizedAccount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getRoleMember\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleMemberCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"callerConfirmation\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"External interface of AccessControlEnumerable declared to support ERC165 detection.\",\"errors\":{\"AccessControlBadConfirmation()\":[{\"details\":\"The caller of a function is not the expected one. NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\"}],\"AccessControlUnauthorizedAccount(address,bytes32)\":[{\"details\":\"The `account` is missing a role.\"}]},\"events\":{\"RoleAdminChanged(bytes32,bytes32,bytes32)\":{\"details\":\"Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole` `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite {RoleAdminChanged} not being emitted signaling this.\"},\"RoleGranted(bytes32,address,address)\":{\"details\":\"Emitted when `account` is granted `role`. `sender` is the account that originated the contract call, an admin role bearer except when using {AccessControl-_setupRole}.\"},\"RoleRevoked(bytes32,address,address)\":{\"details\":\"Emitted when `account` is revoked `role`. `sender` is the account that originated the contract call:   - if using `revokeRole`, it is the admin role bearer   - if using `renounceRole`, it is the role bearer (i.e. `account`)\"}},\"kind\":\"dev\",\"methods\":{\"getRoleAdmin(bytes32)\":{\"details\":\"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {AccessControl-_setRoleAdmin}.\"},\"getRoleMember(bytes32,uint256)\":{\"details\":\"Returns one of the accounts that have `role`. `index` must be a value between 0 and {getRoleMemberCount}, non-inclusive. Role bearers are not sorted in any particular way, and their ordering may change at any point. WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure you perform all queries on the same block. See the following https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post] for more information.\"},\"getRoleMemberCount(bytes32)\":{\"details\":\"Returns the number of accounts that have `role`. Can be used together with {getRoleMember} to enumerate all bearers of a role.\"},\"grantRole(bytes32,address)\":{\"details\":\"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.\"},\"hasRole(bytes32,address)\":{\"details\":\"Returns `true` if `account` has been granted `role`.\"},\"renounceRole(bytes32,address)\":{\"details\":\"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `callerConfirmation`.\"},\"revokeRole(bytes32,address)\":{\"details\":\"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/ExampleAppV1.sol\":\"IAccessControlEnumerable\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/ExampleAppV1.sol\":{\"keccak256\":\"0xb1e9550aef785a0afc4e03fc843839919987ba4f906f09992c6788979c3c0396\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://0ede697223dfa3a2e23501efc1ed5926d5ff6458ee7b9ba833e0587162166c79\",\"dweb:/ipfs/QmUzgopL2ptWG5DYNdGAcoErPnBC4KCoRp8C61dkHHRaA6\"]}},\"version\":1}"},"hashes":{"getRoleAdmin(bytes32)":"248a9ca3","getRoleMember(bytes32,uint256)":"9010d07c","getRoleMemberCount(bytes32)":"ca15c873","grantRole(bytes32,address)":"2f2ff15d","hasRole(bytes32,address)":"91d14854","renounceRole(bytes32,address)":"36568abe","revokeRole(bytes32,address)":"d547741f"}},"solidity/ExampleAppV1.sol:ICAppV1":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/AbstractICAppEvents.sol\n\nabstract contract AbstractICAppEvents {\n    event InterchainClientAdded(address client);\n    event InterchainClientRemoved(address client);\n    event LatestClientSet(address client);\n}\n\n// contracts/events/InterchainAppV1Events.sol\n\nabstract contract InterchainAppV1Events {\n    event AppConfigV1Set(uint256 requiredResponses, uint256 optimisticPeriod);\n    event AppLinked(uint256 indexed chainId, bytes32 indexed remoteApp);\n    event ExecutionServiceSet(address executionService);\n    event TrustedModuleAdded(address module);\n    event TrustedModuleRemoved(address module);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    /// @notice Allows the Interchain Client to pass the message to the Interchain App.\n    /// @dev App is responsible for keeping track of interchain clients, and must verify the message sender.\n    /// @param srcChainId   Chain ID of the source chain, where the message was sent from.\n    /// @param sender       Sender address on the source chain, as a bytes32 value.\n    /// @param dbNonce      The Interchain DB nonce of the batch containing the message entry.\n    /// @param entryIndex   The index of the message entry within the batch.\n    /// @param message      The message being sent.\n    function appReceive(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /// @notice Returns the verification configuration of the Interchain App.\n    /// @dev This configuration is used by the Interchain Client to verify that message has been confirmed\n    /// by the Interchain Modules on the destination chain.\n    /// Note: V1 version of AppConfig includes the required responses count, and optimistic period after which\n    /// the message is considered confirmed by the module. Following versions may include additional fields.\n    /// @return appConfig    The versioned configuration of the Interchain App, encoded as bytes.\n    /// @return modules      The list of Interchain Modules that app is trusting to confirm the messages.\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/Math.sol\n\nlibrary MathLib {\n    /// @notice Rounds up to the nearest multiple of 32.\n    /// Note: Returns zero on overflows instead of reverting. This is fine for practical\n    /// use cases, as this is used for determining the size of the payload in memory.\n    function roundUpToWord(uint256 x) internal pure returns (uint256) {\n        unchecked {\n            return (x + 31) \u0026 ~uint256(31);\n        }\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/VersionedPayload.sol\n\n// solhint-disable no-inline-assembly\n// solhint-disable ordering\nlibrary VersionedPayloadLib {\n    /// @notice Amount of bytes reserved for the version (uint16) in the versioned payload\n    uint256 internal constant VERSION_LENGTH = 2;\n\n    error VersionedPayload__TooShort(bytes versionedPayload);\n    error VersionedPayload__PrecompileFailed();\n\n    /// @notice Encodes the versioned payload into a single bytes array.\n    /// @param version  The payload's version.\n    /// @param payload  The payload to encode.\n    function encodeVersionedPayload(uint16 version, bytes memory payload) internal pure returns (bytes memory) {\n        return abi.encodePacked(version, payload);\n    }\n\n    /// @notice Extracts the version from the versioned payload (calldata reference).\n    /// @param versionedPayload     The versioned payload (calldata reference).\n    function getVersion(bytes calldata versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            version := shr(240, calldataload(versionedPayload.offset))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (calldata reference).\n    /// @dev The extracted payload is also returned as a calldata reference.\n    /// @param versionedPayload     The versioned payload.\n    function getPayload(bytes calldata versionedPayload) internal pure returns (bytes calldata) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        return versionedPayload[VERSION_LENGTH:];\n    }\n\n    /// @notice Extracts the version from the versioned payload (memory reference).\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getVersionFromMemory(bytes memory versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            // We add 0x20 to skip the length of the bytes array.\n            version := shr(240, mload(add(versionedPayload, 0x20)))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (memory reference).\n    /// @dev The extracted payload is copied into a new memory location. Use `getPayload` when possible\n    /// to avoid extra memory allocation.\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getPayloadFromMemory(bytes memory versionedPayload) internal view returns (bytes memory payload) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        // Figure how many bytes to copy and allocate the memory for the extracted payload.\n        uint256 toCopy;\n        unchecked {\n            toCopy = versionedPayload.length - VERSION_LENGTH;\n        }\n        payload = new bytes(toCopy);\n        // Use identity precompile (0x04) to copy the payload. Unlike MCOPY, this is available on all EVM chains.\n        bool res;\n        assembly {\n            // We add 0x20 to skip the length of the bytes array.\n            // We add 0x02 to skip the 2 bytes reserved for the version.\n            // Copy the payload to the previously allocated memory.\n            res := staticcall(gas(), 0x04, add(versionedPayload, 0x22), toCopy, add(payload, 0x20), toCopy)\n        }\n        if (!res) {\n            revert VersionedPayload__PrecompileFailed();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/IAccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n\n// node_modules/@openzeppelin/contracts/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance \u003c amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance \u003c value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 \u0026\u0026 target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SafeCast.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value \u003e type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value \u003e type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value \u003e type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value \u003e type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value \u003e type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value \u003e type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value \u003e type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value \u003e type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value \u003e type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value \u003e type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value \u003e type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value \u003e type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value \u003e type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value \u003e type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value \u003e type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value \u003e type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value \u003e type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value \u003e type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value \u003e type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value \u003e type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value \u003e type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value \u003e type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value \u003e type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value \u003e type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value \u003e type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value \u003e type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value \u003e type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value \u003e type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value \u003e type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value \u003e type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value \u003e type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value \u003c 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value \u003e uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal view returns (AppConfigV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (AppConfigV1));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal view returns (OptionsV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (OptionsV1));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(OPTIONS_V1, abi.encode(options));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/IAccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/IAccessControlEnumerable.sol)\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n// contracts/interfaces/IInterchainAppV1.sol\n\ninterface IInterchainAppV1 is IInterchainApp {\n    error InterchainApp__AppZeroAddress();\n    error InterchainApp__InvalidAppConfig(uint256 requiredResponses, uint256 optimisticPeriod);\n    error InterchainApp__ModuleAlreadyAdded(address module);\n    error InterchainApp__ModuleNotAdded(address module);\n    error InterchainApp__ModuleZeroAddress();\n    error InterchainApp__NotEVMLinkedApp(bytes32 linkedApp);\n\n    /// @notice Allows the owner to add the interchain client to the allowed clients set,\n    /// and optionally set the latest client to this one.\n    /// Note: only the allowed clients can send messages to this app.\n    /// Note: the latest client is used for sending messages from this app.\n    /// @param client       The address of the interchain client to add.\n    /// @param updateLatest Whether to set the latest client to this one.\n    function addInterchainClient(address client, bool updateLatest) external;\n\n    /// @notice Allows the owner to remove the interchain client from the allowed clients set.\n    /// If the client is the latest client, the latest client is set to the zero address.\n    /// @param client       The address of the interchain client to remove.\n    function removeInterchainClient(address client) external;\n\n    /// @notice Allows the owner to set the address of the latest interchain client.\n    /// @dev The new latest client must be an allowed client or zero address.\n    /// Setting the client to zero address effectively pauses the app ability to send messages,\n    /// while allowing to receive them.\n    /// @param client       The address of the latest interchain client.\n    function setLatestInterchainClient(address client) external;\n\n    /// @notice Allows the owner to link the remote app for the given chain ID.\n    /// - This address will be used as the receiver for the messages sent from this chain.\n    /// - This address will be the only trusted sender for the messages sent to this chain.\n    /// @param chainId      The remote chain ID.\n    /// @param remoteApp    The address of the remote app to link.\n    function linkRemoteApp(uint64 chainId, bytes32 remoteApp) external;\n\n    /// @notice Thin wrapper for `linkRemoteApp` to accept EVM address as a parameter.\n    function linkRemoteAppEVM(uint64 chainId, address remoteApp) external;\n\n    /// @notice Allows the owner to add the module to the trusted modules set.\n    /// - This set of modules will be used to verify both sent and received messages.\n    function addTrustedModule(address module) external;\n\n    /// @notice Allows the owner to remove the module from the trusted modules set.\n    function removeTrustedModule(address module) external;\n\n    /// @notice Allows the owner to set the app config for the current app. App config includes:\n    /// - requiredResponses: the number of module responses required for accepting the message\n    /// - optimisticPeriod: the minimum time after which the module responses are considered final\n    function setAppConfigV1(AppConfigV1 memory appConfig) external;\n\n    /// @notice Allows the owner to set the address of the Execution Service.\n    /// This address will be used to request execution of the messages sent from this chain,\n    /// by supplying the Service's execution fee.\n    function setExecutionService(address executionService) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Returns the app config for the current app: requiredResponses and optimisticPeriod.\n    function getAppConfigV1() external view returns (AppConfigV1 memory);\n\n    /// @notice Returns the address of the Execution Service used by this app for sending messages.\n    function getExecutionService() external view returns (address);\n\n    /// @notice Returns the list of Interchain Clients allowed to send messages to this app.\n    function getInterchainClients() external view returns (address[] memory);\n\n    /// @notice Returns the address of the latest interchain client.\n    /// This address is used for sending messages from this app.\n    function getLatestInterchainClient() external view returns (address);\n\n    /// @notice Returns the linked app address (as bytes32) for the given chain ID.\n    function getLinkedApp(uint64 chainId) external view returns (bytes32);\n\n    /// @notice Thin wrapper for `getLinkedApp` to return the linked app address as EVM address.\n    /// @dev Will revert if the linked app address is not an EVM address.\n    function getLinkedAppEVM(uint64 chainId) external view returns (address);\n\n    /// @notice Returns the list of Interchain Modules trusted by this app.\n    /// This set of modules will be used to verify both sent and received messages.\n    function getModules() external view returns (address[] memory);\n}\n\n// contracts/libs/InterchainTransaction.sol\n\ntype ICTxHeader is uint256;\n\nstruct InterchainTransaction {\n    uint64 srcChainId;\n    uint64 dstChainId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcSender;\n    bytes32 dstReceiver;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    using MathLib for uint256;\n    using VersionedPayloadLib for bytes;\n\n    function constructLocalTransaction(\n        address srcSender,\n        uint64 dstChainId,\n        bytes32 dstReceiver,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: SafeCast.toUint64(block.chainid),\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            encodeTxHeader(transaction.srcChainId, transaction.dstChainId, transaction.dbNonce, transaction.entryIndex),\n            transaction.srcSender,\n            transaction.dstReceiver,\n            transaction.options,\n            transaction.message\n        );\n    }\n\n    function decodeTransaction(bytes calldata transaction) internal pure returns (InterchainTransaction memory icTx) {\n        ICTxHeader header;\n        (header, icTx.srcSender, icTx.dstReceiver, icTx.options, icTx.message) =\n            abi.decode(transaction, (ICTxHeader, bytes32, bytes32, bytes, bytes));\n        (icTx.srcChainId, icTx.dstChainId, icTx.dbNonce, icTx.entryIndex) = decodeTxHeader(header);\n    }\n\n    function payloadSize(uint256 optionsLen, uint256 messageLen) internal pure returns (uint256) {\n        // 2 bytes are reserved for the transaction version\n        // + 5 fields * 32 bytes (3 values for static, 2 offsets for dynamic) + 2 * 32 bytes (lengths for dynamic) = 226\n        // (srcChainId, dstChainId, dbNonce, entryIndex) are merged into a single 32 bytes field\n        // Both options and message are dynamic fields, which are padded up to 32 bytes\n        return 226 + optionsLen.roundUpToWord() + messageLen.roundUpToWord();\n    }\n\n    function encodeTxHeader(\n        uint64 srcChainId,\n        uint64 dstChainId,\n        uint64 dbNonce,\n        uint64 entryIndex\n    )\n        internal\n        pure\n        returns (ICTxHeader)\n    {\n        return ICTxHeader.wrap(\n            (uint256(srcChainId) \u003c\u003c 192) | (uint256(dstChainId) \u003c\u003c 128) | (uint256(dbNonce) \u003c\u003c 64) | uint256(entryIndex)\n        );\n    }\n\n    function decodeTxHeader(ICTxHeader header)\n        internal\n        pure\n        returns (uint64 srcChainId, uint64 dstChainId, uint64 dbNonce, uint64 entryIndex)\n    {\n        srcChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 192);\n        dstChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 128);\n        dbNonce = uint64(ICTxHeader.unwrap(header) \u003e\u003e 64);\n        entryIndex = uint64(ICTxHeader.unwrap(header));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/AccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account =\u003e bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role =\u003e RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint64 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__InvalidTransactionVersion(uint16 version);\n    error InterchainClientV1__NoLinkedClient(uint64 chainId);\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint64 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint64 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint64 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint64 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param messageLen           The length of the message being sent.\n    function getInterchainFee(\n        uint64 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        uint256 messageLen\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint64 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint64 chainId) external view returns (address);\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/AccessControlEnumerable.sol)\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 role =\u003e EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {AccessControl-_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool granted = super._grantRole(role, account);\n        if (granted) {\n            _roleMembers[role].add(account);\n        }\n        return granted;\n    }\n\n    /**\n     * @dev Overload {AccessControl-_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool revoked = super._revokeRole(role, account);\n        if (revoked) {\n            _roleMembers[role].remove(account);\n        }\n        return revoked;\n    }\n}\n\n// contracts/apps/AbstractICApp.sol\n\nabstract contract AbstractICApp is AbstractICAppEvents, IInterchainApp {\n    using TypeCasts for address;\n\n    error InterchainApp__AlreadyLatestClient(address client);\n    error InterchainApp__BalanceTooLow(uint256 actual, uint256 required);\n    error InterchainApp__ClientAlreadyAdded(address client);\n    error InterchainApp__InterchainClientZeroAddress();\n    error InterchainApp__NotInterchainClient(address account);\n    error InterchainApp__ReceiverNotSet(uint64 chainId);\n    error InterchainApp__SameChainId(uint64 chainId);\n    error InterchainApp__SenderNotAllowed(uint64 srcChainId, bytes32 sender);\n\n    /// @inheritdoc IInterchainApp\n    function appReceive(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        if (!_isInterchainClient(msg.sender)) {\n            revert InterchainApp__NotInterchainClient(msg.sender);\n        }\n        if (srcChainId == block.chainid) {\n            revert InterchainApp__SameChainId(srcChainId);\n        }\n        if (!_isAllowedSender(srcChainId, sender)) {\n            revert InterchainApp__SenderNotAllowed(srcChainId, sender);\n        }\n        _receiveMessage(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n\n    /// @inheritdoc IInterchainApp\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules) {\n        appConfig = _getAppConfig();\n        modules = _getModules();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Performs necessary checks and adds an Interchain Client.\n    /// Optionally sets the latest client to this one.\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _addClient(address client, bool updateLatest) internal {\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (_isInterchainClient(client)) {\n            revert InterchainApp__ClientAlreadyAdded(client);\n        }\n        _toggleClientState(client, true);\n        emit InterchainClientAdded(client);\n        if (updateLatest) {\n            _setLatestClient(client);\n        }\n    }\n\n    /// @dev Performs necessary checks and removes an Interchain Client. If this client is the latest one,\n    /// the latest client is set to zero address (effectively pausing the app ability to send messages).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _removeClient(address client) internal {\n        if (!_isInterchainClient(client)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        _toggleClientState(client, false);\n        emit InterchainClientRemoved(client);\n        if (client == _getLatestClient()) {\n            _setLatestClient(address(0));\n        }\n    }\n\n    /// @dev Sets the latest Interchain Client to one of the allowed clients. Setting the client to zero address\n    /// is allowed and effectively pauses the app ability to send messages (but still allows to receive them).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _setLatestClient(address client) internal {\n        // New latest client must be an allowed client or zero address.\n        if (!_isInterchainClient(client) \u0026\u0026 client != address(0)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        if (client == _getLatestClient()) {\n            revert InterchainApp__AlreadyLatestClient(client);\n        }\n        _storeLatestClient(client);\n        emit LatestClientSet(client);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal virtual;\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal virtual;\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to accept EVM address as a parameter.\n    function _sendInterchainMessageEVM(\n        uint64 dstChainId,\n        address receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _sendInterchainMessage(dstChainId, receiver.addressToBytes32(), messageFee, options, message);\n    }\n\n    /// @dev Performs necessary checks and sends an interchain message.\n    function _sendInterchainMessage(\n        uint64 dstChainId,\n        bytes32 receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (dstChainId == block.chainid) {\n            revert InterchainApp__SameChainId(dstChainId);\n        }\n        if (receiver == 0) {\n            revert InterchainApp__ReceiverNotSet(dstChainId);\n        }\n        if (address(this).balance \u003c messageFee) {\n            revert InterchainApp__BalanceTooLow({actual: address(this).balance, required: messageFee});\n        }\n        return IInterchainClientV1(client).interchainSend{value: messageFee}(\n            dstChainId, receiver, _getExecutionService(), _getModules(), options, message\n        );\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        virtual;\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee for sending an Interchain message.\n    function _getInterchainFee(\n        uint64 dstChainId,\n        bytes memory options,\n        uint256 messageLen\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        return IInterchainClientV1(client).getInterchainFee(\n            dstChainId, _getExecutionService(), _getModules(), options, messageLen\n        );\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view virtual returns (bytes memory);\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view virtual returns (address);\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view virtual returns (address);\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view virtual returns (address[] memory);\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint64 srcChainId, bytes32 sender) internal view virtual returns (bool);\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view virtual returns (bool);\n}\n\n// contracts/apps/ICAppV1.sol\n\nabstract contract ICAppV1 is AbstractICApp, AccessControlEnumerable, InterchainAppV1Events, IInterchainAppV1 {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Role to manage the Interchain setup of the app.\n    bytes32 public constant IC_GOVERNOR_ROLE = keccak256(\"IC_GOVERNOR_ROLE\");\n\n    /// @dev Address of the latest Interchain Client, used for sending messages.\n    address private _latestClient;\n\n    /// @dev Required responses and optimistic period for the module responses.\n    AppConfigV1 private _appConfigV1;\n    /// @dev Address of the linked app deployed on the remote chain.\n    mapping(uint64 chainId =\u003e bytes32 remoteApp) private _linkedApp;\n    /// @dev Interchain Clients allowed to send messages to this app.\n    EnumerableSet.AddressSet private _interchainClients;\n    /// @dev Trusted Interchain modules.\n    EnumerableSet.AddressSet private _trustedModules;\n    /// @dev Execution Service to use for sending messages.\n    address private _executionService;\n\n    constructor(address admin) {\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addInterchainClient(address client, bool updateLatest) external onlyRole(IC_GOVERNOR_ROLE) {\n        _addClient(client, updateLatest);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _removeClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setLatestInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _setLatestClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteApp(uint64 chainId, bytes32 remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteAppEVM(uint64 chainId, address remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp.addressToBytes32());\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (module == address(0)) {\n            revert InterchainApp__ModuleZeroAddress();\n        }\n        bool added = _trustedModules.add(module);\n        if (!added) {\n            revert InterchainApp__ModuleAlreadyAdded(module);\n        }\n        emit TrustedModuleAdded(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        bool removed = _trustedModules.remove(module);\n        if (!removed) {\n            revert InterchainApp__ModuleNotAdded(module);\n        }\n        emit TrustedModuleRemoved(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setAppConfigV1(AppConfigV1 memory appConfig) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (appConfig.requiredResponses == 0 || appConfig.optimisticPeriod == 0) {\n            revert InterchainApp__InvalidAppConfig(appConfig.requiredResponses, appConfig.optimisticPeriod);\n        }\n        _appConfigV1 = appConfig;\n        emit AppConfigV1Set(appConfig.requiredResponses, appConfig.optimisticPeriod);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setExecutionService(address executionService) external onlyRole(IC_GOVERNOR_ROLE) {\n        _executionService = executionService;\n        emit ExecutionServiceSet(executionService);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainAppV1\n    function getAppConfigV1() external view returns (AppConfigV1 memory) {\n        return _appConfigV1;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getExecutionService() external view returns (address) {\n        return _executionService;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getInterchainClients() external view returns (address[] memory) {\n        return _interchainClients.values();\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLatestInterchainClient() external view returns (address) {\n        return _latestClient;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedApp(uint64 chainId) external view returns (bytes32) {\n        return _linkedApp[chainId];\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedAppEVM(uint64 chainId) external view returns (address linkedAppEVM) {\n        bytes32 linkedApp = _linkedApp[chainId];\n        linkedAppEVM = linkedApp.bytes32ToAddress();\n        if (linkedAppEVM.addressToBytes32() != linkedApp) {\n            revert InterchainApp__NotEVMLinkedApp(linkedApp);\n        }\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getModules() external view returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Links the remote app to the current app.\n    /// Will revert if the chainId is the same as the chainId of the local app.\n    /// Note: Should be guarded with permissions check.\n    function _linkRemoteApp(uint64 chainId, bytes32 remoteApp) internal {\n        if (chainId == block.chainid) {\n            revert InterchainApp__SameChainId(chainId);\n        }\n        if (remoteApp == 0) {\n            revert InterchainApp__AppZeroAddress();\n        }\n        _linkedApp[chainId] = remoteApp;\n        emit AppLinked(chainId, remoteApp);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal override {\n        _latestClient = client;\n    }\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal override {\n        if (allowed) {\n            _interchainClients.add(client);\n        } else {\n            _interchainClients.remove(client);\n        }\n    }\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to send the message to the linked app.\n    function _sendToLinkedApp(\n        uint64 dstChainId,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _sendInterchainMessage(dstChainId, _linkedApp[dstChainId], messageFee, encodedOptions, message);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee to send a message to the linked app on the remote chain.\n    function _getMessageFee(\n        uint64 dstChainId,\n        OptionsV1 memory options,\n        uint256 messageLen\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _getInterchainFee(dstChainId, encodedOptions, messageLen);\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view override returns (bytes memory) {\n        return _appConfigV1.encodeAppConfigV1();\n    }\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view override returns (address) {\n        return _executionService;\n    }\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view override returns (address) {\n        return _latestClient;\n    }\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view override returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint64 srcChainId, bytes32 sender) internal view override returns (bool) {\n        return _linkedApp[srcChainId] == sender;\n    }\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view override returns (bool) {\n        return _interchainClients.contains(caller);\n    }\n}\n\n// contracts/apps/examples/ExampleAppV1.sol\n\ncontract ExampleAppV1 is ICAppV1 {\n    event MessageReceived(uint64 srcChainId, bytes32 sender, uint64 dbNonce, uint64 entryIndex, bytes message);\n    event MessageSent(uint64 dstChainId, uint64 dbNonce, uint64 entryIndex, bytes32 transactionId);\n\n    constructor(address admin) ICAppV1(admin) {\n        _grantRole(IC_GOVERNOR_ROLE, admin);\n    }\n\n    /// @notice Allows the Admin to withdraw the native asset from the contract.\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        Address.sendValue(payable(msg.sender), address(this).balance);\n    }\n\n    /// @notice Sends a basic message to the destination chain.\n    function sendMessage(\n        uint64 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        InterchainTxDescriptor memory desc = _sendToLinkedApp({\n            dstChainId: dstChainId,\n            messageFee: msg.value,\n            options: OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}),\n            message: message\n        });\n        emit MessageSent(dstChainId, desc.dbNonce, desc.entryIndex, desc.transactionId);\n    }\n\n    /// @notice Returns the fee required to send a message using `sendMessage`.\n    function getMessageFee(\n        uint64 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes memory message\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _getMessageFee(dstChainId, OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}), message.length);\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        override\n    {\n        emit MessageReceived(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[],"name":"AccessControlBadConfirmation","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"bytes32","name":"neededRole","type":"bytes32"}],"name":"AccessControlUnauthorizedAccount","type":"error"},{"inputs":[{"internalType":"address","name":"client","type":"address"}],"name":"InterchainApp__AlreadyLatestClient","type":"error"},{"inputs":[],"name":"InterchainApp__AppZeroAddress","type":"error"},{"inputs":[{"internalType":"uint256","name":"actual","type":"uint256"},{"internalType":"uint256","name":"required","type":"uint256"}],"name":"InterchainApp__BalanceTooLow","type":"error"},{"inputs":[{"internalType":"address","name":"client","type":"address"}],"name":"InterchainApp__ClientAlreadyAdded","type":"error"},{"inputs":[],"name":"InterchainApp__InterchainClientZeroAddress","type":"error"},{"inputs":[{"internalType":"uint256","name":"requiredResponses","type":"uint256"},{"internalType":"uint256","name":"optimisticPeriod","type":"uint256"}],"name":"InterchainApp__InvalidAppConfig","type":"error"},{"inputs":[{"internalType":"address","name":"module","type":"address"}],"name":"InterchainApp__ModuleAlreadyAdded","type":"error"},{"inputs":[{"internalType":"address","name":"module","type":"address"}],"name":"InterchainApp__ModuleNotAdded","type":"error"},{"inputs":[],"name":"InterchainApp__ModuleZeroAddress","type":"error"},{"inputs":[{"internalType":"bytes32","name":"linkedApp","type":"bytes32"}],"name":"InterchainApp__NotEVMLinkedApp","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"InterchainApp__NotInterchainClient","type":"error"},{"inputs":[{"internalType":"uint64","name":"chainId","type":"uint64"}],"name":"InterchainApp__ReceiverNotSet","type":"error"},{"inputs":[{"internalType":"uint64","name":"chainId","type":"uint64"}],"name":"InterchainApp__SameChainId","type":"error"},{"inputs":[{"internalType":"uint64","name":"srcChainId","type":"uint64"},{"internalType":"bytes32","name":"sender","type":"bytes32"}],"name":"InterchainApp__SenderNotAllowed","type":"error"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"requiredResponses","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"optimisticPeriod","type":"uint256"}],"name":"AppConfigV1Set","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"chainId","type":"uint256"},{"indexed":true,"internalType":"bytes32","name":"remoteApp","type":"bytes32"}],"name":"AppLinked","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"executionService","type":"address"}],"name":"ExecutionServiceSet","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"client","type":"address"}],"name":"InterchainClientAdded","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"client","type":"address"}],"name":"InterchainClientRemoved","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"client","type":"address"}],"name":"LatestClientSet","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"bytes32","name":"previousAdminRole","type":"bytes32"},{"indexed":true,"internalType":"bytes32","name":"newAdminRole","type":"bytes32"}],"name":"RoleAdminChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":true,"internalType":"address","name":"sender","type":"address"}],"name":"RoleGranted","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":true,"internalType":"address","name":"sender","type":"address"}],"name":"RoleRevoked","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"module","type":"address"}],"name":"TrustedModuleAdded","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"module","type":"address"}],"name":"TrustedModuleRemoved","type":"event"},{"inputs":[],"name":"DEFAULT_ADMIN_ROLE","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"IC_GOVERNOR_ROLE","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"client","type":"address"},{"internalType":"bool","name":"updateLatest","type":"bool"}],"name":"addInterchainClient","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"module","type":"address"}],"name":"addTrustedModule","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint64","name":"srcChainId","type":"uint64"},{"internalType":"bytes32","name":"sender","type":"bytes32"},{"internalType":"uint64","name":"dbNonce","type":"uint64"},{"internalType":"uint64","name":"entryIndex","type":"uint64"},{"internalType":"bytes","name":"message","type":"bytes"}],"name":"appReceive","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"getAppConfigV1","outputs":[{"components":[{"internalType":"uint256","name":"requiredResponses","type":"uint256"},{"internalType":"uint256","name":"optimisticPeriod","type":"uint256"}],"internalType":"struct AppConfigV1","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getExecutionService","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getInterchainClients","outputs":[{"internalType":"address[]","name":"","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getLatestInterchainClient","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint64","name":"chainId","type":"uint64"}],"name":"getLinkedApp","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint64","name":"chainId","type":"uint64"}],"name":"getLinkedAppEVM","outputs":[{"internalType":"address","name":"linkedAppEVM","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getModules","outputs":[{"internalType":"address[]","name":"","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getReceivingConfig","outputs":[{"internalType":"bytes","name":"appConfig","type":"bytes"},{"internalType":"address[]","name":"modules","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"}],"name":"getRoleAdmin","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"uint256","name":"index","type":"uint256"}],"name":"getRoleMember","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"}],"name":"getRoleMemberCount","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"grantRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"hasRole","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint64","name":"chainId","type":"uint64"},{"internalType":"bytes32","name":"remoteApp","type":"bytes32"}],"name":"linkRemoteApp","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint64","name":"chainId","type":"uint64"},{"internalType":"address","name":"remoteApp","type":"address"}],"name":"linkRemoteAppEVM","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"client","type":"address"}],"name":"removeInterchainClient","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"module","type":"address"}],"name":"removeTrustedModule","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"callerConfirmation","type":"address"}],"name":"renounceRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"revokeRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"components":[{"internalType":"uint256","name":"requiredResponses","type":"uint256"},{"internalType":"uint256","name":"optimisticPeriod","type":"uint256"}],"internalType":"struct AppConfigV1","name":"appConfig","type":"tuple"}],"name":"setAppConfigV1","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"executionService","type":"address"}],"name":"setExecutionService","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"client","type":"address"}],"name":"setLatestInterchainClient","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes4","name":"interfaceId","type":"bytes4"}],"name":"supportsInterface","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"}],"userDoc":{"kind":"user","methods":{"IC_GOVERNOR_ROLE()":{"notice":"Role to manage the Interchain setup of the app."},"addInterchainClient(address,bool)":{"notice":"Allows the owner to add the interchain client to the allowed clients set, and optionally set the latest client to this one. Note: only the allowed clients can send messages to this app. Note: the latest client is used for sending messages from this app."},"addTrustedModule(address)":{"notice":"Allows the owner to add the module to the trusted modules set. - This set of modules will be used to verify both sent and received messages."},"appReceive(uint64,bytes32,uint64,uint64,bytes)":{"notice":"Allows the Interchain Client to pass the message to the Interchain App."},"getAppConfigV1()":{"notice":"Returns the app config for the current app: requiredResponses and optimisticPeriod."},"getExecutionService()":{"notice":"Returns the address of the Execution Service used by this app for sending messages."},"getInterchainClients()":{"notice":"Returns the list of Interchain Clients allowed to send messages to this app."},"getLatestInterchainClient()":{"notice":"Returns the address of the latest interchain client. This address is used for sending messages from this app."},"getLinkedApp(uint64)":{"notice":"Returns the linked app address (as bytes32) for the given chain ID."},"getLinkedAppEVM(uint64)":{"notice":"Thin wrapper for `getLinkedApp` to return the linked app address as EVM address."},"getModules()":{"notice":"Returns the list of Interchain Modules trusted by this app. This set of modules will be used to verify both sent and received messages."},"getReceivingConfig()":{"notice":"Returns the verification configuration of the Interchain App."},"linkRemoteApp(uint64,bytes32)":{"notice":"Allows the owner to link the remote app for the given chain ID. - This address will be used as the receiver for the messages sent from this chain. - This address will be the only trusted sender for the messages sent to this chain."},"linkRemoteAppEVM(uint64,address)":{"notice":"Thin wrapper for `linkRemoteApp` to accept EVM address as a parameter."},"removeInterchainClient(address)":{"notice":"Allows the owner to remove the interchain client from the allowed clients set. If the client is the latest client, the latest client is set to the zero address."},"removeTrustedModule(address)":{"notice":"Allows the owner to remove the module from the trusted modules set."},"setAppConfigV1((uint256,uint256))":{"notice":"Allows the owner to set the app config for the current app. App config includes: - requiredResponses: the number of module responses required for accepting the message - optimisticPeriod: the minimum time after which the module responses are considered final"},"setExecutionService(address)":{"notice":"Allows the owner to set the address of the Execution Service. This address will be used to request execution of the messages sent from this chain, by supplying the Service's execution fee."},"setLatestInterchainClient(address)":{"notice":"Allows the owner to set the address of the latest interchain client."}},"version":1},"developerDoc":{"errors":{"AccessControlBadConfirmation()":[{"details":"The caller of a function is not the expected one. NOTE: Don't confuse with {AccessControlUnauthorizedAccount}."}],"AccessControlUnauthorizedAccount(address,bytes32)":[{"details":"The `account` is missing a role."}]},"events":{"RoleAdminChanged(bytes32,bytes32,bytes32)":{"details":"Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole` `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite {RoleAdminChanged} not being emitted signaling this."},"RoleGranted(bytes32,address,address)":{"details":"Emitted when `account` is granted `role`. `sender` is the account that originated the contract call, an admin role bearer except when using {AccessControl-_setupRole}."},"RoleRevoked(bytes32,address,address)":{"details":"Emitted when `account` is revoked `role`. `sender` is the account that originated the contract call:   - if using `revokeRole`, it is the admin role bearer   - if using `renounceRole`, it is the role bearer (i.e. `account`)"}},"kind":"dev","methods":{"addInterchainClient(address,bool)":{"params":{"client":"The address of the interchain client to add.","updateLatest":"Whether to set the latest client to this one."}},"appReceive(uint64,bytes32,uint64,uint64,bytes)":{"details":"App is responsible for keeping track of interchain clients, and must verify the message sender.","params":{"dbNonce":"The Interchain DB nonce of the batch containing the message entry.","entryIndex":"The index of the message entry within the batch.","message":"The message being sent.","sender":"Sender address on the source chain, as a bytes32 value.","srcChainId":"Chain ID of the source chain, where the message was sent from."}},"getLinkedAppEVM(uint64)":{"details":"Will revert if the linked app address is not an EVM address."},"getReceivingConfig()":{"details":"This configuration is used by the Interchain Client to verify that message has been confirmed by the Interchain Modules on the destination chain. Note: V1 version of AppConfig includes the required responses count, and optimistic period after which the message is considered confirmed by the module. Following versions may include additional fields.","returns":{"appConfig":"   The versioned configuration of the Interchain App, encoded as bytes.","modules":"     The list of Interchain Modules that app is trusting to confirm the messages."}},"getRoleAdmin(bytes32)":{"details":"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"getRoleMember(bytes32,uint256)":{"details":"Returns one of the accounts that have `role`. `index` must be a value between 0 and {getRoleMemberCount}, non-inclusive. Role bearers are not sorted in any particular way, and their ordering may change at any point. WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure you perform all queries on the same block. See the following https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post] for more information."},"getRoleMemberCount(bytes32)":{"details":"Returns the number of accounts that have `role`. Can be used together with {getRoleMember} to enumerate all bearers of a role."},"grantRole(bytes32,address)":{"details":"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleGranted} event."},"hasRole(bytes32,address)":{"details":"Returns `true` if `account` has been granted `role`."},"linkRemoteApp(uint64,bytes32)":{"params":{"chainId":"The remote chain ID.","remoteApp":"The address of the remote app to link."}},"removeInterchainClient(address)":{"params":{"client":"The address of the interchain client to remove."}},"renounceRole(bytes32,address)":{"details":"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `callerConfirmation`. May emit a {RoleRevoked} event."},"revokeRole(bytes32,address)":{"details":"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleRevoked} event."},"setLatestInterchainClient(address)":{"details":"The new latest client must be an allowed client or zero address. Setting the client to zero address effectively pauses the app ability to send messages, while allowing to receive them.","params":{"client":"The address of the latest interchain client."}},"supportsInterface(bytes4)":{"details":"See {IERC165-supportsInterface}."}},"stateVariables":{"_appConfigV1":{"details":"Required responses and optimistic period for the module responses."},"_executionService":{"details":"Execution Service to use for sending messages."},"_interchainClients":{"details":"Interchain Clients allowed to send messages to this app."},"_latestClient":{"details":"Address of the latest Interchain Client, used for sending messages."},"_linkedApp":{"details":"Address of the linked app deployed on the remote chain."},"_trustedModules":{"details":"Trusted Interchain modules."}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"AccessControlBadConfirmation\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"neededRole\",\"type\":\"bytes32\"}],\"name\":\"AccessControlUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"}],\"name\":\"InterchainApp__AlreadyLatestClient\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InterchainApp__AppZeroAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"required\",\"type\":\"uint256\"}],\"name\":\"InterchainApp__BalanceTooLow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"}],\"name\":\"InterchainApp__ClientAlreadyAdded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InterchainApp__InterchainClientZeroAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requiredResponses\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"optimisticPeriod\",\"type\":\"uint256\"}],\"name\":\"InterchainApp__InvalidAppConfig\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"InterchainApp__ModuleAlreadyAdded\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"InterchainApp__ModuleNotAdded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InterchainApp__ModuleZeroAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"linkedApp\",\"type\":\"bytes32\"}],\"name\":\"InterchainApp__NotEVMLinkedApp\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"InterchainApp__NotInterchainClient\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"}],\"name\":\"InterchainApp__ReceiverNotSet\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"}],\"name\":\"InterchainApp__SameChainId\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"srcChainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"}],\"name\":\"InterchainApp__SenderNotAllowed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requiredResponses\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"optimisticPeriod\",\"type\":\"uint256\"}],\"name\":\"AppConfigV1Set\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"remoteApp\",\"type\":\"bytes32\"}],\"name\":\"AppLinked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"executionService\",\"type\":\"address\"}],\"name\":\"ExecutionServiceSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"}],\"name\":\"InterchainClientAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"}],\"name\":\"InterchainClientRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"}],\"name\":\"LatestClientSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"TrustedModuleAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"TrustedModuleRemoved\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"IC_GOVERNOR_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"updateLatest\",\"type\":\"bool\"}],\"name\":\"addInterchainClient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"addTrustedModule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"srcChainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"appReceive\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAppConfigV1\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"requiredResponses\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"optimisticPeriod\",\"type\":\"uint256\"}],\"internalType\":\"struct AppConfigV1\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getExecutionService\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getInterchainClients\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLatestInterchainClient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"}],\"name\":\"getLinkedApp\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"}],\"name\":\"getLinkedAppEVM\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"linkedAppEVM\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getModules\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReceivingConfig\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"appConfig\",\"type\":\"bytes\"},{\"internalType\":\"address[]\",\"name\":\"modules\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getRoleMember\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleMemberCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"remoteApp\",\"type\":\"bytes32\"}],\"name\":\"linkRemoteApp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"remoteApp\",\"type\":\"address\"}],\"name\":\"linkRemoteAppEVM\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"}],\"name\":\"removeInterchainClient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"removeTrustedModule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"callerConfirmation\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"requiredResponses\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"optimisticPeriod\",\"type\":\"uint256\"}],\"internalType\":\"struct AppConfigV1\",\"name\":\"appConfig\",\"type\":\"tuple\"}],\"name\":\"setAppConfigV1\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"executionService\",\"type\":\"address\"}],\"name\":\"setExecutionService\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"}],\"name\":\"setLatestInterchainClient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"errors\":{\"AccessControlBadConfirmation()\":[{\"details\":\"The caller of a function is not the expected one. NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\"}],\"AccessControlUnauthorizedAccount(address,bytes32)\":[{\"details\":\"The `account` is missing a role.\"}]},\"events\":{\"RoleAdminChanged(bytes32,bytes32,bytes32)\":{\"details\":\"Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole` `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite {RoleAdminChanged} not being emitted signaling this.\"},\"RoleGranted(bytes32,address,address)\":{\"details\":\"Emitted when `account` is granted `role`. `sender` is the account that originated the contract call, an admin role bearer except when using {AccessControl-_setupRole}.\"},\"RoleRevoked(bytes32,address,address)\":{\"details\":\"Emitted when `account` is revoked `role`. `sender` is the account that originated the contract call:   - if using `revokeRole`, it is the admin role bearer   - if using `renounceRole`, it is the role bearer (i.e. `account`)\"}},\"kind\":\"dev\",\"methods\":{\"addInterchainClient(address,bool)\":{\"params\":{\"client\":\"The address of the interchain client to add.\",\"updateLatest\":\"Whether to set the latest client to this one.\"}},\"appReceive(uint64,bytes32,uint64,uint64,bytes)\":{\"details\":\"App is responsible for keeping track of interchain clients, and must verify the message sender.\",\"params\":{\"dbNonce\":\"The Interchain DB nonce of the batch containing the message entry.\",\"entryIndex\":\"The index of the message entry within the batch.\",\"message\":\"The message being sent.\",\"sender\":\"Sender address on the source chain, as a bytes32 value.\",\"srcChainId\":\"Chain ID of the source chain, where the message was sent from.\"}},\"getLinkedAppEVM(uint64)\":{\"details\":\"Will revert if the linked app address is not an EVM address.\"},\"getReceivingConfig()\":{\"details\":\"This configuration is used by the Interchain Client to verify that message has been confirmed by the Interchain Modules on the destination chain. Note: V1 version of AppConfig includes the required responses count, and optimistic period after which the message is considered confirmed by the module. Following versions may include additional fields.\",\"returns\":{\"appConfig\":\"   The versioned configuration of the Interchain App, encoded as bytes.\",\"modules\":\"     The list of Interchain Modules that app is trusting to confirm the messages.\"}},\"getRoleAdmin(bytes32)\":{\"details\":\"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.\"},\"getRoleMember(bytes32,uint256)\":{\"details\":\"Returns one of the accounts that have `role`. `index` must be a value between 0 and {getRoleMemberCount}, non-inclusive. Role bearers are not sorted in any particular way, and their ordering may change at any point. WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure you perform all queries on the same block. See the following https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post] for more information.\"},\"getRoleMemberCount(bytes32)\":{\"details\":\"Returns the number of accounts that have `role`. Can be used together with {getRoleMember} to enumerate all bearers of a role.\"},\"grantRole(bytes32,address)\":{\"details\":\"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleGranted} event.\"},\"hasRole(bytes32,address)\":{\"details\":\"Returns `true` if `account` has been granted `role`.\"},\"linkRemoteApp(uint64,bytes32)\":{\"params\":{\"chainId\":\"The remote chain ID.\",\"remoteApp\":\"The address of the remote app to link.\"}},\"removeInterchainClient(address)\":{\"params\":{\"client\":\"The address of the interchain client to remove.\"}},\"renounceRole(bytes32,address)\":{\"details\":\"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `callerConfirmation`. May emit a {RoleRevoked} event.\"},\"revokeRole(bytes32,address)\":{\"details\":\"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleRevoked} event.\"},\"setLatestInterchainClient(address)\":{\"details\":\"The new latest client must be an allowed client or zero address. Setting the client to zero address effectively pauses the app ability to send messages, while allowing to receive them.\",\"params\":{\"client\":\"The address of the latest interchain client.\"}},\"supportsInterface(bytes4)\":{\"details\":\"See {IERC165-supportsInterface}.\"}},\"stateVariables\":{\"_appConfigV1\":{\"details\":\"Required responses and optimistic period for the module responses.\"},\"_executionService\":{\"details\":\"Execution Service to use for sending messages.\"},\"_interchainClients\":{\"details\":\"Interchain Clients allowed to send messages to this app.\"},\"_latestClient\":{\"details\":\"Address of the latest Interchain Client, used for sending messages.\"},\"_linkedApp\":{\"details\":\"Address of the linked app deployed on the remote chain.\"},\"_trustedModules\":{\"details\":\"Trusted Interchain modules.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"IC_GOVERNOR_ROLE()\":{\"notice\":\"Role to manage the Interchain setup of the app.\"},\"addInterchainClient(address,bool)\":{\"notice\":\"Allows the owner to add the interchain client to the allowed clients set, and optionally set the latest client to this one. Note: only the allowed clients can send messages to this app. Note: the latest client is used for sending messages from this app.\"},\"addTrustedModule(address)\":{\"notice\":\"Allows the owner to add the module to the trusted modules set. - This set of modules will be used to verify both sent and received messages.\"},\"appReceive(uint64,bytes32,uint64,uint64,bytes)\":{\"notice\":\"Allows the Interchain Client to pass the message to the Interchain App.\"},\"getAppConfigV1()\":{\"notice\":\"Returns the app config for the current app: requiredResponses and optimisticPeriod.\"},\"getExecutionService()\":{\"notice\":\"Returns the address of the Execution Service used by this app for sending messages.\"},\"getInterchainClients()\":{\"notice\":\"Returns the list of Interchain Clients allowed to send messages to this app.\"},\"getLatestInterchainClient()\":{\"notice\":\"Returns the address of the latest interchain client. This address is used for sending messages from this app.\"},\"getLinkedApp(uint64)\":{\"notice\":\"Returns the linked app address (as bytes32) for the given chain ID.\"},\"getLinkedAppEVM(uint64)\":{\"notice\":\"Thin wrapper for `getLinkedApp` to return the linked app address as EVM address.\"},\"getModules()\":{\"notice\":\"Returns the list of Interchain Modules trusted by this app. This set of modules will be used to verify both sent and received messages.\"},\"getReceivingConfig()\":{\"notice\":\"Returns the verification configuration of the Interchain App.\"},\"linkRemoteApp(uint64,bytes32)\":{\"notice\":\"Allows the owner to link the remote app for the given chain ID. - This address will be used as the receiver for the messages sent from this chain. - This address will be the only trusted sender for the messages sent to this chain.\"},\"linkRemoteAppEVM(uint64,address)\":{\"notice\":\"Thin wrapper for `linkRemoteApp` to accept EVM address as a parameter.\"},\"removeInterchainClient(address)\":{\"notice\":\"Allows the owner to remove the interchain client from the allowed clients set. If the client is the latest client, the latest client is set to the zero address.\"},\"removeTrustedModule(address)\":{\"notice\":\"Allows the owner to remove the module from the trusted modules set.\"},\"setAppConfigV1((uint256,uint256))\":{\"notice\":\"Allows the owner to set the app config for the current app. App config includes: - requiredResponses: the number of module responses required for accepting the message - optimisticPeriod: the minimum time after which the module responses are considered final\"},\"setExecutionService(address)\":{\"notice\":\"Allows the owner to set the address of the Execution Service. This address will be used to request execution of the messages sent from this chain, by supplying the Service's execution fee.\"},\"setLatestInterchainClient(address)\":{\"notice\":\"Allows the owner to set the address of the latest interchain client.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/ExampleAppV1.sol\":\"ICAppV1\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/ExampleAppV1.sol\":{\"keccak256\":\"0xb1e9550aef785a0afc4e03fc843839919987ba4f906f09992c6788979c3c0396\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://0ede697223dfa3a2e23501efc1ed5926d5ff6458ee7b9ba833e0587162166c79\",\"dweb:/ipfs/QmUzgopL2ptWG5DYNdGAcoErPnBC4KCoRp8C61dkHHRaA6\"]}},\"version\":1}"},"hashes":{"DEFAULT_ADMIN_ROLE()":"a217fddf","IC_GOVERNOR_ROLE()":"1c489e4f","addInterchainClient(address,bool)":"f22ba23d","addTrustedModule(address)":"cb5038fb","appReceive(uint64,bytes32,uint64,uint64,bytes)":"6e9fd609","getAppConfigV1()":"7717a647","getExecutionService()":"c313c807","getInterchainClients()":"a1aa5d68","getLatestInterchainClient()":"bc0d912c","getLinkedApp(uint64)":"4e6427e7","getLinkedAppEVM(uint64)":"90a92c16","getModules()":"b2494df3","getReceivingConfig()":"287bc057","getRoleAdmin(bytes32)":"248a9ca3","getRoleMember(bytes32,uint256)":"9010d07c","getRoleMemberCount(bytes32)":"ca15c873","grantRole(bytes32,address)":"2f2ff15d","hasRole(bytes32,address)":"91d14854","linkRemoteApp(uint64,bytes32)":"f6b266fd","linkRemoteAppEVM(uint64,address)":"1856ddfe","removeInterchainClient(address)":"0fb59156","removeTrustedModule(address)":"b70c40b3","renounceRole(bytes32,address)":"36568abe","revokeRole(bytes32,address)":"d547741f","setAppConfigV1((uint256,uint256))":"0d32b505","setExecutionService(address)":"496774b1","setLatestInterchainClient(address)":"eb53b44e","supportsInterface(bytes4)":"01ffc9a7"}},"solidity/ExampleAppV1.sol:IERC165":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/AbstractICAppEvents.sol\n\nabstract contract AbstractICAppEvents {\n    event InterchainClientAdded(address client);\n    event InterchainClientRemoved(address client);\n    event LatestClientSet(address client);\n}\n\n// contracts/events/InterchainAppV1Events.sol\n\nabstract contract InterchainAppV1Events {\n    event AppConfigV1Set(uint256 requiredResponses, uint256 optimisticPeriod);\n    event AppLinked(uint256 indexed chainId, bytes32 indexed remoteApp);\n    event ExecutionServiceSet(address executionService);\n    event TrustedModuleAdded(address module);\n    event TrustedModuleRemoved(address module);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    /// @notice Allows the Interchain Client to pass the message to the Interchain App.\n    /// @dev App is responsible for keeping track of interchain clients, and must verify the message sender.\n    /// @param srcChainId   Chain ID of the source chain, where the message was sent from.\n    /// @param sender       Sender address on the source chain, as a bytes32 value.\n    /// @param dbNonce      The Interchain DB nonce of the batch containing the message entry.\n    /// @param entryIndex   The index of the message entry within the batch.\n    /// @param message      The message being sent.\n    function appReceive(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /// @notice Returns the verification configuration of the Interchain App.\n    /// @dev This configuration is used by the Interchain Client to verify that message has been confirmed\n    /// by the Interchain Modules on the destination chain.\n    /// Note: V1 version of AppConfig includes the required responses count, and optimistic period after which\n    /// the message is considered confirmed by the module. Following versions may include additional fields.\n    /// @return appConfig    The versioned configuration of the Interchain App, encoded as bytes.\n    /// @return modules      The list of Interchain Modules that app is trusting to confirm the messages.\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/Math.sol\n\nlibrary MathLib {\n    /// @notice Rounds up to the nearest multiple of 32.\n    /// Note: Returns zero on overflows instead of reverting. This is fine for practical\n    /// use cases, as this is used for determining the size of the payload in memory.\n    function roundUpToWord(uint256 x) internal pure returns (uint256) {\n        unchecked {\n            return (x + 31) \u0026 ~uint256(31);\n        }\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/VersionedPayload.sol\n\n// solhint-disable no-inline-assembly\n// solhint-disable ordering\nlibrary VersionedPayloadLib {\n    /// @notice Amount of bytes reserved for the version (uint16) in the versioned payload\n    uint256 internal constant VERSION_LENGTH = 2;\n\n    error VersionedPayload__TooShort(bytes versionedPayload);\n    error VersionedPayload__PrecompileFailed();\n\n    /// @notice Encodes the versioned payload into a single bytes array.\n    /// @param version  The payload's version.\n    /// @param payload  The payload to encode.\n    function encodeVersionedPayload(uint16 version, bytes memory payload) internal pure returns (bytes memory) {\n        return abi.encodePacked(version, payload);\n    }\n\n    /// @notice Extracts the version from the versioned payload (calldata reference).\n    /// @param versionedPayload     The versioned payload (calldata reference).\n    function getVersion(bytes calldata versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            version := shr(240, calldataload(versionedPayload.offset))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (calldata reference).\n    /// @dev The extracted payload is also returned as a calldata reference.\n    /// @param versionedPayload     The versioned payload.\n    function getPayload(bytes calldata versionedPayload) internal pure returns (bytes calldata) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        return versionedPayload[VERSION_LENGTH:];\n    }\n\n    /// @notice Extracts the version from the versioned payload (memory reference).\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getVersionFromMemory(bytes memory versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            // We add 0x20 to skip the length of the bytes array.\n            version := shr(240, mload(add(versionedPayload, 0x20)))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (memory reference).\n    /// @dev The extracted payload is copied into a new memory location. Use `getPayload` when possible\n    /// to avoid extra memory allocation.\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getPayloadFromMemory(bytes memory versionedPayload) internal view returns (bytes memory payload) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        // Figure how many bytes to copy and allocate the memory for the extracted payload.\n        uint256 toCopy;\n        unchecked {\n            toCopy = versionedPayload.length - VERSION_LENGTH;\n        }\n        payload = new bytes(toCopy);\n        // Use identity precompile (0x04) to copy the payload. Unlike MCOPY, this is available on all EVM chains.\n        bool res;\n        assembly {\n            // We add 0x20 to skip the length of the bytes array.\n            // We add 0x02 to skip the 2 bytes reserved for the version.\n            // Copy the payload to the previously allocated memory.\n            res := staticcall(gas(), 0x04, add(versionedPayload, 0x22), toCopy, add(payload, 0x20), toCopy)\n        }\n        if (!res) {\n            revert VersionedPayload__PrecompileFailed();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/IAccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n\n// node_modules/@openzeppelin/contracts/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance \u003c amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance \u003c value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 \u0026\u0026 target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SafeCast.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value \u003e type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value \u003e type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value \u003e type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value \u003e type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value \u003e type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value \u003e type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value \u003e type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value \u003e type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value \u003e type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value \u003e type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value \u003e type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value \u003e type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value \u003e type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value \u003e type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value \u003e type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value \u003e type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value \u003e type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value \u003e type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value \u003e type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value \u003e type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value \u003e type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value \u003e type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value \u003e type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value \u003e type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value \u003e type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value \u003e type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value \u003e type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value \u003e type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value \u003e type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value \u003e type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value \u003e type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value \u003c 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value \u003e uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal view returns (AppConfigV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (AppConfigV1));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal view returns (OptionsV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (OptionsV1));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(OPTIONS_V1, abi.encode(options));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/IAccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/IAccessControlEnumerable.sol)\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n// contracts/interfaces/IInterchainAppV1.sol\n\ninterface IInterchainAppV1 is IInterchainApp {\n    error InterchainApp__AppZeroAddress();\n    error InterchainApp__InvalidAppConfig(uint256 requiredResponses, uint256 optimisticPeriod);\n    error InterchainApp__ModuleAlreadyAdded(address module);\n    error InterchainApp__ModuleNotAdded(address module);\n    error InterchainApp__ModuleZeroAddress();\n    error InterchainApp__NotEVMLinkedApp(bytes32 linkedApp);\n\n    /// @notice Allows the owner to add the interchain client to the allowed clients set,\n    /// and optionally set the latest client to this one.\n    /// Note: only the allowed clients can send messages to this app.\n    /// Note: the latest client is used for sending messages from this app.\n    /// @param client       The address of the interchain client to add.\n    /// @param updateLatest Whether to set the latest client to this one.\n    function addInterchainClient(address client, bool updateLatest) external;\n\n    /// @notice Allows the owner to remove the interchain client from the allowed clients set.\n    /// If the client is the latest client, the latest client is set to the zero address.\n    /// @param client       The address of the interchain client to remove.\n    function removeInterchainClient(address client) external;\n\n    /// @notice Allows the owner to set the address of the latest interchain client.\n    /// @dev The new latest client must be an allowed client or zero address.\n    /// Setting the client to zero address effectively pauses the app ability to send messages,\n    /// while allowing to receive them.\n    /// @param client       The address of the latest interchain client.\n    function setLatestInterchainClient(address client) external;\n\n    /// @notice Allows the owner to link the remote app for the given chain ID.\n    /// - This address will be used as the receiver for the messages sent from this chain.\n    /// - This address will be the only trusted sender for the messages sent to this chain.\n    /// @param chainId      The remote chain ID.\n    /// @param remoteApp    The address of the remote app to link.\n    function linkRemoteApp(uint64 chainId, bytes32 remoteApp) external;\n\n    /// @notice Thin wrapper for `linkRemoteApp` to accept EVM address as a parameter.\n    function linkRemoteAppEVM(uint64 chainId, address remoteApp) external;\n\n    /// @notice Allows the owner to add the module to the trusted modules set.\n    /// - This set of modules will be used to verify both sent and received messages.\n    function addTrustedModule(address module) external;\n\n    /// @notice Allows the owner to remove the module from the trusted modules set.\n    function removeTrustedModule(address module) external;\n\n    /// @notice Allows the owner to set the app config for the current app. App config includes:\n    /// - requiredResponses: the number of module responses required for accepting the message\n    /// - optimisticPeriod: the minimum time after which the module responses are considered final\n    function setAppConfigV1(AppConfigV1 memory appConfig) external;\n\n    /// @notice Allows the owner to set the address of the Execution Service.\n    /// This address will be used to request execution of the messages sent from this chain,\n    /// by supplying the Service's execution fee.\n    function setExecutionService(address executionService) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Returns the app config for the current app: requiredResponses and optimisticPeriod.\n    function getAppConfigV1() external view returns (AppConfigV1 memory);\n\n    /// @notice Returns the address of the Execution Service used by this app for sending messages.\n    function getExecutionService() external view returns (address);\n\n    /// @notice Returns the list of Interchain Clients allowed to send messages to this app.\n    function getInterchainClients() external view returns (address[] memory);\n\n    /// @notice Returns the address of the latest interchain client.\n    /// This address is used for sending messages from this app.\n    function getLatestInterchainClient() external view returns (address);\n\n    /// @notice Returns the linked app address (as bytes32) for the given chain ID.\n    function getLinkedApp(uint64 chainId) external view returns (bytes32);\n\n    /// @notice Thin wrapper for `getLinkedApp` to return the linked app address as EVM address.\n    /// @dev Will revert if the linked app address is not an EVM address.\n    function getLinkedAppEVM(uint64 chainId) external view returns (address);\n\n    /// @notice Returns the list of Interchain Modules trusted by this app.\n    /// This set of modules will be used to verify both sent and received messages.\n    function getModules() external view returns (address[] memory);\n}\n\n// contracts/libs/InterchainTransaction.sol\n\ntype ICTxHeader is uint256;\n\nstruct InterchainTransaction {\n    uint64 srcChainId;\n    uint64 dstChainId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcSender;\n    bytes32 dstReceiver;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    using MathLib for uint256;\n    using VersionedPayloadLib for bytes;\n\n    function constructLocalTransaction(\n        address srcSender,\n        uint64 dstChainId,\n        bytes32 dstReceiver,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: SafeCast.toUint64(block.chainid),\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            encodeTxHeader(transaction.srcChainId, transaction.dstChainId, transaction.dbNonce, transaction.entryIndex),\n            transaction.srcSender,\n            transaction.dstReceiver,\n            transaction.options,\n            transaction.message\n        );\n    }\n\n    function decodeTransaction(bytes calldata transaction) internal pure returns (InterchainTransaction memory icTx) {\n        ICTxHeader header;\n        (header, icTx.srcSender, icTx.dstReceiver, icTx.options, icTx.message) =\n            abi.decode(transaction, (ICTxHeader, bytes32, bytes32, bytes, bytes));\n        (icTx.srcChainId, icTx.dstChainId, icTx.dbNonce, icTx.entryIndex) = decodeTxHeader(header);\n    }\n\n    function payloadSize(uint256 optionsLen, uint256 messageLen) internal pure returns (uint256) {\n        // 2 bytes are reserved for the transaction version\n        // + 5 fields * 32 bytes (3 values for static, 2 offsets for dynamic) + 2 * 32 bytes (lengths for dynamic) = 226\n        // (srcChainId, dstChainId, dbNonce, entryIndex) are merged into a single 32 bytes field\n        // Both options and message are dynamic fields, which are padded up to 32 bytes\n        return 226 + optionsLen.roundUpToWord() + messageLen.roundUpToWord();\n    }\n\n    function encodeTxHeader(\n        uint64 srcChainId,\n        uint64 dstChainId,\n        uint64 dbNonce,\n        uint64 entryIndex\n    )\n        internal\n        pure\n        returns (ICTxHeader)\n    {\n        return ICTxHeader.wrap(\n            (uint256(srcChainId) \u003c\u003c 192) | (uint256(dstChainId) \u003c\u003c 128) | (uint256(dbNonce) \u003c\u003c 64) | uint256(entryIndex)\n        );\n    }\n\n    function decodeTxHeader(ICTxHeader header)\n        internal\n        pure\n        returns (uint64 srcChainId, uint64 dstChainId, uint64 dbNonce, uint64 entryIndex)\n    {\n        srcChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 192);\n        dstChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 128);\n        dbNonce = uint64(ICTxHeader.unwrap(header) \u003e\u003e 64);\n        entryIndex = uint64(ICTxHeader.unwrap(header));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/AccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account =\u003e bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role =\u003e RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint64 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__InvalidTransactionVersion(uint16 version);\n    error InterchainClientV1__NoLinkedClient(uint64 chainId);\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint64 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint64 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint64 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint64 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param messageLen           The length of the message being sent.\n    function getInterchainFee(\n        uint64 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        uint256 messageLen\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint64 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint64 chainId) external view returns (address);\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/AccessControlEnumerable.sol)\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 role =\u003e EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {AccessControl-_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool granted = super._grantRole(role, account);\n        if (granted) {\n            _roleMembers[role].add(account);\n        }\n        return granted;\n    }\n\n    /**\n     * @dev Overload {AccessControl-_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool revoked = super._revokeRole(role, account);\n        if (revoked) {\n            _roleMembers[role].remove(account);\n        }\n        return revoked;\n    }\n}\n\n// contracts/apps/AbstractICApp.sol\n\nabstract contract AbstractICApp is AbstractICAppEvents, IInterchainApp {\n    using TypeCasts for address;\n\n    error InterchainApp__AlreadyLatestClient(address client);\n    error InterchainApp__BalanceTooLow(uint256 actual, uint256 required);\n    error InterchainApp__ClientAlreadyAdded(address client);\n    error InterchainApp__InterchainClientZeroAddress();\n    error InterchainApp__NotInterchainClient(address account);\n    error InterchainApp__ReceiverNotSet(uint64 chainId);\n    error InterchainApp__SameChainId(uint64 chainId);\n    error InterchainApp__SenderNotAllowed(uint64 srcChainId, bytes32 sender);\n\n    /// @inheritdoc IInterchainApp\n    function appReceive(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        if (!_isInterchainClient(msg.sender)) {\n            revert InterchainApp__NotInterchainClient(msg.sender);\n        }\n        if (srcChainId == block.chainid) {\n            revert InterchainApp__SameChainId(srcChainId);\n        }\n        if (!_isAllowedSender(srcChainId, sender)) {\n            revert InterchainApp__SenderNotAllowed(srcChainId, sender);\n        }\n        _receiveMessage(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n\n    /// @inheritdoc IInterchainApp\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules) {\n        appConfig = _getAppConfig();\n        modules = _getModules();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Performs necessary checks and adds an Interchain Client.\n    /// Optionally sets the latest client to this one.\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _addClient(address client, bool updateLatest) internal {\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (_isInterchainClient(client)) {\n            revert InterchainApp__ClientAlreadyAdded(client);\n        }\n        _toggleClientState(client, true);\n        emit InterchainClientAdded(client);\n        if (updateLatest) {\n            _setLatestClient(client);\n        }\n    }\n\n    /// @dev Performs necessary checks and removes an Interchain Client. If this client is the latest one,\n    /// the latest client is set to zero address (effectively pausing the app ability to send messages).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _removeClient(address client) internal {\n        if (!_isInterchainClient(client)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        _toggleClientState(client, false);\n        emit InterchainClientRemoved(client);\n        if (client == _getLatestClient()) {\n            _setLatestClient(address(0));\n        }\n    }\n\n    /// @dev Sets the latest Interchain Client to one of the allowed clients. Setting the client to zero address\n    /// is allowed and effectively pauses the app ability to send messages (but still allows to receive them).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _setLatestClient(address client) internal {\n        // New latest client must be an allowed client or zero address.\n        if (!_isInterchainClient(client) \u0026\u0026 client != address(0)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        if (client == _getLatestClient()) {\n            revert InterchainApp__AlreadyLatestClient(client);\n        }\n        _storeLatestClient(client);\n        emit LatestClientSet(client);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal virtual;\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal virtual;\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to accept EVM address as a parameter.\n    function _sendInterchainMessageEVM(\n        uint64 dstChainId,\n        address receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _sendInterchainMessage(dstChainId, receiver.addressToBytes32(), messageFee, options, message);\n    }\n\n    /// @dev Performs necessary checks and sends an interchain message.\n    function _sendInterchainMessage(\n        uint64 dstChainId,\n        bytes32 receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (dstChainId == block.chainid) {\n            revert InterchainApp__SameChainId(dstChainId);\n        }\n        if (receiver == 0) {\n            revert InterchainApp__ReceiverNotSet(dstChainId);\n        }\n        if (address(this).balance \u003c messageFee) {\n            revert InterchainApp__BalanceTooLow({actual: address(this).balance, required: messageFee});\n        }\n        return IInterchainClientV1(client).interchainSend{value: messageFee}(\n            dstChainId, receiver, _getExecutionService(), _getModules(), options, message\n        );\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        virtual;\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee for sending an Interchain message.\n    function _getInterchainFee(\n        uint64 dstChainId,\n        bytes memory options,\n        uint256 messageLen\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        return IInterchainClientV1(client).getInterchainFee(\n            dstChainId, _getExecutionService(), _getModules(), options, messageLen\n        );\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view virtual returns (bytes memory);\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view virtual returns (address);\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view virtual returns (address);\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view virtual returns (address[] memory);\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint64 srcChainId, bytes32 sender) internal view virtual returns (bool);\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view virtual returns (bool);\n}\n\n// contracts/apps/ICAppV1.sol\n\nabstract contract ICAppV1 is AbstractICApp, AccessControlEnumerable, InterchainAppV1Events, IInterchainAppV1 {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Role to manage the Interchain setup of the app.\n    bytes32 public constant IC_GOVERNOR_ROLE = keccak256(\"IC_GOVERNOR_ROLE\");\n\n    /// @dev Address of the latest Interchain Client, used for sending messages.\n    address private _latestClient;\n\n    /// @dev Required responses and optimistic period for the module responses.\n    AppConfigV1 private _appConfigV1;\n    /// @dev Address of the linked app deployed on the remote chain.\n    mapping(uint64 chainId =\u003e bytes32 remoteApp) private _linkedApp;\n    /// @dev Interchain Clients allowed to send messages to this app.\n    EnumerableSet.AddressSet private _interchainClients;\n    /// @dev Trusted Interchain modules.\n    EnumerableSet.AddressSet private _trustedModules;\n    /// @dev Execution Service to use for sending messages.\n    address private _executionService;\n\n    constructor(address admin) {\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addInterchainClient(address client, bool updateLatest) external onlyRole(IC_GOVERNOR_ROLE) {\n        _addClient(client, updateLatest);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _removeClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setLatestInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _setLatestClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteApp(uint64 chainId, bytes32 remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteAppEVM(uint64 chainId, address remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp.addressToBytes32());\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (module == address(0)) {\n            revert InterchainApp__ModuleZeroAddress();\n        }\n        bool added = _trustedModules.add(module);\n        if (!added) {\n            revert InterchainApp__ModuleAlreadyAdded(module);\n        }\n        emit TrustedModuleAdded(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        bool removed = _trustedModules.remove(module);\n        if (!removed) {\n            revert InterchainApp__ModuleNotAdded(module);\n        }\n        emit TrustedModuleRemoved(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setAppConfigV1(AppConfigV1 memory appConfig) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (appConfig.requiredResponses == 0 || appConfig.optimisticPeriod == 0) {\n            revert InterchainApp__InvalidAppConfig(appConfig.requiredResponses, appConfig.optimisticPeriod);\n        }\n        _appConfigV1 = appConfig;\n        emit AppConfigV1Set(appConfig.requiredResponses, appConfig.optimisticPeriod);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setExecutionService(address executionService) external onlyRole(IC_GOVERNOR_ROLE) {\n        _executionService = executionService;\n        emit ExecutionServiceSet(executionService);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainAppV1\n    function getAppConfigV1() external view returns (AppConfigV1 memory) {\n        return _appConfigV1;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getExecutionService() external view returns (address) {\n        return _executionService;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getInterchainClients() external view returns (address[] memory) {\n        return _interchainClients.values();\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLatestInterchainClient() external view returns (address) {\n        return _latestClient;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedApp(uint64 chainId) external view returns (bytes32) {\n        return _linkedApp[chainId];\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedAppEVM(uint64 chainId) external view returns (address linkedAppEVM) {\n        bytes32 linkedApp = _linkedApp[chainId];\n        linkedAppEVM = linkedApp.bytes32ToAddress();\n        if (linkedAppEVM.addressToBytes32() != linkedApp) {\n            revert InterchainApp__NotEVMLinkedApp(linkedApp);\n        }\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getModules() external view returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Links the remote app to the current app.\n    /// Will revert if the chainId is the same as the chainId of the local app.\n    /// Note: Should be guarded with permissions check.\n    function _linkRemoteApp(uint64 chainId, bytes32 remoteApp) internal {\n        if (chainId == block.chainid) {\n            revert InterchainApp__SameChainId(chainId);\n        }\n        if (remoteApp == 0) {\n            revert InterchainApp__AppZeroAddress();\n        }\n        _linkedApp[chainId] = remoteApp;\n        emit AppLinked(chainId, remoteApp);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal override {\n        _latestClient = client;\n    }\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal override {\n        if (allowed) {\n            _interchainClients.add(client);\n        } else {\n            _interchainClients.remove(client);\n        }\n    }\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to send the message to the linked app.\n    function _sendToLinkedApp(\n        uint64 dstChainId,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _sendInterchainMessage(dstChainId, _linkedApp[dstChainId], messageFee, encodedOptions, message);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee to send a message to the linked app on the remote chain.\n    function _getMessageFee(\n        uint64 dstChainId,\n        OptionsV1 memory options,\n        uint256 messageLen\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _getInterchainFee(dstChainId, encodedOptions, messageLen);\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view override returns (bytes memory) {\n        return _appConfigV1.encodeAppConfigV1();\n    }\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view override returns (address) {\n        return _executionService;\n    }\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view override returns (address) {\n        return _latestClient;\n    }\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view override returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint64 srcChainId, bytes32 sender) internal view override returns (bool) {\n        return _linkedApp[srcChainId] == sender;\n    }\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view override returns (bool) {\n        return _interchainClients.contains(caller);\n    }\n}\n\n// contracts/apps/examples/ExampleAppV1.sol\n\ncontract ExampleAppV1 is ICAppV1 {\n    event MessageReceived(uint64 srcChainId, bytes32 sender, uint64 dbNonce, uint64 entryIndex, bytes message);\n    event MessageSent(uint64 dstChainId, uint64 dbNonce, uint64 entryIndex, bytes32 transactionId);\n\n    constructor(address admin) ICAppV1(admin) {\n        _grantRole(IC_GOVERNOR_ROLE, admin);\n    }\n\n    /// @notice Allows the Admin to withdraw the native asset from the contract.\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        Address.sendValue(payable(msg.sender), address(this).balance);\n    }\n\n    /// @notice Sends a basic message to the destination chain.\n    function sendMessage(\n        uint64 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        InterchainTxDescriptor memory desc = _sendToLinkedApp({\n            dstChainId: dstChainId,\n            messageFee: msg.value,\n            options: OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}),\n            message: message\n        });\n        emit MessageSent(dstChainId, desc.dbNonce, desc.entryIndex, desc.transactionId);\n    }\n\n    /// @notice Returns the fee required to send a message using `sendMessage`.\n    function getMessageFee(\n        uint64 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes memory message\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _getMessageFee(dstChainId, OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}), message.length);\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        override\n    {\n        emit MessageReceived(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"bytes4","name":"interfaceId","type":"bytes4"}],"name":"supportsInterface","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"details":"Interface of the ERC165 standard, as defined in the https://eips.ethereum.org/EIPS/eip-165[EIP]. Implementers can declare support of contract interfaces, which can then be queried by others ({ERC165Checker}). For an implementation, see {ERC165}.","kind":"dev","methods":{"supportsInterface(bytes4)":{"details":"Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas."}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Interface of the ERC165 standard, as defined in the https://eips.ethereum.org/EIPS/eip-165[EIP]. Implementers can declare support of contract interfaces, which can then be queried by others ({ERC165Checker}). For an implementation, see {ERC165}.\",\"kind\":\"dev\",\"methods\":{\"supportsInterface(bytes4)\":{\"details\":\"Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/ExampleAppV1.sol\":\"IERC165\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/ExampleAppV1.sol\":{\"keccak256\":\"0xb1e9550aef785a0afc4e03fc843839919987ba4f906f09992c6788979c3c0396\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://0ede697223dfa3a2e23501efc1ed5926d5ff6458ee7b9ba833e0587162166c79\",\"dweb:/ipfs/QmUzgopL2ptWG5DYNdGAcoErPnBC4KCoRp8C61dkHHRaA6\"]}},\"version\":1}"},"hashes":{"supportsInterface(bytes4)":"01ffc9a7"}},"solidity/ExampleAppV1.sol:IInterchainApp":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/AbstractICAppEvents.sol\n\nabstract contract AbstractICAppEvents {\n    event InterchainClientAdded(address client);\n    event InterchainClientRemoved(address client);\n    event LatestClientSet(address client);\n}\n\n// contracts/events/InterchainAppV1Events.sol\n\nabstract contract InterchainAppV1Events {\n    event AppConfigV1Set(uint256 requiredResponses, uint256 optimisticPeriod);\n    event AppLinked(uint256 indexed chainId, bytes32 indexed remoteApp);\n    event ExecutionServiceSet(address executionService);\n    event TrustedModuleAdded(address module);\n    event TrustedModuleRemoved(address module);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    /// @notice Allows the Interchain Client to pass the message to the Interchain App.\n    /// @dev App is responsible for keeping track of interchain clients, and must verify the message sender.\n    /// @param srcChainId   Chain ID of the source chain, where the message was sent from.\n    /// @param sender       Sender address on the source chain, as a bytes32 value.\n    /// @param dbNonce      The Interchain DB nonce of the batch containing the message entry.\n    /// @param entryIndex   The index of the message entry within the batch.\n    /// @param message      The message being sent.\n    function appReceive(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /// @notice Returns the verification configuration of the Interchain App.\n    /// @dev This configuration is used by the Interchain Client to verify that message has been confirmed\n    /// by the Interchain Modules on the destination chain.\n    /// Note: V1 version of AppConfig includes the required responses count, and optimistic period after which\n    /// the message is considered confirmed by the module. Following versions may include additional fields.\n    /// @return appConfig    The versioned configuration of the Interchain App, encoded as bytes.\n    /// @return modules      The list of Interchain Modules that app is trusting to confirm the messages.\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/Math.sol\n\nlibrary MathLib {\n    /// @notice Rounds up to the nearest multiple of 32.\n    /// Note: Returns zero on overflows instead of reverting. This is fine for practical\n    /// use cases, as this is used for determining the size of the payload in memory.\n    function roundUpToWord(uint256 x) internal pure returns (uint256) {\n        unchecked {\n            return (x + 31) \u0026 ~uint256(31);\n        }\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/VersionedPayload.sol\n\n// solhint-disable no-inline-assembly\n// solhint-disable ordering\nlibrary VersionedPayloadLib {\n    /// @notice Amount of bytes reserved for the version (uint16) in the versioned payload\n    uint256 internal constant VERSION_LENGTH = 2;\n\n    error VersionedPayload__TooShort(bytes versionedPayload);\n    error VersionedPayload__PrecompileFailed();\n\n    /// @notice Encodes the versioned payload into a single bytes array.\n    /// @param version  The payload's version.\n    /// @param payload  The payload to encode.\n    function encodeVersionedPayload(uint16 version, bytes memory payload) internal pure returns (bytes memory) {\n        return abi.encodePacked(version, payload);\n    }\n\n    /// @notice Extracts the version from the versioned payload (calldata reference).\n    /// @param versionedPayload     The versioned payload (calldata reference).\n    function getVersion(bytes calldata versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            version := shr(240, calldataload(versionedPayload.offset))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (calldata reference).\n    /// @dev The extracted payload is also returned as a calldata reference.\n    /// @param versionedPayload     The versioned payload.\n    function getPayload(bytes calldata versionedPayload) internal pure returns (bytes calldata) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        return versionedPayload[VERSION_LENGTH:];\n    }\n\n    /// @notice Extracts the version from the versioned payload (memory reference).\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getVersionFromMemory(bytes memory versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            // We add 0x20 to skip the length of the bytes array.\n            version := shr(240, mload(add(versionedPayload, 0x20)))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (memory reference).\n    /// @dev The extracted payload is copied into a new memory location. Use `getPayload` when possible\n    /// to avoid extra memory allocation.\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getPayloadFromMemory(bytes memory versionedPayload) internal view returns (bytes memory payload) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        // Figure how many bytes to copy and allocate the memory for the extracted payload.\n        uint256 toCopy;\n        unchecked {\n            toCopy = versionedPayload.length - VERSION_LENGTH;\n        }\n        payload = new bytes(toCopy);\n        // Use identity precompile (0x04) to copy the payload. Unlike MCOPY, this is available on all EVM chains.\n        bool res;\n        assembly {\n            // We add 0x20 to skip the length of the bytes array.\n            // We add 0x02 to skip the 2 bytes reserved for the version.\n            // Copy the payload to the previously allocated memory.\n            res := staticcall(gas(), 0x04, add(versionedPayload, 0x22), toCopy, add(payload, 0x20), toCopy)\n        }\n        if (!res) {\n            revert VersionedPayload__PrecompileFailed();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/IAccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n\n// node_modules/@openzeppelin/contracts/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance \u003c amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance \u003c value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 \u0026\u0026 target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SafeCast.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value \u003e type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value \u003e type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value \u003e type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value \u003e type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value \u003e type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value \u003e type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value \u003e type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value \u003e type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value \u003e type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value \u003e type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value \u003e type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value \u003e type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value \u003e type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value \u003e type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value \u003e type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value \u003e type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value \u003e type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value \u003e type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value \u003e type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value \u003e type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value \u003e type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value \u003e type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value \u003e type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value \u003e type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value \u003e type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value \u003e type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value \u003e type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value \u003e type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value \u003e type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value \u003e type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value \u003e type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value \u003c 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value \u003e uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal view returns (AppConfigV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (AppConfigV1));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal view returns (OptionsV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (OptionsV1));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(OPTIONS_V1, abi.encode(options));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/IAccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/IAccessControlEnumerable.sol)\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n// contracts/interfaces/IInterchainAppV1.sol\n\ninterface IInterchainAppV1 is IInterchainApp {\n    error InterchainApp__AppZeroAddress();\n    error InterchainApp__InvalidAppConfig(uint256 requiredResponses, uint256 optimisticPeriod);\n    error InterchainApp__ModuleAlreadyAdded(address module);\n    error InterchainApp__ModuleNotAdded(address module);\n    error InterchainApp__ModuleZeroAddress();\n    error InterchainApp__NotEVMLinkedApp(bytes32 linkedApp);\n\n    /// @notice Allows the owner to add the interchain client to the allowed clients set,\n    /// and optionally set the latest client to this one.\n    /// Note: only the allowed clients can send messages to this app.\n    /// Note: the latest client is used for sending messages from this app.\n    /// @param client       The address of the interchain client to add.\n    /// @param updateLatest Whether to set the latest client to this one.\n    function addInterchainClient(address client, bool updateLatest) external;\n\n    /// @notice Allows the owner to remove the interchain client from the allowed clients set.\n    /// If the client is the latest client, the latest client is set to the zero address.\n    /// @param client       The address of the interchain client to remove.\n    function removeInterchainClient(address client) external;\n\n    /// @notice Allows the owner to set the address of the latest interchain client.\n    /// @dev The new latest client must be an allowed client or zero address.\n    /// Setting the client to zero address effectively pauses the app ability to send messages,\n    /// while allowing to receive them.\n    /// @param client       The address of the latest interchain client.\n    function setLatestInterchainClient(address client) external;\n\n    /// @notice Allows the owner to link the remote app for the given chain ID.\n    /// - This address will be used as the receiver for the messages sent from this chain.\n    /// - This address will be the only trusted sender for the messages sent to this chain.\n    /// @param chainId      The remote chain ID.\n    /// @param remoteApp    The address of the remote app to link.\n    function linkRemoteApp(uint64 chainId, bytes32 remoteApp) external;\n\n    /// @notice Thin wrapper for `linkRemoteApp` to accept EVM address as a parameter.\n    function linkRemoteAppEVM(uint64 chainId, address remoteApp) external;\n\n    /// @notice Allows the owner to add the module to the trusted modules set.\n    /// - This set of modules will be used to verify both sent and received messages.\n    function addTrustedModule(address module) external;\n\n    /// @notice Allows the owner to remove the module from the trusted modules set.\n    function removeTrustedModule(address module) external;\n\n    /// @notice Allows the owner to set the app config for the current app. App config includes:\n    /// - requiredResponses: the number of module responses required for accepting the message\n    /// - optimisticPeriod: the minimum time after which the module responses are considered final\n    function setAppConfigV1(AppConfigV1 memory appConfig) external;\n\n    /// @notice Allows the owner to set the address of the Execution Service.\n    /// This address will be used to request execution of the messages sent from this chain,\n    /// by supplying the Service's execution fee.\n    function setExecutionService(address executionService) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Returns the app config for the current app: requiredResponses and optimisticPeriod.\n    function getAppConfigV1() external view returns (AppConfigV1 memory);\n\n    /// @notice Returns the address of the Execution Service used by this app for sending messages.\n    function getExecutionService() external view returns (address);\n\n    /// @notice Returns the list of Interchain Clients allowed to send messages to this app.\n    function getInterchainClients() external view returns (address[] memory);\n\n    /// @notice Returns the address of the latest interchain client.\n    /// This address is used for sending messages from this app.\n    function getLatestInterchainClient() external view returns (address);\n\n    /// @notice Returns the linked app address (as bytes32) for the given chain ID.\n    function getLinkedApp(uint64 chainId) external view returns (bytes32);\n\n    /// @notice Thin wrapper for `getLinkedApp` to return the linked app address as EVM address.\n    /// @dev Will revert if the linked app address is not an EVM address.\n    function getLinkedAppEVM(uint64 chainId) external view returns (address);\n\n    /// @notice Returns the list of Interchain Modules trusted by this app.\n    /// This set of modules will be used to verify both sent and received messages.\n    function getModules() external view returns (address[] memory);\n}\n\n// contracts/libs/InterchainTransaction.sol\n\ntype ICTxHeader is uint256;\n\nstruct InterchainTransaction {\n    uint64 srcChainId;\n    uint64 dstChainId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcSender;\n    bytes32 dstReceiver;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    using MathLib for uint256;\n    using VersionedPayloadLib for bytes;\n\n    function constructLocalTransaction(\n        address srcSender,\n        uint64 dstChainId,\n        bytes32 dstReceiver,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: SafeCast.toUint64(block.chainid),\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            encodeTxHeader(transaction.srcChainId, transaction.dstChainId, transaction.dbNonce, transaction.entryIndex),\n            transaction.srcSender,\n            transaction.dstReceiver,\n            transaction.options,\n            transaction.message\n        );\n    }\n\n    function decodeTransaction(bytes calldata transaction) internal pure returns (InterchainTransaction memory icTx) {\n        ICTxHeader header;\n        (header, icTx.srcSender, icTx.dstReceiver, icTx.options, icTx.message) =\n            abi.decode(transaction, (ICTxHeader, bytes32, bytes32, bytes, bytes));\n        (icTx.srcChainId, icTx.dstChainId, icTx.dbNonce, icTx.entryIndex) = decodeTxHeader(header);\n    }\n\n    function payloadSize(uint256 optionsLen, uint256 messageLen) internal pure returns (uint256) {\n        // 2 bytes are reserved for the transaction version\n        // + 5 fields * 32 bytes (3 values for static, 2 offsets for dynamic) + 2 * 32 bytes (lengths for dynamic) = 226\n        // (srcChainId, dstChainId, dbNonce, entryIndex) are merged into a single 32 bytes field\n        // Both options and message are dynamic fields, which are padded up to 32 bytes\n        return 226 + optionsLen.roundUpToWord() + messageLen.roundUpToWord();\n    }\n\n    function encodeTxHeader(\n        uint64 srcChainId,\n        uint64 dstChainId,\n        uint64 dbNonce,\n        uint64 entryIndex\n    )\n        internal\n        pure\n        returns (ICTxHeader)\n    {\n        return ICTxHeader.wrap(\n            (uint256(srcChainId) \u003c\u003c 192) | (uint256(dstChainId) \u003c\u003c 128) | (uint256(dbNonce) \u003c\u003c 64) | uint256(entryIndex)\n        );\n    }\n\n    function decodeTxHeader(ICTxHeader header)\n        internal\n        pure\n        returns (uint64 srcChainId, uint64 dstChainId, uint64 dbNonce, uint64 entryIndex)\n    {\n        srcChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 192);\n        dstChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 128);\n        dbNonce = uint64(ICTxHeader.unwrap(header) \u003e\u003e 64);\n        entryIndex = uint64(ICTxHeader.unwrap(header));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/AccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account =\u003e bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role =\u003e RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint64 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__InvalidTransactionVersion(uint16 version);\n    error InterchainClientV1__NoLinkedClient(uint64 chainId);\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint64 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint64 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint64 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint64 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param messageLen           The length of the message being sent.\n    function getInterchainFee(\n        uint64 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        uint256 messageLen\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint64 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint64 chainId) external view returns (address);\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/AccessControlEnumerable.sol)\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 role =\u003e EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {AccessControl-_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool granted = super._grantRole(role, account);\n        if (granted) {\n            _roleMembers[role].add(account);\n        }\n        return granted;\n    }\n\n    /**\n     * @dev Overload {AccessControl-_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool revoked = super._revokeRole(role, account);\n        if (revoked) {\n            _roleMembers[role].remove(account);\n        }\n        return revoked;\n    }\n}\n\n// contracts/apps/AbstractICApp.sol\n\nabstract contract AbstractICApp is AbstractICAppEvents, IInterchainApp {\n    using TypeCasts for address;\n\n    error InterchainApp__AlreadyLatestClient(address client);\n    error InterchainApp__BalanceTooLow(uint256 actual, uint256 required);\n    error InterchainApp__ClientAlreadyAdded(address client);\n    error InterchainApp__InterchainClientZeroAddress();\n    error InterchainApp__NotInterchainClient(address account);\n    error InterchainApp__ReceiverNotSet(uint64 chainId);\n    error InterchainApp__SameChainId(uint64 chainId);\n    error InterchainApp__SenderNotAllowed(uint64 srcChainId, bytes32 sender);\n\n    /// @inheritdoc IInterchainApp\n    function appReceive(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        if (!_isInterchainClient(msg.sender)) {\n            revert InterchainApp__NotInterchainClient(msg.sender);\n        }\n        if (srcChainId == block.chainid) {\n            revert InterchainApp__SameChainId(srcChainId);\n        }\n        if (!_isAllowedSender(srcChainId, sender)) {\n            revert InterchainApp__SenderNotAllowed(srcChainId, sender);\n        }\n        _receiveMessage(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n\n    /// @inheritdoc IInterchainApp\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules) {\n        appConfig = _getAppConfig();\n        modules = _getModules();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Performs necessary checks and adds an Interchain Client.\n    /// Optionally sets the latest client to this one.\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _addClient(address client, bool updateLatest) internal {\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (_isInterchainClient(client)) {\n            revert InterchainApp__ClientAlreadyAdded(client);\n        }\n        _toggleClientState(client, true);\n        emit InterchainClientAdded(client);\n        if (updateLatest) {\n            _setLatestClient(client);\n        }\n    }\n\n    /// @dev Performs necessary checks and removes an Interchain Client. If this client is the latest one,\n    /// the latest client is set to zero address (effectively pausing the app ability to send messages).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _removeClient(address client) internal {\n        if (!_isInterchainClient(client)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        _toggleClientState(client, false);\n        emit InterchainClientRemoved(client);\n        if (client == _getLatestClient()) {\n            _setLatestClient(address(0));\n        }\n    }\n\n    /// @dev Sets the latest Interchain Client to one of the allowed clients. Setting the client to zero address\n    /// is allowed and effectively pauses the app ability to send messages (but still allows to receive them).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _setLatestClient(address client) internal {\n        // New latest client must be an allowed client or zero address.\n        if (!_isInterchainClient(client) \u0026\u0026 client != address(0)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        if (client == _getLatestClient()) {\n            revert InterchainApp__AlreadyLatestClient(client);\n        }\n        _storeLatestClient(client);\n        emit LatestClientSet(client);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal virtual;\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal virtual;\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to accept EVM address as a parameter.\n    function _sendInterchainMessageEVM(\n        uint64 dstChainId,\n        address receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _sendInterchainMessage(dstChainId, receiver.addressToBytes32(), messageFee, options, message);\n    }\n\n    /// @dev Performs necessary checks and sends an interchain message.\n    function _sendInterchainMessage(\n        uint64 dstChainId,\n        bytes32 receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (dstChainId == block.chainid) {\n            revert InterchainApp__SameChainId(dstChainId);\n        }\n        if (receiver == 0) {\n            revert InterchainApp__ReceiverNotSet(dstChainId);\n        }\n        if (address(this).balance \u003c messageFee) {\n            revert InterchainApp__BalanceTooLow({actual: address(this).balance, required: messageFee});\n        }\n        return IInterchainClientV1(client).interchainSend{value: messageFee}(\n            dstChainId, receiver, _getExecutionService(), _getModules(), options, message\n        );\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        virtual;\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee for sending an Interchain message.\n    function _getInterchainFee(\n        uint64 dstChainId,\n        bytes memory options,\n        uint256 messageLen\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        return IInterchainClientV1(client).getInterchainFee(\n            dstChainId, _getExecutionService(), _getModules(), options, messageLen\n        );\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view virtual returns (bytes memory);\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view virtual returns (address);\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view virtual returns (address);\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view virtual returns (address[] memory);\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint64 srcChainId, bytes32 sender) internal view virtual returns (bool);\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view virtual returns (bool);\n}\n\n// contracts/apps/ICAppV1.sol\n\nabstract contract ICAppV1 is AbstractICApp, AccessControlEnumerable, InterchainAppV1Events, IInterchainAppV1 {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Role to manage the Interchain setup of the app.\n    bytes32 public constant IC_GOVERNOR_ROLE = keccak256(\"IC_GOVERNOR_ROLE\");\n\n    /// @dev Address of the latest Interchain Client, used for sending messages.\n    address private _latestClient;\n\n    /// @dev Required responses and optimistic period for the module responses.\n    AppConfigV1 private _appConfigV1;\n    /// @dev Address of the linked app deployed on the remote chain.\n    mapping(uint64 chainId =\u003e bytes32 remoteApp) private _linkedApp;\n    /// @dev Interchain Clients allowed to send messages to this app.\n    EnumerableSet.AddressSet private _interchainClients;\n    /// @dev Trusted Interchain modules.\n    EnumerableSet.AddressSet private _trustedModules;\n    /// @dev Execution Service to use for sending messages.\n    address private _executionService;\n\n    constructor(address admin) {\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addInterchainClient(address client, bool updateLatest) external onlyRole(IC_GOVERNOR_ROLE) {\n        _addClient(client, updateLatest);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _removeClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setLatestInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _setLatestClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteApp(uint64 chainId, bytes32 remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteAppEVM(uint64 chainId, address remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp.addressToBytes32());\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (module == address(0)) {\n            revert InterchainApp__ModuleZeroAddress();\n        }\n        bool added = _trustedModules.add(module);\n        if (!added) {\n            revert InterchainApp__ModuleAlreadyAdded(module);\n        }\n        emit TrustedModuleAdded(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        bool removed = _trustedModules.remove(module);\n        if (!removed) {\n            revert InterchainApp__ModuleNotAdded(module);\n        }\n        emit TrustedModuleRemoved(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setAppConfigV1(AppConfigV1 memory appConfig) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (appConfig.requiredResponses == 0 || appConfig.optimisticPeriod == 0) {\n            revert InterchainApp__InvalidAppConfig(appConfig.requiredResponses, appConfig.optimisticPeriod);\n        }\n        _appConfigV1 = appConfig;\n        emit AppConfigV1Set(appConfig.requiredResponses, appConfig.optimisticPeriod);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setExecutionService(address executionService) external onlyRole(IC_GOVERNOR_ROLE) {\n        _executionService = executionService;\n        emit ExecutionServiceSet(executionService);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainAppV1\n    function getAppConfigV1() external view returns (AppConfigV1 memory) {\n        return _appConfigV1;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getExecutionService() external view returns (address) {\n        return _executionService;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getInterchainClients() external view returns (address[] memory) {\n        return _interchainClients.values();\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLatestInterchainClient() external view returns (address) {\n        return _latestClient;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedApp(uint64 chainId) external view returns (bytes32) {\n        return _linkedApp[chainId];\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedAppEVM(uint64 chainId) external view returns (address linkedAppEVM) {\n        bytes32 linkedApp = _linkedApp[chainId];\n        linkedAppEVM = linkedApp.bytes32ToAddress();\n        if (linkedAppEVM.addressToBytes32() != linkedApp) {\n            revert InterchainApp__NotEVMLinkedApp(linkedApp);\n        }\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getModules() external view returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Links the remote app to the current app.\n    /// Will revert if the chainId is the same as the chainId of the local app.\n    /// Note: Should be guarded with permissions check.\n    function _linkRemoteApp(uint64 chainId, bytes32 remoteApp) internal {\n        if (chainId == block.chainid) {\n            revert InterchainApp__SameChainId(chainId);\n        }\n        if (remoteApp == 0) {\n            revert InterchainApp__AppZeroAddress();\n        }\n        _linkedApp[chainId] = remoteApp;\n        emit AppLinked(chainId, remoteApp);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal override {\n        _latestClient = client;\n    }\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal override {\n        if (allowed) {\n            _interchainClients.add(client);\n        } else {\n            _interchainClients.remove(client);\n        }\n    }\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to send the message to the linked app.\n    function _sendToLinkedApp(\n        uint64 dstChainId,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _sendInterchainMessage(dstChainId, _linkedApp[dstChainId], messageFee, encodedOptions, message);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee to send a message to the linked app on the remote chain.\n    function _getMessageFee(\n        uint64 dstChainId,\n        OptionsV1 memory options,\n        uint256 messageLen\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _getInterchainFee(dstChainId, encodedOptions, messageLen);\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view override returns (bytes memory) {\n        return _appConfigV1.encodeAppConfigV1();\n    }\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view override returns (address) {\n        return _executionService;\n    }\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view override returns (address) {\n        return _latestClient;\n    }\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view override returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint64 srcChainId, bytes32 sender) internal view override returns (bool) {\n        return _linkedApp[srcChainId] == sender;\n    }\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view override returns (bool) {\n        return _interchainClients.contains(caller);\n    }\n}\n\n// contracts/apps/examples/ExampleAppV1.sol\n\ncontract ExampleAppV1 is ICAppV1 {\n    event MessageReceived(uint64 srcChainId, bytes32 sender, uint64 dbNonce, uint64 entryIndex, bytes message);\n    event MessageSent(uint64 dstChainId, uint64 dbNonce, uint64 entryIndex, bytes32 transactionId);\n\n    constructor(address admin) ICAppV1(admin) {\n        _grantRole(IC_GOVERNOR_ROLE, admin);\n    }\n\n    /// @notice Allows the Admin to withdraw the native asset from the contract.\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        Address.sendValue(payable(msg.sender), address(this).balance);\n    }\n\n    /// @notice Sends a basic message to the destination chain.\n    function sendMessage(\n        uint64 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        InterchainTxDescriptor memory desc = _sendToLinkedApp({\n            dstChainId: dstChainId,\n            messageFee: msg.value,\n            options: OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}),\n            message: message\n        });\n        emit MessageSent(dstChainId, desc.dbNonce, desc.entryIndex, desc.transactionId);\n    }\n\n    /// @notice Returns the fee required to send a message using `sendMessage`.\n    function getMessageFee(\n        uint64 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes memory message\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _getMessageFee(dstChainId, OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}), message.length);\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        override\n    {\n        emit MessageReceived(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"uint64","name":"srcChainId","type":"uint64"},{"internalType":"bytes32","name":"sender","type":"bytes32"},{"internalType":"uint64","name":"dbNonce","type":"uint64"},{"internalType":"uint64","name":"entryIndex","type":"uint64"},{"internalType":"bytes","name":"message","type":"bytes"}],"name":"appReceive","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"getReceivingConfig","outputs":[{"internalType":"bytes","name":"appConfig","type":"bytes"},{"internalType":"address[]","name":"modules","type":"address[]"}],"stateMutability":"view","type":"function"}],"userDoc":{"kind":"user","methods":{"appReceive(uint64,bytes32,uint64,uint64,bytes)":{"notice":"Allows the Interchain Client to pass the message to the Interchain App."},"getReceivingConfig()":{"notice":"Returns the verification configuration of the Interchain App."}},"notice":"Minimal interface for the Interchain App to work with the Interchain Client.","version":1},"developerDoc":{"kind":"dev","methods":{"appReceive(uint64,bytes32,uint64,uint64,bytes)":{"details":"App is responsible for keeping track of interchain clients, and must verify the message sender.","params":{"dbNonce":"The Interchain DB nonce of the batch containing the message entry.","entryIndex":"The index of the message entry within the batch.","message":"The message being sent.","sender":"Sender address on the source chain, as a bytes32 value.","srcChainId":"Chain ID of the source chain, where the message was sent from."}},"getReceivingConfig()":{"details":"This configuration is used by the Interchain Client to verify that message has been confirmed by the Interchain Modules on the destination chain. Note: V1 version of AppConfig includes the required responses count, and optimistic period after which the message is considered confirmed by the module. Following versions may include additional fields.","returns":{"appConfig":"   The versioned configuration of the Interchain App, encoded as bytes.","modules":"     The list of Interchain Modules that app is trusting to confirm the messages."}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"srcChainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"appReceive\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReceivingConfig\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"appConfig\",\"type\":\"bytes\"},{\"internalType\":\"address[]\",\"name\":\"modules\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"appReceive(uint64,bytes32,uint64,uint64,bytes)\":{\"details\":\"App is responsible for keeping track of interchain clients, and must verify the message sender.\",\"params\":{\"dbNonce\":\"The Interchain DB nonce of the batch containing the message entry.\",\"entryIndex\":\"The index of the message entry within the batch.\",\"message\":\"The message being sent.\",\"sender\":\"Sender address on the source chain, as a bytes32 value.\",\"srcChainId\":\"Chain ID of the source chain, where the message was sent from.\"}},\"getReceivingConfig()\":{\"details\":\"This configuration is used by the Interchain Client to verify that message has been confirmed by the Interchain Modules on the destination chain. Note: V1 version of AppConfig includes the required responses count, and optimistic period after which the message is considered confirmed by the module. Following versions may include additional fields.\",\"returns\":{\"appConfig\":\"   The versioned configuration of the Interchain App, encoded as bytes.\",\"modules\":\"     The list of Interchain Modules that app is trusting to confirm the messages.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"appReceive(uint64,bytes32,uint64,uint64,bytes)\":{\"notice\":\"Allows the Interchain Client to pass the message to the Interchain App.\"},\"getReceivingConfig()\":{\"notice\":\"Returns the verification configuration of the Interchain App.\"}},\"notice\":\"Minimal interface for the Interchain App to work with the Interchain Client.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/ExampleAppV1.sol\":\"IInterchainApp\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/ExampleAppV1.sol\":{\"keccak256\":\"0xb1e9550aef785a0afc4e03fc843839919987ba4f906f09992c6788979c3c0396\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://0ede697223dfa3a2e23501efc1ed5926d5ff6458ee7b9ba833e0587162166c79\",\"dweb:/ipfs/QmUzgopL2ptWG5DYNdGAcoErPnBC4KCoRp8C61dkHHRaA6\"]}},\"version\":1}"},"hashes":{"appReceive(uint64,bytes32,uint64,uint64,bytes)":"6e9fd609","getReceivingConfig()":"287bc057"}},"solidity/ExampleAppV1.sol:IInterchainAppV1":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/AbstractICAppEvents.sol\n\nabstract contract AbstractICAppEvents {\n    event InterchainClientAdded(address client);\n    event InterchainClientRemoved(address client);\n    event LatestClientSet(address client);\n}\n\n// contracts/events/InterchainAppV1Events.sol\n\nabstract contract InterchainAppV1Events {\n    event AppConfigV1Set(uint256 requiredResponses, uint256 optimisticPeriod);\n    event AppLinked(uint256 indexed chainId, bytes32 indexed remoteApp);\n    event ExecutionServiceSet(address executionService);\n    event TrustedModuleAdded(address module);\n    event TrustedModuleRemoved(address module);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    /// @notice Allows the Interchain Client to pass the message to the Interchain App.\n    /// @dev App is responsible for keeping track of interchain clients, and must verify the message sender.\n    /// @param srcChainId   Chain ID of the source chain, where the message was sent from.\n    /// @param sender       Sender address on the source chain, as a bytes32 value.\n    /// @param dbNonce      The Interchain DB nonce of the batch containing the message entry.\n    /// @param entryIndex   The index of the message entry within the batch.\n    /// @param message      The message being sent.\n    function appReceive(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /// @notice Returns the verification configuration of the Interchain App.\n    /// @dev This configuration is used by the Interchain Client to verify that message has been confirmed\n    /// by the Interchain Modules on the destination chain.\n    /// Note: V1 version of AppConfig includes the required responses count, and optimistic period after which\n    /// the message is considered confirmed by the module. Following versions may include additional fields.\n    /// @return appConfig    The versioned configuration of the Interchain App, encoded as bytes.\n    /// @return modules      The list of Interchain Modules that app is trusting to confirm the messages.\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/Math.sol\n\nlibrary MathLib {\n    /// @notice Rounds up to the nearest multiple of 32.\n    /// Note: Returns zero on overflows instead of reverting. This is fine for practical\n    /// use cases, as this is used for determining the size of the payload in memory.\n    function roundUpToWord(uint256 x) internal pure returns (uint256) {\n        unchecked {\n            return (x + 31) \u0026 ~uint256(31);\n        }\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/VersionedPayload.sol\n\n// solhint-disable no-inline-assembly\n// solhint-disable ordering\nlibrary VersionedPayloadLib {\n    /// @notice Amount of bytes reserved for the version (uint16) in the versioned payload\n    uint256 internal constant VERSION_LENGTH = 2;\n\n    error VersionedPayload__TooShort(bytes versionedPayload);\n    error VersionedPayload__PrecompileFailed();\n\n    /// @notice Encodes the versioned payload into a single bytes array.\n    /// @param version  The payload's version.\n    /// @param payload  The payload to encode.\n    function encodeVersionedPayload(uint16 version, bytes memory payload) internal pure returns (bytes memory) {\n        return abi.encodePacked(version, payload);\n    }\n\n    /// @notice Extracts the version from the versioned payload (calldata reference).\n    /// @param versionedPayload     The versioned payload (calldata reference).\n    function getVersion(bytes calldata versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            version := shr(240, calldataload(versionedPayload.offset))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (calldata reference).\n    /// @dev The extracted payload is also returned as a calldata reference.\n    /// @param versionedPayload     The versioned payload.\n    function getPayload(bytes calldata versionedPayload) internal pure returns (bytes calldata) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        return versionedPayload[VERSION_LENGTH:];\n    }\n\n    /// @notice Extracts the version from the versioned payload (memory reference).\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getVersionFromMemory(bytes memory versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            // We add 0x20 to skip the length of the bytes array.\n            version := shr(240, mload(add(versionedPayload, 0x20)))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (memory reference).\n    /// @dev The extracted payload is copied into a new memory location. Use `getPayload` when possible\n    /// to avoid extra memory allocation.\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getPayloadFromMemory(bytes memory versionedPayload) internal view returns (bytes memory payload) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        // Figure how many bytes to copy and allocate the memory for the extracted payload.\n        uint256 toCopy;\n        unchecked {\n            toCopy = versionedPayload.length - VERSION_LENGTH;\n        }\n        payload = new bytes(toCopy);\n        // Use identity precompile (0x04) to copy the payload. Unlike MCOPY, this is available on all EVM chains.\n        bool res;\n        assembly {\n            // We add 0x20 to skip the length of the bytes array.\n            // We add 0x02 to skip the 2 bytes reserved for the version.\n            // Copy the payload to the previously allocated memory.\n            res := staticcall(gas(), 0x04, add(versionedPayload, 0x22), toCopy, add(payload, 0x20), toCopy)\n        }\n        if (!res) {\n            revert VersionedPayload__PrecompileFailed();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/IAccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n\n// node_modules/@openzeppelin/contracts/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance \u003c amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance \u003c value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 \u0026\u0026 target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SafeCast.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value \u003e type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value \u003e type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value \u003e type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value \u003e type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value \u003e type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value \u003e type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value \u003e type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value \u003e type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value \u003e type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value \u003e type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value \u003e type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value \u003e type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value \u003e type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value \u003e type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value \u003e type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value \u003e type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value \u003e type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value \u003e type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value \u003e type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value \u003e type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value \u003e type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value \u003e type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value \u003e type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value \u003e type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value \u003e type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value \u003e type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value \u003e type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value \u003e type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value \u003e type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value \u003e type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value \u003e type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value \u003c 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value \u003e uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal view returns (AppConfigV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (AppConfigV1));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal view returns (OptionsV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (OptionsV1));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(OPTIONS_V1, abi.encode(options));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/IAccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/IAccessControlEnumerable.sol)\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n// contracts/interfaces/IInterchainAppV1.sol\n\ninterface IInterchainAppV1 is IInterchainApp {\n    error InterchainApp__AppZeroAddress();\n    error InterchainApp__InvalidAppConfig(uint256 requiredResponses, uint256 optimisticPeriod);\n    error InterchainApp__ModuleAlreadyAdded(address module);\n    error InterchainApp__ModuleNotAdded(address module);\n    error InterchainApp__ModuleZeroAddress();\n    error InterchainApp__NotEVMLinkedApp(bytes32 linkedApp);\n\n    /// @notice Allows the owner to add the interchain client to the allowed clients set,\n    /// and optionally set the latest client to this one.\n    /// Note: only the allowed clients can send messages to this app.\n    /// Note: the latest client is used for sending messages from this app.\n    /// @param client       The address of the interchain client to add.\n    /// @param updateLatest Whether to set the latest client to this one.\n    function addInterchainClient(address client, bool updateLatest) external;\n\n    /// @notice Allows the owner to remove the interchain client from the allowed clients set.\n    /// If the client is the latest client, the latest client is set to the zero address.\n    /// @param client       The address of the interchain client to remove.\n    function removeInterchainClient(address client) external;\n\n    /// @notice Allows the owner to set the address of the latest interchain client.\n    /// @dev The new latest client must be an allowed client or zero address.\n    /// Setting the client to zero address effectively pauses the app ability to send messages,\n    /// while allowing to receive them.\n    /// @param client       The address of the latest interchain client.\n    function setLatestInterchainClient(address client) external;\n\n    /// @notice Allows the owner to link the remote app for the given chain ID.\n    /// - This address will be used as the receiver for the messages sent from this chain.\n    /// - This address will be the only trusted sender for the messages sent to this chain.\n    /// @param chainId      The remote chain ID.\n    /// @param remoteApp    The address of the remote app to link.\n    function linkRemoteApp(uint64 chainId, bytes32 remoteApp) external;\n\n    /// @notice Thin wrapper for `linkRemoteApp` to accept EVM address as a parameter.\n    function linkRemoteAppEVM(uint64 chainId, address remoteApp) external;\n\n    /// @notice Allows the owner to add the module to the trusted modules set.\n    /// - This set of modules will be used to verify both sent and received messages.\n    function addTrustedModule(address module) external;\n\n    /// @notice Allows the owner to remove the module from the trusted modules set.\n    function removeTrustedModule(address module) external;\n\n    /// @notice Allows the owner to set the app config for the current app. App config includes:\n    /// - requiredResponses: the number of module responses required for accepting the message\n    /// - optimisticPeriod: the minimum time after which the module responses are considered final\n    function setAppConfigV1(AppConfigV1 memory appConfig) external;\n\n    /// @notice Allows the owner to set the address of the Execution Service.\n    /// This address will be used to request execution of the messages sent from this chain,\n    /// by supplying the Service's execution fee.\n    function setExecutionService(address executionService) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Returns the app config for the current app: requiredResponses and optimisticPeriod.\n    function getAppConfigV1() external view returns (AppConfigV1 memory);\n\n    /// @notice Returns the address of the Execution Service used by this app for sending messages.\n    function getExecutionService() external view returns (address);\n\n    /// @notice Returns the list of Interchain Clients allowed to send messages to this app.\n    function getInterchainClients() external view returns (address[] memory);\n\n    /// @notice Returns the address of the latest interchain client.\n    /// This address is used for sending messages from this app.\n    function getLatestInterchainClient() external view returns (address);\n\n    /// @notice Returns the linked app address (as bytes32) for the given chain ID.\n    function getLinkedApp(uint64 chainId) external view returns (bytes32);\n\n    /// @notice Thin wrapper for `getLinkedApp` to return the linked app address as EVM address.\n    /// @dev Will revert if the linked app address is not an EVM address.\n    function getLinkedAppEVM(uint64 chainId) external view returns (address);\n\n    /// @notice Returns the list of Interchain Modules trusted by this app.\n    /// This set of modules will be used to verify both sent and received messages.\n    function getModules() external view returns (address[] memory);\n}\n\n// contracts/libs/InterchainTransaction.sol\n\ntype ICTxHeader is uint256;\n\nstruct InterchainTransaction {\n    uint64 srcChainId;\n    uint64 dstChainId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcSender;\n    bytes32 dstReceiver;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    using MathLib for uint256;\n    using VersionedPayloadLib for bytes;\n\n    function constructLocalTransaction(\n        address srcSender,\n        uint64 dstChainId,\n        bytes32 dstReceiver,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: SafeCast.toUint64(block.chainid),\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            encodeTxHeader(transaction.srcChainId, transaction.dstChainId, transaction.dbNonce, transaction.entryIndex),\n            transaction.srcSender,\n            transaction.dstReceiver,\n            transaction.options,\n            transaction.message\n        );\n    }\n\n    function decodeTransaction(bytes calldata transaction) internal pure returns (InterchainTransaction memory icTx) {\n        ICTxHeader header;\n        (header, icTx.srcSender, icTx.dstReceiver, icTx.options, icTx.message) =\n            abi.decode(transaction, (ICTxHeader, bytes32, bytes32, bytes, bytes));\n        (icTx.srcChainId, icTx.dstChainId, icTx.dbNonce, icTx.entryIndex) = decodeTxHeader(header);\n    }\n\n    function payloadSize(uint256 optionsLen, uint256 messageLen) internal pure returns (uint256) {\n        // 2 bytes are reserved for the transaction version\n        // + 5 fields * 32 bytes (3 values for static, 2 offsets for dynamic) + 2 * 32 bytes (lengths for dynamic) = 226\n        // (srcChainId, dstChainId, dbNonce, entryIndex) are merged into a single 32 bytes field\n        // Both options and message are dynamic fields, which are padded up to 32 bytes\n        return 226 + optionsLen.roundUpToWord() + messageLen.roundUpToWord();\n    }\n\n    function encodeTxHeader(\n        uint64 srcChainId,\n        uint64 dstChainId,\n        uint64 dbNonce,\n        uint64 entryIndex\n    )\n        internal\n        pure\n        returns (ICTxHeader)\n    {\n        return ICTxHeader.wrap(\n            (uint256(srcChainId) \u003c\u003c 192) | (uint256(dstChainId) \u003c\u003c 128) | (uint256(dbNonce) \u003c\u003c 64) | uint256(entryIndex)\n        );\n    }\n\n    function decodeTxHeader(ICTxHeader header)\n        internal\n        pure\n        returns (uint64 srcChainId, uint64 dstChainId, uint64 dbNonce, uint64 entryIndex)\n    {\n        srcChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 192);\n        dstChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 128);\n        dbNonce = uint64(ICTxHeader.unwrap(header) \u003e\u003e 64);\n        entryIndex = uint64(ICTxHeader.unwrap(header));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/AccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account =\u003e bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role =\u003e RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint64 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__InvalidTransactionVersion(uint16 version);\n    error InterchainClientV1__NoLinkedClient(uint64 chainId);\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint64 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint64 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint64 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint64 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param messageLen           The length of the message being sent.\n    function getInterchainFee(\n        uint64 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        uint256 messageLen\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint64 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint64 chainId) external view returns (address);\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/AccessControlEnumerable.sol)\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 role =\u003e EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {AccessControl-_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool granted = super._grantRole(role, account);\n        if (granted) {\n            _roleMembers[role].add(account);\n        }\n        return granted;\n    }\n\n    /**\n     * @dev Overload {AccessControl-_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool revoked = super._revokeRole(role, account);\n        if (revoked) {\n            _roleMembers[role].remove(account);\n        }\n        return revoked;\n    }\n}\n\n// contracts/apps/AbstractICApp.sol\n\nabstract contract AbstractICApp is AbstractICAppEvents, IInterchainApp {\n    using TypeCasts for address;\n\n    error InterchainApp__AlreadyLatestClient(address client);\n    error InterchainApp__BalanceTooLow(uint256 actual, uint256 required);\n    error InterchainApp__ClientAlreadyAdded(address client);\n    error InterchainApp__InterchainClientZeroAddress();\n    error InterchainApp__NotInterchainClient(address account);\n    error InterchainApp__ReceiverNotSet(uint64 chainId);\n    error InterchainApp__SameChainId(uint64 chainId);\n    error InterchainApp__SenderNotAllowed(uint64 srcChainId, bytes32 sender);\n\n    /// @inheritdoc IInterchainApp\n    function appReceive(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        if (!_isInterchainClient(msg.sender)) {\n            revert InterchainApp__NotInterchainClient(msg.sender);\n        }\n        if (srcChainId == block.chainid) {\n            revert InterchainApp__SameChainId(srcChainId);\n        }\n        if (!_isAllowedSender(srcChainId, sender)) {\n            revert InterchainApp__SenderNotAllowed(srcChainId, sender);\n        }\n        _receiveMessage(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n\n    /// @inheritdoc IInterchainApp\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules) {\n        appConfig = _getAppConfig();\n        modules = _getModules();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Performs necessary checks and adds an Interchain Client.\n    /// Optionally sets the latest client to this one.\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _addClient(address client, bool updateLatest) internal {\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (_isInterchainClient(client)) {\n            revert InterchainApp__ClientAlreadyAdded(client);\n        }\n        _toggleClientState(client, true);\n        emit InterchainClientAdded(client);\n        if (updateLatest) {\n            _setLatestClient(client);\n        }\n    }\n\n    /// @dev Performs necessary checks and removes an Interchain Client. If this client is the latest one,\n    /// the latest client is set to zero address (effectively pausing the app ability to send messages).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _removeClient(address client) internal {\n        if (!_isInterchainClient(client)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        _toggleClientState(client, false);\n        emit InterchainClientRemoved(client);\n        if (client == _getLatestClient()) {\n            _setLatestClient(address(0));\n        }\n    }\n\n    /// @dev Sets the latest Interchain Client to one of the allowed clients. Setting the client to zero address\n    /// is allowed and effectively pauses the app ability to send messages (but still allows to receive them).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _setLatestClient(address client) internal {\n        // New latest client must be an allowed client or zero address.\n        if (!_isInterchainClient(client) \u0026\u0026 client != address(0)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        if (client == _getLatestClient()) {\n            revert InterchainApp__AlreadyLatestClient(client);\n        }\n        _storeLatestClient(client);\n        emit LatestClientSet(client);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal virtual;\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal virtual;\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to accept EVM address as a parameter.\n    function _sendInterchainMessageEVM(\n        uint64 dstChainId,\n        address receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _sendInterchainMessage(dstChainId, receiver.addressToBytes32(), messageFee, options, message);\n    }\n\n    /// @dev Performs necessary checks and sends an interchain message.\n    function _sendInterchainMessage(\n        uint64 dstChainId,\n        bytes32 receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (dstChainId == block.chainid) {\n            revert InterchainApp__SameChainId(dstChainId);\n        }\n        if (receiver == 0) {\n            revert InterchainApp__ReceiverNotSet(dstChainId);\n        }\n        if (address(this).balance \u003c messageFee) {\n            revert InterchainApp__BalanceTooLow({actual: address(this).balance, required: messageFee});\n        }\n        return IInterchainClientV1(client).interchainSend{value: messageFee}(\n            dstChainId, receiver, _getExecutionService(), _getModules(), options, message\n        );\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        virtual;\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee for sending an Interchain message.\n    function _getInterchainFee(\n        uint64 dstChainId,\n        bytes memory options,\n        uint256 messageLen\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        return IInterchainClientV1(client).getInterchainFee(\n            dstChainId, _getExecutionService(), _getModules(), options, messageLen\n        );\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view virtual returns (bytes memory);\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view virtual returns (address);\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view virtual returns (address);\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view virtual returns (address[] memory);\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint64 srcChainId, bytes32 sender) internal view virtual returns (bool);\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view virtual returns (bool);\n}\n\n// contracts/apps/ICAppV1.sol\n\nabstract contract ICAppV1 is AbstractICApp, AccessControlEnumerable, InterchainAppV1Events, IInterchainAppV1 {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Role to manage the Interchain setup of the app.\n    bytes32 public constant IC_GOVERNOR_ROLE = keccak256(\"IC_GOVERNOR_ROLE\");\n\n    /// @dev Address of the latest Interchain Client, used for sending messages.\n    address private _latestClient;\n\n    /// @dev Required responses and optimistic period for the module responses.\n    AppConfigV1 private _appConfigV1;\n    /// @dev Address of the linked app deployed on the remote chain.\n    mapping(uint64 chainId =\u003e bytes32 remoteApp) private _linkedApp;\n    /// @dev Interchain Clients allowed to send messages to this app.\n    EnumerableSet.AddressSet private _interchainClients;\n    /// @dev Trusted Interchain modules.\n    EnumerableSet.AddressSet private _trustedModules;\n    /// @dev Execution Service to use for sending messages.\n    address private _executionService;\n\n    constructor(address admin) {\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addInterchainClient(address client, bool updateLatest) external onlyRole(IC_GOVERNOR_ROLE) {\n        _addClient(client, updateLatest);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _removeClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setLatestInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _setLatestClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteApp(uint64 chainId, bytes32 remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteAppEVM(uint64 chainId, address remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp.addressToBytes32());\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (module == address(0)) {\n            revert InterchainApp__ModuleZeroAddress();\n        }\n        bool added = _trustedModules.add(module);\n        if (!added) {\n            revert InterchainApp__ModuleAlreadyAdded(module);\n        }\n        emit TrustedModuleAdded(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        bool removed = _trustedModules.remove(module);\n        if (!removed) {\n            revert InterchainApp__ModuleNotAdded(module);\n        }\n        emit TrustedModuleRemoved(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setAppConfigV1(AppConfigV1 memory appConfig) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (appConfig.requiredResponses == 0 || appConfig.optimisticPeriod == 0) {\n            revert InterchainApp__InvalidAppConfig(appConfig.requiredResponses, appConfig.optimisticPeriod);\n        }\n        _appConfigV1 = appConfig;\n        emit AppConfigV1Set(appConfig.requiredResponses, appConfig.optimisticPeriod);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setExecutionService(address executionService) external onlyRole(IC_GOVERNOR_ROLE) {\n        _executionService = executionService;\n        emit ExecutionServiceSet(executionService);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainAppV1\n    function getAppConfigV1() external view returns (AppConfigV1 memory) {\n        return _appConfigV1;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getExecutionService() external view returns (address) {\n        return _executionService;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getInterchainClients() external view returns (address[] memory) {\n        return _interchainClients.values();\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLatestInterchainClient() external view returns (address) {\n        return _latestClient;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedApp(uint64 chainId) external view returns (bytes32) {\n        return _linkedApp[chainId];\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedAppEVM(uint64 chainId) external view returns (address linkedAppEVM) {\n        bytes32 linkedApp = _linkedApp[chainId];\n        linkedAppEVM = linkedApp.bytes32ToAddress();\n        if (linkedAppEVM.addressToBytes32() != linkedApp) {\n            revert InterchainApp__NotEVMLinkedApp(linkedApp);\n        }\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getModules() external view returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Links the remote app to the current app.\n    /// Will revert if the chainId is the same as the chainId of the local app.\n    /// Note: Should be guarded with permissions check.\n    function _linkRemoteApp(uint64 chainId, bytes32 remoteApp) internal {\n        if (chainId == block.chainid) {\n            revert InterchainApp__SameChainId(chainId);\n        }\n        if (remoteApp == 0) {\n            revert InterchainApp__AppZeroAddress();\n        }\n        _linkedApp[chainId] = remoteApp;\n        emit AppLinked(chainId, remoteApp);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal override {\n        _latestClient = client;\n    }\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal override {\n        if (allowed) {\n            _interchainClients.add(client);\n        } else {\n            _interchainClients.remove(client);\n        }\n    }\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to send the message to the linked app.\n    function _sendToLinkedApp(\n        uint64 dstChainId,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _sendInterchainMessage(dstChainId, _linkedApp[dstChainId], messageFee, encodedOptions, message);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee to send a message to the linked app on the remote chain.\n    function _getMessageFee(\n        uint64 dstChainId,\n        OptionsV1 memory options,\n        uint256 messageLen\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _getInterchainFee(dstChainId, encodedOptions, messageLen);\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view override returns (bytes memory) {\n        return _appConfigV1.encodeAppConfigV1();\n    }\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view override returns (address) {\n        return _executionService;\n    }\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view override returns (address) {\n        return _latestClient;\n    }\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view override returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint64 srcChainId, bytes32 sender) internal view override returns (bool) {\n        return _linkedApp[srcChainId] == sender;\n    }\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view override returns (bool) {\n        return _interchainClients.contains(caller);\n    }\n}\n\n// contracts/apps/examples/ExampleAppV1.sol\n\ncontract ExampleAppV1 is ICAppV1 {\n    event MessageReceived(uint64 srcChainId, bytes32 sender, uint64 dbNonce, uint64 entryIndex, bytes message);\n    event MessageSent(uint64 dstChainId, uint64 dbNonce, uint64 entryIndex, bytes32 transactionId);\n\n    constructor(address admin) ICAppV1(admin) {\n        _grantRole(IC_GOVERNOR_ROLE, admin);\n    }\n\n    /// @notice Allows the Admin to withdraw the native asset from the contract.\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        Address.sendValue(payable(msg.sender), address(this).balance);\n    }\n\n    /// @notice Sends a basic message to the destination chain.\n    function sendMessage(\n        uint64 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        InterchainTxDescriptor memory desc = _sendToLinkedApp({\n            dstChainId: dstChainId,\n            messageFee: msg.value,\n            options: OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}),\n            message: message\n        });\n        emit MessageSent(dstChainId, desc.dbNonce, desc.entryIndex, desc.transactionId);\n    }\n\n    /// @notice Returns the fee required to send a message using `sendMessage`.\n    function getMessageFee(\n        uint64 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes memory message\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _getMessageFee(dstChainId, OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}), message.length);\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        override\n    {\n        emit MessageReceived(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[],"name":"InterchainApp__AppZeroAddress","type":"error"},{"inputs":[{"internalType":"uint256","name":"requiredResponses","type":"uint256"},{"internalType":"uint256","name":"optimisticPeriod","type":"uint256"}],"name":"InterchainApp__InvalidAppConfig","type":"error"},{"inputs":[{"internalType":"address","name":"module","type":"address"}],"name":"InterchainApp__ModuleAlreadyAdded","type":"error"},{"inputs":[{"internalType":"address","name":"module","type":"address"}],"name":"InterchainApp__ModuleNotAdded","type":"error"},{"inputs":[],"name":"InterchainApp__ModuleZeroAddress","type":"error"},{"inputs":[{"internalType":"bytes32","name":"linkedApp","type":"bytes32"}],"name":"InterchainApp__NotEVMLinkedApp","type":"error"},{"inputs":[{"internalType":"address","name":"client","type":"address"},{"internalType":"bool","name":"updateLatest","type":"bool"}],"name":"addInterchainClient","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"module","type":"address"}],"name":"addTrustedModule","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint64","name":"srcChainId","type":"uint64"},{"internalType":"bytes32","name":"sender","type":"bytes32"},{"internalType":"uint64","name":"dbNonce","type":"uint64"},{"internalType":"uint64","name":"entryIndex","type":"uint64"},{"internalType":"bytes","name":"message","type":"bytes"}],"name":"appReceive","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"getAppConfigV1","outputs":[{"components":[{"internalType":"uint256","name":"requiredResponses","type":"uint256"},{"internalType":"uint256","name":"optimisticPeriod","type":"uint256"}],"internalType":"struct AppConfigV1","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getExecutionService","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getInterchainClients","outputs":[{"internalType":"address[]","name":"","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getLatestInterchainClient","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint64","name":"chainId","type":"uint64"}],"name":"getLinkedApp","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint64","name":"chainId","type":"uint64"}],"name":"getLinkedAppEVM","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getModules","outputs":[{"internalType":"address[]","name":"","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getReceivingConfig","outputs":[{"internalType":"bytes","name":"appConfig","type":"bytes"},{"internalType":"address[]","name":"modules","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint64","name":"chainId","type":"uint64"},{"internalType":"bytes32","name":"remoteApp","type":"bytes32"}],"name":"linkRemoteApp","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint64","name":"chainId","type":"uint64"},{"internalType":"address","name":"remoteApp","type":"address"}],"name":"linkRemoteAppEVM","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"client","type":"address"}],"name":"removeInterchainClient","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"module","type":"address"}],"name":"removeTrustedModule","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"components":[{"internalType":"uint256","name":"requiredResponses","type":"uint256"},{"internalType":"uint256","name":"optimisticPeriod","type":"uint256"}],"internalType":"struct AppConfigV1","name":"appConfig","type":"tuple"}],"name":"setAppConfigV1","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"executionService","type":"address"}],"name":"setExecutionService","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"client","type":"address"}],"name":"setLatestInterchainClient","outputs":[],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{"addInterchainClient(address,bool)":{"notice":"Allows the owner to add the interchain client to the allowed clients set, and optionally set the latest client to this one. Note: only the allowed clients can send messages to this app. Note: the latest client is used for sending messages from this app."},"addTrustedModule(address)":{"notice":"Allows the owner to add the module to the trusted modules set. - This set of modules will be used to verify both sent and received messages."},"appReceive(uint64,bytes32,uint64,uint64,bytes)":{"notice":"Allows the Interchain Client to pass the message to the Interchain App."},"getAppConfigV1()":{"notice":"Returns the app config for the current app: requiredResponses and optimisticPeriod."},"getExecutionService()":{"notice":"Returns the address of the Execution Service used by this app for sending messages."},"getInterchainClients()":{"notice":"Returns the list of Interchain Clients allowed to send messages to this app."},"getLatestInterchainClient()":{"notice":"Returns the address of the latest interchain client. This address is used for sending messages from this app."},"getLinkedApp(uint64)":{"notice":"Returns the linked app address (as bytes32) for the given chain ID."},"getLinkedAppEVM(uint64)":{"notice":"Thin wrapper for `getLinkedApp` to return the linked app address as EVM address."},"getModules()":{"notice":"Returns the list of Interchain Modules trusted by this app. This set of modules will be used to verify both sent and received messages."},"getReceivingConfig()":{"notice":"Returns the verification configuration of the Interchain App."},"linkRemoteApp(uint64,bytes32)":{"notice":"Allows the owner to link the remote app for the given chain ID. - This address will be used as the receiver for the messages sent from this chain. - This address will be the only trusted sender for the messages sent to this chain."},"linkRemoteAppEVM(uint64,address)":{"notice":"Thin wrapper for `linkRemoteApp` to accept EVM address as a parameter."},"removeInterchainClient(address)":{"notice":"Allows the owner to remove the interchain client from the allowed clients set. If the client is the latest client, the latest client is set to the zero address."},"removeTrustedModule(address)":{"notice":"Allows the owner to remove the module from the trusted modules set."},"setAppConfigV1((uint256,uint256))":{"notice":"Allows the owner to set the app config for the current app. App config includes: - requiredResponses: the number of module responses required for accepting the message - optimisticPeriod: the minimum time after which the module responses are considered final"},"setExecutionService(address)":{"notice":"Allows the owner to set the address of the Execution Service. This address will be used to request execution of the messages sent from this chain, by supplying the Service's execution fee."},"setLatestInterchainClient(address)":{"notice":"Allows the owner to set the address of the latest interchain client."}},"version":1},"developerDoc":{"kind":"dev","methods":{"addInterchainClient(address,bool)":{"params":{"client":"The address of the interchain client to add.","updateLatest":"Whether to set the latest client to this one."}},"appReceive(uint64,bytes32,uint64,uint64,bytes)":{"details":"App is responsible for keeping track of interchain clients, and must verify the message sender.","params":{"dbNonce":"The Interchain DB nonce of the batch containing the message entry.","entryIndex":"The index of the message entry within the batch.","message":"The message being sent.","sender":"Sender address on the source chain, as a bytes32 value.","srcChainId":"Chain ID of the source chain, where the message was sent from."}},"getLinkedAppEVM(uint64)":{"details":"Will revert if the linked app address is not an EVM address."},"getReceivingConfig()":{"details":"This configuration is used by the Interchain Client to verify that message has been confirmed by the Interchain Modules on the destination chain. Note: V1 version of AppConfig includes the required responses count, and optimistic period after which the message is considered confirmed by the module. Following versions may include additional fields.","returns":{"appConfig":"   The versioned configuration of the Interchain App, encoded as bytes.","modules":"     The list of Interchain Modules that app is trusting to confirm the messages."}},"linkRemoteApp(uint64,bytes32)":{"params":{"chainId":"The remote chain ID.","remoteApp":"The address of the remote app to link."}},"removeInterchainClient(address)":{"params":{"client":"The address of the interchain client to remove."}},"setLatestInterchainClient(address)":{"details":"The new latest client must be an allowed client or zero address. Setting the client to zero address effectively pauses the app ability to send messages, while allowing to receive them.","params":{"client":"The address of the latest interchain client."}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"InterchainApp__AppZeroAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requiredResponses\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"optimisticPeriod\",\"type\":\"uint256\"}],\"name\":\"InterchainApp__InvalidAppConfig\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"InterchainApp__ModuleAlreadyAdded\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"InterchainApp__ModuleNotAdded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InterchainApp__ModuleZeroAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"linkedApp\",\"type\":\"bytes32\"}],\"name\":\"InterchainApp__NotEVMLinkedApp\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"updateLatest\",\"type\":\"bool\"}],\"name\":\"addInterchainClient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"addTrustedModule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"srcChainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"appReceive\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAppConfigV1\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"requiredResponses\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"optimisticPeriod\",\"type\":\"uint256\"}],\"internalType\":\"struct AppConfigV1\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getExecutionService\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getInterchainClients\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLatestInterchainClient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"}],\"name\":\"getLinkedApp\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"}],\"name\":\"getLinkedAppEVM\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getModules\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReceivingConfig\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"appConfig\",\"type\":\"bytes\"},{\"internalType\":\"address[]\",\"name\":\"modules\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"remoteApp\",\"type\":\"bytes32\"}],\"name\":\"linkRemoteApp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"remoteApp\",\"type\":\"address\"}],\"name\":\"linkRemoteAppEVM\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"}],\"name\":\"removeInterchainClient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"removeTrustedModule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"requiredResponses\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"optimisticPeriod\",\"type\":\"uint256\"}],\"internalType\":\"struct AppConfigV1\",\"name\":\"appConfig\",\"type\":\"tuple\"}],\"name\":\"setAppConfigV1\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"executionService\",\"type\":\"address\"}],\"name\":\"setExecutionService\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"}],\"name\":\"setLatestInterchainClient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"addInterchainClient(address,bool)\":{\"params\":{\"client\":\"The address of the interchain client to add.\",\"updateLatest\":\"Whether to set the latest client to this one.\"}},\"appReceive(uint64,bytes32,uint64,uint64,bytes)\":{\"details\":\"App is responsible for keeping track of interchain clients, and must verify the message sender.\",\"params\":{\"dbNonce\":\"The Interchain DB nonce of the batch containing the message entry.\",\"entryIndex\":\"The index of the message entry within the batch.\",\"message\":\"The message being sent.\",\"sender\":\"Sender address on the source chain, as a bytes32 value.\",\"srcChainId\":\"Chain ID of the source chain, where the message was sent from.\"}},\"getLinkedAppEVM(uint64)\":{\"details\":\"Will revert if the linked app address is not an EVM address.\"},\"getReceivingConfig()\":{\"details\":\"This configuration is used by the Interchain Client to verify that message has been confirmed by the Interchain Modules on the destination chain. Note: V1 version of AppConfig includes the required responses count, and optimistic period after which the message is considered confirmed by the module. Following versions may include additional fields.\",\"returns\":{\"appConfig\":\"   The versioned configuration of the Interchain App, encoded as bytes.\",\"modules\":\"     The list of Interchain Modules that app is trusting to confirm the messages.\"}},\"linkRemoteApp(uint64,bytes32)\":{\"params\":{\"chainId\":\"The remote chain ID.\",\"remoteApp\":\"The address of the remote app to link.\"}},\"removeInterchainClient(address)\":{\"params\":{\"client\":\"The address of the interchain client to remove.\"}},\"setLatestInterchainClient(address)\":{\"details\":\"The new latest client must be an allowed client or zero address. Setting the client to zero address effectively pauses the app ability to send messages, while allowing to receive them.\",\"params\":{\"client\":\"The address of the latest interchain client.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"addInterchainClient(address,bool)\":{\"notice\":\"Allows the owner to add the interchain client to the allowed clients set, and optionally set the latest client to this one. Note: only the allowed clients can send messages to this app. Note: the latest client is used for sending messages from this app.\"},\"addTrustedModule(address)\":{\"notice\":\"Allows the owner to add the module to the trusted modules set. - This set of modules will be used to verify both sent and received messages.\"},\"appReceive(uint64,bytes32,uint64,uint64,bytes)\":{\"notice\":\"Allows the Interchain Client to pass the message to the Interchain App.\"},\"getAppConfigV1()\":{\"notice\":\"Returns the app config for the current app: requiredResponses and optimisticPeriod.\"},\"getExecutionService()\":{\"notice\":\"Returns the address of the Execution Service used by this app for sending messages.\"},\"getInterchainClients()\":{\"notice\":\"Returns the list of Interchain Clients allowed to send messages to this app.\"},\"getLatestInterchainClient()\":{\"notice\":\"Returns the address of the latest interchain client. This address is used for sending messages from this app.\"},\"getLinkedApp(uint64)\":{\"notice\":\"Returns the linked app address (as bytes32) for the given chain ID.\"},\"getLinkedAppEVM(uint64)\":{\"notice\":\"Thin wrapper for `getLinkedApp` to return the linked app address as EVM address.\"},\"getModules()\":{\"notice\":\"Returns the list of Interchain Modules trusted by this app. This set of modules will be used to verify both sent and received messages.\"},\"getReceivingConfig()\":{\"notice\":\"Returns the verification configuration of the Interchain App.\"},\"linkRemoteApp(uint64,bytes32)\":{\"notice\":\"Allows the owner to link the remote app for the given chain ID. - This address will be used as the receiver for the messages sent from this chain. - This address will be the only trusted sender for the messages sent to this chain.\"},\"linkRemoteAppEVM(uint64,address)\":{\"notice\":\"Thin wrapper for `linkRemoteApp` to accept EVM address as a parameter.\"},\"removeInterchainClient(address)\":{\"notice\":\"Allows the owner to remove the interchain client from the allowed clients set. If the client is the latest client, the latest client is set to the zero address.\"},\"removeTrustedModule(address)\":{\"notice\":\"Allows the owner to remove the module from the trusted modules set.\"},\"setAppConfigV1((uint256,uint256))\":{\"notice\":\"Allows the owner to set the app config for the current app. App config includes: - requiredResponses: the number of module responses required for accepting the message - optimisticPeriod: the minimum time after which the module responses are considered final\"},\"setExecutionService(address)\":{\"notice\":\"Allows the owner to set the address of the Execution Service. This address will be used to request execution of the messages sent from this chain, by supplying the Service's execution fee.\"},\"setLatestInterchainClient(address)\":{\"notice\":\"Allows the owner to set the address of the latest interchain client.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/ExampleAppV1.sol\":\"IInterchainAppV1\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/ExampleAppV1.sol\":{\"keccak256\":\"0xb1e9550aef785a0afc4e03fc843839919987ba4f906f09992c6788979c3c0396\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://0ede697223dfa3a2e23501efc1ed5926d5ff6458ee7b9ba833e0587162166c79\",\"dweb:/ipfs/QmUzgopL2ptWG5DYNdGAcoErPnBC4KCoRp8C61dkHHRaA6\"]}},\"version\":1}"},"hashes":{"addInterchainClient(address,bool)":"f22ba23d","addTrustedModule(address)":"cb5038fb","appReceive(uint64,bytes32,uint64,uint64,bytes)":"6e9fd609","getAppConfigV1()":"7717a647","getExecutionService()":"c313c807","getInterchainClients()":"a1aa5d68","getLatestInterchainClient()":"bc0d912c","getLinkedApp(uint64)":"4e6427e7","getLinkedAppEVM(uint64)":"90a92c16","getModules()":"b2494df3","getReceivingConfig()":"287bc057","linkRemoteApp(uint64,bytes32)":"f6b266fd","linkRemoteAppEVM(uint64,address)":"1856ddfe","removeInterchainClient(address)":"0fb59156","removeTrustedModule(address)":"b70c40b3","setAppConfigV1((uint256,uint256))":"0d32b505","setExecutionService(address)":"496774b1","setLatestInterchainClient(address)":"eb53b44e"}},"solidity/ExampleAppV1.sol:IInterchainClientV1":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/AbstractICAppEvents.sol\n\nabstract contract AbstractICAppEvents {\n    event InterchainClientAdded(address client);\n    event InterchainClientRemoved(address client);\n    event LatestClientSet(address client);\n}\n\n// contracts/events/InterchainAppV1Events.sol\n\nabstract contract InterchainAppV1Events {\n    event AppConfigV1Set(uint256 requiredResponses, uint256 optimisticPeriod);\n    event AppLinked(uint256 indexed chainId, bytes32 indexed remoteApp);\n    event ExecutionServiceSet(address executionService);\n    event TrustedModuleAdded(address module);\n    event TrustedModuleRemoved(address module);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    /// @notice Allows the Interchain Client to pass the message to the Interchain App.\n    /// @dev App is responsible for keeping track of interchain clients, and must verify the message sender.\n    /// @param srcChainId   Chain ID of the source chain, where the message was sent from.\n    /// @param sender       Sender address on the source chain, as a bytes32 value.\n    /// @param dbNonce      The Interchain DB nonce of the batch containing the message entry.\n    /// @param entryIndex   The index of the message entry within the batch.\n    /// @param message      The message being sent.\n    function appReceive(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /// @notice Returns the verification configuration of the Interchain App.\n    /// @dev This configuration is used by the Interchain Client to verify that message has been confirmed\n    /// by the Interchain Modules on the destination chain.\n    /// Note: V1 version of AppConfig includes the required responses count, and optimistic period after which\n    /// the message is considered confirmed by the module. Following versions may include additional fields.\n    /// @return appConfig    The versioned configuration of the Interchain App, encoded as bytes.\n    /// @return modules      The list of Interchain Modules that app is trusting to confirm the messages.\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/Math.sol\n\nlibrary MathLib {\n    /// @notice Rounds up to the nearest multiple of 32.\n    /// Note: Returns zero on overflows instead of reverting. This is fine for practical\n    /// use cases, as this is used for determining the size of the payload in memory.\n    function roundUpToWord(uint256 x) internal pure returns (uint256) {\n        unchecked {\n            return (x + 31) \u0026 ~uint256(31);\n        }\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/VersionedPayload.sol\n\n// solhint-disable no-inline-assembly\n// solhint-disable ordering\nlibrary VersionedPayloadLib {\n    /// @notice Amount of bytes reserved for the version (uint16) in the versioned payload\n    uint256 internal constant VERSION_LENGTH = 2;\n\n    error VersionedPayload__TooShort(bytes versionedPayload);\n    error VersionedPayload__PrecompileFailed();\n\n    /// @notice Encodes the versioned payload into a single bytes array.\n    /// @param version  The payload's version.\n    /// @param payload  The payload to encode.\n    function encodeVersionedPayload(uint16 version, bytes memory payload) internal pure returns (bytes memory) {\n        return abi.encodePacked(version, payload);\n    }\n\n    /// @notice Extracts the version from the versioned payload (calldata reference).\n    /// @param versionedPayload     The versioned payload (calldata reference).\n    function getVersion(bytes calldata versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            version := shr(240, calldataload(versionedPayload.offset))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (calldata reference).\n    /// @dev The extracted payload is also returned as a calldata reference.\n    /// @param versionedPayload     The versioned payload.\n    function getPayload(bytes calldata versionedPayload) internal pure returns (bytes calldata) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        return versionedPayload[VERSION_LENGTH:];\n    }\n\n    /// @notice Extracts the version from the versioned payload (memory reference).\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getVersionFromMemory(bytes memory versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            // We add 0x20 to skip the length of the bytes array.\n            version := shr(240, mload(add(versionedPayload, 0x20)))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (memory reference).\n    /// @dev The extracted payload is copied into a new memory location. Use `getPayload` when possible\n    /// to avoid extra memory allocation.\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getPayloadFromMemory(bytes memory versionedPayload) internal view returns (bytes memory payload) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        // Figure how many bytes to copy and allocate the memory for the extracted payload.\n        uint256 toCopy;\n        unchecked {\n            toCopy = versionedPayload.length - VERSION_LENGTH;\n        }\n        payload = new bytes(toCopy);\n        // Use identity precompile (0x04) to copy the payload. Unlike MCOPY, this is available on all EVM chains.\n        bool res;\n        assembly {\n            // We add 0x20 to skip the length of the bytes array.\n            // We add 0x02 to skip the 2 bytes reserved for the version.\n            // Copy the payload to the previously allocated memory.\n            res := staticcall(gas(), 0x04, add(versionedPayload, 0x22), toCopy, add(payload, 0x20), toCopy)\n        }\n        if (!res) {\n            revert VersionedPayload__PrecompileFailed();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/IAccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n\n// node_modules/@openzeppelin/contracts/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance \u003c amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance \u003c value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 \u0026\u0026 target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SafeCast.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value \u003e type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value \u003e type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value \u003e type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value \u003e type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value \u003e type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value \u003e type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value \u003e type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value \u003e type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value \u003e type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value \u003e type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value \u003e type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value \u003e type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value \u003e type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value \u003e type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value \u003e type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value \u003e type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value \u003e type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value \u003e type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value \u003e type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value \u003e type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value \u003e type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value \u003e type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value \u003e type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value \u003e type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value \u003e type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value \u003e type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value \u003e type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value \u003e type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value \u003e type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value \u003e type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value \u003e type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value \u003c 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value \u003e uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal view returns (AppConfigV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (AppConfigV1));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal view returns (OptionsV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (OptionsV1));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(OPTIONS_V1, abi.encode(options));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/IAccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/IAccessControlEnumerable.sol)\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n// contracts/interfaces/IInterchainAppV1.sol\n\ninterface IInterchainAppV1 is IInterchainApp {\n    error InterchainApp__AppZeroAddress();\n    error InterchainApp__InvalidAppConfig(uint256 requiredResponses, uint256 optimisticPeriod);\n    error InterchainApp__ModuleAlreadyAdded(address module);\n    error InterchainApp__ModuleNotAdded(address module);\n    error InterchainApp__ModuleZeroAddress();\n    error InterchainApp__NotEVMLinkedApp(bytes32 linkedApp);\n\n    /// @notice Allows the owner to add the interchain client to the allowed clients set,\n    /// and optionally set the latest client to this one.\n    /// Note: only the allowed clients can send messages to this app.\n    /// Note: the latest client is used for sending messages from this app.\n    /// @param client       The address of the interchain client to add.\n    /// @param updateLatest Whether to set the latest client to this one.\n    function addInterchainClient(address client, bool updateLatest) external;\n\n    /// @notice Allows the owner to remove the interchain client from the allowed clients set.\n    /// If the client is the latest client, the latest client is set to the zero address.\n    /// @param client       The address of the interchain client to remove.\n    function removeInterchainClient(address client) external;\n\n    /// @notice Allows the owner to set the address of the latest interchain client.\n    /// @dev The new latest client must be an allowed client or zero address.\n    /// Setting the client to zero address effectively pauses the app ability to send messages,\n    /// while allowing to receive them.\n    /// @param client       The address of the latest interchain client.\n    function setLatestInterchainClient(address client) external;\n\n    /// @notice Allows the owner to link the remote app for the given chain ID.\n    /// - This address will be used as the receiver for the messages sent from this chain.\n    /// - This address will be the only trusted sender for the messages sent to this chain.\n    /// @param chainId      The remote chain ID.\n    /// @param remoteApp    The address of the remote app to link.\n    function linkRemoteApp(uint64 chainId, bytes32 remoteApp) external;\n\n    /// @notice Thin wrapper for `linkRemoteApp` to accept EVM address as a parameter.\n    function linkRemoteAppEVM(uint64 chainId, address remoteApp) external;\n\n    /// @notice Allows the owner to add the module to the trusted modules set.\n    /// - This set of modules will be used to verify both sent and received messages.\n    function addTrustedModule(address module) external;\n\n    /// @notice Allows the owner to remove the module from the trusted modules set.\n    function removeTrustedModule(address module) external;\n\n    /// @notice Allows the owner to set the app config for the current app. App config includes:\n    /// - requiredResponses: the number of module responses required for accepting the message\n    /// - optimisticPeriod: the minimum time after which the module responses are considered final\n    function setAppConfigV1(AppConfigV1 memory appConfig) external;\n\n    /// @notice Allows the owner to set the address of the Execution Service.\n    /// This address will be used to request execution of the messages sent from this chain,\n    /// by supplying the Service's execution fee.\n    function setExecutionService(address executionService) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Returns the app config for the current app: requiredResponses and optimisticPeriod.\n    function getAppConfigV1() external view returns (AppConfigV1 memory);\n\n    /// @notice Returns the address of the Execution Service used by this app for sending messages.\n    function getExecutionService() external view returns (address);\n\n    /// @notice Returns the list of Interchain Clients allowed to send messages to this app.\n    function getInterchainClients() external view returns (address[] memory);\n\n    /// @notice Returns the address of the latest interchain client.\n    /// This address is used for sending messages from this app.\n    function getLatestInterchainClient() external view returns (address);\n\n    /// @notice Returns the linked app address (as bytes32) for the given chain ID.\n    function getLinkedApp(uint64 chainId) external view returns (bytes32);\n\n    /// @notice Thin wrapper for `getLinkedApp` to return the linked app address as EVM address.\n    /// @dev Will revert if the linked app address is not an EVM address.\n    function getLinkedAppEVM(uint64 chainId) external view returns (address);\n\n    /// @notice Returns the list of Interchain Modules trusted by this app.\n    /// This set of modules will be used to verify both sent and received messages.\n    function getModules() external view returns (address[] memory);\n}\n\n// contracts/libs/InterchainTransaction.sol\n\ntype ICTxHeader is uint256;\n\nstruct InterchainTransaction {\n    uint64 srcChainId;\n    uint64 dstChainId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcSender;\n    bytes32 dstReceiver;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    using MathLib for uint256;\n    using VersionedPayloadLib for bytes;\n\n    function constructLocalTransaction(\n        address srcSender,\n        uint64 dstChainId,\n        bytes32 dstReceiver,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: SafeCast.toUint64(block.chainid),\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            encodeTxHeader(transaction.srcChainId, transaction.dstChainId, transaction.dbNonce, transaction.entryIndex),\n            transaction.srcSender,\n            transaction.dstReceiver,\n            transaction.options,\n            transaction.message\n        );\n    }\n\n    function decodeTransaction(bytes calldata transaction) internal pure returns (InterchainTransaction memory icTx) {\n        ICTxHeader header;\n        (header, icTx.srcSender, icTx.dstReceiver, icTx.options, icTx.message) =\n            abi.decode(transaction, (ICTxHeader, bytes32, bytes32, bytes, bytes));\n        (icTx.srcChainId, icTx.dstChainId, icTx.dbNonce, icTx.entryIndex) = decodeTxHeader(header);\n    }\n\n    function payloadSize(uint256 optionsLen, uint256 messageLen) internal pure returns (uint256) {\n        // 2 bytes are reserved for the transaction version\n        // + 5 fields * 32 bytes (3 values for static, 2 offsets for dynamic) + 2 * 32 bytes (lengths for dynamic) = 226\n        // (srcChainId, dstChainId, dbNonce, entryIndex) are merged into a single 32 bytes field\n        // Both options and message are dynamic fields, which are padded up to 32 bytes\n        return 226 + optionsLen.roundUpToWord() + messageLen.roundUpToWord();\n    }\n\n    function encodeTxHeader(\n        uint64 srcChainId,\n        uint64 dstChainId,\n        uint64 dbNonce,\n        uint64 entryIndex\n    )\n        internal\n        pure\n        returns (ICTxHeader)\n    {\n        return ICTxHeader.wrap(\n            (uint256(srcChainId) \u003c\u003c 192) | (uint256(dstChainId) \u003c\u003c 128) | (uint256(dbNonce) \u003c\u003c 64) | uint256(entryIndex)\n        );\n    }\n\n    function decodeTxHeader(ICTxHeader header)\n        internal\n        pure\n        returns (uint64 srcChainId, uint64 dstChainId, uint64 dbNonce, uint64 entryIndex)\n    {\n        srcChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 192);\n        dstChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 128);\n        dbNonce = uint64(ICTxHeader.unwrap(header) \u003e\u003e 64);\n        entryIndex = uint64(ICTxHeader.unwrap(header));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/AccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account =\u003e bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role =\u003e RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint64 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__InvalidTransactionVersion(uint16 version);\n    error InterchainClientV1__NoLinkedClient(uint64 chainId);\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint64 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint64 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint64 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint64 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param messageLen           The length of the message being sent.\n    function getInterchainFee(\n        uint64 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        uint256 messageLen\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint64 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint64 chainId) external view returns (address);\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/AccessControlEnumerable.sol)\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 role =\u003e EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {AccessControl-_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool granted = super._grantRole(role, account);\n        if (granted) {\n            _roleMembers[role].add(account);\n        }\n        return granted;\n    }\n\n    /**\n     * @dev Overload {AccessControl-_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool revoked = super._revokeRole(role, account);\n        if (revoked) {\n            _roleMembers[role].remove(account);\n        }\n        return revoked;\n    }\n}\n\n// contracts/apps/AbstractICApp.sol\n\nabstract contract AbstractICApp is AbstractICAppEvents, IInterchainApp {\n    using TypeCasts for address;\n\n    error InterchainApp__AlreadyLatestClient(address client);\n    error InterchainApp__BalanceTooLow(uint256 actual, uint256 required);\n    error InterchainApp__ClientAlreadyAdded(address client);\n    error InterchainApp__InterchainClientZeroAddress();\n    error InterchainApp__NotInterchainClient(address account);\n    error InterchainApp__ReceiverNotSet(uint64 chainId);\n    error InterchainApp__SameChainId(uint64 chainId);\n    error InterchainApp__SenderNotAllowed(uint64 srcChainId, bytes32 sender);\n\n    /// @inheritdoc IInterchainApp\n    function appReceive(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        if (!_isInterchainClient(msg.sender)) {\n            revert InterchainApp__NotInterchainClient(msg.sender);\n        }\n        if (srcChainId == block.chainid) {\n            revert InterchainApp__SameChainId(srcChainId);\n        }\n        if (!_isAllowedSender(srcChainId, sender)) {\n            revert InterchainApp__SenderNotAllowed(srcChainId, sender);\n        }\n        _receiveMessage(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n\n    /// @inheritdoc IInterchainApp\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules) {\n        appConfig = _getAppConfig();\n        modules = _getModules();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Performs necessary checks and adds an Interchain Client.\n    /// Optionally sets the latest client to this one.\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _addClient(address client, bool updateLatest) internal {\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (_isInterchainClient(client)) {\n            revert InterchainApp__ClientAlreadyAdded(client);\n        }\n        _toggleClientState(client, true);\n        emit InterchainClientAdded(client);\n        if (updateLatest) {\n            _setLatestClient(client);\n        }\n    }\n\n    /// @dev Performs necessary checks and removes an Interchain Client. If this client is the latest one,\n    /// the latest client is set to zero address (effectively pausing the app ability to send messages).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _removeClient(address client) internal {\n        if (!_isInterchainClient(client)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        _toggleClientState(client, false);\n        emit InterchainClientRemoved(client);\n        if (client == _getLatestClient()) {\n            _setLatestClient(address(0));\n        }\n    }\n\n    /// @dev Sets the latest Interchain Client to one of the allowed clients. Setting the client to zero address\n    /// is allowed and effectively pauses the app ability to send messages (but still allows to receive them).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _setLatestClient(address client) internal {\n        // New latest client must be an allowed client or zero address.\n        if (!_isInterchainClient(client) \u0026\u0026 client != address(0)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        if (client == _getLatestClient()) {\n            revert InterchainApp__AlreadyLatestClient(client);\n        }\n        _storeLatestClient(client);\n        emit LatestClientSet(client);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal virtual;\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal virtual;\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to accept EVM address as a parameter.\n    function _sendInterchainMessageEVM(\n        uint64 dstChainId,\n        address receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _sendInterchainMessage(dstChainId, receiver.addressToBytes32(), messageFee, options, message);\n    }\n\n    /// @dev Performs necessary checks and sends an interchain message.\n    function _sendInterchainMessage(\n        uint64 dstChainId,\n        bytes32 receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (dstChainId == block.chainid) {\n            revert InterchainApp__SameChainId(dstChainId);\n        }\n        if (receiver == 0) {\n            revert InterchainApp__ReceiverNotSet(dstChainId);\n        }\n        if (address(this).balance \u003c messageFee) {\n            revert InterchainApp__BalanceTooLow({actual: address(this).balance, required: messageFee});\n        }\n        return IInterchainClientV1(client).interchainSend{value: messageFee}(\n            dstChainId, receiver, _getExecutionService(), _getModules(), options, message\n        );\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        virtual;\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee for sending an Interchain message.\n    function _getInterchainFee(\n        uint64 dstChainId,\n        bytes memory options,\n        uint256 messageLen\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        return IInterchainClientV1(client).getInterchainFee(\n            dstChainId, _getExecutionService(), _getModules(), options, messageLen\n        );\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view virtual returns (bytes memory);\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view virtual returns (address);\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view virtual returns (address);\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view virtual returns (address[] memory);\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint64 srcChainId, bytes32 sender) internal view virtual returns (bool);\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view virtual returns (bool);\n}\n\n// contracts/apps/ICAppV1.sol\n\nabstract contract ICAppV1 is AbstractICApp, AccessControlEnumerable, InterchainAppV1Events, IInterchainAppV1 {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Role to manage the Interchain setup of the app.\n    bytes32 public constant IC_GOVERNOR_ROLE = keccak256(\"IC_GOVERNOR_ROLE\");\n\n    /// @dev Address of the latest Interchain Client, used for sending messages.\n    address private _latestClient;\n\n    /// @dev Required responses and optimistic period for the module responses.\n    AppConfigV1 private _appConfigV1;\n    /// @dev Address of the linked app deployed on the remote chain.\n    mapping(uint64 chainId =\u003e bytes32 remoteApp) private _linkedApp;\n    /// @dev Interchain Clients allowed to send messages to this app.\n    EnumerableSet.AddressSet private _interchainClients;\n    /// @dev Trusted Interchain modules.\n    EnumerableSet.AddressSet private _trustedModules;\n    /// @dev Execution Service to use for sending messages.\n    address private _executionService;\n\n    constructor(address admin) {\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addInterchainClient(address client, bool updateLatest) external onlyRole(IC_GOVERNOR_ROLE) {\n        _addClient(client, updateLatest);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _removeClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setLatestInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _setLatestClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteApp(uint64 chainId, bytes32 remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteAppEVM(uint64 chainId, address remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp.addressToBytes32());\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (module == address(0)) {\n            revert InterchainApp__ModuleZeroAddress();\n        }\n        bool added = _trustedModules.add(module);\n        if (!added) {\n            revert InterchainApp__ModuleAlreadyAdded(module);\n        }\n        emit TrustedModuleAdded(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        bool removed = _trustedModules.remove(module);\n        if (!removed) {\n            revert InterchainApp__ModuleNotAdded(module);\n        }\n        emit TrustedModuleRemoved(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setAppConfigV1(AppConfigV1 memory appConfig) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (appConfig.requiredResponses == 0 || appConfig.optimisticPeriod == 0) {\n            revert InterchainApp__InvalidAppConfig(appConfig.requiredResponses, appConfig.optimisticPeriod);\n        }\n        _appConfigV1 = appConfig;\n        emit AppConfigV1Set(appConfig.requiredResponses, appConfig.optimisticPeriod);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setExecutionService(address executionService) external onlyRole(IC_GOVERNOR_ROLE) {\n        _executionService = executionService;\n        emit ExecutionServiceSet(executionService);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainAppV1\n    function getAppConfigV1() external view returns (AppConfigV1 memory) {\n        return _appConfigV1;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getExecutionService() external view returns (address) {\n        return _executionService;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getInterchainClients() external view returns (address[] memory) {\n        return _interchainClients.values();\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLatestInterchainClient() external view returns (address) {\n        return _latestClient;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedApp(uint64 chainId) external view returns (bytes32) {\n        return _linkedApp[chainId];\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedAppEVM(uint64 chainId) external view returns (address linkedAppEVM) {\n        bytes32 linkedApp = _linkedApp[chainId];\n        linkedAppEVM = linkedApp.bytes32ToAddress();\n        if (linkedAppEVM.addressToBytes32() != linkedApp) {\n            revert InterchainApp__NotEVMLinkedApp(linkedApp);\n        }\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getModules() external view returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Links the remote app to the current app.\n    /// Will revert if the chainId is the same as the chainId of the local app.\n    /// Note: Should be guarded with permissions check.\n    function _linkRemoteApp(uint64 chainId, bytes32 remoteApp) internal {\n        if (chainId == block.chainid) {\n            revert InterchainApp__SameChainId(chainId);\n        }\n        if (remoteApp == 0) {\n            revert InterchainApp__AppZeroAddress();\n        }\n        _linkedApp[chainId] = remoteApp;\n        emit AppLinked(chainId, remoteApp);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal override {\n        _latestClient = client;\n    }\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal override {\n        if (allowed) {\n            _interchainClients.add(client);\n        } else {\n            _interchainClients.remove(client);\n        }\n    }\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to send the message to the linked app.\n    function _sendToLinkedApp(\n        uint64 dstChainId,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _sendInterchainMessage(dstChainId, _linkedApp[dstChainId], messageFee, encodedOptions, message);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee to send a message to the linked app on the remote chain.\n    function _getMessageFee(\n        uint64 dstChainId,\n        OptionsV1 memory options,\n        uint256 messageLen\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _getInterchainFee(dstChainId, encodedOptions, messageLen);\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view override returns (bytes memory) {\n        return _appConfigV1.encodeAppConfigV1();\n    }\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view override returns (address) {\n        return _executionService;\n    }\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view override returns (address) {\n        return _latestClient;\n    }\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view override returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint64 srcChainId, bytes32 sender) internal view override returns (bool) {\n        return _linkedApp[srcChainId] == sender;\n    }\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view override returns (bool) {\n        return _interchainClients.contains(caller);\n    }\n}\n\n// contracts/apps/examples/ExampleAppV1.sol\n\ncontract ExampleAppV1 is ICAppV1 {\n    event MessageReceived(uint64 srcChainId, bytes32 sender, uint64 dbNonce, uint64 entryIndex, bytes message);\n    event MessageSent(uint64 dstChainId, uint64 dbNonce, uint64 entryIndex, bytes32 transactionId);\n\n    constructor(address admin) ICAppV1(admin) {\n        _grantRole(IC_GOVERNOR_ROLE, admin);\n    }\n\n    /// @notice Allows the Admin to withdraw the native asset from the contract.\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        Address.sendValue(payable(msg.sender), address(this).balance);\n    }\n\n    /// @notice Sends a basic message to the destination chain.\n    function sendMessage(\n        uint64 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        InterchainTxDescriptor memory desc = _sendToLinkedApp({\n            dstChainId: dstChainId,\n            messageFee: msg.value,\n            options: OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}),\n            message: message\n        });\n        emit MessageSent(dstChainId, desc.dbNonce, desc.entryIndex, desc.transactionId);\n    }\n\n    /// @notice Returns the fee required to send a message using `sendMessage`.\n    function getMessageFee(\n        uint64 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes memory message\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _getMessageFee(dstChainId, OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}), message.length);\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        override\n    {\n        emit MessageReceived(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"uint256","name":"actual","type":"uint256"},{"internalType":"uint256","name":"required","type":"uint256"}],"name":"InterchainClientV1__FeeAmountTooLow","type":"error"},{"inputs":[{"internalType":"uint64","name":"chainId","type":"uint64"}],"name":"InterchainClientV1__IncorrectDstChainId","type":"error"},{"inputs":[{"internalType":"uint256","name":"actual","type":"uint256"},{"internalType":"uint256","name":"required","type":"uint256"}],"name":"InterchainClientV1__IncorrectMsgValue","type":"error"},{"inputs":[{"internalType":"uint16","name":"version","type":"uint16"}],"name":"InterchainClientV1__InvalidTransactionVersion","type":"error"},{"inputs":[{"internalType":"uint64","name":"chainId","type":"uint64"}],"name":"InterchainClientV1__NoLinkedClient","type":"error"},{"inputs":[{"internalType":"bytes32","name":"client","type":"bytes32"}],"name":"InterchainClientV1__NotEVMClient","type":"error"},{"inputs":[{"internalType":"uint256","name":"actual","type":"uint256"},{"internalType":"uint256","name":"required","type":"uint256"}],"name":"InterchainClientV1__NotEnoughResponses","type":"error"},{"inputs":[{"internalType":"uint64","name":"chainId","type":"uint64"}],"name":"InterchainClientV1__NotRemoteChainId","type":"error"},{"inputs":[{"internalType":"bytes32","name":"transactionId","type":"bytes32"}],"name":"InterchainClientV1__TxAlreadyExecuted","type":"error"},{"inputs":[{"internalType":"bytes32","name":"transactionId","type":"bytes32"}],"name":"InterchainClientV1__TxNotExecuted","type":"error"},{"inputs":[],"name":"InterchainClientV1__ZeroReceiver","type":"error"},{"inputs":[],"name":"InterchainClientV1__ZeroRequiredResponses","type":"error"},{"inputs":[{"internalType":"bytes","name":"transaction","type":"bytes"}],"name":"getExecutor","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"transactionId","type":"bytes32"}],"name":"getExecutorById","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint64","name":"dstChainId","type":"uint64"},{"internalType":"address","name":"srcExecutionService","type":"address"},{"internalType":"address[]","name":"srcModules","type":"address[]"},{"internalType":"bytes","name":"options","type":"bytes"},{"internalType":"uint256","name":"messageLen","type":"uint256"}],"name":"getInterchainFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint64","name":"chainId","type":"uint64"}],"name":"getLinkedClient","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint64","name":"chainId","type":"uint64"}],"name":"getLinkedClientEVM","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"gasLimit","type":"uint256"},{"internalType":"bytes","name":"transaction","type":"bytes"},{"internalType":"bytes32[]","name":"proof","type":"bytes32[]"}],"name":"interchainExecute","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint64","name":"dstChainId","type":"uint64"},{"internalType":"bytes32","name":"receiver","type":"bytes32"},{"internalType":"address","name":"srcExecutionService","type":"address"},{"internalType":"address[]","name":"srcModules","type":"address[]"},{"internalType":"bytes","name":"options","type":"bytes"},{"internalType":"bytes","name":"message","type":"bytes"}],"name":"interchainSend","outputs":[{"components":[{"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"internalType":"uint64","name":"dbNonce","type":"uint64"},{"internalType":"uint64","name":"entryIndex","type":"uint64"}],"internalType":"struct InterchainTxDescriptor","name":"desc","type":"tuple"}],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint64","name":"dstChainId","type":"uint64"},{"internalType":"address","name":"receiver","type":"address"},{"internalType":"address","name":"srcExecutionService","type":"address"},{"internalType":"address[]","name":"srcModules","type":"address[]"},{"internalType":"bytes","name":"options","type":"bytes"},{"internalType":"bytes","name":"message","type":"bytes"}],"name":"interchainSendEVM","outputs":[{"components":[{"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"internalType":"uint64","name":"dbNonce","type":"uint64"},{"internalType":"uint64","name":"entryIndex","type":"uint64"}],"internalType":"struct InterchainTxDescriptor","name":"desc","type":"tuple"}],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"bytes","name":"transaction","type":"bytes"},{"internalType":"bytes32[]","name":"proof","type":"bytes32[]"}],"name":"isExecutable","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"executionFees_","type":"address"}],"name":"setExecutionFees","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint64","name":"chainId","type":"uint64"},{"internalType":"bytes32","name":"client","type":"bytes32"}],"name":"setLinkedClient","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"transactionId","type":"bytes32"}],"name":"writeExecutionProof","outputs":[{"internalType":"uint64","name":"dbNonce","type":"uint64"},{"internalType":"uint64","name":"entryIndex","type":"uint64"}],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{"getExecutor(bytes)":{"notice":"Returns the address of the executor for a transaction that has been sent to the local chain."},"getExecutorById(bytes32)":{"notice":"Returns the address of the executor for a transaction that has been sent to the local chain."},"getInterchainFee(uint64,address,address[],bytes,uint256)":{"notice":"Returns the fee for sending an Interchain message."},"getLinkedClient(uint64)":{"notice":"Returns the address of the linked client (as bytes32) for a specific chain ID."},"getLinkedClientEVM(uint64)":{"notice":"Returns the EVM address of the linked client for a specific chain ID."},"interchainExecute(uint256,bytes,bytes32[])":{"notice":"Executes a transaction that has been sent via the Interchain."},"interchainSend(uint64,bytes32,address,address[],bytes,bytes)":{"notice":"Sends a message to another chain via the Interchain Communication Protocol."},"isExecutable(bytes,bytes32[])":{"notice":"Checks if a transaction is executable."},"setExecutionFees(address)":{"notice":"Sets the address of the ExecutionFees contract."},"setLinkedClient(uint64,bytes32)":{"notice":"Sets the linked client for a specific chain ID."},"writeExecutionProof(bytes32)":{"notice":"Writes the proof of execution for a transaction into the InterchainDB."}},"version":1},"developerDoc":{"kind":"dev","methods":{"getInterchainFee(uint64,address,address[],bytes,uint256)":{"params":{"dstChainId":"The chain ID of the destination chain.","messageLen":"The length of the message being sent.","options":"Execution options for the message sent, currently gas limit + native gas drop.","srcExecutionService":"The address of the execution service to use for the message.","srcModules":"The source modules involved in the message sending."}},"getLinkedClient(uint64)":{"details":"Will return 0x0 if no client is linked for the chain ID."},"getLinkedClientEVM(uint64)":{"details":"Will return 0x0 if no client is linked for the chain ID. Will revert if the client is not an EVM client."},"interchainExecute(uint256,bytes,bytes32[])":{"details":"The transaction must have been previously sent and recorded. Transaction data includes the requested gas limit, but the executors could specify a different gas limit. If the specified gas limit is lower than requested, the requested gas limit will be used. Otherwise, the specified gas limit will be used. This allows to execute the transactions with requested gas limit set too low.","params":{"gasLimit":"The gas limit to use for the execution.","proof":"The Merkle proof for transaction execution, fetched from the source chain.","transaction":"The transaction data."}},"interchainSend(uint64,bytes32,address,address[],bytes,bytes)":{"details":"Charges a fee for the message, which is payable upon calling this function: - Verification fees: paid to every module that verifies the message. - Execution fee: paid to the executor that executes the message. Note: while a specific execution service is specified to request the execution of the message, any executor is able to execute the message on destination chain, earning the execution fee.","params":{"dstChainId":"The chain ID of the destination chain.","message":"The message being sent.","options":"Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.","receiver":"The address of the receiver on the destination chain.","srcExecutionService":"The address of the execution service to use for the message.","srcModules":"The source modules involved in the message sending."},"returns":{"desc":"The descriptor of the sent transaction: - transactionId: the ID of the transaction that was sent. - dbNonce: the database nonce of the batch containing the written entry for transaction. - entryIndex: the index of the written entry for transaction within the batch."}},"isExecutable(bytes,bytes32[])":{"details":"Determines if a transaction meets the criteria to be executed based on: - If approved modules have written to the InterchainDB - If the threshold of approved modules have been met - If the optimistic window has passed for all modules","params":{"proof":"The Merkle proof for transaction execution, fetched from the source chain.","transaction":"The InterchainTransaction struct to be checked."},"returns":{"_0":"bool Returns true if the transaction is executable, false otherwise."}},"setExecutionFees(address)":{"details":"Only callable by the contract owner or an authorized account.","params":{"executionFees_":"The address of the ExecutionFees contract."}},"setLinkedClient(uint64,bytes32)":{"details":"Stores the address of the linked client in a mapping with the chain ID as the key.","params":{"chainId":"The chain ID for which the client is being set.","client":"The address of the client being linked."}},"writeExecutionProof(bytes32)":{"details":"Will revert if the transaction has not been executed.","params":{"transactionId":"The ID of the transaction to write the proof for."},"returns":{"dbNonce":"        The database nonce of the batch containing the written proof for transaction.","entryIndex":"     The index of the written proof for transaction within the batch."}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"required\",\"type\":\"uint256\"}],\"name\":\"InterchainClientV1__FeeAmountTooLow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"}],\"name\":\"InterchainClientV1__IncorrectDstChainId\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"required\",\"type\":\"uint256\"}],\"name\":\"InterchainClientV1__IncorrectMsgValue\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"version\",\"type\":\"uint16\"}],\"name\":\"InterchainClientV1__InvalidTransactionVersion\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"}],\"name\":\"InterchainClientV1__NoLinkedClient\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"client\",\"type\":\"bytes32\"}],\"name\":\"InterchainClientV1__NotEVMClient\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"required\",\"type\":\"uint256\"}],\"name\":\"InterchainClientV1__NotEnoughResponses\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"}],\"name\":\"InterchainClientV1__NotRemoteChainId\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"}],\"name\":\"InterchainClientV1__TxAlreadyExecuted\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"}],\"name\":\"InterchainClientV1__TxNotExecuted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InterchainClientV1__ZeroReceiver\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InterchainClientV1__ZeroRequiredResponses\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"transaction\",\"type\":\"bytes\"}],\"name\":\"getExecutor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"}],\"name\":\"getExecutorById\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"dstChainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"srcExecutionService\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"},{\"internalType\":\"bytes\",\"name\":\"options\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"messageLen\",\"type\":\"uint256\"}],\"name\":\"getInterchainFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"}],\"name\":\"getLinkedClient\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"}],\"name\":\"getLinkedClientEVM\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"transaction\",\"type\":\"bytes\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"interchainExecute\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"dstChainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"receiver\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"srcExecutionService\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"},{\"internalType\":\"bytes\",\"name\":\"options\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"interchainSend\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"}],\"internalType\":\"struct InterchainTxDescriptor\",\"name\":\"desc\",\"type\":\"tuple\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"dstChainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"srcExecutionService\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"},{\"internalType\":\"bytes\",\"name\":\"options\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"interchainSendEVM\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"}],\"internalType\":\"struct InterchainTxDescriptor\",\"name\":\"desc\",\"type\":\"tuple\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"transaction\",\"type\":\"bytes\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"isExecutable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"executionFees_\",\"type\":\"address\"}],\"name\":\"setExecutionFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"client\",\"type\":\"bytes32\"}],\"name\":\"setLinkedClient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"}],\"name\":\"writeExecutionProof\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"getInterchainFee(uint64,address,address[],bytes,uint256)\":{\"params\":{\"dstChainId\":\"The chain ID of the destination chain.\",\"messageLen\":\"The length of the message being sent.\",\"options\":\"Execution options for the message sent, currently gas limit + native gas drop.\",\"srcExecutionService\":\"The address of the execution service to use for the message.\",\"srcModules\":\"The source modules involved in the message sending.\"}},\"getLinkedClient(uint64)\":{\"details\":\"Will return 0x0 if no client is linked for the chain ID.\"},\"getLinkedClientEVM(uint64)\":{\"details\":\"Will return 0x0 if no client is linked for the chain ID. Will revert if the client is not an EVM client.\"},\"interchainExecute(uint256,bytes,bytes32[])\":{\"details\":\"The transaction must have been previously sent and recorded. Transaction data includes the requested gas limit, but the executors could specify a different gas limit. If the specified gas limit is lower than requested, the requested gas limit will be used. Otherwise, the specified gas limit will be used. This allows to execute the transactions with requested gas limit set too low.\",\"params\":{\"gasLimit\":\"The gas limit to use for the execution.\",\"proof\":\"The Merkle proof for transaction execution, fetched from the source chain.\",\"transaction\":\"The transaction data.\"}},\"interchainSend(uint64,bytes32,address,address[],bytes,bytes)\":{\"details\":\"Charges a fee for the message, which is payable upon calling this function: - Verification fees: paid to every module that verifies the message. - Execution fee: paid to the executor that executes the message. Note: while a specific execution service is specified to request the execution of the message, any executor is able to execute the message on destination chain, earning the execution fee.\",\"params\":{\"dstChainId\":\"The chain ID of the destination chain.\",\"message\":\"The message being sent.\",\"options\":\"Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\",\"receiver\":\"The address of the receiver on the destination chain.\",\"srcExecutionService\":\"The address of the execution service to use for the message.\",\"srcModules\":\"The source modules involved in the message sending.\"},\"returns\":{\"desc\":\"The descriptor of the sent transaction: - transactionId: the ID of the transaction that was sent. - dbNonce: the database nonce of the batch containing the written entry for transaction. - entryIndex: the index of the written entry for transaction within the batch.\"}},\"isExecutable(bytes,bytes32[])\":{\"details\":\"Determines if a transaction meets the criteria to be executed based on: - If approved modules have written to the InterchainDB - If the threshold of approved modules have been met - If the optimistic window has passed for all modules\",\"params\":{\"proof\":\"The Merkle proof for transaction execution, fetched from the source chain.\",\"transaction\":\"The InterchainTransaction struct to be checked.\"},\"returns\":{\"_0\":\"bool Returns true if the transaction is executable, false otherwise.\"}},\"setExecutionFees(address)\":{\"details\":\"Only callable by the contract owner or an authorized account.\",\"params\":{\"executionFees_\":\"The address of the ExecutionFees contract.\"}},\"setLinkedClient(uint64,bytes32)\":{\"details\":\"Stores the address of the linked client in a mapping with the chain ID as the key.\",\"params\":{\"chainId\":\"The chain ID for which the client is being set.\",\"client\":\"The address of the client being linked.\"}},\"writeExecutionProof(bytes32)\":{\"details\":\"Will revert if the transaction has not been executed.\",\"params\":{\"transactionId\":\"The ID of the transaction to write the proof for.\"},\"returns\":{\"dbNonce\":\"        The database nonce of the batch containing the written proof for transaction.\",\"entryIndex\":\"     The index of the written proof for transaction within the batch.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"getExecutor(bytes)\":{\"notice\":\"Returns the address of the executor for a transaction that has been sent to the local chain.\"},\"getExecutorById(bytes32)\":{\"notice\":\"Returns the address of the executor for a transaction that has been sent to the local chain.\"},\"getInterchainFee(uint64,address,address[],bytes,uint256)\":{\"notice\":\"Returns the fee for sending an Interchain message.\"},\"getLinkedClient(uint64)\":{\"notice\":\"Returns the address of the linked client (as bytes32) for a specific chain ID.\"},\"getLinkedClientEVM(uint64)\":{\"notice\":\"Returns the EVM address of the linked client for a specific chain ID.\"},\"interchainExecute(uint256,bytes,bytes32[])\":{\"notice\":\"Executes a transaction that has been sent via the Interchain.\"},\"interchainSend(uint64,bytes32,address,address[],bytes,bytes)\":{\"notice\":\"Sends a message to another chain via the Interchain Communication Protocol.\"},\"isExecutable(bytes,bytes32[])\":{\"notice\":\"Checks if a transaction is executable.\"},\"setExecutionFees(address)\":{\"notice\":\"Sets the address of the ExecutionFees contract.\"},\"setLinkedClient(uint64,bytes32)\":{\"notice\":\"Sets the linked client for a specific chain ID.\"},\"writeExecutionProof(bytes32)\":{\"notice\":\"Writes the proof of execution for a transaction into the InterchainDB.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/ExampleAppV1.sol\":\"IInterchainClientV1\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/ExampleAppV1.sol\":{\"keccak256\":\"0xb1e9550aef785a0afc4e03fc843839919987ba4f906f09992c6788979c3c0396\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://0ede697223dfa3a2e23501efc1ed5926d5ff6458ee7b9ba833e0587162166c79\",\"dweb:/ipfs/QmUzgopL2ptWG5DYNdGAcoErPnBC4KCoRp8C61dkHHRaA6\"]}},\"version\":1}"},"hashes":{"getExecutor(bytes)":"f92a79ff","getExecutorById(bytes32)":"f1a61fac","getInterchainFee(uint64,address,address[],bytes,uint256)":"cbb3c631","getLinkedClient(uint64)":"2e568739","getLinkedClientEVM(uint64)":"35c4a191","interchainExecute(uint256,bytes,bytes32[])":"53b67d74","interchainSend(uint64,bytes32,address,address[],bytes,bytes)":"547efb84","interchainSendEVM(uint64,address,address,address[],bytes,bytes)":"3f34448e","isExecutable(bytes,bytes32[])":"1450c281","setExecutionFees(address)":"3dc68b87","setLinkedClient(uint64,bytes32)":"f3c66e2b","writeExecutionProof(bytes32)":"90e81077"}},"solidity/ExampleAppV1.sol:InterchainAppV1Events":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/AbstractICAppEvents.sol\n\nabstract contract AbstractICAppEvents {\n    event InterchainClientAdded(address client);\n    event InterchainClientRemoved(address client);\n    event LatestClientSet(address client);\n}\n\n// contracts/events/InterchainAppV1Events.sol\n\nabstract contract InterchainAppV1Events {\n    event AppConfigV1Set(uint256 requiredResponses, uint256 optimisticPeriod);\n    event AppLinked(uint256 indexed chainId, bytes32 indexed remoteApp);\n    event ExecutionServiceSet(address executionService);\n    event TrustedModuleAdded(address module);\n    event TrustedModuleRemoved(address module);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    /// @notice Allows the Interchain Client to pass the message to the Interchain App.\n    /// @dev App is responsible for keeping track of interchain clients, and must verify the message sender.\n    /// @param srcChainId   Chain ID of the source chain, where the message was sent from.\n    /// @param sender       Sender address on the source chain, as a bytes32 value.\n    /// @param dbNonce      The Interchain DB nonce of the batch containing the message entry.\n    /// @param entryIndex   The index of the message entry within the batch.\n    /// @param message      The message being sent.\n    function appReceive(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /// @notice Returns the verification configuration of the Interchain App.\n    /// @dev This configuration is used by the Interchain Client to verify that message has been confirmed\n    /// by the Interchain Modules on the destination chain.\n    /// Note: V1 version of AppConfig includes the required responses count, and optimistic period after which\n    /// the message is considered confirmed by the module. Following versions may include additional fields.\n    /// @return appConfig    The versioned configuration of the Interchain App, encoded as bytes.\n    /// @return modules      The list of Interchain Modules that app is trusting to confirm the messages.\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/Math.sol\n\nlibrary MathLib {\n    /// @notice Rounds up to the nearest multiple of 32.\n    /// Note: Returns zero on overflows instead of reverting. This is fine for practical\n    /// use cases, as this is used for determining the size of the payload in memory.\n    function roundUpToWord(uint256 x) internal pure returns (uint256) {\n        unchecked {\n            return (x + 31) \u0026 ~uint256(31);\n        }\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/VersionedPayload.sol\n\n// solhint-disable no-inline-assembly\n// solhint-disable ordering\nlibrary VersionedPayloadLib {\n    /// @notice Amount of bytes reserved for the version (uint16) in the versioned payload\n    uint256 internal constant VERSION_LENGTH = 2;\n\n    error VersionedPayload__TooShort(bytes versionedPayload);\n    error VersionedPayload__PrecompileFailed();\n\n    /// @notice Encodes the versioned payload into a single bytes array.\n    /// @param version  The payload's version.\n    /// @param payload  The payload to encode.\n    function encodeVersionedPayload(uint16 version, bytes memory payload) internal pure returns (bytes memory) {\n        return abi.encodePacked(version, payload);\n    }\n\n    /// @notice Extracts the version from the versioned payload (calldata reference).\n    /// @param versionedPayload     The versioned payload (calldata reference).\n    function getVersion(bytes calldata versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            version := shr(240, calldataload(versionedPayload.offset))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (calldata reference).\n    /// @dev The extracted payload is also returned as a calldata reference.\n    /// @param versionedPayload     The versioned payload.\n    function getPayload(bytes calldata versionedPayload) internal pure returns (bytes calldata) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        return versionedPayload[VERSION_LENGTH:];\n    }\n\n    /// @notice Extracts the version from the versioned payload (memory reference).\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getVersionFromMemory(bytes memory versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            // We add 0x20 to skip the length of the bytes array.\n            version := shr(240, mload(add(versionedPayload, 0x20)))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (memory reference).\n    /// @dev The extracted payload is copied into a new memory location. Use `getPayload` when possible\n    /// to avoid extra memory allocation.\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getPayloadFromMemory(bytes memory versionedPayload) internal view returns (bytes memory payload) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        // Figure how many bytes to copy and allocate the memory for the extracted payload.\n        uint256 toCopy;\n        unchecked {\n            toCopy = versionedPayload.length - VERSION_LENGTH;\n        }\n        payload = new bytes(toCopy);\n        // Use identity precompile (0x04) to copy the payload. Unlike MCOPY, this is available on all EVM chains.\n        bool res;\n        assembly {\n            // We add 0x20 to skip the length of the bytes array.\n            // We add 0x02 to skip the 2 bytes reserved for the version.\n            // Copy the payload to the previously allocated memory.\n            res := staticcall(gas(), 0x04, add(versionedPayload, 0x22), toCopy, add(payload, 0x20), toCopy)\n        }\n        if (!res) {\n            revert VersionedPayload__PrecompileFailed();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/IAccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n\n// node_modules/@openzeppelin/contracts/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance \u003c amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance \u003c value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 \u0026\u0026 target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SafeCast.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value \u003e type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value \u003e type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value \u003e type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value \u003e type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value \u003e type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value \u003e type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value \u003e type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value \u003e type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value \u003e type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value \u003e type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value \u003e type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value \u003e type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value \u003e type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value \u003e type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value \u003e type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value \u003e type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value \u003e type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value \u003e type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value \u003e type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value \u003e type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value \u003e type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value \u003e type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value \u003e type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value \u003e type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value \u003e type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value \u003e type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value \u003e type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value \u003e type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value \u003e type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value \u003e type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value \u003e type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value \u003c 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value \u003e uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal view returns (AppConfigV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (AppConfigV1));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal view returns (OptionsV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (OptionsV1));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(OPTIONS_V1, abi.encode(options));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/IAccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/IAccessControlEnumerable.sol)\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n// contracts/interfaces/IInterchainAppV1.sol\n\ninterface IInterchainAppV1 is IInterchainApp {\n    error InterchainApp__AppZeroAddress();\n    error InterchainApp__InvalidAppConfig(uint256 requiredResponses, uint256 optimisticPeriod);\n    error InterchainApp__ModuleAlreadyAdded(address module);\n    error InterchainApp__ModuleNotAdded(address module);\n    error InterchainApp__ModuleZeroAddress();\n    error InterchainApp__NotEVMLinkedApp(bytes32 linkedApp);\n\n    /// @notice Allows the owner to add the interchain client to the allowed clients set,\n    /// and optionally set the latest client to this one.\n    /// Note: only the allowed clients can send messages to this app.\n    /// Note: the latest client is used for sending messages from this app.\n    /// @param client       The address of the interchain client to add.\n    /// @param updateLatest Whether to set the latest client to this one.\n    function addInterchainClient(address client, bool updateLatest) external;\n\n    /// @notice Allows the owner to remove the interchain client from the allowed clients set.\n    /// If the client is the latest client, the latest client is set to the zero address.\n    /// @param client       The address of the interchain client to remove.\n    function removeInterchainClient(address client) external;\n\n    /// @notice Allows the owner to set the address of the latest interchain client.\n    /// @dev The new latest client must be an allowed client or zero address.\n    /// Setting the client to zero address effectively pauses the app ability to send messages,\n    /// while allowing to receive them.\n    /// @param client       The address of the latest interchain client.\n    function setLatestInterchainClient(address client) external;\n\n    /// @notice Allows the owner to link the remote app for the given chain ID.\n    /// - This address will be used as the receiver for the messages sent from this chain.\n    /// - This address will be the only trusted sender for the messages sent to this chain.\n    /// @param chainId      The remote chain ID.\n    /// @param remoteApp    The address of the remote app to link.\n    function linkRemoteApp(uint64 chainId, bytes32 remoteApp) external;\n\n    /// @notice Thin wrapper for `linkRemoteApp` to accept EVM address as a parameter.\n    function linkRemoteAppEVM(uint64 chainId, address remoteApp) external;\n\n    /// @notice Allows the owner to add the module to the trusted modules set.\n    /// - This set of modules will be used to verify both sent and received messages.\n    function addTrustedModule(address module) external;\n\n    /// @notice Allows the owner to remove the module from the trusted modules set.\n    function removeTrustedModule(address module) external;\n\n    /// @notice Allows the owner to set the app config for the current app. App config includes:\n    /// - requiredResponses: the number of module responses required for accepting the message\n    /// - optimisticPeriod: the minimum time after which the module responses are considered final\n    function setAppConfigV1(AppConfigV1 memory appConfig) external;\n\n    /// @notice Allows the owner to set the address of the Execution Service.\n    /// This address will be used to request execution of the messages sent from this chain,\n    /// by supplying the Service's execution fee.\n    function setExecutionService(address executionService) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Returns the app config for the current app: requiredResponses and optimisticPeriod.\n    function getAppConfigV1() external view returns (AppConfigV1 memory);\n\n    /// @notice Returns the address of the Execution Service used by this app for sending messages.\n    function getExecutionService() external view returns (address);\n\n    /// @notice Returns the list of Interchain Clients allowed to send messages to this app.\n    function getInterchainClients() external view returns (address[] memory);\n\n    /// @notice Returns the address of the latest interchain client.\n    /// This address is used for sending messages from this app.\n    function getLatestInterchainClient() external view returns (address);\n\n    /// @notice Returns the linked app address (as bytes32) for the given chain ID.\n    function getLinkedApp(uint64 chainId) external view returns (bytes32);\n\n    /// @notice Thin wrapper for `getLinkedApp` to return the linked app address as EVM address.\n    /// @dev Will revert if the linked app address is not an EVM address.\n    function getLinkedAppEVM(uint64 chainId) external view returns (address);\n\n    /// @notice Returns the list of Interchain Modules trusted by this app.\n    /// This set of modules will be used to verify both sent and received messages.\n    function getModules() external view returns (address[] memory);\n}\n\n// contracts/libs/InterchainTransaction.sol\n\ntype ICTxHeader is uint256;\n\nstruct InterchainTransaction {\n    uint64 srcChainId;\n    uint64 dstChainId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcSender;\n    bytes32 dstReceiver;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    using MathLib for uint256;\n    using VersionedPayloadLib for bytes;\n\n    function constructLocalTransaction(\n        address srcSender,\n        uint64 dstChainId,\n        bytes32 dstReceiver,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: SafeCast.toUint64(block.chainid),\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            encodeTxHeader(transaction.srcChainId, transaction.dstChainId, transaction.dbNonce, transaction.entryIndex),\n            transaction.srcSender,\n            transaction.dstReceiver,\n            transaction.options,\n            transaction.message\n        );\n    }\n\n    function decodeTransaction(bytes calldata transaction) internal pure returns (InterchainTransaction memory icTx) {\n        ICTxHeader header;\n        (header, icTx.srcSender, icTx.dstReceiver, icTx.options, icTx.message) =\n            abi.decode(transaction, (ICTxHeader, bytes32, bytes32, bytes, bytes));\n        (icTx.srcChainId, icTx.dstChainId, icTx.dbNonce, icTx.entryIndex) = decodeTxHeader(header);\n    }\n\n    function payloadSize(uint256 optionsLen, uint256 messageLen) internal pure returns (uint256) {\n        // 2 bytes are reserved for the transaction version\n        // + 5 fields * 32 bytes (3 values for static, 2 offsets for dynamic) + 2 * 32 bytes (lengths for dynamic) = 226\n        // (srcChainId, dstChainId, dbNonce, entryIndex) are merged into a single 32 bytes field\n        // Both options and message are dynamic fields, which are padded up to 32 bytes\n        return 226 + optionsLen.roundUpToWord() + messageLen.roundUpToWord();\n    }\n\n    function encodeTxHeader(\n        uint64 srcChainId,\n        uint64 dstChainId,\n        uint64 dbNonce,\n        uint64 entryIndex\n    )\n        internal\n        pure\n        returns (ICTxHeader)\n    {\n        return ICTxHeader.wrap(\n            (uint256(srcChainId) \u003c\u003c 192) | (uint256(dstChainId) \u003c\u003c 128) | (uint256(dbNonce) \u003c\u003c 64) | uint256(entryIndex)\n        );\n    }\n\n    function decodeTxHeader(ICTxHeader header)\n        internal\n        pure\n        returns (uint64 srcChainId, uint64 dstChainId, uint64 dbNonce, uint64 entryIndex)\n    {\n        srcChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 192);\n        dstChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 128);\n        dbNonce = uint64(ICTxHeader.unwrap(header) \u003e\u003e 64);\n        entryIndex = uint64(ICTxHeader.unwrap(header));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/AccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account =\u003e bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role =\u003e RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint64 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__InvalidTransactionVersion(uint16 version);\n    error InterchainClientV1__NoLinkedClient(uint64 chainId);\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint64 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint64 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint64 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint64 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param messageLen           The length of the message being sent.\n    function getInterchainFee(\n        uint64 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        uint256 messageLen\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint64 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint64 chainId) external view returns (address);\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/AccessControlEnumerable.sol)\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 role =\u003e EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {AccessControl-_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool granted = super._grantRole(role, account);\n        if (granted) {\n            _roleMembers[role].add(account);\n        }\n        return granted;\n    }\n\n    /**\n     * @dev Overload {AccessControl-_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool revoked = super._revokeRole(role, account);\n        if (revoked) {\n            _roleMembers[role].remove(account);\n        }\n        return revoked;\n    }\n}\n\n// contracts/apps/AbstractICApp.sol\n\nabstract contract AbstractICApp is AbstractICAppEvents, IInterchainApp {\n    using TypeCasts for address;\n\n    error InterchainApp__AlreadyLatestClient(address client);\n    error InterchainApp__BalanceTooLow(uint256 actual, uint256 required);\n    error InterchainApp__ClientAlreadyAdded(address client);\n    error InterchainApp__InterchainClientZeroAddress();\n    error InterchainApp__NotInterchainClient(address account);\n    error InterchainApp__ReceiverNotSet(uint64 chainId);\n    error InterchainApp__SameChainId(uint64 chainId);\n    error InterchainApp__SenderNotAllowed(uint64 srcChainId, bytes32 sender);\n\n    /// @inheritdoc IInterchainApp\n    function appReceive(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        if (!_isInterchainClient(msg.sender)) {\n            revert InterchainApp__NotInterchainClient(msg.sender);\n        }\n        if (srcChainId == block.chainid) {\n            revert InterchainApp__SameChainId(srcChainId);\n        }\n        if (!_isAllowedSender(srcChainId, sender)) {\n            revert InterchainApp__SenderNotAllowed(srcChainId, sender);\n        }\n        _receiveMessage(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n\n    /// @inheritdoc IInterchainApp\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules) {\n        appConfig = _getAppConfig();\n        modules = _getModules();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Performs necessary checks and adds an Interchain Client.\n    /// Optionally sets the latest client to this one.\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _addClient(address client, bool updateLatest) internal {\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (_isInterchainClient(client)) {\n            revert InterchainApp__ClientAlreadyAdded(client);\n        }\n        _toggleClientState(client, true);\n        emit InterchainClientAdded(client);\n        if (updateLatest) {\n            _setLatestClient(client);\n        }\n    }\n\n    /// @dev Performs necessary checks and removes an Interchain Client. If this client is the latest one,\n    /// the latest client is set to zero address (effectively pausing the app ability to send messages).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _removeClient(address client) internal {\n        if (!_isInterchainClient(client)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        _toggleClientState(client, false);\n        emit InterchainClientRemoved(client);\n        if (client == _getLatestClient()) {\n            _setLatestClient(address(0));\n        }\n    }\n\n    /// @dev Sets the latest Interchain Client to one of the allowed clients. Setting the client to zero address\n    /// is allowed and effectively pauses the app ability to send messages (but still allows to receive them).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _setLatestClient(address client) internal {\n        // New latest client must be an allowed client or zero address.\n        if (!_isInterchainClient(client) \u0026\u0026 client != address(0)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        if (client == _getLatestClient()) {\n            revert InterchainApp__AlreadyLatestClient(client);\n        }\n        _storeLatestClient(client);\n        emit LatestClientSet(client);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal virtual;\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal virtual;\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to accept EVM address as a parameter.\n    function _sendInterchainMessageEVM(\n        uint64 dstChainId,\n        address receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _sendInterchainMessage(dstChainId, receiver.addressToBytes32(), messageFee, options, message);\n    }\n\n    /// @dev Performs necessary checks and sends an interchain message.\n    function _sendInterchainMessage(\n        uint64 dstChainId,\n        bytes32 receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (dstChainId == block.chainid) {\n            revert InterchainApp__SameChainId(dstChainId);\n        }\n        if (receiver == 0) {\n            revert InterchainApp__ReceiverNotSet(dstChainId);\n        }\n        if (address(this).balance \u003c messageFee) {\n            revert InterchainApp__BalanceTooLow({actual: address(this).balance, required: messageFee});\n        }\n        return IInterchainClientV1(client).interchainSend{value: messageFee}(\n            dstChainId, receiver, _getExecutionService(), _getModules(), options, message\n        );\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        virtual;\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee for sending an Interchain message.\n    function _getInterchainFee(\n        uint64 dstChainId,\n        bytes memory options,\n        uint256 messageLen\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        return IInterchainClientV1(client).getInterchainFee(\n            dstChainId, _getExecutionService(), _getModules(), options, messageLen\n        );\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view virtual returns (bytes memory);\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view virtual returns (address);\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view virtual returns (address);\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view virtual returns (address[] memory);\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint64 srcChainId, bytes32 sender) internal view virtual returns (bool);\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view virtual returns (bool);\n}\n\n// contracts/apps/ICAppV1.sol\n\nabstract contract ICAppV1 is AbstractICApp, AccessControlEnumerable, InterchainAppV1Events, IInterchainAppV1 {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Role to manage the Interchain setup of the app.\n    bytes32 public constant IC_GOVERNOR_ROLE = keccak256(\"IC_GOVERNOR_ROLE\");\n\n    /// @dev Address of the latest Interchain Client, used for sending messages.\n    address private _latestClient;\n\n    /// @dev Required responses and optimistic period for the module responses.\n    AppConfigV1 private _appConfigV1;\n    /// @dev Address of the linked app deployed on the remote chain.\n    mapping(uint64 chainId =\u003e bytes32 remoteApp) private _linkedApp;\n    /// @dev Interchain Clients allowed to send messages to this app.\n    EnumerableSet.AddressSet private _interchainClients;\n    /// @dev Trusted Interchain modules.\n    EnumerableSet.AddressSet private _trustedModules;\n    /// @dev Execution Service to use for sending messages.\n    address private _executionService;\n\n    constructor(address admin) {\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addInterchainClient(address client, bool updateLatest) external onlyRole(IC_GOVERNOR_ROLE) {\n        _addClient(client, updateLatest);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _removeClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setLatestInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _setLatestClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteApp(uint64 chainId, bytes32 remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteAppEVM(uint64 chainId, address remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp.addressToBytes32());\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (module == address(0)) {\n            revert InterchainApp__ModuleZeroAddress();\n        }\n        bool added = _trustedModules.add(module);\n        if (!added) {\n            revert InterchainApp__ModuleAlreadyAdded(module);\n        }\n        emit TrustedModuleAdded(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        bool removed = _trustedModules.remove(module);\n        if (!removed) {\n            revert InterchainApp__ModuleNotAdded(module);\n        }\n        emit TrustedModuleRemoved(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setAppConfigV1(AppConfigV1 memory appConfig) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (appConfig.requiredResponses == 0 || appConfig.optimisticPeriod == 0) {\n            revert InterchainApp__InvalidAppConfig(appConfig.requiredResponses, appConfig.optimisticPeriod);\n        }\n        _appConfigV1 = appConfig;\n        emit AppConfigV1Set(appConfig.requiredResponses, appConfig.optimisticPeriod);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setExecutionService(address executionService) external onlyRole(IC_GOVERNOR_ROLE) {\n        _executionService = executionService;\n        emit ExecutionServiceSet(executionService);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainAppV1\n    function getAppConfigV1() external view returns (AppConfigV1 memory) {\n        return _appConfigV1;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getExecutionService() external view returns (address) {\n        return _executionService;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getInterchainClients() external view returns (address[] memory) {\n        return _interchainClients.values();\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLatestInterchainClient() external view returns (address) {\n        return _latestClient;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedApp(uint64 chainId) external view returns (bytes32) {\n        return _linkedApp[chainId];\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedAppEVM(uint64 chainId) external view returns (address linkedAppEVM) {\n        bytes32 linkedApp = _linkedApp[chainId];\n        linkedAppEVM = linkedApp.bytes32ToAddress();\n        if (linkedAppEVM.addressToBytes32() != linkedApp) {\n            revert InterchainApp__NotEVMLinkedApp(linkedApp);\n        }\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getModules() external view returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Links the remote app to the current app.\n    /// Will revert if the chainId is the same as the chainId of the local app.\n    /// Note: Should be guarded with permissions check.\n    function _linkRemoteApp(uint64 chainId, bytes32 remoteApp) internal {\n        if (chainId == block.chainid) {\n            revert InterchainApp__SameChainId(chainId);\n        }\n        if (remoteApp == 0) {\n            revert InterchainApp__AppZeroAddress();\n        }\n        _linkedApp[chainId] = remoteApp;\n        emit AppLinked(chainId, remoteApp);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal override {\n        _latestClient = client;\n    }\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal override {\n        if (allowed) {\n            _interchainClients.add(client);\n        } else {\n            _interchainClients.remove(client);\n        }\n    }\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to send the message to the linked app.\n    function _sendToLinkedApp(\n        uint64 dstChainId,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _sendInterchainMessage(dstChainId, _linkedApp[dstChainId], messageFee, encodedOptions, message);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee to send a message to the linked app on the remote chain.\n    function _getMessageFee(\n        uint64 dstChainId,\n        OptionsV1 memory options,\n        uint256 messageLen\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _getInterchainFee(dstChainId, encodedOptions, messageLen);\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view override returns (bytes memory) {\n        return _appConfigV1.encodeAppConfigV1();\n    }\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view override returns (address) {\n        return _executionService;\n    }\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view override returns (address) {\n        return _latestClient;\n    }\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view override returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint64 srcChainId, bytes32 sender) internal view override returns (bool) {\n        return _linkedApp[srcChainId] == sender;\n    }\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view override returns (bool) {\n        return _interchainClients.contains(caller);\n    }\n}\n\n// contracts/apps/examples/ExampleAppV1.sol\n\ncontract ExampleAppV1 is ICAppV1 {\n    event MessageReceived(uint64 srcChainId, bytes32 sender, uint64 dbNonce, uint64 entryIndex, bytes message);\n    event MessageSent(uint64 dstChainId, uint64 dbNonce, uint64 entryIndex, bytes32 transactionId);\n\n    constructor(address admin) ICAppV1(admin) {\n        _grantRole(IC_GOVERNOR_ROLE, admin);\n    }\n\n    /// @notice Allows the Admin to withdraw the native asset from the contract.\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        Address.sendValue(payable(msg.sender), address(this).balance);\n    }\n\n    /// @notice Sends a basic message to the destination chain.\n    function sendMessage(\n        uint64 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        InterchainTxDescriptor memory desc = _sendToLinkedApp({\n            dstChainId: dstChainId,\n            messageFee: msg.value,\n            options: OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}),\n            message: message\n        });\n        emit MessageSent(dstChainId, desc.dbNonce, desc.entryIndex, desc.transactionId);\n    }\n\n    /// @notice Returns the fee required to send a message using `sendMessage`.\n    function getMessageFee(\n        uint64 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes memory message\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _getMessageFee(dstChainId, OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}), message.length);\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        override\n    {\n        emit MessageReceived(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"requiredResponses","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"optimisticPeriod","type":"uint256"}],"name":"AppConfigV1Set","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"chainId","type":"uint256"},{"indexed":true,"internalType":"bytes32","name":"remoteApp","type":"bytes32"}],"name":"AppLinked","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"executionService","type":"address"}],"name":"ExecutionServiceSet","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"module","type":"address"}],"name":"TrustedModuleAdded","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"module","type":"address"}],"name":"TrustedModuleRemoved","type":"event"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requiredResponses\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"optimisticPeriod\",\"type\":\"uint256\"}],\"name\":\"AppConfigV1Set\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"remoteApp\",\"type\":\"bytes32\"}],\"name\":\"AppLinked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"executionService\",\"type\":\"address\"}],\"name\":\"ExecutionServiceSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"TrustedModuleAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"TrustedModuleRemoved\",\"type\":\"event\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/ExampleAppV1.sol\":\"InterchainAppV1Events\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/ExampleAppV1.sol\":{\"keccak256\":\"0xb1e9550aef785a0afc4e03fc843839919987ba4f906f09992c6788979c3c0396\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://0ede697223dfa3a2e23501efc1ed5926d5ff6458ee7b9ba833e0587162166c79\",\"dweb:/ipfs/QmUzgopL2ptWG5DYNdGAcoErPnBC4KCoRp8C61dkHHRaA6\"]}},\"version\":1}"},"hashes":{}},"solidity/ExampleAppV1.sol:InterchainTransactionLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212203a492d02a3899980031ef91cf996c44e02997b5dbe4adbdb0fba61f00d54aa0e64736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212203a492d02a3899980031ef91cf996c44e02997b5dbe4adbdb0fba61f00d54aa0e64736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/AbstractICAppEvents.sol\n\nabstract contract AbstractICAppEvents {\n    event InterchainClientAdded(address client);\n    event InterchainClientRemoved(address client);\n    event LatestClientSet(address client);\n}\n\n// contracts/events/InterchainAppV1Events.sol\n\nabstract contract InterchainAppV1Events {\n    event AppConfigV1Set(uint256 requiredResponses, uint256 optimisticPeriod);\n    event AppLinked(uint256 indexed chainId, bytes32 indexed remoteApp);\n    event ExecutionServiceSet(address executionService);\n    event TrustedModuleAdded(address module);\n    event TrustedModuleRemoved(address module);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    /// @notice Allows the Interchain Client to pass the message to the Interchain App.\n    /// @dev App is responsible for keeping track of interchain clients, and must verify the message sender.\n    /// @param srcChainId   Chain ID of the source chain, where the message was sent from.\n    /// @param sender       Sender address on the source chain, as a bytes32 value.\n    /// @param dbNonce      The Interchain DB nonce of the batch containing the message entry.\n    /// @param entryIndex   The index of the message entry within the batch.\n    /// @param message      The message being sent.\n    function appReceive(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /// @notice Returns the verification configuration of the Interchain App.\n    /// @dev This configuration is used by the Interchain Client to verify that message has been confirmed\n    /// by the Interchain Modules on the destination chain.\n    /// Note: V1 version of AppConfig includes the required responses count, and optimistic period after which\n    /// the message is considered confirmed by the module. Following versions may include additional fields.\n    /// @return appConfig    The versioned configuration of the Interchain App, encoded as bytes.\n    /// @return modules      The list of Interchain Modules that app is trusting to confirm the messages.\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/Math.sol\n\nlibrary MathLib {\n    /// @notice Rounds up to the nearest multiple of 32.\n    /// Note: Returns zero on overflows instead of reverting. This is fine for practical\n    /// use cases, as this is used for determining the size of the payload in memory.\n    function roundUpToWord(uint256 x) internal pure returns (uint256) {\n        unchecked {\n            return (x + 31) \u0026 ~uint256(31);\n        }\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/VersionedPayload.sol\n\n// solhint-disable no-inline-assembly\n// solhint-disable ordering\nlibrary VersionedPayloadLib {\n    /// @notice Amount of bytes reserved for the version (uint16) in the versioned payload\n    uint256 internal constant VERSION_LENGTH = 2;\n\n    error VersionedPayload__TooShort(bytes versionedPayload);\n    error VersionedPayload__PrecompileFailed();\n\n    /// @notice Encodes the versioned payload into a single bytes array.\n    /// @param version  The payload's version.\n    /// @param payload  The payload to encode.\n    function encodeVersionedPayload(uint16 version, bytes memory payload) internal pure returns (bytes memory) {\n        return abi.encodePacked(version, payload);\n    }\n\n    /// @notice Extracts the version from the versioned payload (calldata reference).\n    /// @param versionedPayload     The versioned payload (calldata reference).\n    function getVersion(bytes calldata versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            version := shr(240, calldataload(versionedPayload.offset))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (calldata reference).\n    /// @dev The extracted payload is also returned as a calldata reference.\n    /// @param versionedPayload     The versioned payload.\n    function getPayload(bytes calldata versionedPayload) internal pure returns (bytes calldata) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        return versionedPayload[VERSION_LENGTH:];\n    }\n\n    /// @notice Extracts the version from the versioned payload (memory reference).\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getVersionFromMemory(bytes memory versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            // We add 0x20 to skip the length of the bytes array.\n            version := shr(240, mload(add(versionedPayload, 0x20)))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (memory reference).\n    /// @dev The extracted payload is copied into a new memory location. Use `getPayload` when possible\n    /// to avoid extra memory allocation.\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getPayloadFromMemory(bytes memory versionedPayload) internal view returns (bytes memory payload) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        // Figure how many bytes to copy and allocate the memory for the extracted payload.\n        uint256 toCopy;\n        unchecked {\n            toCopy = versionedPayload.length - VERSION_LENGTH;\n        }\n        payload = new bytes(toCopy);\n        // Use identity precompile (0x04) to copy the payload. Unlike MCOPY, this is available on all EVM chains.\n        bool res;\n        assembly {\n            // We add 0x20 to skip the length of the bytes array.\n            // We add 0x02 to skip the 2 bytes reserved for the version.\n            // Copy the payload to the previously allocated memory.\n            res := staticcall(gas(), 0x04, add(versionedPayload, 0x22), toCopy, add(payload, 0x20), toCopy)\n        }\n        if (!res) {\n            revert VersionedPayload__PrecompileFailed();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/IAccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n\n// node_modules/@openzeppelin/contracts/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance \u003c amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance \u003c value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 \u0026\u0026 target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SafeCast.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value \u003e type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value \u003e type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value \u003e type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value \u003e type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value \u003e type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value \u003e type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value \u003e type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value \u003e type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value \u003e type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value \u003e type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value \u003e type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value \u003e type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value \u003e type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value \u003e type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value \u003e type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value \u003e type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value \u003e type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value \u003e type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value \u003e type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value \u003e type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value \u003e type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value \u003e type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value \u003e type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value \u003e type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value \u003e type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value \u003e type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value \u003e type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value \u003e type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value \u003e type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value \u003e type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value \u003e type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value \u003c 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value \u003e uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal view returns (AppConfigV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (AppConfigV1));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal view returns (OptionsV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (OptionsV1));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(OPTIONS_V1, abi.encode(options));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/IAccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/IAccessControlEnumerable.sol)\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n// contracts/interfaces/IInterchainAppV1.sol\n\ninterface IInterchainAppV1 is IInterchainApp {\n    error InterchainApp__AppZeroAddress();\n    error InterchainApp__InvalidAppConfig(uint256 requiredResponses, uint256 optimisticPeriod);\n    error InterchainApp__ModuleAlreadyAdded(address module);\n    error InterchainApp__ModuleNotAdded(address module);\n    error InterchainApp__ModuleZeroAddress();\n    error InterchainApp__NotEVMLinkedApp(bytes32 linkedApp);\n\n    /// @notice Allows the owner to add the interchain client to the allowed clients set,\n    /// and optionally set the latest client to this one.\n    /// Note: only the allowed clients can send messages to this app.\n    /// Note: the latest client is used for sending messages from this app.\n    /// @param client       The address of the interchain client to add.\n    /// @param updateLatest Whether to set the latest client to this one.\n    function addInterchainClient(address client, bool updateLatest) external;\n\n    /// @notice Allows the owner to remove the interchain client from the allowed clients set.\n    /// If the client is the latest client, the latest client is set to the zero address.\n    /// @param client       The address of the interchain client to remove.\n    function removeInterchainClient(address client) external;\n\n    /// @notice Allows the owner to set the address of the latest interchain client.\n    /// @dev The new latest client must be an allowed client or zero address.\n    /// Setting the client to zero address effectively pauses the app ability to send messages,\n    /// while allowing to receive them.\n    /// @param client       The address of the latest interchain client.\n    function setLatestInterchainClient(address client) external;\n\n    /// @notice Allows the owner to link the remote app for the given chain ID.\n    /// - This address will be used as the receiver for the messages sent from this chain.\n    /// - This address will be the only trusted sender for the messages sent to this chain.\n    /// @param chainId      The remote chain ID.\n    /// @param remoteApp    The address of the remote app to link.\n    function linkRemoteApp(uint64 chainId, bytes32 remoteApp) external;\n\n    /// @notice Thin wrapper for `linkRemoteApp` to accept EVM address as a parameter.\n    function linkRemoteAppEVM(uint64 chainId, address remoteApp) external;\n\n    /// @notice Allows the owner to add the module to the trusted modules set.\n    /// - This set of modules will be used to verify both sent and received messages.\n    function addTrustedModule(address module) external;\n\n    /// @notice Allows the owner to remove the module from the trusted modules set.\n    function removeTrustedModule(address module) external;\n\n    /// @notice Allows the owner to set the app config for the current app. App config includes:\n    /// - requiredResponses: the number of module responses required for accepting the message\n    /// - optimisticPeriod: the minimum time after which the module responses are considered final\n    function setAppConfigV1(AppConfigV1 memory appConfig) external;\n\n    /// @notice Allows the owner to set the address of the Execution Service.\n    /// This address will be used to request execution of the messages sent from this chain,\n    /// by supplying the Service's execution fee.\n    function setExecutionService(address executionService) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Returns the app config for the current app: requiredResponses and optimisticPeriod.\n    function getAppConfigV1() external view returns (AppConfigV1 memory);\n\n    /// @notice Returns the address of the Execution Service used by this app for sending messages.\n    function getExecutionService() external view returns (address);\n\n    /// @notice Returns the list of Interchain Clients allowed to send messages to this app.\n    function getInterchainClients() external view returns (address[] memory);\n\n    /// @notice Returns the address of the latest interchain client.\n    /// This address is used for sending messages from this app.\n    function getLatestInterchainClient() external view returns (address);\n\n    /// @notice Returns the linked app address (as bytes32) for the given chain ID.\n    function getLinkedApp(uint64 chainId) external view returns (bytes32);\n\n    /// @notice Thin wrapper for `getLinkedApp` to return the linked app address as EVM address.\n    /// @dev Will revert if the linked app address is not an EVM address.\n    function getLinkedAppEVM(uint64 chainId) external view returns (address);\n\n    /// @notice Returns the list of Interchain Modules trusted by this app.\n    /// This set of modules will be used to verify both sent and received messages.\n    function getModules() external view returns (address[] memory);\n}\n\n// contracts/libs/InterchainTransaction.sol\n\ntype ICTxHeader is uint256;\n\nstruct InterchainTransaction {\n    uint64 srcChainId;\n    uint64 dstChainId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcSender;\n    bytes32 dstReceiver;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    using MathLib for uint256;\n    using VersionedPayloadLib for bytes;\n\n    function constructLocalTransaction(\n        address srcSender,\n        uint64 dstChainId,\n        bytes32 dstReceiver,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: SafeCast.toUint64(block.chainid),\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            encodeTxHeader(transaction.srcChainId, transaction.dstChainId, transaction.dbNonce, transaction.entryIndex),\n            transaction.srcSender,\n            transaction.dstReceiver,\n            transaction.options,\n            transaction.message\n        );\n    }\n\n    function decodeTransaction(bytes calldata transaction) internal pure returns (InterchainTransaction memory icTx) {\n        ICTxHeader header;\n        (header, icTx.srcSender, icTx.dstReceiver, icTx.options, icTx.message) =\n            abi.decode(transaction, (ICTxHeader, bytes32, bytes32, bytes, bytes));\n        (icTx.srcChainId, icTx.dstChainId, icTx.dbNonce, icTx.entryIndex) = decodeTxHeader(header);\n    }\n\n    function payloadSize(uint256 optionsLen, uint256 messageLen) internal pure returns (uint256) {\n        // 2 bytes are reserved for the transaction version\n        // + 5 fields * 32 bytes (3 values for static, 2 offsets for dynamic) + 2 * 32 bytes (lengths for dynamic) = 226\n        // (srcChainId, dstChainId, dbNonce, entryIndex) are merged into a single 32 bytes field\n        // Both options and message are dynamic fields, which are padded up to 32 bytes\n        return 226 + optionsLen.roundUpToWord() + messageLen.roundUpToWord();\n    }\n\n    function encodeTxHeader(\n        uint64 srcChainId,\n        uint64 dstChainId,\n        uint64 dbNonce,\n        uint64 entryIndex\n    )\n        internal\n        pure\n        returns (ICTxHeader)\n    {\n        return ICTxHeader.wrap(\n            (uint256(srcChainId) \u003c\u003c 192) | (uint256(dstChainId) \u003c\u003c 128) | (uint256(dbNonce) \u003c\u003c 64) | uint256(entryIndex)\n        );\n    }\n\n    function decodeTxHeader(ICTxHeader header)\n        internal\n        pure\n        returns (uint64 srcChainId, uint64 dstChainId, uint64 dbNonce, uint64 entryIndex)\n    {\n        srcChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 192);\n        dstChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 128);\n        dbNonce = uint64(ICTxHeader.unwrap(header) \u003e\u003e 64);\n        entryIndex = uint64(ICTxHeader.unwrap(header));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/AccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account =\u003e bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role =\u003e RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint64 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__InvalidTransactionVersion(uint16 version);\n    error InterchainClientV1__NoLinkedClient(uint64 chainId);\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint64 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint64 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint64 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint64 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param messageLen           The length of the message being sent.\n    function getInterchainFee(\n        uint64 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        uint256 messageLen\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint64 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint64 chainId) external view returns (address);\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/AccessControlEnumerable.sol)\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 role =\u003e EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {AccessControl-_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool granted = super._grantRole(role, account);\n        if (granted) {\n            _roleMembers[role].add(account);\n        }\n        return granted;\n    }\n\n    /**\n     * @dev Overload {AccessControl-_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool revoked = super._revokeRole(role, account);\n        if (revoked) {\n            _roleMembers[role].remove(account);\n        }\n        return revoked;\n    }\n}\n\n// contracts/apps/AbstractICApp.sol\n\nabstract contract AbstractICApp is AbstractICAppEvents, IInterchainApp {\n    using TypeCasts for address;\n\n    error InterchainApp__AlreadyLatestClient(address client);\n    error InterchainApp__BalanceTooLow(uint256 actual, uint256 required);\n    error InterchainApp__ClientAlreadyAdded(address client);\n    error InterchainApp__InterchainClientZeroAddress();\n    error InterchainApp__NotInterchainClient(address account);\n    error InterchainApp__ReceiverNotSet(uint64 chainId);\n    error InterchainApp__SameChainId(uint64 chainId);\n    error InterchainApp__SenderNotAllowed(uint64 srcChainId, bytes32 sender);\n\n    /// @inheritdoc IInterchainApp\n    function appReceive(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        if (!_isInterchainClient(msg.sender)) {\n            revert InterchainApp__NotInterchainClient(msg.sender);\n        }\n        if (srcChainId == block.chainid) {\n            revert InterchainApp__SameChainId(srcChainId);\n        }\n        if (!_isAllowedSender(srcChainId, sender)) {\n            revert InterchainApp__SenderNotAllowed(srcChainId, sender);\n        }\n        _receiveMessage(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n\n    /// @inheritdoc IInterchainApp\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules) {\n        appConfig = _getAppConfig();\n        modules = _getModules();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Performs necessary checks and adds an Interchain Client.\n    /// Optionally sets the latest client to this one.\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _addClient(address client, bool updateLatest) internal {\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (_isInterchainClient(client)) {\n            revert InterchainApp__ClientAlreadyAdded(client);\n        }\n        _toggleClientState(client, true);\n        emit InterchainClientAdded(client);\n        if (updateLatest) {\n            _setLatestClient(client);\n        }\n    }\n\n    /// @dev Performs necessary checks and removes an Interchain Client. If this client is the latest one,\n    /// the latest client is set to zero address (effectively pausing the app ability to send messages).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _removeClient(address client) internal {\n        if (!_isInterchainClient(client)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        _toggleClientState(client, false);\n        emit InterchainClientRemoved(client);\n        if (client == _getLatestClient()) {\n            _setLatestClient(address(0));\n        }\n    }\n\n    /// @dev Sets the latest Interchain Client to one of the allowed clients. Setting the client to zero address\n    /// is allowed and effectively pauses the app ability to send messages (but still allows to receive them).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _setLatestClient(address client) internal {\n        // New latest client must be an allowed client or zero address.\n        if (!_isInterchainClient(client) \u0026\u0026 client != address(0)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        if (client == _getLatestClient()) {\n            revert InterchainApp__AlreadyLatestClient(client);\n        }\n        _storeLatestClient(client);\n        emit LatestClientSet(client);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal virtual;\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal virtual;\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to accept EVM address as a parameter.\n    function _sendInterchainMessageEVM(\n        uint64 dstChainId,\n        address receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _sendInterchainMessage(dstChainId, receiver.addressToBytes32(), messageFee, options, message);\n    }\n\n    /// @dev Performs necessary checks and sends an interchain message.\n    function _sendInterchainMessage(\n        uint64 dstChainId,\n        bytes32 receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (dstChainId == block.chainid) {\n            revert InterchainApp__SameChainId(dstChainId);\n        }\n        if (receiver == 0) {\n            revert InterchainApp__ReceiverNotSet(dstChainId);\n        }\n        if (address(this).balance \u003c messageFee) {\n            revert InterchainApp__BalanceTooLow({actual: address(this).balance, required: messageFee});\n        }\n        return IInterchainClientV1(client).interchainSend{value: messageFee}(\n            dstChainId, receiver, _getExecutionService(), _getModules(), options, message\n        );\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        virtual;\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee for sending an Interchain message.\n    function _getInterchainFee(\n        uint64 dstChainId,\n        bytes memory options,\n        uint256 messageLen\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        return IInterchainClientV1(client).getInterchainFee(\n            dstChainId, _getExecutionService(), _getModules(), options, messageLen\n        );\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view virtual returns (bytes memory);\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view virtual returns (address);\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view virtual returns (address);\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view virtual returns (address[] memory);\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint64 srcChainId, bytes32 sender) internal view virtual returns (bool);\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view virtual returns (bool);\n}\n\n// contracts/apps/ICAppV1.sol\n\nabstract contract ICAppV1 is AbstractICApp, AccessControlEnumerable, InterchainAppV1Events, IInterchainAppV1 {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Role to manage the Interchain setup of the app.\n    bytes32 public constant IC_GOVERNOR_ROLE = keccak256(\"IC_GOVERNOR_ROLE\");\n\n    /// @dev Address of the latest Interchain Client, used for sending messages.\n    address private _latestClient;\n\n    /// @dev Required responses and optimistic period for the module responses.\n    AppConfigV1 private _appConfigV1;\n    /// @dev Address of the linked app deployed on the remote chain.\n    mapping(uint64 chainId =\u003e bytes32 remoteApp) private _linkedApp;\n    /// @dev Interchain Clients allowed to send messages to this app.\n    EnumerableSet.AddressSet private _interchainClients;\n    /// @dev Trusted Interchain modules.\n    EnumerableSet.AddressSet private _trustedModules;\n    /// @dev Execution Service to use for sending messages.\n    address private _executionService;\n\n    constructor(address admin) {\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addInterchainClient(address client, bool updateLatest) external onlyRole(IC_GOVERNOR_ROLE) {\n        _addClient(client, updateLatest);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _removeClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setLatestInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _setLatestClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteApp(uint64 chainId, bytes32 remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteAppEVM(uint64 chainId, address remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp.addressToBytes32());\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (module == address(0)) {\n            revert InterchainApp__ModuleZeroAddress();\n        }\n        bool added = _trustedModules.add(module);\n        if (!added) {\n            revert InterchainApp__ModuleAlreadyAdded(module);\n        }\n        emit TrustedModuleAdded(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        bool removed = _trustedModules.remove(module);\n        if (!removed) {\n            revert InterchainApp__ModuleNotAdded(module);\n        }\n        emit TrustedModuleRemoved(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setAppConfigV1(AppConfigV1 memory appConfig) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (appConfig.requiredResponses == 0 || appConfig.optimisticPeriod == 0) {\n            revert InterchainApp__InvalidAppConfig(appConfig.requiredResponses, appConfig.optimisticPeriod);\n        }\n        _appConfigV1 = appConfig;\n        emit AppConfigV1Set(appConfig.requiredResponses, appConfig.optimisticPeriod);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setExecutionService(address executionService) external onlyRole(IC_GOVERNOR_ROLE) {\n        _executionService = executionService;\n        emit ExecutionServiceSet(executionService);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainAppV1\n    function getAppConfigV1() external view returns (AppConfigV1 memory) {\n        return _appConfigV1;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getExecutionService() external view returns (address) {\n        return _executionService;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getInterchainClients() external view returns (address[] memory) {\n        return _interchainClients.values();\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLatestInterchainClient() external view returns (address) {\n        return _latestClient;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedApp(uint64 chainId) external view returns (bytes32) {\n        return _linkedApp[chainId];\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedAppEVM(uint64 chainId) external view returns (address linkedAppEVM) {\n        bytes32 linkedApp = _linkedApp[chainId];\n        linkedAppEVM = linkedApp.bytes32ToAddress();\n        if (linkedAppEVM.addressToBytes32() != linkedApp) {\n            revert InterchainApp__NotEVMLinkedApp(linkedApp);\n        }\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getModules() external view returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Links the remote app to the current app.\n    /// Will revert if the chainId is the same as the chainId of the local app.\n    /// Note: Should be guarded with permissions check.\n    function _linkRemoteApp(uint64 chainId, bytes32 remoteApp) internal {\n        if (chainId == block.chainid) {\n            revert InterchainApp__SameChainId(chainId);\n        }\n        if (remoteApp == 0) {\n            revert InterchainApp__AppZeroAddress();\n        }\n        _linkedApp[chainId] = remoteApp;\n        emit AppLinked(chainId, remoteApp);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal override {\n        _latestClient = client;\n    }\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal override {\n        if (allowed) {\n            _interchainClients.add(client);\n        } else {\n            _interchainClients.remove(client);\n        }\n    }\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to send the message to the linked app.\n    function _sendToLinkedApp(\n        uint64 dstChainId,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _sendInterchainMessage(dstChainId, _linkedApp[dstChainId], messageFee, encodedOptions, message);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee to send a message to the linked app on the remote chain.\n    function _getMessageFee(\n        uint64 dstChainId,\n        OptionsV1 memory options,\n        uint256 messageLen\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _getInterchainFee(dstChainId, encodedOptions, messageLen);\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view override returns (bytes memory) {\n        return _appConfigV1.encodeAppConfigV1();\n    }\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view override returns (address) {\n        return _executionService;\n    }\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view override returns (address) {\n        return _latestClient;\n    }\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view override returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint64 srcChainId, bytes32 sender) internal view override returns (bool) {\n        return _linkedApp[srcChainId] == sender;\n    }\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view override returns (bool) {\n        return _interchainClients.contains(caller);\n    }\n}\n\n// contracts/apps/examples/ExampleAppV1.sol\n\ncontract ExampleAppV1 is ICAppV1 {\n    event MessageReceived(uint64 srcChainId, bytes32 sender, uint64 dbNonce, uint64 entryIndex, bytes message);\n    event MessageSent(uint64 dstChainId, uint64 dbNonce, uint64 entryIndex, bytes32 transactionId);\n\n    constructor(address admin) ICAppV1(admin) {\n        _grantRole(IC_GOVERNOR_ROLE, admin);\n    }\n\n    /// @notice Allows the Admin to withdraw the native asset from the contract.\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        Address.sendValue(payable(msg.sender), address(this).balance);\n    }\n\n    /// @notice Sends a basic message to the destination chain.\n    function sendMessage(\n        uint64 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        InterchainTxDescriptor memory desc = _sendToLinkedApp({\n            dstChainId: dstChainId,\n            messageFee: msg.value,\n            options: OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}),\n            message: message\n        });\n        emit MessageSent(dstChainId, desc.dbNonce, desc.entryIndex, desc.transactionId);\n    }\n\n    /// @notice Returns the fee required to send a message using `sendMessage`.\n    function getMessageFee(\n        uint64 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes memory message\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _getMessageFee(dstChainId, OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}), message.length);\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        override\n    {\n        emit MessageReceived(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"76982:2997:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;76982:2997:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"76982:2997:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/ExampleAppV1.sol\":\"InterchainTransactionLib\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/ExampleAppV1.sol\":{\"keccak256\":\"0xb1e9550aef785a0afc4e03fc843839919987ba4f906f09992c6788979c3c0396\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://0ede697223dfa3a2e23501efc1ed5926d5ff6458ee7b9ba833e0587162166c79\",\"dweb:/ipfs/QmUzgopL2ptWG5DYNdGAcoErPnBC4KCoRp8C61dkHHRaA6\"]}},\"version\":1}"},"hashes":{}},"solidity/ExampleAppV1.sol:MathLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122056c4a726ad438123565e231d0bdce72450b84e21bea75262d76ce9054925efa664736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122056c4a726ad438123565e231d0bdce72450b84e21bea75262d76ce9054925efa664736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/AbstractICAppEvents.sol\n\nabstract contract AbstractICAppEvents {\n    event InterchainClientAdded(address client);\n    event InterchainClientRemoved(address client);\n    event LatestClientSet(address client);\n}\n\n// contracts/events/InterchainAppV1Events.sol\n\nabstract contract InterchainAppV1Events {\n    event AppConfigV1Set(uint256 requiredResponses, uint256 optimisticPeriod);\n    event AppLinked(uint256 indexed chainId, bytes32 indexed remoteApp);\n    event ExecutionServiceSet(address executionService);\n    event TrustedModuleAdded(address module);\n    event TrustedModuleRemoved(address module);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    /// @notice Allows the Interchain Client to pass the message to the Interchain App.\n    /// @dev App is responsible for keeping track of interchain clients, and must verify the message sender.\n    /// @param srcChainId   Chain ID of the source chain, where the message was sent from.\n    /// @param sender       Sender address on the source chain, as a bytes32 value.\n    /// @param dbNonce      The Interchain DB nonce of the batch containing the message entry.\n    /// @param entryIndex   The index of the message entry within the batch.\n    /// @param message      The message being sent.\n    function appReceive(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /// @notice Returns the verification configuration of the Interchain App.\n    /// @dev This configuration is used by the Interchain Client to verify that message has been confirmed\n    /// by the Interchain Modules on the destination chain.\n    /// Note: V1 version of AppConfig includes the required responses count, and optimistic period after which\n    /// the message is considered confirmed by the module. Following versions may include additional fields.\n    /// @return appConfig    The versioned configuration of the Interchain App, encoded as bytes.\n    /// @return modules      The list of Interchain Modules that app is trusting to confirm the messages.\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/Math.sol\n\nlibrary MathLib {\n    /// @notice Rounds up to the nearest multiple of 32.\n    /// Note: Returns zero on overflows instead of reverting. This is fine for practical\n    /// use cases, as this is used for determining the size of the payload in memory.\n    function roundUpToWord(uint256 x) internal pure returns (uint256) {\n        unchecked {\n            return (x + 31) \u0026 ~uint256(31);\n        }\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/VersionedPayload.sol\n\n// solhint-disable no-inline-assembly\n// solhint-disable ordering\nlibrary VersionedPayloadLib {\n    /// @notice Amount of bytes reserved for the version (uint16) in the versioned payload\n    uint256 internal constant VERSION_LENGTH = 2;\n\n    error VersionedPayload__TooShort(bytes versionedPayload);\n    error VersionedPayload__PrecompileFailed();\n\n    /// @notice Encodes the versioned payload into a single bytes array.\n    /// @param version  The payload's version.\n    /// @param payload  The payload to encode.\n    function encodeVersionedPayload(uint16 version, bytes memory payload) internal pure returns (bytes memory) {\n        return abi.encodePacked(version, payload);\n    }\n\n    /// @notice Extracts the version from the versioned payload (calldata reference).\n    /// @param versionedPayload     The versioned payload (calldata reference).\n    function getVersion(bytes calldata versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            version := shr(240, calldataload(versionedPayload.offset))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (calldata reference).\n    /// @dev The extracted payload is also returned as a calldata reference.\n    /// @param versionedPayload     The versioned payload.\n    function getPayload(bytes calldata versionedPayload) internal pure returns (bytes calldata) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        return versionedPayload[VERSION_LENGTH:];\n    }\n\n    /// @notice Extracts the version from the versioned payload (memory reference).\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getVersionFromMemory(bytes memory versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            // We add 0x20 to skip the length of the bytes array.\n            version := shr(240, mload(add(versionedPayload, 0x20)))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (memory reference).\n    /// @dev The extracted payload is copied into a new memory location. Use `getPayload` when possible\n    /// to avoid extra memory allocation.\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getPayloadFromMemory(bytes memory versionedPayload) internal view returns (bytes memory payload) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        // Figure how many bytes to copy and allocate the memory for the extracted payload.\n        uint256 toCopy;\n        unchecked {\n            toCopy = versionedPayload.length - VERSION_LENGTH;\n        }\n        payload = new bytes(toCopy);\n        // Use identity precompile (0x04) to copy the payload. Unlike MCOPY, this is available on all EVM chains.\n        bool res;\n        assembly {\n            // We add 0x20 to skip the length of the bytes array.\n            // We add 0x02 to skip the 2 bytes reserved for the version.\n            // Copy the payload to the previously allocated memory.\n            res := staticcall(gas(), 0x04, add(versionedPayload, 0x22), toCopy, add(payload, 0x20), toCopy)\n        }\n        if (!res) {\n            revert VersionedPayload__PrecompileFailed();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/IAccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n\n// node_modules/@openzeppelin/contracts/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance \u003c amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance \u003c value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 \u0026\u0026 target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SafeCast.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value \u003e type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value \u003e type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value \u003e type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value \u003e type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value \u003e type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value \u003e type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value \u003e type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value \u003e type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value \u003e type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value \u003e type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value \u003e type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value \u003e type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value \u003e type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value \u003e type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value \u003e type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value \u003e type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value \u003e type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value \u003e type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value \u003e type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value \u003e type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value \u003e type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value \u003e type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value \u003e type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value \u003e type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value \u003e type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value \u003e type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value \u003e type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value \u003e type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value \u003e type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value \u003e type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value \u003e type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value \u003c 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value \u003e uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal view returns (AppConfigV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (AppConfigV1));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal view returns (OptionsV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (OptionsV1));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(OPTIONS_V1, abi.encode(options));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/IAccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/IAccessControlEnumerable.sol)\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n// contracts/interfaces/IInterchainAppV1.sol\n\ninterface IInterchainAppV1 is IInterchainApp {\n    error InterchainApp__AppZeroAddress();\n    error InterchainApp__InvalidAppConfig(uint256 requiredResponses, uint256 optimisticPeriod);\n    error InterchainApp__ModuleAlreadyAdded(address module);\n    error InterchainApp__ModuleNotAdded(address module);\n    error InterchainApp__ModuleZeroAddress();\n    error InterchainApp__NotEVMLinkedApp(bytes32 linkedApp);\n\n    /// @notice Allows the owner to add the interchain client to the allowed clients set,\n    /// and optionally set the latest client to this one.\n    /// Note: only the allowed clients can send messages to this app.\n    /// Note: the latest client is used for sending messages from this app.\n    /// @param client       The address of the interchain client to add.\n    /// @param updateLatest Whether to set the latest client to this one.\n    function addInterchainClient(address client, bool updateLatest) external;\n\n    /// @notice Allows the owner to remove the interchain client from the allowed clients set.\n    /// If the client is the latest client, the latest client is set to the zero address.\n    /// @param client       The address of the interchain client to remove.\n    function removeInterchainClient(address client) external;\n\n    /// @notice Allows the owner to set the address of the latest interchain client.\n    /// @dev The new latest client must be an allowed client or zero address.\n    /// Setting the client to zero address effectively pauses the app ability to send messages,\n    /// while allowing to receive them.\n    /// @param client       The address of the latest interchain client.\n    function setLatestInterchainClient(address client) external;\n\n    /// @notice Allows the owner to link the remote app for the given chain ID.\n    /// - This address will be used as the receiver for the messages sent from this chain.\n    /// - This address will be the only trusted sender for the messages sent to this chain.\n    /// @param chainId      The remote chain ID.\n    /// @param remoteApp    The address of the remote app to link.\n    function linkRemoteApp(uint64 chainId, bytes32 remoteApp) external;\n\n    /// @notice Thin wrapper for `linkRemoteApp` to accept EVM address as a parameter.\n    function linkRemoteAppEVM(uint64 chainId, address remoteApp) external;\n\n    /// @notice Allows the owner to add the module to the trusted modules set.\n    /// - This set of modules will be used to verify both sent and received messages.\n    function addTrustedModule(address module) external;\n\n    /// @notice Allows the owner to remove the module from the trusted modules set.\n    function removeTrustedModule(address module) external;\n\n    /// @notice Allows the owner to set the app config for the current app. App config includes:\n    /// - requiredResponses: the number of module responses required for accepting the message\n    /// - optimisticPeriod: the minimum time after which the module responses are considered final\n    function setAppConfigV1(AppConfigV1 memory appConfig) external;\n\n    /// @notice Allows the owner to set the address of the Execution Service.\n    /// This address will be used to request execution of the messages sent from this chain,\n    /// by supplying the Service's execution fee.\n    function setExecutionService(address executionService) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Returns the app config for the current app: requiredResponses and optimisticPeriod.\n    function getAppConfigV1() external view returns (AppConfigV1 memory);\n\n    /// @notice Returns the address of the Execution Service used by this app for sending messages.\n    function getExecutionService() external view returns (address);\n\n    /// @notice Returns the list of Interchain Clients allowed to send messages to this app.\n    function getInterchainClients() external view returns (address[] memory);\n\n    /// @notice Returns the address of the latest interchain client.\n    /// This address is used for sending messages from this app.\n    function getLatestInterchainClient() external view returns (address);\n\n    /// @notice Returns the linked app address (as bytes32) for the given chain ID.\n    function getLinkedApp(uint64 chainId) external view returns (bytes32);\n\n    /// @notice Thin wrapper for `getLinkedApp` to return the linked app address as EVM address.\n    /// @dev Will revert if the linked app address is not an EVM address.\n    function getLinkedAppEVM(uint64 chainId) external view returns (address);\n\n    /// @notice Returns the list of Interchain Modules trusted by this app.\n    /// This set of modules will be used to verify both sent and received messages.\n    function getModules() external view returns (address[] memory);\n}\n\n// contracts/libs/InterchainTransaction.sol\n\ntype ICTxHeader is uint256;\n\nstruct InterchainTransaction {\n    uint64 srcChainId;\n    uint64 dstChainId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcSender;\n    bytes32 dstReceiver;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    using MathLib for uint256;\n    using VersionedPayloadLib for bytes;\n\n    function constructLocalTransaction(\n        address srcSender,\n        uint64 dstChainId,\n        bytes32 dstReceiver,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: SafeCast.toUint64(block.chainid),\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            encodeTxHeader(transaction.srcChainId, transaction.dstChainId, transaction.dbNonce, transaction.entryIndex),\n            transaction.srcSender,\n            transaction.dstReceiver,\n            transaction.options,\n            transaction.message\n        );\n    }\n\n    function decodeTransaction(bytes calldata transaction) internal pure returns (InterchainTransaction memory icTx) {\n        ICTxHeader header;\n        (header, icTx.srcSender, icTx.dstReceiver, icTx.options, icTx.message) =\n            abi.decode(transaction, (ICTxHeader, bytes32, bytes32, bytes, bytes));\n        (icTx.srcChainId, icTx.dstChainId, icTx.dbNonce, icTx.entryIndex) = decodeTxHeader(header);\n    }\n\n    function payloadSize(uint256 optionsLen, uint256 messageLen) internal pure returns (uint256) {\n        // 2 bytes are reserved for the transaction version\n        // + 5 fields * 32 bytes (3 values for static, 2 offsets for dynamic) + 2 * 32 bytes (lengths for dynamic) = 226\n        // (srcChainId, dstChainId, dbNonce, entryIndex) are merged into a single 32 bytes field\n        // Both options and message are dynamic fields, which are padded up to 32 bytes\n        return 226 + optionsLen.roundUpToWord() + messageLen.roundUpToWord();\n    }\n\n    function encodeTxHeader(\n        uint64 srcChainId,\n        uint64 dstChainId,\n        uint64 dbNonce,\n        uint64 entryIndex\n    )\n        internal\n        pure\n        returns (ICTxHeader)\n    {\n        return ICTxHeader.wrap(\n            (uint256(srcChainId) \u003c\u003c 192) | (uint256(dstChainId) \u003c\u003c 128) | (uint256(dbNonce) \u003c\u003c 64) | uint256(entryIndex)\n        );\n    }\n\n    function decodeTxHeader(ICTxHeader header)\n        internal\n        pure\n        returns (uint64 srcChainId, uint64 dstChainId, uint64 dbNonce, uint64 entryIndex)\n    {\n        srcChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 192);\n        dstChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 128);\n        dbNonce = uint64(ICTxHeader.unwrap(header) \u003e\u003e 64);\n        entryIndex = uint64(ICTxHeader.unwrap(header));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/AccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account =\u003e bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role =\u003e RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint64 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__InvalidTransactionVersion(uint16 version);\n    error InterchainClientV1__NoLinkedClient(uint64 chainId);\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint64 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint64 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint64 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint64 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param messageLen           The length of the message being sent.\n    function getInterchainFee(\n        uint64 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        uint256 messageLen\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint64 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint64 chainId) external view returns (address);\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/AccessControlEnumerable.sol)\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 role =\u003e EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {AccessControl-_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool granted = super._grantRole(role, account);\n        if (granted) {\n            _roleMembers[role].add(account);\n        }\n        return granted;\n    }\n\n    /**\n     * @dev Overload {AccessControl-_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool revoked = super._revokeRole(role, account);\n        if (revoked) {\n            _roleMembers[role].remove(account);\n        }\n        return revoked;\n    }\n}\n\n// contracts/apps/AbstractICApp.sol\n\nabstract contract AbstractICApp is AbstractICAppEvents, IInterchainApp {\n    using TypeCasts for address;\n\n    error InterchainApp__AlreadyLatestClient(address client);\n    error InterchainApp__BalanceTooLow(uint256 actual, uint256 required);\n    error InterchainApp__ClientAlreadyAdded(address client);\n    error InterchainApp__InterchainClientZeroAddress();\n    error InterchainApp__NotInterchainClient(address account);\n    error InterchainApp__ReceiverNotSet(uint64 chainId);\n    error InterchainApp__SameChainId(uint64 chainId);\n    error InterchainApp__SenderNotAllowed(uint64 srcChainId, bytes32 sender);\n\n    /// @inheritdoc IInterchainApp\n    function appReceive(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        if (!_isInterchainClient(msg.sender)) {\n            revert InterchainApp__NotInterchainClient(msg.sender);\n        }\n        if (srcChainId == block.chainid) {\n            revert InterchainApp__SameChainId(srcChainId);\n        }\n        if (!_isAllowedSender(srcChainId, sender)) {\n            revert InterchainApp__SenderNotAllowed(srcChainId, sender);\n        }\n        _receiveMessage(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n\n    /// @inheritdoc IInterchainApp\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules) {\n        appConfig = _getAppConfig();\n        modules = _getModules();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Performs necessary checks and adds an Interchain Client.\n    /// Optionally sets the latest client to this one.\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _addClient(address client, bool updateLatest) internal {\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (_isInterchainClient(client)) {\n            revert InterchainApp__ClientAlreadyAdded(client);\n        }\n        _toggleClientState(client, true);\n        emit InterchainClientAdded(client);\n        if (updateLatest) {\n            _setLatestClient(client);\n        }\n    }\n\n    /// @dev Performs necessary checks and removes an Interchain Client. If this client is the latest one,\n    /// the latest client is set to zero address (effectively pausing the app ability to send messages).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _removeClient(address client) internal {\n        if (!_isInterchainClient(client)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        _toggleClientState(client, false);\n        emit InterchainClientRemoved(client);\n        if (client == _getLatestClient()) {\n            _setLatestClient(address(0));\n        }\n    }\n\n    /// @dev Sets the latest Interchain Client to one of the allowed clients. Setting the client to zero address\n    /// is allowed and effectively pauses the app ability to send messages (but still allows to receive them).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _setLatestClient(address client) internal {\n        // New latest client must be an allowed client or zero address.\n        if (!_isInterchainClient(client) \u0026\u0026 client != address(0)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        if (client == _getLatestClient()) {\n            revert InterchainApp__AlreadyLatestClient(client);\n        }\n        _storeLatestClient(client);\n        emit LatestClientSet(client);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal virtual;\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal virtual;\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to accept EVM address as a parameter.\n    function _sendInterchainMessageEVM(\n        uint64 dstChainId,\n        address receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _sendInterchainMessage(dstChainId, receiver.addressToBytes32(), messageFee, options, message);\n    }\n\n    /// @dev Performs necessary checks and sends an interchain message.\n    function _sendInterchainMessage(\n        uint64 dstChainId,\n        bytes32 receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (dstChainId == block.chainid) {\n            revert InterchainApp__SameChainId(dstChainId);\n        }\n        if (receiver == 0) {\n            revert InterchainApp__ReceiverNotSet(dstChainId);\n        }\n        if (address(this).balance \u003c messageFee) {\n            revert InterchainApp__BalanceTooLow({actual: address(this).balance, required: messageFee});\n        }\n        return IInterchainClientV1(client).interchainSend{value: messageFee}(\n            dstChainId, receiver, _getExecutionService(), _getModules(), options, message\n        );\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        virtual;\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee for sending an Interchain message.\n    function _getInterchainFee(\n        uint64 dstChainId,\n        bytes memory options,\n        uint256 messageLen\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        return IInterchainClientV1(client).getInterchainFee(\n            dstChainId, _getExecutionService(), _getModules(), options, messageLen\n        );\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view virtual returns (bytes memory);\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view virtual returns (address);\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view virtual returns (address);\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view virtual returns (address[] memory);\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint64 srcChainId, bytes32 sender) internal view virtual returns (bool);\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view virtual returns (bool);\n}\n\n// contracts/apps/ICAppV1.sol\n\nabstract contract ICAppV1 is AbstractICApp, AccessControlEnumerable, InterchainAppV1Events, IInterchainAppV1 {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Role to manage the Interchain setup of the app.\n    bytes32 public constant IC_GOVERNOR_ROLE = keccak256(\"IC_GOVERNOR_ROLE\");\n\n    /// @dev Address of the latest Interchain Client, used for sending messages.\n    address private _latestClient;\n\n    /// @dev Required responses and optimistic period for the module responses.\n    AppConfigV1 private _appConfigV1;\n    /// @dev Address of the linked app deployed on the remote chain.\n    mapping(uint64 chainId =\u003e bytes32 remoteApp) private _linkedApp;\n    /// @dev Interchain Clients allowed to send messages to this app.\n    EnumerableSet.AddressSet private _interchainClients;\n    /// @dev Trusted Interchain modules.\n    EnumerableSet.AddressSet private _trustedModules;\n    /// @dev Execution Service to use for sending messages.\n    address private _executionService;\n\n    constructor(address admin) {\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addInterchainClient(address client, bool updateLatest) external onlyRole(IC_GOVERNOR_ROLE) {\n        _addClient(client, updateLatest);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _removeClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setLatestInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _setLatestClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteApp(uint64 chainId, bytes32 remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteAppEVM(uint64 chainId, address remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp.addressToBytes32());\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (module == address(0)) {\n            revert InterchainApp__ModuleZeroAddress();\n        }\n        bool added = _trustedModules.add(module);\n        if (!added) {\n            revert InterchainApp__ModuleAlreadyAdded(module);\n        }\n        emit TrustedModuleAdded(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        bool removed = _trustedModules.remove(module);\n        if (!removed) {\n            revert InterchainApp__ModuleNotAdded(module);\n        }\n        emit TrustedModuleRemoved(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setAppConfigV1(AppConfigV1 memory appConfig) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (appConfig.requiredResponses == 0 || appConfig.optimisticPeriod == 0) {\n            revert InterchainApp__InvalidAppConfig(appConfig.requiredResponses, appConfig.optimisticPeriod);\n        }\n        _appConfigV1 = appConfig;\n        emit AppConfigV1Set(appConfig.requiredResponses, appConfig.optimisticPeriod);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setExecutionService(address executionService) external onlyRole(IC_GOVERNOR_ROLE) {\n        _executionService = executionService;\n        emit ExecutionServiceSet(executionService);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainAppV1\n    function getAppConfigV1() external view returns (AppConfigV1 memory) {\n        return _appConfigV1;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getExecutionService() external view returns (address) {\n        return _executionService;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getInterchainClients() external view returns (address[] memory) {\n        return _interchainClients.values();\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLatestInterchainClient() external view returns (address) {\n        return _latestClient;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedApp(uint64 chainId) external view returns (bytes32) {\n        return _linkedApp[chainId];\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedAppEVM(uint64 chainId) external view returns (address linkedAppEVM) {\n        bytes32 linkedApp = _linkedApp[chainId];\n        linkedAppEVM = linkedApp.bytes32ToAddress();\n        if (linkedAppEVM.addressToBytes32() != linkedApp) {\n            revert InterchainApp__NotEVMLinkedApp(linkedApp);\n        }\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getModules() external view returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Links the remote app to the current app.\n    /// Will revert if the chainId is the same as the chainId of the local app.\n    /// Note: Should be guarded with permissions check.\n    function _linkRemoteApp(uint64 chainId, bytes32 remoteApp) internal {\n        if (chainId == block.chainid) {\n            revert InterchainApp__SameChainId(chainId);\n        }\n        if (remoteApp == 0) {\n            revert InterchainApp__AppZeroAddress();\n        }\n        _linkedApp[chainId] = remoteApp;\n        emit AppLinked(chainId, remoteApp);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal override {\n        _latestClient = client;\n    }\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal override {\n        if (allowed) {\n            _interchainClients.add(client);\n        } else {\n            _interchainClients.remove(client);\n        }\n    }\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to send the message to the linked app.\n    function _sendToLinkedApp(\n        uint64 dstChainId,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _sendInterchainMessage(dstChainId, _linkedApp[dstChainId], messageFee, encodedOptions, message);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee to send a message to the linked app on the remote chain.\n    function _getMessageFee(\n        uint64 dstChainId,\n        OptionsV1 memory options,\n        uint256 messageLen\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _getInterchainFee(dstChainId, encodedOptions, messageLen);\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view override returns (bytes memory) {\n        return _appConfigV1.encodeAppConfigV1();\n    }\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view override returns (address) {\n        return _executionService;\n    }\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view override returns (address) {\n        return _latestClient;\n    }\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view override returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint64 srcChainId, bytes32 sender) internal view override returns (bool) {\n        return _linkedApp[srcChainId] == sender;\n    }\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view override returns (bool) {\n        return _interchainClients.contains(caller);\n    }\n}\n\n// contracts/apps/examples/ExampleAppV1.sol\n\ncontract ExampleAppV1 is ICAppV1 {\n    event MessageReceived(uint64 srcChainId, bytes32 sender, uint64 dbNonce, uint64 entryIndex, bytes message);\n    event MessageSent(uint64 dstChainId, uint64 dbNonce, uint64 entryIndex, bytes32 transactionId);\n\n    constructor(address admin) ICAppV1(admin) {\n        _grantRole(IC_GOVERNOR_ROLE, admin);\n    }\n\n    /// @notice Allows the Admin to withdraw the native asset from the contract.\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        Address.sendValue(payable(msg.sender), address(this).balance);\n    }\n\n    /// @notice Sends a basic message to the destination chain.\n    function sendMessage(\n        uint64 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        InterchainTxDescriptor memory desc = _sendToLinkedApp({\n            dstChainId: dstChainId,\n            messageFee: msg.value,\n            options: OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}),\n            message: message\n        });\n        emit MessageSent(dstChainId, desc.dbNonce, desc.entryIndex, desc.transactionId);\n    }\n\n    /// @notice Returns the fee required to send a message using `sendMessage`.\n    function getMessageFee(\n        uint64 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes memory message\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _getMessageFee(dstChainId, OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}), message.length);\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        override\n    {\n        emit MessageReceived(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"2470:403:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;2470:403:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"2470:403:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/ExampleAppV1.sol\":\"MathLib\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/ExampleAppV1.sol\":{\"keccak256\":\"0xb1e9550aef785a0afc4e03fc843839919987ba4f906f09992c6788979c3c0396\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://0ede697223dfa3a2e23501efc1ed5926d5ff6458ee7b9ba833e0587162166c79\",\"dweb:/ipfs/QmUzgopL2ptWG5DYNdGAcoErPnBC4KCoRp8C61dkHHRaA6\"]}},\"version\":1}"},"hashes":{}},"solidity/ExampleAppV1.sol:OptionsLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122014bd48eaab38897efe9b370b6f8d0e1a25072680ce158c5c0b7375d1c10e513464736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122014bd48eaab38897efe9b370b6f8d0e1a25072680ce158c5c0b7375d1c10e513464736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/AbstractICAppEvents.sol\n\nabstract contract AbstractICAppEvents {\n    event InterchainClientAdded(address client);\n    event InterchainClientRemoved(address client);\n    event LatestClientSet(address client);\n}\n\n// contracts/events/InterchainAppV1Events.sol\n\nabstract contract InterchainAppV1Events {\n    event AppConfigV1Set(uint256 requiredResponses, uint256 optimisticPeriod);\n    event AppLinked(uint256 indexed chainId, bytes32 indexed remoteApp);\n    event ExecutionServiceSet(address executionService);\n    event TrustedModuleAdded(address module);\n    event TrustedModuleRemoved(address module);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    /// @notice Allows the Interchain Client to pass the message to the Interchain App.\n    /// @dev App is responsible for keeping track of interchain clients, and must verify the message sender.\n    /// @param srcChainId   Chain ID of the source chain, where the message was sent from.\n    /// @param sender       Sender address on the source chain, as a bytes32 value.\n    /// @param dbNonce      The Interchain DB nonce of the batch containing the message entry.\n    /// @param entryIndex   The index of the message entry within the batch.\n    /// @param message      The message being sent.\n    function appReceive(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /// @notice Returns the verification configuration of the Interchain App.\n    /// @dev This configuration is used by the Interchain Client to verify that message has been confirmed\n    /// by the Interchain Modules on the destination chain.\n    /// Note: V1 version of AppConfig includes the required responses count, and optimistic period after which\n    /// the message is considered confirmed by the module. Following versions may include additional fields.\n    /// @return appConfig    The versioned configuration of the Interchain App, encoded as bytes.\n    /// @return modules      The list of Interchain Modules that app is trusting to confirm the messages.\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/Math.sol\n\nlibrary MathLib {\n    /// @notice Rounds up to the nearest multiple of 32.\n    /// Note: Returns zero on overflows instead of reverting. This is fine for practical\n    /// use cases, as this is used for determining the size of the payload in memory.\n    function roundUpToWord(uint256 x) internal pure returns (uint256) {\n        unchecked {\n            return (x + 31) \u0026 ~uint256(31);\n        }\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/VersionedPayload.sol\n\n// solhint-disable no-inline-assembly\n// solhint-disable ordering\nlibrary VersionedPayloadLib {\n    /// @notice Amount of bytes reserved for the version (uint16) in the versioned payload\n    uint256 internal constant VERSION_LENGTH = 2;\n\n    error VersionedPayload__TooShort(bytes versionedPayload);\n    error VersionedPayload__PrecompileFailed();\n\n    /// @notice Encodes the versioned payload into a single bytes array.\n    /// @param version  The payload's version.\n    /// @param payload  The payload to encode.\n    function encodeVersionedPayload(uint16 version, bytes memory payload) internal pure returns (bytes memory) {\n        return abi.encodePacked(version, payload);\n    }\n\n    /// @notice Extracts the version from the versioned payload (calldata reference).\n    /// @param versionedPayload     The versioned payload (calldata reference).\n    function getVersion(bytes calldata versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            version := shr(240, calldataload(versionedPayload.offset))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (calldata reference).\n    /// @dev The extracted payload is also returned as a calldata reference.\n    /// @param versionedPayload     The versioned payload.\n    function getPayload(bytes calldata versionedPayload) internal pure returns (bytes calldata) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        return versionedPayload[VERSION_LENGTH:];\n    }\n\n    /// @notice Extracts the version from the versioned payload (memory reference).\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getVersionFromMemory(bytes memory versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            // We add 0x20 to skip the length of the bytes array.\n            version := shr(240, mload(add(versionedPayload, 0x20)))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (memory reference).\n    /// @dev The extracted payload is copied into a new memory location. Use `getPayload` when possible\n    /// to avoid extra memory allocation.\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getPayloadFromMemory(bytes memory versionedPayload) internal view returns (bytes memory payload) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        // Figure how many bytes to copy and allocate the memory for the extracted payload.\n        uint256 toCopy;\n        unchecked {\n            toCopy = versionedPayload.length - VERSION_LENGTH;\n        }\n        payload = new bytes(toCopy);\n        // Use identity precompile (0x04) to copy the payload. Unlike MCOPY, this is available on all EVM chains.\n        bool res;\n        assembly {\n            // We add 0x20 to skip the length of the bytes array.\n            // We add 0x02 to skip the 2 bytes reserved for the version.\n            // Copy the payload to the previously allocated memory.\n            res := staticcall(gas(), 0x04, add(versionedPayload, 0x22), toCopy, add(payload, 0x20), toCopy)\n        }\n        if (!res) {\n            revert VersionedPayload__PrecompileFailed();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/IAccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n\n// node_modules/@openzeppelin/contracts/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance \u003c amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance \u003c value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 \u0026\u0026 target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SafeCast.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value \u003e type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value \u003e type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value \u003e type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value \u003e type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value \u003e type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value \u003e type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value \u003e type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value \u003e type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value \u003e type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value \u003e type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value \u003e type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value \u003e type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value \u003e type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value \u003e type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value \u003e type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value \u003e type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value \u003e type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value \u003e type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value \u003e type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value \u003e type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value \u003e type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value \u003e type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value \u003e type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value \u003e type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value \u003e type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value \u003e type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value \u003e type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value \u003e type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value \u003e type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value \u003e type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value \u003e type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value \u003c 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value \u003e uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal view returns (AppConfigV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (AppConfigV1));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal view returns (OptionsV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (OptionsV1));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(OPTIONS_V1, abi.encode(options));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/IAccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/IAccessControlEnumerable.sol)\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n// contracts/interfaces/IInterchainAppV1.sol\n\ninterface IInterchainAppV1 is IInterchainApp {\n    error InterchainApp__AppZeroAddress();\n    error InterchainApp__InvalidAppConfig(uint256 requiredResponses, uint256 optimisticPeriod);\n    error InterchainApp__ModuleAlreadyAdded(address module);\n    error InterchainApp__ModuleNotAdded(address module);\n    error InterchainApp__ModuleZeroAddress();\n    error InterchainApp__NotEVMLinkedApp(bytes32 linkedApp);\n\n    /// @notice Allows the owner to add the interchain client to the allowed clients set,\n    /// and optionally set the latest client to this one.\n    /// Note: only the allowed clients can send messages to this app.\n    /// Note: the latest client is used for sending messages from this app.\n    /// @param client       The address of the interchain client to add.\n    /// @param updateLatest Whether to set the latest client to this one.\n    function addInterchainClient(address client, bool updateLatest) external;\n\n    /// @notice Allows the owner to remove the interchain client from the allowed clients set.\n    /// If the client is the latest client, the latest client is set to the zero address.\n    /// @param client       The address of the interchain client to remove.\n    function removeInterchainClient(address client) external;\n\n    /// @notice Allows the owner to set the address of the latest interchain client.\n    /// @dev The new latest client must be an allowed client or zero address.\n    /// Setting the client to zero address effectively pauses the app ability to send messages,\n    /// while allowing to receive them.\n    /// @param client       The address of the latest interchain client.\n    function setLatestInterchainClient(address client) external;\n\n    /// @notice Allows the owner to link the remote app for the given chain ID.\n    /// - This address will be used as the receiver for the messages sent from this chain.\n    /// - This address will be the only trusted sender for the messages sent to this chain.\n    /// @param chainId      The remote chain ID.\n    /// @param remoteApp    The address of the remote app to link.\n    function linkRemoteApp(uint64 chainId, bytes32 remoteApp) external;\n\n    /// @notice Thin wrapper for `linkRemoteApp` to accept EVM address as a parameter.\n    function linkRemoteAppEVM(uint64 chainId, address remoteApp) external;\n\n    /// @notice Allows the owner to add the module to the trusted modules set.\n    /// - This set of modules will be used to verify both sent and received messages.\n    function addTrustedModule(address module) external;\n\n    /// @notice Allows the owner to remove the module from the trusted modules set.\n    function removeTrustedModule(address module) external;\n\n    /// @notice Allows the owner to set the app config for the current app. App config includes:\n    /// - requiredResponses: the number of module responses required for accepting the message\n    /// - optimisticPeriod: the minimum time after which the module responses are considered final\n    function setAppConfigV1(AppConfigV1 memory appConfig) external;\n\n    /// @notice Allows the owner to set the address of the Execution Service.\n    /// This address will be used to request execution of the messages sent from this chain,\n    /// by supplying the Service's execution fee.\n    function setExecutionService(address executionService) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Returns the app config for the current app: requiredResponses and optimisticPeriod.\n    function getAppConfigV1() external view returns (AppConfigV1 memory);\n\n    /// @notice Returns the address of the Execution Service used by this app for sending messages.\n    function getExecutionService() external view returns (address);\n\n    /// @notice Returns the list of Interchain Clients allowed to send messages to this app.\n    function getInterchainClients() external view returns (address[] memory);\n\n    /// @notice Returns the address of the latest interchain client.\n    /// This address is used for sending messages from this app.\n    function getLatestInterchainClient() external view returns (address);\n\n    /// @notice Returns the linked app address (as bytes32) for the given chain ID.\n    function getLinkedApp(uint64 chainId) external view returns (bytes32);\n\n    /// @notice Thin wrapper for `getLinkedApp` to return the linked app address as EVM address.\n    /// @dev Will revert if the linked app address is not an EVM address.\n    function getLinkedAppEVM(uint64 chainId) external view returns (address);\n\n    /// @notice Returns the list of Interchain Modules trusted by this app.\n    /// This set of modules will be used to verify both sent and received messages.\n    function getModules() external view returns (address[] memory);\n}\n\n// contracts/libs/InterchainTransaction.sol\n\ntype ICTxHeader is uint256;\n\nstruct InterchainTransaction {\n    uint64 srcChainId;\n    uint64 dstChainId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcSender;\n    bytes32 dstReceiver;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    using MathLib for uint256;\n    using VersionedPayloadLib for bytes;\n\n    function constructLocalTransaction(\n        address srcSender,\n        uint64 dstChainId,\n        bytes32 dstReceiver,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: SafeCast.toUint64(block.chainid),\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            encodeTxHeader(transaction.srcChainId, transaction.dstChainId, transaction.dbNonce, transaction.entryIndex),\n            transaction.srcSender,\n            transaction.dstReceiver,\n            transaction.options,\n            transaction.message\n        );\n    }\n\n    function decodeTransaction(bytes calldata transaction) internal pure returns (InterchainTransaction memory icTx) {\n        ICTxHeader header;\n        (header, icTx.srcSender, icTx.dstReceiver, icTx.options, icTx.message) =\n            abi.decode(transaction, (ICTxHeader, bytes32, bytes32, bytes, bytes));\n        (icTx.srcChainId, icTx.dstChainId, icTx.dbNonce, icTx.entryIndex) = decodeTxHeader(header);\n    }\n\n    function payloadSize(uint256 optionsLen, uint256 messageLen) internal pure returns (uint256) {\n        // 2 bytes are reserved for the transaction version\n        // + 5 fields * 32 bytes (3 values for static, 2 offsets for dynamic) + 2 * 32 bytes (lengths for dynamic) = 226\n        // (srcChainId, dstChainId, dbNonce, entryIndex) are merged into a single 32 bytes field\n        // Both options and message are dynamic fields, which are padded up to 32 bytes\n        return 226 + optionsLen.roundUpToWord() + messageLen.roundUpToWord();\n    }\n\n    function encodeTxHeader(\n        uint64 srcChainId,\n        uint64 dstChainId,\n        uint64 dbNonce,\n        uint64 entryIndex\n    )\n        internal\n        pure\n        returns (ICTxHeader)\n    {\n        return ICTxHeader.wrap(\n            (uint256(srcChainId) \u003c\u003c 192) | (uint256(dstChainId) \u003c\u003c 128) | (uint256(dbNonce) \u003c\u003c 64) | uint256(entryIndex)\n        );\n    }\n\n    function decodeTxHeader(ICTxHeader header)\n        internal\n        pure\n        returns (uint64 srcChainId, uint64 dstChainId, uint64 dbNonce, uint64 entryIndex)\n    {\n        srcChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 192);\n        dstChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 128);\n        dbNonce = uint64(ICTxHeader.unwrap(header) \u003e\u003e 64);\n        entryIndex = uint64(ICTxHeader.unwrap(header));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/AccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account =\u003e bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role =\u003e RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint64 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__InvalidTransactionVersion(uint16 version);\n    error InterchainClientV1__NoLinkedClient(uint64 chainId);\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint64 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint64 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint64 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint64 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param messageLen           The length of the message being sent.\n    function getInterchainFee(\n        uint64 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        uint256 messageLen\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint64 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint64 chainId) external view returns (address);\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/AccessControlEnumerable.sol)\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 role =\u003e EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {AccessControl-_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool granted = super._grantRole(role, account);\n        if (granted) {\n            _roleMembers[role].add(account);\n        }\n        return granted;\n    }\n\n    /**\n     * @dev Overload {AccessControl-_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool revoked = super._revokeRole(role, account);\n        if (revoked) {\n            _roleMembers[role].remove(account);\n        }\n        return revoked;\n    }\n}\n\n// contracts/apps/AbstractICApp.sol\n\nabstract contract AbstractICApp is AbstractICAppEvents, IInterchainApp {\n    using TypeCasts for address;\n\n    error InterchainApp__AlreadyLatestClient(address client);\n    error InterchainApp__BalanceTooLow(uint256 actual, uint256 required);\n    error InterchainApp__ClientAlreadyAdded(address client);\n    error InterchainApp__InterchainClientZeroAddress();\n    error InterchainApp__NotInterchainClient(address account);\n    error InterchainApp__ReceiverNotSet(uint64 chainId);\n    error InterchainApp__SameChainId(uint64 chainId);\n    error InterchainApp__SenderNotAllowed(uint64 srcChainId, bytes32 sender);\n\n    /// @inheritdoc IInterchainApp\n    function appReceive(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        if (!_isInterchainClient(msg.sender)) {\n            revert InterchainApp__NotInterchainClient(msg.sender);\n        }\n        if (srcChainId == block.chainid) {\n            revert InterchainApp__SameChainId(srcChainId);\n        }\n        if (!_isAllowedSender(srcChainId, sender)) {\n            revert InterchainApp__SenderNotAllowed(srcChainId, sender);\n        }\n        _receiveMessage(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n\n    /// @inheritdoc IInterchainApp\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules) {\n        appConfig = _getAppConfig();\n        modules = _getModules();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Performs necessary checks and adds an Interchain Client.\n    /// Optionally sets the latest client to this one.\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _addClient(address client, bool updateLatest) internal {\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (_isInterchainClient(client)) {\n            revert InterchainApp__ClientAlreadyAdded(client);\n        }\n        _toggleClientState(client, true);\n        emit InterchainClientAdded(client);\n        if (updateLatest) {\n            _setLatestClient(client);\n        }\n    }\n\n    /// @dev Performs necessary checks and removes an Interchain Client. If this client is the latest one,\n    /// the latest client is set to zero address (effectively pausing the app ability to send messages).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _removeClient(address client) internal {\n        if (!_isInterchainClient(client)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        _toggleClientState(client, false);\n        emit InterchainClientRemoved(client);\n        if (client == _getLatestClient()) {\n            _setLatestClient(address(0));\n        }\n    }\n\n    /// @dev Sets the latest Interchain Client to one of the allowed clients. Setting the client to zero address\n    /// is allowed and effectively pauses the app ability to send messages (but still allows to receive them).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _setLatestClient(address client) internal {\n        // New latest client must be an allowed client or zero address.\n        if (!_isInterchainClient(client) \u0026\u0026 client != address(0)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        if (client == _getLatestClient()) {\n            revert InterchainApp__AlreadyLatestClient(client);\n        }\n        _storeLatestClient(client);\n        emit LatestClientSet(client);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal virtual;\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal virtual;\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to accept EVM address as a parameter.\n    function _sendInterchainMessageEVM(\n        uint64 dstChainId,\n        address receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _sendInterchainMessage(dstChainId, receiver.addressToBytes32(), messageFee, options, message);\n    }\n\n    /// @dev Performs necessary checks and sends an interchain message.\n    function _sendInterchainMessage(\n        uint64 dstChainId,\n        bytes32 receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (dstChainId == block.chainid) {\n            revert InterchainApp__SameChainId(dstChainId);\n        }\n        if (receiver == 0) {\n            revert InterchainApp__ReceiverNotSet(dstChainId);\n        }\n        if (address(this).balance \u003c messageFee) {\n            revert InterchainApp__BalanceTooLow({actual: address(this).balance, required: messageFee});\n        }\n        return IInterchainClientV1(client).interchainSend{value: messageFee}(\n            dstChainId, receiver, _getExecutionService(), _getModules(), options, message\n        );\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        virtual;\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee for sending an Interchain message.\n    function _getInterchainFee(\n        uint64 dstChainId,\n        bytes memory options,\n        uint256 messageLen\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        return IInterchainClientV1(client).getInterchainFee(\n            dstChainId, _getExecutionService(), _getModules(), options, messageLen\n        );\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view virtual returns (bytes memory);\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view virtual returns (address);\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view virtual returns (address);\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view virtual returns (address[] memory);\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint64 srcChainId, bytes32 sender) internal view virtual returns (bool);\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view virtual returns (bool);\n}\n\n// contracts/apps/ICAppV1.sol\n\nabstract contract ICAppV1 is AbstractICApp, AccessControlEnumerable, InterchainAppV1Events, IInterchainAppV1 {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Role to manage the Interchain setup of the app.\n    bytes32 public constant IC_GOVERNOR_ROLE = keccak256(\"IC_GOVERNOR_ROLE\");\n\n    /// @dev Address of the latest Interchain Client, used for sending messages.\n    address private _latestClient;\n\n    /// @dev Required responses and optimistic period for the module responses.\n    AppConfigV1 private _appConfigV1;\n    /// @dev Address of the linked app deployed on the remote chain.\n    mapping(uint64 chainId =\u003e bytes32 remoteApp) private _linkedApp;\n    /// @dev Interchain Clients allowed to send messages to this app.\n    EnumerableSet.AddressSet private _interchainClients;\n    /// @dev Trusted Interchain modules.\n    EnumerableSet.AddressSet private _trustedModules;\n    /// @dev Execution Service to use for sending messages.\n    address private _executionService;\n\n    constructor(address admin) {\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addInterchainClient(address client, bool updateLatest) external onlyRole(IC_GOVERNOR_ROLE) {\n        _addClient(client, updateLatest);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _removeClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setLatestInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _setLatestClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteApp(uint64 chainId, bytes32 remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteAppEVM(uint64 chainId, address remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp.addressToBytes32());\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (module == address(0)) {\n            revert InterchainApp__ModuleZeroAddress();\n        }\n        bool added = _trustedModules.add(module);\n        if (!added) {\n            revert InterchainApp__ModuleAlreadyAdded(module);\n        }\n        emit TrustedModuleAdded(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        bool removed = _trustedModules.remove(module);\n        if (!removed) {\n            revert InterchainApp__ModuleNotAdded(module);\n        }\n        emit TrustedModuleRemoved(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setAppConfigV1(AppConfigV1 memory appConfig) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (appConfig.requiredResponses == 0 || appConfig.optimisticPeriod == 0) {\n            revert InterchainApp__InvalidAppConfig(appConfig.requiredResponses, appConfig.optimisticPeriod);\n        }\n        _appConfigV1 = appConfig;\n        emit AppConfigV1Set(appConfig.requiredResponses, appConfig.optimisticPeriod);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setExecutionService(address executionService) external onlyRole(IC_GOVERNOR_ROLE) {\n        _executionService = executionService;\n        emit ExecutionServiceSet(executionService);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainAppV1\n    function getAppConfigV1() external view returns (AppConfigV1 memory) {\n        return _appConfigV1;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getExecutionService() external view returns (address) {\n        return _executionService;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getInterchainClients() external view returns (address[] memory) {\n        return _interchainClients.values();\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLatestInterchainClient() external view returns (address) {\n        return _latestClient;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedApp(uint64 chainId) external view returns (bytes32) {\n        return _linkedApp[chainId];\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedAppEVM(uint64 chainId) external view returns (address linkedAppEVM) {\n        bytes32 linkedApp = _linkedApp[chainId];\n        linkedAppEVM = linkedApp.bytes32ToAddress();\n        if (linkedAppEVM.addressToBytes32() != linkedApp) {\n            revert InterchainApp__NotEVMLinkedApp(linkedApp);\n        }\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getModules() external view returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Links the remote app to the current app.\n    /// Will revert if the chainId is the same as the chainId of the local app.\n    /// Note: Should be guarded with permissions check.\n    function _linkRemoteApp(uint64 chainId, bytes32 remoteApp) internal {\n        if (chainId == block.chainid) {\n            revert InterchainApp__SameChainId(chainId);\n        }\n        if (remoteApp == 0) {\n            revert InterchainApp__AppZeroAddress();\n        }\n        _linkedApp[chainId] = remoteApp;\n        emit AppLinked(chainId, remoteApp);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal override {\n        _latestClient = client;\n    }\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal override {\n        if (allowed) {\n            _interchainClients.add(client);\n        } else {\n            _interchainClients.remove(client);\n        }\n    }\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to send the message to the linked app.\n    function _sendToLinkedApp(\n        uint64 dstChainId,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _sendInterchainMessage(dstChainId, _linkedApp[dstChainId], messageFee, encodedOptions, message);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee to send a message to the linked app on the remote chain.\n    function _getMessageFee(\n        uint64 dstChainId,\n        OptionsV1 memory options,\n        uint256 messageLen\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _getInterchainFee(dstChainId, encodedOptions, messageLen);\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view override returns (bytes memory) {\n        return _appConfigV1.encodeAppConfigV1();\n    }\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view override returns (address) {\n        return _executionService;\n    }\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view override returns (address) {\n        return _latestClient;\n    }\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view override returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint64 srcChainId, bytes32 sender) internal view override returns (bool) {\n        return _linkedApp[srcChainId] == sender;\n    }\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view override returns (bool) {\n        return _interchainClients.contains(caller);\n    }\n}\n\n// contracts/apps/examples/ExampleAppV1.sol\n\ncontract ExampleAppV1 is ICAppV1 {\n    event MessageReceived(uint64 srcChainId, bytes32 sender, uint64 dbNonce, uint64 entryIndex, bytes message);\n    event MessageSent(uint64 dstChainId, uint64 dbNonce, uint64 entryIndex, bytes32 transactionId);\n\n    constructor(address admin) ICAppV1(admin) {\n        _grantRole(IC_GOVERNOR_ROLE, admin);\n    }\n\n    /// @notice Allows the Admin to withdraw the native asset from the contract.\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        Address.sendValue(payable(msg.sender), address(this).balance);\n    }\n\n    /// @notice Sends a basic message to the destination chain.\n    function sendMessage(\n        uint64 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        InterchainTxDescriptor memory desc = _sendToLinkedApp({\n            dstChainId: dstChainId,\n            messageFee: msg.value,\n            options: OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}),\n            message: message\n        });\n        emit MessageSent(dstChainId, desc.dbNonce, desc.entryIndex, desc.transactionId);\n    }\n\n    /// @notice Returns the fee required to send a message using `sendMessage`.\n    function getMessageFee(\n        uint64 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes memory message\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _getMessageFee(dstChainId, OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}), message.length);\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        override\n    {\n        emit MessageReceived(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"68081:1233:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;68081:1233:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"68081:1233:0:-:0;;;;;;;;","abiDefinition":[{"inputs":[{"internalType":"uint16","name":"version","type":"uint16"}],"name":"OptionsLib__IncorrectVersion","type":"error"}],"userDoc":{"kind":"user","methods":{},"notice":"A library for encoding and decoding Interchain options related to interchain messages.","version":1},"developerDoc":{"kind":"dev","methods":{},"title":"OptionsLib","version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"version\",\"type\":\"uint16\"}],\"name\":\"OptionsLib__IncorrectVersion\",\"type\":\"error\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"title\":\"OptionsLib\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"A library for encoding and decoding Interchain options related to interchain messages.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/ExampleAppV1.sol\":\"OptionsLib\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/ExampleAppV1.sol\":{\"keccak256\":\"0xb1e9550aef785a0afc4e03fc843839919987ba4f906f09992c6788979c3c0396\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://0ede697223dfa3a2e23501efc1ed5926d5ff6458ee7b9ba833e0587162166c79\",\"dweb:/ipfs/QmUzgopL2ptWG5DYNdGAcoErPnBC4KCoRp8C61dkHHRaA6\"]}},\"version\":1}"},"hashes":{}},"solidity/ExampleAppV1.sol:SafeCast":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220e95f55fbd153b3834bfd7f26254bb8eee62be5fcadc0e9ec9cab209c23099a2064736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220e95f55fbd153b3834bfd7f26254bb8eee62be5fcadc0e9ec9cab209c23099a2064736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/AbstractICAppEvents.sol\n\nabstract contract AbstractICAppEvents {\n    event InterchainClientAdded(address client);\n    event InterchainClientRemoved(address client);\n    event LatestClientSet(address client);\n}\n\n// contracts/events/InterchainAppV1Events.sol\n\nabstract contract InterchainAppV1Events {\n    event AppConfigV1Set(uint256 requiredResponses, uint256 optimisticPeriod);\n    event AppLinked(uint256 indexed chainId, bytes32 indexed remoteApp);\n    event ExecutionServiceSet(address executionService);\n    event TrustedModuleAdded(address module);\n    event TrustedModuleRemoved(address module);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    /// @notice Allows the Interchain Client to pass the message to the Interchain App.\n    /// @dev App is responsible for keeping track of interchain clients, and must verify the message sender.\n    /// @param srcChainId   Chain ID of the source chain, where the message was sent from.\n    /// @param sender       Sender address on the source chain, as a bytes32 value.\n    /// @param dbNonce      The Interchain DB nonce of the batch containing the message entry.\n    /// @param entryIndex   The index of the message entry within the batch.\n    /// @param message      The message being sent.\n    function appReceive(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /// @notice Returns the verification configuration of the Interchain App.\n    /// @dev This configuration is used by the Interchain Client to verify that message has been confirmed\n    /// by the Interchain Modules on the destination chain.\n    /// Note: V1 version of AppConfig includes the required responses count, and optimistic period after which\n    /// the message is considered confirmed by the module. Following versions may include additional fields.\n    /// @return appConfig    The versioned configuration of the Interchain App, encoded as bytes.\n    /// @return modules      The list of Interchain Modules that app is trusting to confirm the messages.\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/Math.sol\n\nlibrary MathLib {\n    /// @notice Rounds up to the nearest multiple of 32.\n    /// Note: Returns zero on overflows instead of reverting. This is fine for practical\n    /// use cases, as this is used for determining the size of the payload in memory.\n    function roundUpToWord(uint256 x) internal pure returns (uint256) {\n        unchecked {\n            return (x + 31) \u0026 ~uint256(31);\n        }\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/VersionedPayload.sol\n\n// solhint-disable no-inline-assembly\n// solhint-disable ordering\nlibrary VersionedPayloadLib {\n    /// @notice Amount of bytes reserved for the version (uint16) in the versioned payload\n    uint256 internal constant VERSION_LENGTH = 2;\n\n    error VersionedPayload__TooShort(bytes versionedPayload);\n    error VersionedPayload__PrecompileFailed();\n\n    /// @notice Encodes the versioned payload into a single bytes array.\n    /// @param version  The payload's version.\n    /// @param payload  The payload to encode.\n    function encodeVersionedPayload(uint16 version, bytes memory payload) internal pure returns (bytes memory) {\n        return abi.encodePacked(version, payload);\n    }\n\n    /// @notice Extracts the version from the versioned payload (calldata reference).\n    /// @param versionedPayload     The versioned payload (calldata reference).\n    function getVersion(bytes calldata versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            version := shr(240, calldataload(versionedPayload.offset))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (calldata reference).\n    /// @dev The extracted payload is also returned as a calldata reference.\n    /// @param versionedPayload     The versioned payload.\n    function getPayload(bytes calldata versionedPayload) internal pure returns (bytes calldata) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        return versionedPayload[VERSION_LENGTH:];\n    }\n\n    /// @notice Extracts the version from the versioned payload (memory reference).\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getVersionFromMemory(bytes memory versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            // We add 0x20 to skip the length of the bytes array.\n            version := shr(240, mload(add(versionedPayload, 0x20)))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (memory reference).\n    /// @dev The extracted payload is copied into a new memory location. Use `getPayload` when possible\n    /// to avoid extra memory allocation.\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getPayloadFromMemory(bytes memory versionedPayload) internal view returns (bytes memory payload) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        // Figure how many bytes to copy and allocate the memory for the extracted payload.\n        uint256 toCopy;\n        unchecked {\n            toCopy = versionedPayload.length - VERSION_LENGTH;\n        }\n        payload = new bytes(toCopy);\n        // Use identity precompile (0x04) to copy the payload. Unlike MCOPY, this is available on all EVM chains.\n        bool res;\n        assembly {\n            // We add 0x20 to skip the length of the bytes array.\n            // We add 0x02 to skip the 2 bytes reserved for the version.\n            // Copy the payload to the previously allocated memory.\n            res := staticcall(gas(), 0x04, add(versionedPayload, 0x22), toCopy, add(payload, 0x20), toCopy)\n        }\n        if (!res) {\n            revert VersionedPayload__PrecompileFailed();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/IAccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n\n// node_modules/@openzeppelin/contracts/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance \u003c amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance \u003c value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 \u0026\u0026 target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SafeCast.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value \u003e type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value \u003e type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value \u003e type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value \u003e type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value \u003e type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value \u003e type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value \u003e type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value \u003e type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value \u003e type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value \u003e type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value \u003e type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value \u003e type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value \u003e type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value \u003e type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value \u003e type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value \u003e type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value \u003e type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value \u003e type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value \u003e type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value \u003e type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value \u003e type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value \u003e type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value \u003e type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value \u003e type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value \u003e type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value \u003e type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value \u003e type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value \u003e type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value \u003e type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value \u003e type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value \u003e type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value \u003c 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value \u003e uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal view returns (AppConfigV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (AppConfigV1));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal view returns (OptionsV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (OptionsV1));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(OPTIONS_V1, abi.encode(options));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/IAccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/IAccessControlEnumerable.sol)\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n// contracts/interfaces/IInterchainAppV1.sol\n\ninterface IInterchainAppV1 is IInterchainApp {\n    error InterchainApp__AppZeroAddress();\n    error InterchainApp__InvalidAppConfig(uint256 requiredResponses, uint256 optimisticPeriod);\n    error InterchainApp__ModuleAlreadyAdded(address module);\n    error InterchainApp__ModuleNotAdded(address module);\n    error InterchainApp__ModuleZeroAddress();\n    error InterchainApp__NotEVMLinkedApp(bytes32 linkedApp);\n\n    /// @notice Allows the owner to add the interchain client to the allowed clients set,\n    /// and optionally set the latest client to this one.\n    /// Note: only the allowed clients can send messages to this app.\n    /// Note: the latest client is used for sending messages from this app.\n    /// @param client       The address of the interchain client to add.\n    /// @param updateLatest Whether to set the latest client to this one.\n    function addInterchainClient(address client, bool updateLatest) external;\n\n    /// @notice Allows the owner to remove the interchain client from the allowed clients set.\n    /// If the client is the latest client, the latest client is set to the zero address.\n    /// @param client       The address of the interchain client to remove.\n    function removeInterchainClient(address client) external;\n\n    /// @notice Allows the owner to set the address of the latest interchain client.\n    /// @dev The new latest client must be an allowed client or zero address.\n    /// Setting the client to zero address effectively pauses the app ability to send messages,\n    /// while allowing to receive them.\n    /// @param client       The address of the latest interchain client.\n    function setLatestInterchainClient(address client) external;\n\n    /// @notice Allows the owner to link the remote app for the given chain ID.\n    /// - This address will be used as the receiver for the messages sent from this chain.\n    /// - This address will be the only trusted sender for the messages sent to this chain.\n    /// @param chainId      The remote chain ID.\n    /// @param remoteApp    The address of the remote app to link.\n    function linkRemoteApp(uint64 chainId, bytes32 remoteApp) external;\n\n    /// @notice Thin wrapper for `linkRemoteApp` to accept EVM address as a parameter.\n    function linkRemoteAppEVM(uint64 chainId, address remoteApp) external;\n\n    /// @notice Allows the owner to add the module to the trusted modules set.\n    /// - This set of modules will be used to verify both sent and received messages.\n    function addTrustedModule(address module) external;\n\n    /// @notice Allows the owner to remove the module from the trusted modules set.\n    function removeTrustedModule(address module) external;\n\n    /// @notice Allows the owner to set the app config for the current app. App config includes:\n    /// - requiredResponses: the number of module responses required for accepting the message\n    /// - optimisticPeriod: the minimum time after which the module responses are considered final\n    function setAppConfigV1(AppConfigV1 memory appConfig) external;\n\n    /// @notice Allows the owner to set the address of the Execution Service.\n    /// This address will be used to request execution of the messages sent from this chain,\n    /// by supplying the Service's execution fee.\n    function setExecutionService(address executionService) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Returns the app config for the current app: requiredResponses and optimisticPeriod.\n    function getAppConfigV1() external view returns (AppConfigV1 memory);\n\n    /// @notice Returns the address of the Execution Service used by this app for sending messages.\n    function getExecutionService() external view returns (address);\n\n    /// @notice Returns the list of Interchain Clients allowed to send messages to this app.\n    function getInterchainClients() external view returns (address[] memory);\n\n    /// @notice Returns the address of the latest interchain client.\n    /// This address is used for sending messages from this app.\n    function getLatestInterchainClient() external view returns (address);\n\n    /// @notice Returns the linked app address (as bytes32) for the given chain ID.\n    function getLinkedApp(uint64 chainId) external view returns (bytes32);\n\n    /// @notice Thin wrapper for `getLinkedApp` to return the linked app address as EVM address.\n    /// @dev Will revert if the linked app address is not an EVM address.\n    function getLinkedAppEVM(uint64 chainId) external view returns (address);\n\n    /// @notice Returns the list of Interchain Modules trusted by this app.\n    /// This set of modules will be used to verify both sent and received messages.\n    function getModules() external view returns (address[] memory);\n}\n\n// contracts/libs/InterchainTransaction.sol\n\ntype ICTxHeader is uint256;\n\nstruct InterchainTransaction {\n    uint64 srcChainId;\n    uint64 dstChainId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcSender;\n    bytes32 dstReceiver;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    using MathLib for uint256;\n    using VersionedPayloadLib for bytes;\n\n    function constructLocalTransaction(\n        address srcSender,\n        uint64 dstChainId,\n        bytes32 dstReceiver,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: SafeCast.toUint64(block.chainid),\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            encodeTxHeader(transaction.srcChainId, transaction.dstChainId, transaction.dbNonce, transaction.entryIndex),\n            transaction.srcSender,\n            transaction.dstReceiver,\n            transaction.options,\n            transaction.message\n        );\n    }\n\n    function decodeTransaction(bytes calldata transaction) internal pure returns (InterchainTransaction memory icTx) {\n        ICTxHeader header;\n        (header, icTx.srcSender, icTx.dstReceiver, icTx.options, icTx.message) =\n            abi.decode(transaction, (ICTxHeader, bytes32, bytes32, bytes, bytes));\n        (icTx.srcChainId, icTx.dstChainId, icTx.dbNonce, icTx.entryIndex) = decodeTxHeader(header);\n    }\n\n    function payloadSize(uint256 optionsLen, uint256 messageLen) internal pure returns (uint256) {\n        // 2 bytes are reserved for the transaction version\n        // + 5 fields * 32 bytes (3 values for static, 2 offsets for dynamic) + 2 * 32 bytes (lengths for dynamic) = 226\n        // (srcChainId, dstChainId, dbNonce, entryIndex) are merged into a single 32 bytes field\n        // Both options and message are dynamic fields, which are padded up to 32 bytes\n        return 226 + optionsLen.roundUpToWord() + messageLen.roundUpToWord();\n    }\n\n    function encodeTxHeader(\n        uint64 srcChainId,\n        uint64 dstChainId,\n        uint64 dbNonce,\n        uint64 entryIndex\n    )\n        internal\n        pure\n        returns (ICTxHeader)\n    {\n        return ICTxHeader.wrap(\n            (uint256(srcChainId) \u003c\u003c 192) | (uint256(dstChainId) \u003c\u003c 128) | (uint256(dbNonce) \u003c\u003c 64) | uint256(entryIndex)\n        );\n    }\n\n    function decodeTxHeader(ICTxHeader header)\n        internal\n        pure\n        returns (uint64 srcChainId, uint64 dstChainId, uint64 dbNonce, uint64 entryIndex)\n    {\n        srcChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 192);\n        dstChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 128);\n        dbNonce = uint64(ICTxHeader.unwrap(header) \u003e\u003e 64);\n        entryIndex = uint64(ICTxHeader.unwrap(header));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/AccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account =\u003e bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role =\u003e RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint64 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__InvalidTransactionVersion(uint16 version);\n    error InterchainClientV1__NoLinkedClient(uint64 chainId);\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint64 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint64 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint64 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint64 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param messageLen           The length of the message being sent.\n    function getInterchainFee(\n        uint64 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        uint256 messageLen\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint64 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint64 chainId) external view returns (address);\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/AccessControlEnumerable.sol)\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 role =\u003e EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {AccessControl-_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool granted = super._grantRole(role, account);\n        if (granted) {\n            _roleMembers[role].add(account);\n        }\n        return granted;\n    }\n\n    /**\n     * @dev Overload {AccessControl-_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool revoked = super._revokeRole(role, account);\n        if (revoked) {\n            _roleMembers[role].remove(account);\n        }\n        return revoked;\n    }\n}\n\n// contracts/apps/AbstractICApp.sol\n\nabstract contract AbstractICApp is AbstractICAppEvents, IInterchainApp {\n    using TypeCasts for address;\n\n    error InterchainApp__AlreadyLatestClient(address client);\n    error InterchainApp__BalanceTooLow(uint256 actual, uint256 required);\n    error InterchainApp__ClientAlreadyAdded(address client);\n    error InterchainApp__InterchainClientZeroAddress();\n    error InterchainApp__NotInterchainClient(address account);\n    error InterchainApp__ReceiverNotSet(uint64 chainId);\n    error InterchainApp__SameChainId(uint64 chainId);\n    error InterchainApp__SenderNotAllowed(uint64 srcChainId, bytes32 sender);\n\n    /// @inheritdoc IInterchainApp\n    function appReceive(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        if (!_isInterchainClient(msg.sender)) {\n            revert InterchainApp__NotInterchainClient(msg.sender);\n        }\n        if (srcChainId == block.chainid) {\n            revert InterchainApp__SameChainId(srcChainId);\n        }\n        if (!_isAllowedSender(srcChainId, sender)) {\n            revert InterchainApp__SenderNotAllowed(srcChainId, sender);\n        }\n        _receiveMessage(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n\n    /// @inheritdoc IInterchainApp\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules) {\n        appConfig = _getAppConfig();\n        modules = _getModules();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Performs necessary checks and adds an Interchain Client.\n    /// Optionally sets the latest client to this one.\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _addClient(address client, bool updateLatest) internal {\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (_isInterchainClient(client)) {\n            revert InterchainApp__ClientAlreadyAdded(client);\n        }\n        _toggleClientState(client, true);\n        emit InterchainClientAdded(client);\n        if (updateLatest) {\n            _setLatestClient(client);\n        }\n    }\n\n    /// @dev Performs necessary checks and removes an Interchain Client. If this client is the latest one,\n    /// the latest client is set to zero address (effectively pausing the app ability to send messages).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _removeClient(address client) internal {\n        if (!_isInterchainClient(client)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        _toggleClientState(client, false);\n        emit InterchainClientRemoved(client);\n        if (client == _getLatestClient()) {\n            _setLatestClient(address(0));\n        }\n    }\n\n    /// @dev Sets the latest Interchain Client to one of the allowed clients. Setting the client to zero address\n    /// is allowed and effectively pauses the app ability to send messages (but still allows to receive them).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _setLatestClient(address client) internal {\n        // New latest client must be an allowed client or zero address.\n        if (!_isInterchainClient(client) \u0026\u0026 client != address(0)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        if (client == _getLatestClient()) {\n            revert InterchainApp__AlreadyLatestClient(client);\n        }\n        _storeLatestClient(client);\n        emit LatestClientSet(client);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal virtual;\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal virtual;\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to accept EVM address as a parameter.\n    function _sendInterchainMessageEVM(\n        uint64 dstChainId,\n        address receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _sendInterchainMessage(dstChainId, receiver.addressToBytes32(), messageFee, options, message);\n    }\n\n    /// @dev Performs necessary checks and sends an interchain message.\n    function _sendInterchainMessage(\n        uint64 dstChainId,\n        bytes32 receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (dstChainId == block.chainid) {\n            revert InterchainApp__SameChainId(dstChainId);\n        }\n        if (receiver == 0) {\n            revert InterchainApp__ReceiverNotSet(dstChainId);\n        }\n        if (address(this).balance \u003c messageFee) {\n            revert InterchainApp__BalanceTooLow({actual: address(this).balance, required: messageFee});\n        }\n        return IInterchainClientV1(client).interchainSend{value: messageFee}(\n            dstChainId, receiver, _getExecutionService(), _getModules(), options, message\n        );\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        virtual;\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee for sending an Interchain message.\n    function _getInterchainFee(\n        uint64 dstChainId,\n        bytes memory options,\n        uint256 messageLen\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        return IInterchainClientV1(client).getInterchainFee(\n            dstChainId, _getExecutionService(), _getModules(), options, messageLen\n        );\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view virtual returns (bytes memory);\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view virtual returns (address);\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view virtual returns (address);\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view virtual returns (address[] memory);\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint64 srcChainId, bytes32 sender) internal view virtual returns (bool);\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view virtual returns (bool);\n}\n\n// contracts/apps/ICAppV1.sol\n\nabstract contract ICAppV1 is AbstractICApp, AccessControlEnumerable, InterchainAppV1Events, IInterchainAppV1 {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Role to manage the Interchain setup of the app.\n    bytes32 public constant IC_GOVERNOR_ROLE = keccak256(\"IC_GOVERNOR_ROLE\");\n\n    /// @dev Address of the latest Interchain Client, used for sending messages.\n    address private _latestClient;\n\n    /// @dev Required responses and optimistic period for the module responses.\n    AppConfigV1 private _appConfigV1;\n    /// @dev Address of the linked app deployed on the remote chain.\n    mapping(uint64 chainId =\u003e bytes32 remoteApp) private _linkedApp;\n    /// @dev Interchain Clients allowed to send messages to this app.\n    EnumerableSet.AddressSet private _interchainClients;\n    /// @dev Trusted Interchain modules.\n    EnumerableSet.AddressSet private _trustedModules;\n    /// @dev Execution Service to use for sending messages.\n    address private _executionService;\n\n    constructor(address admin) {\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addInterchainClient(address client, bool updateLatest) external onlyRole(IC_GOVERNOR_ROLE) {\n        _addClient(client, updateLatest);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _removeClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setLatestInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _setLatestClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteApp(uint64 chainId, bytes32 remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteAppEVM(uint64 chainId, address remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp.addressToBytes32());\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (module == address(0)) {\n            revert InterchainApp__ModuleZeroAddress();\n        }\n        bool added = _trustedModules.add(module);\n        if (!added) {\n            revert InterchainApp__ModuleAlreadyAdded(module);\n        }\n        emit TrustedModuleAdded(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        bool removed = _trustedModules.remove(module);\n        if (!removed) {\n            revert InterchainApp__ModuleNotAdded(module);\n        }\n        emit TrustedModuleRemoved(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setAppConfigV1(AppConfigV1 memory appConfig) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (appConfig.requiredResponses == 0 || appConfig.optimisticPeriod == 0) {\n            revert InterchainApp__InvalidAppConfig(appConfig.requiredResponses, appConfig.optimisticPeriod);\n        }\n        _appConfigV1 = appConfig;\n        emit AppConfigV1Set(appConfig.requiredResponses, appConfig.optimisticPeriod);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setExecutionService(address executionService) external onlyRole(IC_GOVERNOR_ROLE) {\n        _executionService = executionService;\n        emit ExecutionServiceSet(executionService);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainAppV1\n    function getAppConfigV1() external view returns (AppConfigV1 memory) {\n        return _appConfigV1;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getExecutionService() external view returns (address) {\n        return _executionService;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getInterchainClients() external view returns (address[] memory) {\n        return _interchainClients.values();\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLatestInterchainClient() external view returns (address) {\n        return _latestClient;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedApp(uint64 chainId) external view returns (bytes32) {\n        return _linkedApp[chainId];\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedAppEVM(uint64 chainId) external view returns (address linkedAppEVM) {\n        bytes32 linkedApp = _linkedApp[chainId];\n        linkedAppEVM = linkedApp.bytes32ToAddress();\n        if (linkedAppEVM.addressToBytes32() != linkedApp) {\n            revert InterchainApp__NotEVMLinkedApp(linkedApp);\n        }\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getModules() external view returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Links the remote app to the current app.\n    /// Will revert if the chainId is the same as the chainId of the local app.\n    /// Note: Should be guarded with permissions check.\n    function _linkRemoteApp(uint64 chainId, bytes32 remoteApp) internal {\n        if (chainId == block.chainid) {\n            revert InterchainApp__SameChainId(chainId);\n        }\n        if (remoteApp == 0) {\n            revert InterchainApp__AppZeroAddress();\n        }\n        _linkedApp[chainId] = remoteApp;\n        emit AppLinked(chainId, remoteApp);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal override {\n        _latestClient = client;\n    }\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal override {\n        if (allowed) {\n            _interchainClients.add(client);\n        } else {\n            _interchainClients.remove(client);\n        }\n    }\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to send the message to the linked app.\n    function _sendToLinkedApp(\n        uint64 dstChainId,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _sendInterchainMessage(dstChainId, _linkedApp[dstChainId], messageFee, encodedOptions, message);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee to send a message to the linked app on the remote chain.\n    function _getMessageFee(\n        uint64 dstChainId,\n        OptionsV1 memory options,\n        uint256 messageLen\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _getInterchainFee(dstChainId, encodedOptions, messageLen);\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view override returns (bytes memory) {\n        return _appConfigV1.encodeAppConfigV1();\n    }\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view override returns (address) {\n        return _executionService;\n    }\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view override returns (address) {\n        return _latestClient;\n    }\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view override returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint64 srcChainId, bytes32 sender) internal view override returns (bool) {\n        return _linkedApp[srcChainId] == sender;\n    }\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view override returns (bool) {\n        return _interchainClients.contains(caller);\n    }\n}\n\n// contracts/apps/examples/ExampleAppV1.sol\n\ncontract ExampleAppV1 is ICAppV1 {\n    event MessageReceived(uint64 srcChainId, bytes32 sender, uint64 dbNonce, uint64 entryIndex, bytes message);\n    event MessageSent(uint64 dstChainId, uint64 dbNonce, uint64 entryIndex, bytes32 transactionId);\n\n    constructor(address admin) ICAppV1(admin) {\n        _grantRole(IC_GOVERNOR_ROLE, admin);\n    }\n\n    /// @notice Allows the Admin to withdraw the native asset from the contract.\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        Address.sendValue(payable(msg.sender), address(this).balance);\n    }\n\n    /// @notice Sends a basic message to the destination chain.\n    function sendMessage(\n        uint64 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        InterchainTxDescriptor memory desc = _sendToLinkedApp({\n            dstChainId: dstChainId,\n            messageFee: msg.value,\n            options: OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}),\n            message: message\n        });\n        emit MessageSent(dstChainId, desc.dbNonce, desc.entryIndex, desc.transactionId);\n    }\n\n    /// @notice Returns the fee required to send a message using `sendMessage`.\n    function getMessageFee(\n        uint64 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes memory message\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _getMessageFee(dstChainId, OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}), message.length);\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        override\n    {\n        emit MessageReceived(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"19209:33927:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;19209:33927:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"19209:33927:0:-:0;;;;;;;;","abiDefinition":[{"inputs":[{"internalType":"uint8","name":"bits","type":"uint8"},{"internalType":"int256","name":"value","type":"int256"}],"name":"SafeCastOverflowedIntDowncast","type":"error"},{"inputs":[{"internalType":"int256","name":"value","type":"int256"}],"name":"SafeCastOverflowedIntToUint","type":"error"},{"inputs":[{"internalType":"uint8","name":"bits","type":"uint8"},{"internalType":"uint256","name":"value","type":"uint256"}],"name":"SafeCastOverflowedUintDowncast","type":"error"},{"inputs":[{"internalType":"uint256","name":"value","type":"uint256"}],"name":"SafeCastOverflowedUintToInt","type":"error"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"details":"Wrappers over Solidity's uintXX/intXX casting operators with added overflow checks. Downcasting from uint256/int256 in Solidity does not revert on overflow. This can easily result in undesired exploitation or bugs, since developers usually assume that overflows raise errors. `SafeCast` restores this intuition by reverting the transaction when such an operation overflows. Using this library instead of the unchecked operations eliminates an entire class of bugs, so it's recommended to use it always.","errors":{"SafeCastOverflowedIntDowncast(uint8,int256)":[{"details":"Value doesn't fit in an int of `bits` size."}],"SafeCastOverflowedIntToUint(int256)":[{"details":"An int value doesn't fit in an uint of `bits` size."}],"SafeCastOverflowedUintDowncast(uint8,uint256)":[{"details":"Value doesn't fit in an uint of `bits` size."}],"SafeCastOverflowedUintToInt(uint256)":[{"details":"An uint value doesn't fit in an int of `bits` size."}]},"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"bits\",\"type\":\"uint8\"},{\"internalType\":\"int256\",\"name\":\"value\",\"type\":\"int256\"}],\"name\":\"SafeCastOverflowedIntDowncast\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"value\",\"type\":\"int256\"}],\"name\":\"SafeCastOverflowedIntToUint\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"bits\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"SafeCastOverflowedUintDowncast\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"SafeCastOverflowedUintToInt\",\"type\":\"error\"}],\"devdoc\":{\"details\":\"Wrappers over Solidity's uintXX/intXX casting operators with added overflow checks. Downcasting from uint256/int256 in Solidity does not revert on overflow. This can easily result in undesired exploitation or bugs, since developers usually assume that overflows raise errors. `SafeCast` restores this intuition by reverting the transaction when such an operation overflows. Using this library instead of the unchecked operations eliminates an entire class of bugs, so it's recommended to use it always.\",\"errors\":{\"SafeCastOverflowedIntDowncast(uint8,int256)\":[{\"details\":\"Value doesn't fit in an int of `bits` size.\"}],\"SafeCastOverflowedIntToUint(int256)\":[{\"details\":\"An int value doesn't fit in an uint of `bits` size.\"}],\"SafeCastOverflowedUintDowncast(uint8,uint256)\":[{\"details\":\"Value doesn't fit in an uint of `bits` size.\"}],\"SafeCastOverflowedUintToInt(uint256)\":[{\"details\":\"An uint value doesn't fit in an int of `bits` size.\"}]},\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/ExampleAppV1.sol\":\"SafeCast\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/ExampleAppV1.sol\":{\"keccak256\":\"0xb1e9550aef785a0afc4e03fc843839919987ba4f906f09992c6788979c3c0396\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://0ede697223dfa3a2e23501efc1ed5926d5ff6458ee7b9ba833e0587162166c79\",\"dweb:/ipfs/QmUzgopL2ptWG5DYNdGAcoErPnBC4KCoRp8C61dkHHRaA6\"]}},\"version\":1}"},"hashes":{}},"solidity/ExampleAppV1.sol:TypeCasts":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220d86f8a41bc6340f4198fd224f6d75009d365e08304bbe750d0ee633cf62879b464736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220d86f8a41bc6340f4198fd224f6d75009d365e08304bbe750d0ee633cf62879b464736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/AbstractICAppEvents.sol\n\nabstract contract AbstractICAppEvents {\n    event InterchainClientAdded(address client);\n    event InterchainClientRemoved(address client);\n    event LatestClientSet(address client);\n}\n\n// contracts/events/InterchainAppV1Events.sol\n\nabstract contract InterchainAppV1Events {\n    event AppConfigV1Set(uint256 requiredResponses, uint256 optimisticPeriod);\n    event AppLinked(uint256 indexed chainId, bytes32 indexed remoteApp);\n    event ExecutionServiceSet(address executionService);\n    event TrustedModuleAdded(address module);\n    event TrustedModuleRemoved(address module);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    /// @notice Allows the Interchain Client to pass the message to the Interchain App.\n    /// @dev App is responsible for keeping track of interchain clients, and must verify the message sender.\n    /// @param srcChainId   Chain ID of the source chain, where the message was sent from.\n    /// @param sender       Sender address on the source chain, as a bytes32 value.\n    /// @param dbNonce      The Interchain DB nonce of the batch containing the message entry.\n    /// @param entryIndex   The index of the message entry within the batch.\n    /// @param message      The message being sent.\n    function appReceive(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /// @notice Returns the verification configuration of the Interchain App.\n    /// @dev This configuration is used by the Interchain Client to verify that message has been confirmed\n    /// by the Interchain Modules on the destination chain.\n    /// Note: V1 version of AppConfig includes the required responses count, and optimistic period after which\n    /// the message is considered confirmed by the module. Following versions may include additional fields.\n    /// @return appConfig    The versioned configuration of the Interchain App, encoded as bytes.\n    /// @return modules      The list of Interchain Modules that app is trusting to confirm the messages.\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/Math.sol\n\nlibrary MathLib {\n    /// @notice Rounds up to the nearest multiple of 32.\n    /// Note: Returns zero on overflows instead of reverting. This is fine for practical\n    /// use cases, as this is used for determining the size of the payload in memory.\n    function roundUpToWord(uint256 x) internal pure returns (uint256) {\n        unchecked {\n            return (x + 31) \u0026 ~uint256(31);\n        }\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/VersionedPayload.sol\n\n// solhint-disable no-inline-assembly\n// solhint-disable ordering\nlibrary VersionedPayloadLib {\n    /// @notice Amount of bytes reserved for the version (uint16) in the versioned payload\n    uint256 internal constant VERSION_LENGTH = 2;\n\n    error VersionedPayload__TooShort(bytes versionedPayload);\n    error VersionedPayload__PrecompileFailed();\n\n    /// @notice Encodes the versioned payload into a single bytes array.\n    /// @param version  The payload's version.\n    /// @param payload  The payload to encode.\n    function encodeVersionedPayload(uint16 version, bytes memory payload) internal pure returns (bytes memory) {\n        return abi.encodePacked(version, payload);\n    }\n\n    /// @notice Extracts the version from the versioned payload (calldata reference).\n    /// @param versionedPayload     The versioned payload (calldata reference).\n    function getVersion(bytes calldata versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            version := shr(240, calldataload(versionedPayload.offset))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (calldata reference).\n    /// @dev The extracted payload is also returned as a calldata reference.\n    /// @param versionedPayload     The versioned payload.\n    function getPayload(bytes calldata versionedPayload) internal pure returns (bytes calldata) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        return versionedPayload[VERSION_LENGTH:];\n    }\n\n    /// @notice Extracts the version from the versioned payload (memory reference).\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getVersionFromMemory(bytes memory versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            // We add 0x20 to skip the length of the bytes array.\n            version := shr(240, mload(add(versionedPayload, 0x20)))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (memory reference).\n    /// @dev The extracted payload is copied into a new memory location. Use `getPayload` when possible\n    /// to avoid extra memory allocation.\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getPayloadFromMemory(bytes memory versionedPayload) internal view returns (bytes memory payload) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        // Figure how many bytes to copy and allocate the memory for the extracted payload.\n        uint256 toCopy;\n        unchecked {\n            toCopy = versionedPayload.length - VERSION_LENGTH;\n        }\n        payload = new bytes(toCopy);\n        // Use identity precompile (0x04) to copy the payload. Unlike MCOPY, this is available on all EVM chains.\n        bool res;\n        assembly {\n            // We add 0x20 to skip the length of the bytes array.\n            // We add 0x02 to skip the 2 bytes reserved for the version.\n            // Copy the payload to the previously allocated memory.\n            res := staticcall(gas(), 0x04, add(versionedPayload, 0x22), toCopy, add(payload, 0x20), toCopy)\n        }\n        if (!res) {\n            revert VersionedPayload__PrecompileFailed();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/IAccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n\n// node_modules/@openzeppelin/contracts/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance \u003c amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance \u003c value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 \u0026\u0026 target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SafeCast.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value \u003e type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value \u003e type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value \u003e type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value \u003e type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value \u003e type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value \u003e type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value \u003e type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value \u003e type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value \u003e type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value \u003e type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value \u003e type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value \u003e type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value \u003e type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value \u003e type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value \u003e type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value \u003e type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value \u003e type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value \u003e type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value \u003e type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value \u003e type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value \u003e type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value \u003e type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value \u003e type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value \u003e type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value \u003e type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value \u003e type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value \u003e type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value \u003e type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value \u003e type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value \u003e type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value \u003e type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value \u003c 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value \u003e uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal view returns (AppConfigV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (AppConfigV1));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal view returns (OptionsV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (OptionsV1));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(OPTIONS_V1, abi.encode(options));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/IAccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/IAccessControlEnumerable.sol)\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n// contracts/interfaces/IInterchainAppV1.sol\n\ninterface IInterchainAppV1 is IInterchainApp {\n    error InterchainApp__AppZeroAddress();\n    error InterchainApp__InvalidAppConfig(uint256 requiredResponses, uint256 optimisticPeriod);\n    error InterchainApp__ModuleAlreadyAdded(address module);\n    error InterchainApp__ModuleNotAdded(address module);\n    error InterchainApp__ModuleZeroAddress();\n    error InterchainApp__NotEVMLinkedApp(bytes32 linkedApp);\n\n    /// @notice Allows the owner to add the interchain client to the allowed clients set,\n    /// and optionally set the latest client to this one.\n    /// Note: only the allowed clients can send messages to this app.\n    /// Note: the latest client is used for sending messages from this app.\n    /// @param client       The address of the interchain client to add.\n    /// @param updateLatest Whether to set the latest client to this one.\n    function addInterchainClient(address client, bool updateLatest) external;\n\n    /// @notice Allows the owner to remove the interchain client from the allowed clients set.\n    /// If the client is the latest client, the latest client is set to the zero address.\n    /// @param client       The address of the interchain client to remove.\n    function removeInterchainClient(address client) external;\n\n    /// @notice Allows the owner to set the address of the latest interchain client.\n    /// @dev The new latest client must be an allowed client or zero address.\n    /// Setting the client to zero address effectively pauses the app ability to send messages,\n    /// while allowing to receive them.\n    /// @param client       The address of the latest interchain client.\n    function setLatestInterchainClient(address client) external;\n\n    /// @notice Allows the owner to link the remote app for the given chain ID.\n    /// - This address will be used as the receiver for the messages sent from this chain.\n    /// - This address will be the only trusted sender for the messages sent to this chain.\n    /// @param chainId      The remote chain ID.\n    /// @param remoteApp    The address of the remote app to link.\n    function linkRemoteApp(uint64 chainId, bytes32 remoteApp) external;\n\n    /// @notice Thin wrapper for `linkRemoteApp` to accept EVM address as a parameter.\n    function linkRemoteAppEVM(uint64 chainId, address remoteApp) external;\n\n    /// @notice Allows the owner to add the module to the trusted modules set.\n    /// - This set of modules will be used to verify both sent and received messages.\n    function addTrustedModule(address module) external;\n\n    /// @notice Allows the owner to remove the module from the trusted modules set.\n    function removeTrustedModule(address module) external;\n\n    /// @notice Allows the owner to set the app config for the current app. App config includes:\n    /// - requiredResponses: the number of module responses required for accepting the message\n    /// - optimisticPeriod: the minimum time after which the module responses are considered final\n    function setAppConfigV1(AppConfigV1 memory appConfig) external;\n\n    /// @notice Allows the owner to set the address of the Execution Service.\n    /// This address will be used to request execution of the messages sent from this chain,\n    /// by supplying the Service's execution fee.\n    function setExecutionService(address executionService) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Returns the app config for the current app: requiredResponses and optimisticPeriod.\n    function getAppConfigV1() external view returns (AppConfigV1 memory);\n\n    /// @notice Returns the address of the Execution Service used by this app for sending messages.\n    function getExecutionService() external view returns (address);\n\n    /// @notice Returns the list of Interchain Clients allowed to send messages to this app.\n    function getInterchainClients() external view returns (address[] memory);\n\n    /// @notice Returns the address of the latest interchain client.\n    /// This address is used for sending messages from this app.\n    function getLatestInterchainClient() external view returns (address);\n\n    /// @notice Returns the linked app address (as bytes32) for the given chain ID.\n    function getLinkedApp(uint64 chainId) external view returns (bytes32);\n\n    /// @notice Thin wrapper for `getLinkedApp` to return the linked app address as EVM address.\n    /// @dev Will revert if the linked app address is not an EVM address.\n    function getLinkedAppEVM(uint64 chainId) external view returns (address);\n\n    /// @notice Returns the list of Interchain Modules trusted by this app.\n    /// This set of modules will be used to verify both sent and received messages.\n    function getModules() external view returns (address[] memory);\n}\n\n// contracts/libs/InterchainTransaction.sol\n\ntype ICTxHeader is uint256;\n\nstruct InterchainTransaction {\n    uint64 srcChainId;\n    uint64 dstChainId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcSender;\n    bytes32 dstReceiver;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    using MathLib for uint256;\n    using VersionedPayloadLib for bytes;\n\n    function constructLocalTransaction(\n        address srcSender,\n        uint64 dstChainId,\n        bytes32 dstReceiver,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: SafeCast.toUint64(block.chainid),\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            encodeTxHeader(transaction.srcChainId, transaction.dstChainId, transaction.dbNonce, transaction.entryIndex),\n            transaction.srcSender,\n            transaction.dstReceiver,\n            transaction.options,\n            transaction.message\n        );\n    }\n\n    function decodeTransaction(bytes calldata transaction) internal pure returns (InterchainTransaction memory icTx) {\n        ICTxHeader header;\n        (header, icTx.srcSender, icTx.dstReceiver, icTx.options, icTx.message) =\n            abi.decode(transaction, (ICTxHeader, bytes32, bytes32, bytes, bytes));\n        (icTx.srcChainId, icTx.dstChainId, icTx.dbNonce, icTx.entryIndex) = decodeTxHeader(header);\n    }\n\n    function payloadSize(uint256 optionsLen, uint256 messageLen) internal pure returns (uint256) {\n        // 2 bytes are reserved for the transaction version\n        // + 5 fields * 32 bytes (3 values for static, 2 offsets for dynamic) + 2 * 32 bytes (lengths for dynamic) = 226\n        // (srcChainId, dstChainId, dbNonce, entryIndex) are merged into a single 32 bytes field\n        // Both options and message are dynamic fields, which are padded up to 32 bytes\n        return 226 + optionsLen.roundUpToWord() + messageLen.roundUpToWord();\n    }\n\n    function encodeTxHeader(\n        uint64 srcChainId,\n        uint64 dstChainId,\n        uint64 dbNonce,\n        uint64 entryIndex\n    )\n        internal\n        pure\n        returns (ICTxHeader)\n    {\n        return ICTxHeader.wrap(\n            (uint256(srcChainId) \u003c\u003c 192) | (uint256(dstChainId) \u003c\u003c 128) | (uint256(dbNonce) \u003c\u003c 64) | uint256(entryIndex)\n        );\n    }\n\n    function decodeTxHeader(ICTxHeader header)\n        internal\n        pure\n        returns (uint64 srcChainId, uint64 dstChainId, uint64 dbNonce, uint64 entryIndex)\n    {\n        srcChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 192);\n        dstChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 128);\n        dbNonce = uint64(ICTxHeader.unwrap(header) \u003e\u003e 64);\n        entryIndex = uint64(ICTxHeader.unwrap(header));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/AccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account =\u003e bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role =\u003e RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint64 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__InvalidTransactionVersion(uint16 version);\n    error InterchainClientV1__NoLinkedClient(uint64 chainId);\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint64 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint64 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint64 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint64 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param messageLen           The length of the message being sent.\n    function getInterchainFee(\n        uint64 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        uint256 messageLen\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint64 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint64 chainId) external view returns (address);\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/AccessControlEnumerable.sol)\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 role =\u003e EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {AccessControl-_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool granted = super._grantRole(role, account);\n        if (granted) {\n            _roleMembers[role].add(account);\n        }\n        return granted;\n    }\n\n    /**\n     * @dev Overload {AccessControl-_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool revoked = super._revokeRole(role, account);\n        if (revoked) {\n            _roleMembers[role].remove(account);\n        }\n        return revoked;\n    }\n}\n\n// contracts/apps/AbstractICApp.sol\n\nabstract contract AbstractICApp is AbstractICAppEvents, IInterchainApp {\n    using TypeCasts for address;\n\n    error InterchainApp__AlreadyLatestClient(address client);\n    error InterchainApp__BalanceTooLow(uint256 actual, uint256 required);\n    error InterchainApp__ClientAlreadyAdded(address client);\n    error InterchainApp__InterchainClientZeroAddress();\n    error InterchainApp__NotInterchainClient(address account);\n    error InterchainApp__ReceiverNotSet(uint64 chainId);\n    error InterchainApp__SameChainId(uint64 chainId);\n    error InterchainApp__SenderNotAllowed(uint64 srcChainId, bytes32 sender);\n\n    /// @inheritdoc IInterchainApp\n    function appReceive(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        if (!_isInterchainClient(msg.sender)) {\n            revert InterchainApp__NotInterchainClient(msg.sender);\n        }\n        if (srcChainId == block.chainid) {\n            revert InterchainApp__SameChainId(srcChainId);\n        }\n        if (!_isAllowedSender(srcChainId, sender)) {\n            revert InterchainApp__SenderNotAllowed(srcChainId, sender);\n        }\n        _receiveMessage(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n\n    /// @inheritdoc IInterchainApp\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules) {\n        appConfig = _getAppConfig();\n        modules = _getModules();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Performs necessary checks and adds an Interchain Client.\n    /// Optionally sets the latest client to this one.\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _addClient(address client, bool updateLatest) internal {\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (_isInterchainClient(client)) {\n            revert InterchainApp__ClientAlreadyAdded(client);\n        }\n        _toggleClientState(client, true);\n        emit InterchainClientAdded(client);\n        if (updateLatest) {\n            _setLatestClient(client);\n        }\n    }\n\n    /// @dev Performs necessary checks and removes an Interchain Client. If this client is the latest one,\n    /// the latest client is set to zero address (effectively pausing the app ability to send messages).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _removeClient(address client) internal {\n        if (!_isInterchainClient(client)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        _toggleClientState(client, false);\n        emit InterchainClientRemoved(client);\n        if (client == _getLatestClient()) {\n            _setLatestClient(address(0));\n        }\n    }\n\n    /// @dev Sets the latest Interchain Client to one of the allowed clients. Setting the client to zero address\n    /// is allowed and effectively pauses the app ability to send messages (but still allows to receive them).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _setLatestClient(address client) internal {\n        // New latest client must be an allowed client or zero address.\n        if (!_isInterchainClient(client) \u0026\u0026 client != address(0)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        if (client == _getLatestClient()) {\n            revert InterchainApp__AlreadyLatestClient(client);\n        }\n        _storeLatestClient(client);\n        emit LatestClientSet(client);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal virtual;\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal virtual;\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to accept EVM address as a parameter.\n    function _sendInterchainMessageEVM(\n        uint64 dstChainId,\n        address receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _sendInterchainMessage(dstChainId, receiver.addressToBytes32(), messageFee, options, message);\n    }\n\n    /// @dev Performs necessary checks and sends an interchain message.\n    function _sendInterchainMessage(\n        uint64 dstChainId,\n        bytes32 receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (dstChainId == block.chainid) {\n            revert InterchainApp__SameChainId(dstChainId);\n        }\n        if (receiver == 0) {\n            revert InterchainApp__ReceiverNotSet(dstChainId);\n        }\n        if (address(this).balance \u003c messageFee) {\n            revert InterchainApp__BalanceTooLow({actual: address(this).balance, required: messageFee});\n        }\n        return IInterchainClientV1(client).interchainSend{value: messageFee}(\n            dstChainId, receiver, _getExecutionService(), _getModules(), options, message\n        );\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        virtual;\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee for sending an Interchain message.\n    function _getInterchainFee(\n        uint64 dstChainId,\n        bytes memory options,\n        uint256 messageLen\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        return IInterchainClientV1(client).getInterchainFee(\n            dstChainId, _getExecutionService(), _getModules(), options, messageLen\n        );\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view virtual returns (bytes memory);\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view virtual returns (address);\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view virtual returns (address);\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view virtual returns (address[] memory);\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint64 srcChainId, bytes32 sender) internal view virtual returns (bool);\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view virtual returns (bool);\n}\n\n// contracts/apps/ICAppV1.sol\n\nabstract contract ICAppV1 is AbstractICApp, AccessControlEnumerable, InterchainAppV1Events, IInterchainAppV1 {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Role to manage the Interchain setup of the app.\n    bytes32 public constant IC_GOVERNOR_ROLE = keccak256(\"IC_GOVERNOR_ROLE\");\n\n    /// @dev Address of the latest Interchain Client, used for sending messages.\n    address private _latestClient;\n\n    /// @dev Required responses and optimistic period for the module responses.\n    AppConfigV1 private _appConfigV1;\n    /// @dev Address of the linked app deployed on the remote chain.\n    mapping(uint64 chainId =\u003e bytes32 remoteApp) private _linkedApp;\n    /// @dev Interchain Clients allowed to send messages to this app.\n    EnumerableSet.AddressSet private _interchainClients;\n    /// @dev Trusted Interchain modules.\n    EnumerableSet.AddressSet private _trustedModules;\n    /// @dev Execution Service to use for sending messages.\n    address private _executionService;\n\n    constructor(address admin) {\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addInterchainClient(address client, bool updateLatest) external onlyRole(IC_GOVERNOR_ROLE) {\n        _addClient(client, updateLatest);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _removeClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setLatestInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _setLatestClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteApp(uint64 chainId, bytes32 remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteAppEVM(uint64 chainId, address remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp.addressToBytes32());\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (module == address(0)) {\n            revert InterchainApp__ModuleZeroAddress();\n        }\n        bool added = _trustedModules.add(module);\n        if (!added) {\n            revert InterchainApp__ModuleAlreadyAdded(module);\n        }\n        emit TrustedModuleAdded(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        bool removed = _trustedModules.remove(module);\n        if (!removed) {\n            revert InterchainApp__ModuleNotAdded(module);\n        }\n        emit TrustedModuleRemoved(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setAppConfigV1(AppConfigV1 memory appConfig) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (appConfig.requiredResponses == 0 || appConfig.optimisticPeriod == 0) {\n            revert InterchainApp__InvalidAppConfig(appConfig.requiredResponses, appConfig.optimisticPeriod);\n        }\n        _appConfigV1 = appConfig;\n        emit AppConfigV1Set(appConfig.requiredResponses, appConfig.optimisticPeriod);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setExecutionService(address executionService) external onlyRole(IC_GOVERNOR_ROLE) {\n        _executionService = executionService;\n        emit ExecutionServiceSet(executionService);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainAppV1\n    function getAppConfigV1() external view returns (AppConfigV1 memory) {\n        return _appConfigV1;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getExecutionService() external view returns (address) {\n        return _executionService;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getInterchainClients() external view returns (address[] memory) {\n        return _interchainClients.values();\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLatestInterchainClient() external view returns (address) {\n        return _latestClient;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedApp(uint64 chainId) external view returns (bytes32) {\n        return _linkedApp[chainId];\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedAppEVM(uint64 chainId) external view returns (address linkedAppEVM) {\n        bytes32 linkedApp = _linkedApp[chainId];\n        linkedAppEVM = linkedApp.bytes32ToAddress();\n        if (linkedAppEVM.addressToBytes32() != linkedApp) {\n            revert InterchainApp__NotEVMLinkedApp(linkedApp);\n        }\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getModules() external view returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Links the remote app to the current app.\n    /// Will revert if the chainId is the same as the chainId of the local app.\n    /// Note: Should be guarded with permissions check.\n    function _linkRemoteApp(uint64 chainId, bytes32 remoteApp) internal {\n        if (chainId == block.chainid) {\n            revert InterchainApp__SameChainId(chainId);\n        }\n        if (remoteApp == 0) {\n            revert InterchainApp__AppZeroAddress();\n        }\n        _linkedApp[chainId] = remoteApp;\n        emit AppLinked(chainId, remoteApp);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal override {\n        _latestClient = client;\n    }\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal override {\n        if (allowed) {\n            _interchainClients.add(client);\n        } else {\n            _interchainClients.remove(client);\n        }\n    }\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to send the message to the linked app.\n    function _sendToLinkedApp(\n        uint64 dstChainId,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _sendInterchainMessage(dstChainId, _linkedApp[dstChainId], messageFee, encodedOptions, message);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee to send a message to the linked app on the remote chain.\n    function _getMessageFee(\n        uint64 dstChainId,\n        OptionsV1 memory options,\n        uint256 messageLen\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _getInterchainFee(dstChainId, encodedOptions, messageLen);\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view override returns (bytes memory) {\n        return _appConfigV1.encodeAppConfigV1();\n    }\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view override returns (address) {\n        return _executionService;\n    }\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view override returns (address) {\n        return _latestClient;\n    }\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view override returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint64 srcChainId, bytes32 sender) internal view override returns (bool) {\n        return _linkedApp[srcChainId] == sender;\n    }\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view override returns (bool) {\n        return _interchainClients.contains(caller);\n    }\n}\n\n// contracts/apps/examples/ExampleAppV1.sol\n\ncontract ExampleAppV1 is ICAppV1 {\n    event MessageReceived(uint64 srcChainId, bytes32 sender, uint64 dbNonce, uint64 entryIndex, bytes message);\n    event MessageSent(uint64 dstChainId, uint64 dbNonce, uint64 entryIndex, bytes32 transactionId);\n\n    constructor(address admin) ICAppV1(admin) {\n        _grantRole(IC_GOVERNOR_ROLE, admin);\n    }\n\n    /// @notice Allows the Admin to withdraw the native asset from the contract.\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        Address.sendValue(payable(msg.sender), address(this).balance);\n    }\n\n    /// @notice Sends a basic message to the destination chain.\n    function sendMessage(\n        uint64 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        InterchainTxDescriptor memory desc = _sendToLinkedApp({\n            dstChainId: dstChainId,\n            messageFee: msg.value,\n            options: OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}),\n            message: message\n        });\n        emit MessageSent(dstChainId, desc.dbNonce, desc.entryIndex, desc.transactionId);\n    }\n\n    /// @notice Returns the fee required to send a message using `sendMessage`.\n    function getMessageFee(\n        uint64 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes memory message\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _getMessageFee(dstChainId, OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}), message.length);\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        override\n    {\n        emit MessageReceived(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"2908:280:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;2908:280:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"2908:280:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/ExampleAppV1.sol\":\"TypeCasts\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/ExampleAppV1.sol\":{\"keccak256\":\"0xb1e9550aef785a0afc4e03fc843839919987ba4f906f09992c6788979c3c0396\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://0ede697223dfa3a2e23501efc1ed5926d5ff6458ee7b9ba833e0587162166c79\",\"dweb:/ipfs/QmUzgopL2ptWG5DYNdGAcoErPnBC4KCoRp8C61dkHHRaA6\"]}},\"version\":1}"},"hashes":{}},"solidity/ExampleAppV1.sol:VersionedPayloadLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220bfb7d64143b7a3d8c7dd840d1c69c786d48a50afb304b468ba9fad8577fe0b0664736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220bfb7d64143b7a3d8c7dd840d1c69c786d48a50afb304b468ba9fad8577fe0b0664736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/AbstractICAppEvents.sol\n\nabstract contract AbstractICAppEvents {\n    event InterchainClientAdded(address client);\n    event InterchainClientRemoved(address client);\n    event LatestClientSet(address client);\n}\n\n// contracts/events/InterchainAppV1Events.sol\n\nabstract contract InterchainAppV1Events {\n    event AppConfigV1Set(uint256 requiredResponses, uint256 optimisticPeriod);\n    event AppLinked(uint256 indexed chainId, bytes32 indexed remoteApp);\n    event ExecutionServiceSet(address executionService);\n    event TrustedModuleAdded(address module);\n    event TrustedModuleRemoved(address module);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    /// @notice Allows the Interchain Client to pass the message to the Interchain App.\n    /// @dev App is responsible for keeping track of interchain clients, and must verify the message sender.\n    /// @param srcChainId   Chain ID of the source chain, where the message was sent from.\n    /// @param sender       Sender address on the source chain, as a bytes32 value.\n    /// @param dbNonce      The Interchain DB nonce of the batch containing the message entry.\n    /// @param entryIndex   The index of the message entry within the batch.\n    /// @param message      The message being sent.\n    function appReceive(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /// @notice Returns the verification configuration of the Interchain App.\n    /// @dev This configuration is used by the Interchain Client to verify that message has been confirmed\n    /// by the Interchain Modules on the destination chain.\n    /// Note: V1 version of AppConfig includes the required responses count, and optimistic period after which\n    /// the message is considered confirmed by the module. Following versions may include additional fields.\n    /// @return appConfig    The versioned configuration of the Interchain App, encoded as bytes.\n    /// @return modules      The list of Interchain Modules that app is trusting to confirm the messages.\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/Math.sol\n\nlibrary MathLib {\n    /// @notice Rounds up to the nearest multiple of 32.\n    /// Note: Returns zero on overflows instead of reverting. This is fine for practical\n    /// use cases, as this is used for determining the size of the payload in memory.\n    function roundUpToWord(uint256 x) internal pure returns (uint256) {\n        unchecked {\n            return (x + 31) \u0026 ~uint256(31);\n        }\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/VersionedPayload.sol\n\n// solhint-disable no-inline-assembly\n// solhint-disable ordering\nlibrary VersionedPayloadLib {\n    /// @notice Amount of bytes reserved for the version (uint16) in the versioned payload\n    uint256 internal constant VERSION_LENGTH = 2;\n\n    error VersionedPayload__TooShort(bytes versionedPayload);\n    error VersionedPayload__PrecompileFailed();\n\n    /// @notice Encodes the versioned payload into a single bytes array.\n    /// @param version  The payload's version.\n    /// @param payload  The payload to encode.\n    function encodeVersionedPayload(uint16 version, bytes memory payload) internal pure returns (bytes memory) {\n        return abi.encodePacked(version, payload);\n    }\n\n    /// @notice Extracts the version from the versioned payload (calldata reference).\n    /// @param versionedPayload     The versioned payload (calldata reference).\n    function getVersion(bytes calldata versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            version := shr(240, calldataload(versionedPayload.offset))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (calldata reference).\n    /// @dev The extracted payload is also returned as a calldata reference.\n    /// @param versionedPayload     The versioned payload.\n    function getPayload(bytes calldata versionedPayload) internal pure returns (bytes calldata) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        return versionedPayload[VERSION_LENGTH:];\n    }\n\n    /// @notice Extracts the version from the versioned payload (memory reference).\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getVersionFromMemory(bytes memory versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            // We add 0x20 to skip the length of the bytes array.\n            version := shr(240, mload(add(versionedPayload, 0x20)))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (memory reference).\n    /// @dev The extracted payload is copied into a new memory location. Use `getPayload` when possible\n    /// to avoid extra memory allocation.\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getPayloadFromMemory(bytes memory versionedPayload) internal view returns (bytes memory payload) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        // Figure how many bytes to copy and allocate the memory for the extracted payload.\n        uint256 toCopy;\n        unchecked {\n            toCopy = versionedPayload.length - VERSION_LENGTH;\n        }\n        payload = new bytes(toCopy);\n        // Use identity precompile (0x04) to copy the payload. Unlike MCOPY, this is available on all EVM chains.\n        bool res;\n        assembly {\n            // We add 0x20 to skip the length of the bytes array.\n            // We add 0x02 to skip the 2 bytes reserved for the version.\n            // Copy the payload to the previously allocated memory.\n            res := staticcall(gas(), 0x04, add(versionedPayload, 0x22), toCopy, add(payload, 0x20), toCopy)\n        }\n        if (!res) {\n            revert VersionedPayload__PrecompileFailed();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/IAccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n\n// node_modules/@openzeppelin/contracts/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance \u003c amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance \u003c value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 \u0026\u0026 target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SafeCast.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value \u003e type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value \u003e type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value \u003e type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value \u003e type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value \u003e type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value \u003e type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value \u003e type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value \u003e type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value \u003e type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value \u003e type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value \u003e type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value \u003e type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value \u003e type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value \u003e type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value \u003e type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value \u003e type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value \u003e type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value \u003e type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value \u003e type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value \u003e type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value \u003e type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value \u003e type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value \u003e type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value \u003e type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value \u003e type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value \u003e type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value \u003e type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value \u003e type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value \u003e type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value \u003e type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value \u003e type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value \u003c 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value \u003e uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal view returns (AppConfigV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (AppConfigV1));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal view returns (OptionsV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (OptionsV1));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(OPTIONS_V1, abi.encode(options));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/IAccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/IAccessControlEnumerable.sol)\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n\n// node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n// contracts/interfaces/IInterchainAppV1.sol\n\ninterface IInterchainAppV1 is IInterchainApp {\n    error InterchainApp__AppZeroAddress();\n    error InterchainApp__InvalidAppConfig(uint256 requiredResponses, uint256 optimisticPeriod);\n    error InterchainApp__ModuleAlreadyAdded(address module);\n    error InterchainApp__ModuleNotAdded(address module);\n    error InterchainApp__ModuleZeroAddress();\n    error InterchainApp__NotEVMLinkedApp(bytes32 linkedApp);\n\n    /// @notice Allows the owner to add the interchain client to the allowed clients set,\n    /// and optionally set the latest client to this one.\n    /// Note: only the allowed clients can send messages to this app.\n    /// Note: the latest client is used for sending messages from this app.\n    /// @param client       The address of the interchain client to add.\n    /// @param updateLatest Whether to set the latest client to this one.\n    function addInterchainClient(address client, bool updateLatest) external;\n\n    /// @notice Allows the owner to remove the interchain client from the allowed clients set.\n    /// If the client is the latest client, the latest client is set to the zero address.\n    /// @param client       The address of the interchain client to remove.\n    function removeInterchainClient(address client) external;\n\n    /// @notice Allows the owner to set the address of the latest interchain client.\n    /// @dev The new latest client must be an allowed client or zero address.\n    /// Setting the client to zero address effectively pauses the app ability to send messages,\n    /// while allowing to receive them.\n    /// @param client       The address of the latest interchain client.\n    function setLatestInterchainClient(address client) external;\n\n    /// @notice Allows the owner to link the remote app for the given chain ID.\n    /// - This address will be used as the receiver for the messages sent from this chain.\n    /// - This address will be the only trusted sender for the messages sent to this chain.\n    /// @param chainId      The remote chain ID.\n    /// @param remoteApp    The address of the remote app to link.\n    function linkRemoteApp(uint64 chainId, bytes32 remoteApp) external;\n\n    /// @notice Thin wrapper for `linkRemoteApp` to accept EVM address as a parameter.\n    function linkRemoteAppEVM(uint64 chainId, address remoteApp) external;\n\n    /// @notice Allows the owner to add the module to the trusted modules set.\n    /// - This set of modules will be used to verify both sent and received messages.\n    function addTrustedModule(address module) external;\n\n    /// @notice Allows the owner to remove the module from the trusted modules set.\n    function removeTrustedModule(address module) external;\n\n    /// @notice Allows the owner to set the app config for the current app. App config includes:\n    /// - requiredResponses: the number of module responses required for accepting the message\n    /// - optimisticPeriod: the minimum time after which the module responses are considered final\n    function setAppConfigV1(AppConfigV1 memory appConfig) external;\n\n    /// @notice Allows the owner to set the address of the Execution Service.\n    /// This address will be used to request execution of the messages sent from this chain,\n    /// by supplying the Service's execution fee.\n    function setExecutionService(address executionService) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Returns the app config for the current app: requiredResponses and optimisticPeriod.\n    function getAppConfigV1() external view returns (AppConfigV1 memory);\n\n    /// @notice Returns the address of the Execution Service used by this app for sending messages.\n    function getExecutionService() external view returns (address);\n\n    /// @notice Returns the list of Interchain Clients allowed to send messages to this app.\n    function getInterchainClients() external view returns (address[] memory);\n\n    /// @notice Returns the address of the latest interchain client.\n    /// This address is used for sending messages from this app.\n    function getLatestInterchainClient() external view returns (address);\n\n    /// @notice Returns the linked app address (as bytes32) for the given chain ID.\n    function getLinkedApp(uint64 chainId) external view returns (bytes32);\n\n    /// @notice Thin wrapper for `getLinkedApp` to return the linked app address as EVM address.\n    /// @dev Will revert if the linked app address is not an EVM address.\n    function getLinkedAppEVM(uint64 chainId) external view returns (address);\n\n    /// @notice Returns the list of Interchain Modules trusted by this app.\n    /// This set of modules will be used to verify both sent and received messages.\n    function getModules() external view returns (address[] memory);\n}\n\n// contracts/libs/InterchainTransaction.sol\n\ntype ICTxHeader is uint256;\n\nstruct InterchainTransaction {\n    uint64 srcChainId;\n    uint64 dstChainId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcSender;\n    bytes32 dstReceiver;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    using MathLib for uint256;\n    using VersionedPayloadLib for bytes;\n\n    function constructLocalTransaction(\n        address srcSender,\n        uint64 dstChainId,\n        bytes32 dstReceiver,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: SafeCast.toUint64(block.chainid),\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            encodeTxHeader(transaction.srcChainId, transaction.dstChainId, transaction.dbNonce, transaction.entryIndex),\n            transaction.srcSender,\n            transaction.dstReceiver,\n            transaction.options,\n            transaction.message\n        );\n    }\n\n    function decodeTransaction(bytes calldata transaction) internal pure returns (InterchainTransaction memory icTx) {\n        ICTxHeader header;\n        (header, icTx.srcSender, icTx.dstReceiver, icTx.options, icTx.message) =\n            abi.decode(transaction, (ICTxHeader, bytes32, bytes32, bytes, bytes));\n        (icTx.srcChainId, icTx.dstChainId, icTx.dbNonce, icTx.entryIndex) = decodeTxHeader(header);\n    }\n\n    function payloadSize(uint256 optionsLen, uint256 messageLen) internal pure returns (uint256) {\n        // 2 bytes are reserved for the transaction version\n        // + 5 fields * 32 bytes (3 values for static, 2 offsets for dynamic) + 2 * 32 bytes (lengths for dynamic) = 226\n        // (srcChainId, dstChainId, dbNonce, entryIndex) are merged into a single 32 bytes field\n        // Both options and message are dynamic fields, which are padded up to 32 bytes\n        return 226 + optionsLen.roundUpToWord() + messageLen.roundUpToWord();\n    }\n\n    function encodeTxHeader(\n        uint64 srcChainId,\n        uint64 dstChainId,\n        uint64 dbNonce,\n        uint64 entryIndex\n    )\n        internal\n        pure\n        returns (ICTxHeader)\n    {\n        return ICTxHeader.wrap(\n            (uint256(srcChainId) \u003c\u003c 192) | (uint256(dstChainId) \u003c\u003c 128) | (uint256(dbNonce) \u003c\u003c 64) | uint256(entryIndex)\n        );\n    }\n\n    function decodeTxHeader(ICTxHeader header)\n        internal\n        pure\n        returns (uint64 srcChainId, uint64 dstChainId, uint64 dbNonce, uint64 entryIndex)\n    {\n        srcChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 192);\n        dstChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 128);\n        dbNonce = uint64(ICTxHeader.unwrap(header) \u003e\u003e 64);\n        entryIndex = uint64(ICTxHeader.unwrap(header));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/AccessControl.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account =\u003e bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role =\u003e RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint64 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__InvalidTransactionVersion(uint16 version);\n    error InterchainClientV1__NoLinkedClient(uint64 chainId);\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint64 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint64 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint64 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint64 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param messageLen           The length of the message being sent.\n    function getInterchainFee(\n        uint64 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        uint256 messageLen\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint64 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint64 chainId) external view returns (address);\n}\n\n// node_modules/@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/AccessControlEnumerable.sol)\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 role =\u003e EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {AccessControl-_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool granted = super._grantRole(role, account);\n        if (granted) {\n            _roleMembers[role].add(account);\n        }\n        return granted;\n    }\n\n    /**\n     * @dev Overload {AccessControl-_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool revoked = super._revokeRole(role, account);\n        if (revoked) {\n            _roleMembers[role].remove(account);\n        }\n        return revoked;\n    }\n}\n\n// contracts/apps/AbstractICApp.sol\n\nabstract contract AbstractICApp is AbstractICAppEvents, IInterchainApp {\n    using TypeCasts for address;\n\n    error InterchainApp__AlreadyLatestClient(address client);\n    error InterchainApp__BalanceTooLow(uint256 actual, uint256 required);\n    error InterchainApp__ClientAlreadyAdded(address client);\n    error InterchainApp__InterchainClientZeroAddress();\n    error InterchainApp__NotInterchainClient(address account);\n    error InterchainApp__ReceiverNotSet(uint64 chainId);\n    error InterchainApp__SameChainId(uint64 chainId);\n    error InterchainApp__SenderNotAllowed(uint64 srcChainId, bytes32 sender);\n\n    /// @inheritdoc IInterchainApp\n    function appReceive(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        if (!_isInterchainClient(msg.sender)) {\n            revert InterchainApp__NotInterchainClient(msg.sender);\n        }\n        if (srcChainId == block.chainid) {\n            revert InterchainApp__SameChainId(srcChainId);\n        }\n        if (!_isAllowedSender(srcChainId, sender)) {\n            revert InterchainApp__SenderNotAllowed(srcChainId, sender);\n        }\n        _receiveMessage(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n\n    /// @inheritdoc IInterchainApp\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules) {\n        appConfig = _getAppConfig();\n        modules = _getModules();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Performs necessary checks and adds an Interchain Client.\n    /// Optionally sets the latest client to this one.\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _addClient(address client, bool updateLatest) internal {\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (_isInterchainClient(client)) {\n            revert InterchainApp__ClientAlreadyAdded(client);\n        }\n        _toggleClientState(client, true);\n        emit InterchainClientAdded(client);\n        if (updateLatest) {\n            _setLatestClient(client);\n        }\n    }\n\n    /// @dev Performs necessary checks and removes an Interchain Client. If this client is the latest one,\n    /// the latest client is set to zero address (effectively pausing the app ability to send messages).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _removeClient(address client) internal {\n        if (!_isInterchainClient(client)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        _toggleClientState(client, false);\n        emit InterchainClientRemoved(client);\n        if (client == _getLatestClient()) {\n            _setLatestClient(address(0));\n        }\n    }\n\n    /// @dev Sets the latest Interchain Client to one of the allowed clients. Setting the client to zero address\n    /// is allowed and effectively pauses the app ability to send messages (but still allows to receive them).\n    /// Note: should be guarded with permission checks in the derived contracts.\n    function _setLatestClient(address client) internal {\n        // New latest client must be an allowed client or zero address.\n        if (!_isInterchainClient(client) \u0026\u0026 client != address(0)) {\n            revert InterchainApp__NotInterchainClient(client);\n        }\n        if (client == _getLatestClient()) {\n            revert InterchainApp__AlreadyLatestClient(client);\n        }\n        _storeLatestClient(client);\n        emit LatestClientSet(client);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal virtual;\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal virtual;\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to accept EVM address as a parameter.\n    function _sendInterchainMessageEVM(\n        uint64 dstChainId,\n        address receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _sendInterchainMessage(dstChainId, receiver.addressToBytes32(), messageFee, options, message);\n    }\n\n    /// @dev Performs necessary checks and sends an interchain message.\n    function _sendInterchainMessage(\n        uint64 dstChainId,\n        bytes32 receiver,\n        uint256 messageFee,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        if (dstChainId == block.chainid) {\n            revert InterchainApp__SameChainId(dstChainId);\n        }\n        if (receiver == 0) {\n            revert InterchainApp__ReceiverNotSet(dstChainId);\n        }\n        if (address(this).balance \u003c messageFee) {\n            revert InterchainApp__BalanceTooLow({actual: address(this).balance, required: messageFee});\n        }\n        return IInterchainClientV1(client).interchainSend{value: messageFee}(\n            dstChainId, receiver, _getExecutionService(), _getModules(), options, message\n        );\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        virtual;\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee for sending an Interchain message.\n    function _getInterchainFee(\n        uint64 dstChainId,\n        bytes memory options,\n        uint256 messageLen\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        address client = _getLatestClient();\n        if (client == address(0)) {\n            revert InterchainApp__InterchainClientZeroAddress();\n        }\n        return IInterchainClientV1(client).getInterchainFee(\n            dstChainId, _getExecutionService(), _getModules(), options, messageLen\n        );\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view virtual returns (bytes memory);\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view virtual returns (address);\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view virtual returns (address);\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view virtual returns (address[] memory);\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint64 srcChainId, bytes32 sender) internal view virtual returns (bool);\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view virtual returns (bool);\n}\n\n// contracts/apps/ICAppV1.sol\n\nabstract contract ICAppV1 is AbstractICApp, AccessControlEnumerable, InterchainAppV1Events, IInterchainAppV1 {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Role to manage the Interchain setup of the app.\n    bytes32 public constant IC_GOVERNOR_ROLE = keccak256(\"IC_GOVERNOR_ROLE\");\n\n    /// @dev Address of the latest Interchain Client, used for sending messages.\n    address private _latestClient;\n\n    /// @dev Required responses and optimistic period for the module responses.\n    AppConfigV1 private _appConfigV1;\n    /// @dev Address of the linked app deployed on the remote chain.\n    mapping(uint64 chainId =\u003e bytes32 remoteApp) private _linkedApp;\n    /// @dev Interchain Clients allowed to send messages to this app.\n    EnumerableSet.AddressSet private _interchainClients;\n    /// @dev Trusted Interchain modules.\n    EnumerableSet.AddressSet private _trustedModules;\n    /// @dev Execution Service to use for sending messages.\n    address private _executionService;\n\n    constructor(address admin) {\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addInterchainClient(address client, bool updateLatest) external onlyRole(IC_GOVERNOR_ROLE) {\n        _addClient(client, updateLatest);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _removeClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setLatestInterchainClient(address client) external onlyRole(IC_GOVERNOR_ROLE) {\n        _setLatestClient(client);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteApp(uint64 chainId, bytes32 remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function linkRemoteAppEVM(uint64 chainId, address remoteApp) external onlyRole(IC_GOVERNOR_ROLE) {\n        _linkRemoteApp(chainId, remoteApp.addressToBytes32());\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function addTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (module == address(0)) {\n            revert InterchainApp__ModuleZeroAddress();\n        }\n        bool added = _trustedModules.add(module);\n        if (!added) {\n            revert InterchainApp__ModuleAlreadyAdded(module);\n        }\n        emit TrustedModuleAdded(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function removeTrustedModule(address module) external onlyRole(IC_GOVERNOR_ROLE) {\n        bool removed = _trustedModules.remove(module);\n        if (!removed) {\n            revert InterchainApp__ModuleNotAdded(module);\n        }\n        emit TrustedModuleRemoved(module);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setAppConfigV1(AppConfigV1 memory appConfig) external onlyRole(IC_GOVERNOR_ROLE) {\n        if (appConfig.requiredResponses == 0 || appConfig.optimisticPeriod == 0) {\n            revert InterchainApp__InvalidAppConfig(appConfig.requiredResponses, appConfig.optimisticPeriod);\n        }\n        _appConfigV1 = appConfig;\n        emit AppConfigV1Set(appConfig.requiredResponses, appConfig.optimisticPeriod);\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function setExecutionService(address executionService) external onlyRole(IC_GOVERNOR_ROLE) {\n        _executionService = executionService;\n        emit ExecutionServiceSet(executionService);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainAppV1\n    function getAppConfigV1() external view returns (AppConfigV1 memory) {\n        return _appConfigV1;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getExecutionService() external view returns (address) {\n        return _executionService;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getInterchainClients() external view returns (address[] memory) {\n        return _interchainClients.values();\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLatestInterchainClient() external view returns (address) {\n        return _latestClient;\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedApp(uint64 chainId) external view returns (bytes32) {\n        return _linkedApp[chainId];\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getLinkedAppEVM(uint64 chainId) external view returns (address linkedAppEVM) {\n        bytes32 linkedApp = _linkedApp[chainId];\n        linkedAppEVM = linkedApp.bytes32ToAddress();\n        if (linkedAppEVM.addressToBytes32() != linkedApp) {\n            revert InterchainApp__NotEVMLinkedApp(linkedApp);\n        }\n    }\n\n    /// @inheritdoc IInterchainAppV1\n    function getModules() external view returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    // ═══════════════════════════════════════════ INTERNAL: MANAGEMENT ════════════════════════════════════════════════\n\n    /// @dev Links the remote app to the current app.\n    /// Will revert if the chainId is the same as the chainId of the local app.\n    /// Note: Should be guarded with permissions check.\n    function _linkRemoteApp(uint64 chainId, bytes32 remoteApp) internal {\n        if (chainId == block.chainid) {\n            revert InterchainApp__SameChainId(chainId);\n        }\n        if (remoteApp == 0) {\n            revert InterchainApp__AppZeroAddress();\n        }\n        _linkedApp[chainId] = remoteApp;\n        emit AppLinked(chainId, remoteApp);\n    }\n\n    /// @dev Stores the address of the latest Interchain Client.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_setLatestClient` instead.\n    /// - Should not emit any events: this is done in the calling function.\n    function _storeLatestClient(address client) internal override {\n        _latestClient = client;\n    }\n\n    /// @dev Toggle the state of the Interchain Client (allowed/disallowed to send messages to this app).\n    /// - The client is checked to be in the opposite state before the change.\n    /// - The exact storage location is up to the implementation.\n    /// - Must NOT be called directly: use `_addClient` and `_removeClient` instead.\n    /// - Should not emit any events: this is done in the calling functions.\n    function _toggleClientState(address client, bool allowed) internal override {\n        if (allowed) {\n            _interchainClients.add(client);\n        } else {\n            _interchainClients.remove(client);\n        }\n    }\n\n    // ════════════════════════════════════════════ INTERNAL: MESSAGING ════════════════════════════════════════════════\n\n    /// @dev Thin wrapper around _sendInterchainMessage to send the message to the linked app.\n    function _sendToLinkedApp(\n        uint64 dstChainId,\n        uint256 messageFee,\n        OptionsV1 memory options,\n        bytes memory message\n    )\n        internal\n        returns (InterchainTxDescriptor memory)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _sendInterchainMessage(dstChainId, _linkedApp[dstChainId], messageFee, encodedOptions, message);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Returns the fee to send a message to the linked app on the remote chain.\n    function _getMessageFee(\n        uint64 dstChainId,\n        OptionsV1 memory options,\n        uint256 messageLen\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        bytes memory encodedOptions = options.encodeOptionsV1();\n        return _getInterchainFee(dstChainId, encodedOptions, messageLen);\n    }\n\n    /// @dev Returns the configuration of the app for validating the received messages.\n    function _getAppConfig() internal view override returns (bytes memory) {\n        return _appConfigV1.encodeAppConfigV1();\n    }\n\n    /// @dev Returns the address of the Execution Service to use for sending messages.\n    function _getExecutionService() internal view override returns (address) {\n        return _executionService;\n    }\n\n    /// @dev Returns the latest Interchain Client. This is the Client that is used for sending messages.\n    function _getLatestClient() internal view override returns (address) {\n        return _latestClient;\n    }\n\n    /// @dev Returns the list of modules to use for sending messages, as well as validating the received messages.\n    function _getModules() internal view override returns (address[] memory) {\n        return _trustedModules.values();\n    }\n\n    /// @dev Checks if the sender is allowed to send messages to this app.\n    function _isAllowedSender(uint64 srcChainId, bytes32 sender) internal view override returns (bool) {\n        return _linkedApp[srcChainId] == sender;\n    }\n\n    /// @dev Checks if the caller is an Interchain Client.\n    /// Both latest and legacy Interchain Clients are allowed to call `appReceive`.\n    function _isInterchainClient(address caller) internal view override returns (bool) {\n        return _interchainClients.contains(caller);\n    }\n}\n\n// contracts/apps/examples/ExampleAppV1.sol\n\ncontract ExampleAppV1 is ICAppV1 {\n    event MessageReceived(uint64 srcChainId, bytes32 sender, uint64 dbNonce, uint64 entryIndex, bytes message);\n    event MessageSent(uint64 dstChainId, uint64 dbNonce, uint64 entryIndex, bytes32 transactionId);\n\n    constructor(address admin) ICAppV1(admin) {\n        _grantRole(IC_GOVERNOR_ROLE, admin);\n    }\n\n    /// @notice Allows the Admin to withdraw the native asset from the contract.\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        Address.sendValue(payable(msg.sender), address(this).balance);\n    }\n\n    /// @notice Sends a basic message to the destination chain.\n    function sendMessage(\n        uint64 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes calldata message\n    )\n        external\n        payable\n    {\n        InterchainTxDescriptor memory desc = _sendToLinkedApp({\n            dstChainId: dstChainId,\n            messageFee: msg.value,\n            options: OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}),\n            message: message\n        });\n        emit MessageSent(dstChainId, desc.dbNonce, desc.entryIndex, desc.transactionId);\n    }\n\n    /// @notice Returns the fee required to send a message using `sendMessage`.\n    function getMessageFee(\n        uint64 dstChainId,\n        uint256 gasLimit,\n        uint256 gasAirdrop,\n        bytes memory message\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _getMessageFee(dstChainId, OptionsV1({gasLimit: gasLimit, gasAirdrop: gasAirdrop}), message.length);\n    }\n\n    /// @dev Internal logic for receiving messages. At this point the validity of the message is already checked.\n    function _receiveMessage(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        internal\n        override\n    {\n        emit MessageReceived(srcChainId, sender, dbNonce, entryIndex, message);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"3296:3757:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;3296:3757:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"3296:3757:0:-:0;;;;;;;;","abiDefinition":[{"inputs":[],"name":"VersionedPayload__PrecompileFailed","type":"error"},{"inputs":[{"internalType":"bytes","name":"versionedPayload","type":"bytes"}],"name":"VersionedPayload__TooShort","type":"error"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"VersionedPayload__PrecompileFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"versionedPayload\",\"type\":\"bytes\"}],\"name\":\"VersionedPayload__TooShort\",\"type\":\"error\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/ExampleAppV1.sol\":\"VersionedPayloadLib\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/ExampleAppV1.sol\":{\"keccak256\":\"0xb1e9550aef785a0afc4e03fc843839919987ba4f906f09992c6788979c3c0396\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://0ede697223dfa3a2e23501efc1ed5926d5ff6458ee7b9ba833e0587162166c79\",\"dweb:/ipfs/QmUzgopL2ptWG5DYNdGAcoErPnBC4KCoRp8C61dkHHRaA6\"]}},\"version\":1}"},"hashes":{}}}