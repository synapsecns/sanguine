{"solidity/OptionsLibExport.sol:OptionsLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220c04b11497d53de845781836e619953aa409a9a41eeaa5ffde264c68eb136e8d864736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220c04b11497d53de845781836e619953aa409a9a41eeaa5ffde264c68eb136e8d864736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13;\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/VersionedPayload.sol\n\n// solhint-disable no-inline-assembly\n// solhint-disable ordering\nlibrary VersionedPayloadLib {\n    /// @notice Amount of bytes reserved for the version (uint16) in the versioned payload\n    uint256 internal constant VERSION_LENGTH = 2;\n\n    error VersionedPayload__PayloadTooShort(bytes versionedPayload);\n    error VersionedPayload__PrecompileFailed();\n\n    /// @notice Encodes the versioned payload into a single bytes array.\n    /// @param version  The payload's version.\n    /// @param payload  The payload to encode.\n    function encodeVersionedPayload(uint16 version, bytes memory payload) internal pure returns (bytes memory) {\n        return abi.encodePacked(version, payload);\n    }\n\n    /// @notice Extracts the version from the versioned payload (calldata reference).\n    /// @param versionedPayload     The versioned payload (calldata reference).\n    function getVersion(bytes calldata versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__PayloadTooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            version := shr(240, calldataload(versionedPayload.offset))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (calldata reference).\n    /// @dev The extracted payload is also returned as a calldata reference.\n    /// @param versionedPayload     The versioned payload.\n    function getPayload(bytes calldata versionedPayload) internal pure returns (bytes calldata) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__PayloadTooShort(versionedPayload);\n        }\n        return versionedPayload[VERSION_LENGTH:];\n    }\n\n    /// @notice Extracts the version from the versioned payload (memory reference).\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getVersionFromMemory(bytes memory versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__PayloadTooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            // We add 0x20 to skip the length of the bytes array.\n            version := shr(240, mload(add(versionedPayload, 0x20)))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (memory reference).\n    /// @dev The extracted payload is copied into a new memory location. Use `getPayload` when possible\n    /// to avoid extra memory allocation.\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getPayloadFromMemory(bytes memory versionedPayload) internal view returns (bytes memory payload) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__PayloadTooShort(versionedPayload);\n        }\n        // Figure how many bytes to copy and allocate the memory for the extracted payload.\n        uint256 toCopy;\n        unchecked {\n            toCopy = versionedPayload.length - VERSION_LENGTH;\n        }\n        payload = new bytes(toCopy);\n        // Use identity precompile (0x04) to copy the payload. Unlike MCOPY, this is available on all EVM chains.\n        bool res;\n        assembly {\n            // We add 0x20 to skip the length of the bytes array.\n            // We add 0x02 to skip the 2 bytes reserved for the version.\n            // Copy the payload to the previously allocated memory.\n            res := staticcall(gas(), 0x04, add(versionedPayload, 0x22), toCopy, add(payload, 0x20), toCopy)\n        }\n        if (!res) {\n            revert VersionedPayload__PrecompileFailed();\n        }\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant OPTIONS_V1 = 1;\n\n    error OptionsLib__VersionInvalid(uint16 version);\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal view returns (OptionsV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__VersionInvalid(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (OptionsV1));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(OPTIONS_V1, abi.encode(options));\n    }\n}\n\n// contracts/mocks/OptionsLibExport.sol\n\ncontract OptionsLibMocks {\n    function decodeOptions(bytes memory data) external view returns (OptionsV1 memory) {\n        return OptionsLib.decodeOptionsV1(data);\n    }\n\n    function encodeOptions(OptionsV1 memory options) external pure returns (bytes memory) {\n        return OptionsLib.encodeOptionsV1(options);\n    }\n\n    function addressToBytes32(address convertable) external pure returns (bytes32) {\n        return TypeCasts.addressToBytes32(convertable);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"4805:1229:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;4805:1229:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"4805:1229:0:-:0;;;;;;;;","abiDefinition":[{"inputs":[{"internalType":"uint16","name":"version","type":"uint16"}],"name":"OptionsLib__VersionInvalid","type":"error"}],"userDoc":{"kind":"user","methods":{},"notice":"A library for encoding and decoding Interchain options related to interchain messages.","version":1},"developerDoc":{"kind":"dev","methods":{},"title":"OptionsLib","version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"version\",\"type\":\"uint16\"}],\"name\":\"OptionsLib__VersionInvalid\",\"type\":\"error\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"title\":\"OptionsLib\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"A library for encoding and decoding Interchain options related to interchain messages.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/OptionsLibExport.sol\":\"OptionsLib\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/OptionsLibExport.sol\":{\"keccak256\":\"0xb8859b9712fe340d8a18347b081befc45a9c750cf6650a9f5ba9302ec63c89bb\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://03b5e8b8530eeea95fa309166d46288516a8d09b587cea03b76eba74014010bf\",\"dweb:/ipfs/QmRgpmpqSmYNPheFFknvdiVk6d3prvtTvVfQqx7gRYi9mx\"]}},\"version\":1}"},"hashes":{}},"solidity/OptionsLibExport.sol:OptionsLibMocks":{"code":"0x608060405234801561001057600080fd5b506105f6806100206000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c806382c947b714610046578063c551274c1461006c578063d5e788a01461008c575b600080fd5b61005961005436600461033f565b6100ba565b6040519081526020015b60405180910390f35b61007f61007a3660046103cd565b6100da565b6040516100639190610423565b61009f61009a366004610474565b6100e5565b60408051825181526020928301519281019290925201610063565b600073ffffffffffffffffffffffffffffffffffffffff82165b92915050565b60606100d482610102565b60408051808201909152600080825260208201526100d482610140565b60606100d460018360405160200161012c9190815181526020918201519181019190915260400190565b6040516020818303038152906040526101ce565b6040805180820190915260008082526020820152600061015f836101fa565b9050600161ffff821610156101ab576040517f2b346f3700000000000000000000000000000000000000000000000000000000815261ffff821660048201526024015b60405180910390fd5b6101b483610245565b8060200190518101906101c79190610543565b9392505050565b606082826040516020016101e3929190610575565b604051602081830303815290604052905092915050565b600060028251101561023a57816040517fb0818b620000000000000000000000000000000000000000000000000000000081526004016101a29190610423565b506020015160f01c90565b606060028251101561028557816040517fb0818b620000000000000000000000000000000000000000000000000000000081526004016101a29190610423565b81517ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe018067ffffffffffffffff8111156102c2576102c2610375565b6040519080825280601f01601f1916602001820160405280156102ec576020820181803683370190505b50915060008160208401836022870160045afa905080610338576040517f101e44fa00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5050919050565b60006020828403121561035157600080fd5b813573ffffffffffffffffffffffffffffffffffffffff811681146101c757600080fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040805190810167ffffffffffffffff811182821017156103c7576103c7610375565b60405290565b6000604082840312156103df57600080fd5b6103e76103a4565b82358152602083013560208201528091505092915050565b60005b8381101561041a578181015183820152602001610402565b50506000910152565b60208152600082518060208401526104428160408501602087016103ff565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169190910160400192915050565b60006020828403121561048657600080fd5b813567ffffffffffffffff8082111561049e57600080fd5b818401915084601f8301126104b257600080fd5b8135818111156104c4576104c4610375565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f0116810190838211818310171561050a5761050a610375565b8160405282815287602084870101111561052357600080fd5b826020860160208301376000928101602001929092525095945050505050565b60006040828403121561055557600080fd5b61055d6103a4565b82518152602083015160208201528091505092915050565b7fffff0000000000000000000000000000000000000000000000000000000000008360f01b168152600082516105b28160028501602087016103ff565b91909101600201939250505056fea26469706673582212203b83180ed5e6393c445ed424f92f8c5920e36f1a2eb75a65b81fb74a9192d4f964736f6c63430008140033","runtime-code":"0x608060405234801561001057600080fd5b50600436106100415760003560e01c806382c947b714610046578063c551274c1461006c578063d5e788a01461008c575b600080fd5b61005961005436600461033f565b6100ba565b6040519081526020015b60405180910390f35b61007f61007a3660046103cd565b6100da565b6040516100639190610423565b61009f61009a366004610474565b6100e5565b60408051825181526020928301519281019290925201610063565b600073ffffffffffffffffffffffffffffffffffffffff82165b92915050565b60606100d482610102565b60408051808201909152600080825260208201526100d482610140565b60606100d460018360405160200161012c9190815181526020918201519181019190915260400190565b6040516020818303038152906040526101ce565b6040805180820190915260008082526020820152600061015f836101fa565b9050600161ffff821610156101ab576040517f2b346f3700000000000000000000000000000000000000000000000000000000815261ffff821660048201526024015b60405180910390fd5b6101b483610245565b8060200190518101906101c79190610543565b9392505050565b606082826040516020016101e3929190610575565b604051602081830303815290604052905092915050565b600060028251101561023a57816040517fb0818b620000000000000000000000000000000000000000000000000000000081526004016101a29190610423565b506020015160f01c90565b606060028251101561028557816040517fb0818b620000000000000000000000000000000000000000000000000000000081526004016101a29190610423565b81517ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe018067ffffffffffffffff8111156102c2576102c2610375565b6040519080825280601f01601f1916602001820160405280156102ec576020820181803683370190505b50915060008160208401836022870160045afa905080610338576040517f101e44fa00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5050919050565b60006020828403121561035157600080fd5b813573ffffffffffffffffffffffffffffffffffffffff811681146101c757600080fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040805190810167ffffffffffffffff811182821017156103c7576103c7610375565b60405290565b6000604082840312156103df57600080fd5b6103e76103a4565b82358152602083013560208201528091505092915050565b60005b8381101561041a578181015183820152602001610402565b50506000910152565b60208152600082518060208401526104428160408501602087016103ff565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169190910160400192915050565b60006020828403121561048657600080fd5b813567ffffffffffffffff8082111561049e57600080fd5b818401915084601f8301126104b257600080fd5b8135818111156104c4576104c4610375565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f0116810190838211818310171561050a5761050a610375565b8160405282815287602084870101111561052357600080fd5b826020860160208301376000928101602001929092525095945050505050565b60006040828403121561055557600080fd5b61055d6103a4565b82518152602083015160208201528091505092915050565b7fffff0000000000000000000000000000000000000000000000000000000000008360f01b168152600082516105b28160028501602087016103ff565b91909101600201939250505056fea26469706673582212203b83180ed5e6393c445ed424f92f8c5920e36f1a2eb75a65b81fb74a9192d4f964736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13;\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/VersionedPayload.sol\n\n// solhint-disable no-inline-assembly\n// solhint-disable ordering\nlibrary VersionedPayloadLib {\n    /// @notice Amount of bytes reserved for the version (uint16) in the versioned payload\n    uint256 internal constant VERSION_LENGTH = 2;\n\n    error VersionedPayload__PayloadTooShort(bytes versionedPayload);\n    error VersionedPayload__PrecompileFailed();\n\n    /// @notice Encodes the versioned payload into a single bytes array.\n    /// @param version  The payload's version.\n    /// @param payload  The payload to encode.\n    function encodeVersionedPayload(uint16 version, bytes memory payload) internal pure returns (bytes memory) {\n        return abi.encodePacked(version, payload);\n    }\n\n    /// @notice Extracts the version from the versioned payload (calldata reference).\n    /// @param versionedPayload     The versioned payload (calldata reference).\n    function getVersion(bytes calldata versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__PayloadTooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            version := shr(240, calldataload(versionedPayload.offset))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (calldata reference).\n    /// @dev The extracted payload is also returned as a calldata reference.\n    /// @param versionedPayload     The versioned payload.\n    function getPayload(bytes calldata versionedPayload) internal pure returns (bytes calldata) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__PayloadTooShort(versionedPayload);\n        }\n        return versionedPayload[VERSION_LENGTH:];\n    }\n\n    /// @notice Extracts the version from the versioned payload (memory reference).\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getVersionFromMemory(bytes memory versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__PayloadTooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            // We add 0x20 to skip the length of the bytes array.\n            version := shr(240, mload(add(versionedPayload, 0x20)))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (memory reference).\n    /// @dev The extracted payload is copied into a new memory location. Use `getPayload` when possible\n    /// to avoid extra memory allocation.\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getPayloadFromMemory(bytes memory versionedPayload) internal view returns (bytes memory payload) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__PayloadTooShort(versionedPayload);\n        }\n        // Figure how many bytes to copy and allocate the memory for the extracted payload.\n        uint256 toCopy;\n        unchecked {\n            toCopy = versionedPayload.length - VERSION_LENGTH;\n        }\n        payload = new bytes(toCopy);\n        // Use identity precompile (0x04) to copy the payload. Unlike MCOPY, this is available on all EVM chains.\n        bool res;\n        assembly {\n            // We add 0x20 to skip the length of the bytes array.\n            // We add 0x02 to skip the 2 bytes reserved for the version.\n            // Copy the payload to the previously allocated memory.\n            res := staticcall(gas(), 0x04, add(versionedPayload, 0x22), toCopy, add(payload, 0x20), toCopy)\n        }\n        if (!res) {\n            revert VersionedPayload__PrecompileFailed();\n        }\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant OPTIONS_V1 = 1;\n\n    error OptionsLib__VersionInvalid(uint16 version);\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal view returns (OptionsV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__VersionInvalid(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (OptionsV1));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(OPTIONS_V1, abi.encode(options));\n    }\n}\n\n// contracts/mocks/OptionsLibExport.sol\n\ncontract OptionsLibMocks {\n    function decodeOptions(bytes memory data) external view returns (OptionsV1 memory) {\n        return OptionsLib.decodeOptionsV1(data);\n    }\n\n    function encodeOptions(OptionsV1 memory options) external pure returns (bytes memory) {\n        return OptionsLib.encodeOptionsV1(options);\n    }\n\n    function addressToBytes32(address convertable) external pure returns (bytes32) {\n        return TypeCasts.addressToBytes32(convertable);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"6077:471:0:-:0;;;;;;;;;;;;;;;;;;;","srcMapRuntime":"6077:471:0:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;6404:142;;;;;;:::i;:::-;;:::i;:::-;;;474:25:1;;;462:2;447:18;6404:142:0;;;;;;;;6253:145;;;;;;:::i;:::-;;:::i;:::-;;;;;;;:::i;6108:139::-;;;;;;:::i;:::-;;:::i;:::-;;;;3208:13:1;;3190:32;;3278:4;3266:17;;;3260:24;3238:20;;;3231:54;;;;3163:18;6108:139:0;2992:299:1;6404:142:0;6474:7;227:22;;;6500:39;6493:46;6404:142;-1:-1:-1;;6404:142:0:o;6253:145::-;6325:12;6356:35;6383:7;6356:26;:35::i;6108:139::-;-1:-1:-1;;;;;;;;;;;;;;;;;6208:32:0;6235:4;6208:26;:32::i;5845:187::-;5919:12;5950:75;4910:1;6016:7;6005:19;;;;;;;3208:13:1;;3190:32;;3278:4;3266:17;;;3260:24;3238:20;;;3231:54;;;;3178:2;3163:18;;2992:299;6005:19:0;;;;;;;;;;;;;5950:42;:75::i;5133:597::-;-1:-1:-1;;;;;;;;;;;;;;;;;5228:14:0;5245:27;:4;:25;:27::i;:::-;5228:44;-1:-1:-1;4910:1:0;5286:20;;;;5282:93;;;5329:35;;;;;3470:6:1;3458:19;;5329:35:0;;;3440:38:1;3413:18;;5329:35:0;;;;;;;;5282:93;5682:27;:4;:25;:27::i;:::-;5671:52;;;;;;;;;;;;:::i;:::-;5664:59;5133:597;-1:-1:-1;;;5133:597:0:o;955:165::-;1048:12;1096:7;1105;1079:34;;;;;;;;;:::i;:::-;;;;;;;;;;;;;1072:41;;955:165;;;;:::o;2407:503::-;2491:14;662:1;2521:16;:23;:40;2517:129;;;2618:16;2584:51;;;;;;;;;;;:::i;2517:129::-;-1:-1:-1;2887:4:0;2865:27;2859:34;2854:3;2850:44;;2407:503::o;3224:1060::-;3308:20;662:1;3344:16;:23;:40;3340:129;;;3441:16;3407:51;;;;;;;;;;;:::i;3340:129::-;3627:23;;:40;;;3697:17;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;3697:17:0;;3687:27;;3838:8;4174:6;4167:4;4158:7;4154:18;4146:6;4139:4;4121:16;4117:27;4111:4;4104:5;4093:88;4086:95;;4205:3;4200:78;;4231:36;;;;;;;;;;;;;;4200:78;3330:954;;3224:1060;;;:::o;14:309:1:-;73:6;126:2;114:9;105:7;101:23;97:32;94:52;;;142:1;139;132:12;94:52;181:9;168:23;231:42;224:5;220:54;213:5;210:65;200:93;;289:1;286;279:12;510:184;562:77;559:1;552:88;659:4;656:1;649:15;683:4;680:1;673:15;699:246;766:2;760:9;;;796:15;;841:18;826:34;;862:22;;;823:62;820:88;;;888:18;;:::i;:::-;924:2;917:22;699:246;:::o;950:339::-;1035:6;1088:2;1076:9;1067:7;1063:23;1059:32;1056:52;;;1104:1;1101;1094:12;1056:52;1130:17;;:::i;:::-;1183:9;1170:23;1163:5;1156:38;1254:2;1243:9;1239:18;1226:32;1221:2;1214:5;1210:14;1203:56;1278:5;1268:15;;;950:339;;;;:::o;1294:250::-;1379:1;1389:113;1403:6;1400:1;1397:13;1389:113;;;1479:11;;;1473:18;1460:11;;;1453:39;1425:2;1418:10;1389:113;;;-1:-1:-1;;1536:1:1;1518:16;;1511:27;1294:250::o;1549:453::-;1696:2;1685:9;1678:21;1659:4;1728:6;1722:13;1771:6;1766:2;1755:9;1751:18;1744:34;1787:79;1859:6;1854:2;1843:9;1839:18;1834:2;1826:6;1822:15;1787:79;:::i;:::-;1918:2;1906:15;1923:66;1902:88;1887:104;;;;1993:2;1883:113;;1549:453;-1:-1:-1;;1549:453:1:o;2007:980::-;2075:6;2128:2;2116:9;2107:7;2103:23;2099:32;2096:52;;;2144:1;2141;2134:12;2096:52;2184:9;2171:23;2213:18;2254:2;2246:6;2243:14;2240:34;;;2270:1;2267;2260:12;2240:34;2308:6;2297:9;2293:22;2283:32;;2353:7;2346:4;2342:2;2338:13;2334:27;2324:55;;2375:1;2372;2365:12;2324:55;2411:2;2398:16;2433:2;2429;2426:10;2423:36;;;2439:18;;:::i;:::-;2573:2;2567:9;2635:4;2627:13;;2478:66;2623:22;;;2647:2;2619:31;2615:40;2603:53;;;2671:18;;;2691:22;;;2668:46;2665:72;;;2717:18;;:::i;:::-;2757:10;2753:2;2746:22;2792:2;2784:6;2777:18;2832:7;2827:2;2822;2818;2814:11;2810:20;2807:33;2804:53;;;2853:1;2850;2843:12;2804:53;2909:2;2904;2900;2896:11;2891:2;2883:6;2879:15;2866:46;2954:1;2932:15;;;2949:2;2928:24;2921:35;;;;-1:-1:-1;2936:6:1;2007:980;-1:-1:-1;;;;;2007:980:1:o;3489:336::-;3585:6;3638:2;3626:9;3617:7;3613:23;3609:32;3606:52;;;3654:1;3651;3644:12;3606:52;3680:17;;:::i;:::-;3726:9;3720:16;3713:5;3706:31;3790:2;3779:9;3775:18;3769:25;3764:2;3757:5;3753:14;3746:49;3814:5;3804:15;;;3489:336;;;;:::o;3830:440::-;4037:66;4028:6;4023:3;4019:16;4015:89;4010:3;4003:102;3985:3;4134:6;4128:13;4150:74;4217:6;4213:1;4208:3;4204:11;4197:4;4189:6;4185:17;4150:74;:::i;:::-;4244:16;;;;4262:1;4240:24;;3830:440;-1:-1:-1;;;3830:440:1:o","abiDefinition":[{"inputs":[{"internalType":"uint16","name":"version","type":"uint16"}],"name":"OptionsLib__VersionInvalid","type":"error"},{"inputs":[{"internalType":"bytes","name":"versionedPayload","type":"bytes"}],"name":"VersionedPayload__PayloadTooShort","type":"error"},{"inputs":[],"name":"VersionedPayload__PrecompileFailed","type":"error"},{"inputs":[{"internalType":"address","name":"convertable","type":"address"}],"name":"addressToBytes32","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"data","type":"bytes"}],"name":"decodeOptions","outputs":[{"components":[{"internalType":"uint256","name":"gasLimit","type":"uint256"},{"internalType":"uint256","name":"gasAirdrop","type":"uint256"}],"internalType":"struct OptionsV1","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[{"components":[{"internalType":"uint256","name":"gasLimit","type":"uint256"},{"internalType":"uint256","name":"gasAirdrop","type":"uint256"}],"internalType":"struct OptionsV1","name":"options","type":"tuple"}],"name":"encodeOptions","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"pure","type":"function"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"version\",\"type\":\"uint16\"}],\"name\":\"OptionsLib__VersionInvalid\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"versionedPayload\",\"type\":\"bytes\"}],\"name\":\"VersionedPayload__PayloadTooShort\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VersionedPayload__PrecompileFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"convertable\",\"type\":\"address\"}],\"name\":\"addressToBytes32\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"decodeOptions\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasAirdrop\",\"type\":\"uint256\"}],\"internalType\":\"struct OptionsV1\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasAirdrop\",\"type\":\"uint256\"}],\"internalType\":\"struct OptionsV1\",\"name\":\"options\",\"type\":\"tuple\"}],\"name\":\"encodeOptions\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/OptionsLibExport.sol\":\"OptionsLibMocks\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/OptionsLibExport.sol\":{\"keccak256\":\"0xb8859b9712fe340d8a18347b081befc45a9c750cf6650a9f5ba9302ec63c89bb\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://03b5e8b8530eeea95fa309166d46288516a8d09b587cea03b76eba74014010bf\",\"dweb:/ipfs/QmRgpmpqSmYNPheFFknvdiVk6d3prvtTvVfQqx7gRYi9mx\"]}},\"version\":1}"},"hashes":{"addressToBytes32(address)":"82c947b7","decodeOptions(bytes)":"d5e788a0","encodeOptions((uint256,uint256))":"c551274c"}},"solidity/OptionsLibExport.sol:TypeCasts":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122074d3fbc0adad6cebf17e5dd9805506a3b248df0c20b8b600c21ecd75911a2cac64736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122074d3fbc0adad6cebf17e5dd9805506a3b248df0c20b8b600c21ecd75911a2cac64736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13;\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/VersionedPayload.sol\n\n// solhint-disable no-inline-assembly\n// solhint-disable ordering\nlibrary VersionedPayloadLib {\n    /// @notice Amount of bytes reserved for the version (uint16) in the versioned payload\n    uint256 internal constant VERSION_LENGTH = 2;\n\n    error VersionedPayload__PayloadTooShort(bytes versionedPayload);\n    error VersionedPayload__PrecompileFailed();\n\n    /// @notice Encodes the versioned payload into a single bytes array.\n    /// @param version  The payload's version.\n    /// @param payload  The payload to encode.\n    function encodeVersionedPayload(uint16 version, bytes memory payload) internal pure returns (bytes memory) {\n        return abi.encodePacked(version, payload);\n    }\n\n    /// @notice Extracts the version from the versioned payload (calldata reference).\n    /// @param versionedPayload     The versioned payload (calldata reference).\n    function getVersion(bytes calldata versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__PayloadTooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            version := shr(240, calldataload(versionedPayload.offset))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (calldata reference).\n    /// @dev The extracted payload is also returned as a calldata reference.\n    /// @param versionedPayload     The versioned payload.\n    function getPayload(bytes calldata versionedPayload) internal pure returns (bytes calldata) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__PayloadTooShort(versionedPayload);\n        }\n        return versionedPayload[VERSION_LENGTH:];\n    }\n\n    /// @notice Extracts the version from the versioned payload (memory reference).\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getVersionFromMemory(bytes memory versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__PayloadTooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            // We add 0x20 to skip the length of the bytes array.\n            version := shr(240, mload(add(versionedPayload, 0x20)))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (memory reference).\n    /// @dev The extracted payload is copied into a new memory location. Use `getPayload` when possible\n    /// to avoid extra memory allocation.\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getPayloadFromMemory(bytes memory versionedPayload) internal view returns (bytes memory payload) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__PayloadTooShort(versionedPayload);\n        }\n        // Figure how many bytes to copy and allocate the memory for the extracted payload.\n        uint256 toCopy;\n        unchecked {\n            toCopy = versionedPayload.length - VERSION_LENGTH;\n        }\n        payload = new bytes(toCopy);\n        // Use identity precompile (0x04) to copy the payload. Unlike MCOPY, this is available on all EVM chains.\n        bool res;\n        assembly {\n            // We add 0x20 to skip the length of the bytes array.\n            // We add 0x02 to skip the 2 bytes reserved for the version.\n            // Copy the payload to the previously allocated memory.\n            res := staticcall(gas(), 0x04, add(versionedPayload, 0x22), toCopy, add(payload, 0x20), toCopy)\n        }\n        if (!res) {\n            revert VersionedPayload__PrecompileFailed();\n        }\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant OPTIONS_V1 = 1;\n\n    error OptionsLib__VersionInvalid(uint16 version);\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal view returns (OptionsV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__VersionInvalid(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (OptionsV1));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(OPTIONS_V1, abi.encode(options));\n    }\n}\n\n// contracts/mocks/OptionsLibExport.sol\n\ncontract OptionsLibMocks {\n    function decodeOptions(bytes memory data) external view returns (OptionsV1 memory) {\n        return OptionsLib.decodeOptionsV1(data);\n    }\n\n    function encodeOptions(OptionsV1 memory options) external pure returns (bytes memory) {\n        return OptionsLib.encodeOptionsV1(options);\n    }\n\n    function addressToBytes32(address convertable) external pure returns (bytes32) {\n        return TypeCasts.addressToBytes32(convertable);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"106:280:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;106:280:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"106:280:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/OptionsLibExport.sol\":\"TypeCasts\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/OptionsLibExport.sol\":{\"keccak256\":\"0xb8859b9712fe340d8a18347b081befc45a9c750cf6650a9f5ba9302ec63c89bb\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://03b5e8b8530eeea95fa309166d46288516a8d09b587cea03b76eba74014010bf\",\"dweb:/ipfs/QmRgpmpqSmYNPheFFknvdiVk6d3prvtTvVfQqx7gRYi9mx\"]}},\"version\":1}"},"hashes":{}},"solidity/OptionsLibExport.sol:VersionedPayloadLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122073f50e36a5113699dd0d944331dc3048c64d311718fb8cb9598839f4a0c0a63564736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122073f50e36a5113699dd0d944331dc3048c64d311718fb8cb9598839f4a0c0a63564736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13;\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/VersionedPayload.sol\n\n// solhint-disable no-inline-assembly\n// solhint-disable ordering\nlibrary VersionedPayloadLib {\n    /// @notice Amount of bytes reserved for the version (uint16) in the versioned payload\n    uint256 internal constant VERSION_LENGTH = 2;\n\n    error VersionedPayload__PayloadTooShort(bytes versionedPayload);\n    error VersionedPayload__PrecompileFailed();\n\n    /// @notice Encodes the versioned payload into a single bytes array.\n    /// @param version  The payload's version.\n    /// @param payload  The payload to encode.\n    function encodeVersionedPayload(uint16 version, bytes memory payload) internal pure returns (bytes memory) {\n        return abi.encodePacked(version, payload);\n    }\n\n    /// @notice Extracts the version from the versioned payload (calldata reference).\n    /// @param versionedPayload     The versioned payload (calldata reference).\n    function getVersion(bytes calldata versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__PayloadTooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            version := shr(240, calldataload(versionedPayload.offset))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (calldata reference).\n    /// @dev The extracted payload is also returned as a calldata reference.\n    /// @param versionedPayload     The versioned payload.\n    function getPayload(bytes calldata versionedPayload) internal pure returns (bytes calldata) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__PayloadTooShort(versionedPayload);\n        }\n        return versionedPayload[VERSION_LENGTH:];\n    }\n\n    /// @notice Extracts the version from the versioned payload (memory reference).\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getVersionFromMemory(bytes memory versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__PayloadTooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            // We add 0x20 to skip the length of the bytes array.\n            version := shr(240, mload(add(versionedPayload, 0x20)))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (memory reference).\n    /// @dev The extracted payload is copied into a new memory location. Use `getPayload` when possible\n    /// to avoid extra memory allocation.\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getPayloadFromMemory(bytes memory versionedPayload) internal view returns (bytes memory payload) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__PayloadTooShort(versionedPayload);\n        }\n        // Figure how many bytes to copy and allocate the memory for the extracted payload.\n        uint256 toCopy;\n        unchecked {\n            toCopy = versionedPayload.length - VERSION_LENGTH;\n        }\n        payload = new bytes(toCopy);\n        // Use identity precompile (0x04) to copy the payload. Unlike MCOPY, this is available on all EVM chains.\n        bool res;\n        assembly {\n            // We add 0x20 to skip the length of the bytes array.\n            // We add 0x02 to skip the 2 bytes reserved for the version.\n            // Copy the payload to the previously allocated memory.\n            res := staticcall(gas(), 0x04, add(versionedPayload, 0x22), toCopy, add(payload, 0x20), toCopy)\n        }\n        if (!res) {\n            revert VersionedPayload__PrecompileFailed();\n        }\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant OPTIONS_V1 = 1;\n\n    error OptionsLib__VersionInvalid(uint16 version);\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal view returns (OptionsV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__VersionInvalid(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (OptionsV1));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(OPTIONS_V1, abi.encode(options));\n    }\n}\n\n// contracts/mocks/OptionsLibExport.sol\n\ncontract OptionsLibMocks {\n    function decodeOptions(bytes memory data) external view returns (OptionsV1 memory) {\n        return OptionsLib.decodeOptionsV1(data);\n    }\n\n    function encodeOptions(OptionsV1 memory options) external pure returns (bytes memory) {\n        return OptionsLib.encodeOptionsV1(options);\n    }\n\n    function addressToBytes32(address convertable) external pure returns (bytes32) {\n        return TypeCasts.addressToBytes32(convertable);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"494:3792:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;494:3792:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"494:3792:0:-:0;;;;;;;;","abiDefinition":[{"inputs":[{"internalType":"bytes","name":"versionedPayload","type":"bytes"}],"name":"VersionedPayload__PayloadTooShort","type":"error"},{"inputs":[],"name":"VersionedPayload__PrecompileFailed","type":"error"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"versionedPayload\",\"type\":\"bytes\"}],\"name\":\"VersionedPayload__PayloadTooShort\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VersionedPayload__PrecompileFailed\",\"type\":\"error\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/OptionsLibExport.sol\":\"VersionedPayloadLib\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/OptionsLibExport.sol\":{\"keccak256\":\"0xb8859b9712fe340d8a18347b081befc45a9c750cf6650a9f5ba9302ec63c89bb\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://03b5e8b8530eeea95fa309166d46288516a8d09b587cea03b76eba74014010bf\",\"dweb:/ipfs/QmRgpmpqSmYNPheFFknvdiVk6d3prvtTvVfQqx7gRYi9mx\"]}},\"version\":1}"},"hashes":{}}}