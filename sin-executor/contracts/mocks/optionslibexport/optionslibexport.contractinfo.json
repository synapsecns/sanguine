{"solidity/OptionsLibExport.sol:OptionsLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220ceddc9626cd1aaef2a9f48baf87743ae318709c51b5ebbb8061b9804b9b53c6164736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220ceddc9626cd1aaef2a9f48baf87743ae318709c51b5ebbb8061b9804b9b53c6164736f6c63430008140033","info":{"source":"pragma solidity =0.8.20 ^0.8.0 ^0.8.13;\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/VersionedPayload.sol\n\n// solhint-disable no-inline-assembly\n// solhint-disable ordering\nlibrary VersionedPayloadLib {\n    /// @notice Amount of bytes reserved for the version (uint16) in the versioned payload\n    uint256 internal constant VERSION_LENGTH = 2;\n\n    error VersionedPayload__TooShort(bytes versionedPayload);\n    error VersionedPayload__PrecompileFailed();\n\n    /// @notice Encodes the versioned payload into a single bytes array.\n    /// @param version  The payload's version.\n    /// @param payload  The payload to encode.\n    function encodeVersionedPayload(uint16 version, bytes memory payload) internal pure returns (bytes memory) {\n        return abi.encodePacked(version, payload);\n    }\n\n    /// @notice Extracts the version from the versioned payload (calldata reference).\n    /// @param versionedPayload     The versioned payload (calldata reference).\n    function getVersion(bytes calldata versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            version := shr(240, calldataload(versionedPayload.offset))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (calldata reference).\n    /// @dev The extracted payload is also returned as a calldata reference.\n    /// @param versionedPayload     The versioned payload.\n    function getPayload(bytes calldata versionedPayload) internal pure returns (bytes calldata) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        return versionedPayload[VERSION_LENGTH:];\n    }\n\n    /// @notice Extracts the version from the versioned payload (memory reference).\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getVersionFromMemory(bytes memory versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            // We add 0x20 to skip the length of the bytes array.\n            version := shr(240, mload(add(versionedPayload, 0x20)))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (memory reference).\n    /// @dev The extracted payload is copied into a new memory location. Use `getPayload` when possible\n    /// to avoid extra memory allocation.\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getPayloadFromMemory(bytes memory versionedPayload) internal view returns (bytes memory payload) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        // Figure how many bytes to copy and allocate the memory for the extracted payload.\n        uint256 toCopy;\n        unchecked {\n            toCopy = versionedPayload.length - VERSION_LENGTH;\n        }\n        payload = new bytes(toCopy);\n        // Use identity precompile (0x04) to copy the payload. Unlike MCOPY, this is available on all EVM chains.\n        bool res;\n        assembly {\n            // We add 0x20 to skip the length of the bytes array.\n            // We add 0x02 to skip the 2 bytes reserved for the version.\n            // Copy the payload to the previously allocated memory.\n            res := staticcall(gas(), 0x04, add(versionedPayload, 0x22), toCopy, add(payload, 0x20), toCopy)\n        }\n        if (!res) {\n            revert VersionedPayload__PrecompileFailed();\n        }\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal view returns (OptionsV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (OptionsV1));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(OPTIONS_V1, abi.encode(options));\n    }\n}\n\n// contracts/mocks/OptionsLibExport.sol\n\ncontract OptionsLibMocks {\n    function encodeOptions(OptionsV1 memory options) public view returns (bytes memory) {\n        return OptionsLib.encodeOptionsV1(options);\n    }\n\n    function decodeOptions(bytes memory data) public view returns (OptionsV1 memory) {\n        return OptionsLib.decodeOptionsV1(data);\n    }\n\n    function addressToBytes32(address convertable) public view returns (bytes32) {\n        return TypeCasts.addressToBytes32(convertable);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"4738:1233:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;4738:1233:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"4738:1233:0:-:0;;;;;;;;","abiDefinition":[{"inputs":[{"internalType":"uint16","name":"version","type":"uint16"}],"name":"OptionsLib__IncorrectVersion","type":"error"}],"userDoc":{"kind":"user","methods":{},"notice":"A library for encoding and decoding Interchain options related to interchain messages.","version":1},"developerDoc":{"kind":"dev","methods":{},"title":"OptionsLib","version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"version\",\"type\":\"uint16\"}],\"name\":\"OptionsLib__IncorrectVersion\",\"type\":\"error\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"title\":\"OptionsLib\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"A library for encoding and decoding Interchain options related to interchain messages.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/OptionsLibExport.sol\":\"OptionsLib\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/OptionsLibExport.sol\":{\"keccak256\":\"0x4ce8e3db7bd6012066c69b2789cc045ff8633da199b576f9e1b6e6bf2801e39c\",\"urls\":[\"bzz-raw://3254d79e9717f010a0e672934fa720e8e2a21951f08ac3c30ee95a4bef05ced3\",\"dweb:/ipfs/QmNbxZoEWCwrxqfV8r7RfkheH6d34DpE8KuDh3Tgqp1XvN\"]}},\"version\":1}"},"hashes":{}},"solidity/OptionsLibExport.sol:OptionsLibMocks":{"code":"0x608060405234801561001057600080fd5b506105f6806100206000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c806382c947b714610046578063c551274c1461006c578063d5e788a01461008c575b600080fd5b61005961005436600461033f565b6100ba565b6040519081526020015b60405180910390f35b61007f61007a3660046103cd565b6100da565b6040516100639190610423565b61009f61009a366004610474565b6100e5565b60408051825181526020928301519281019290925201610063565b600073ffffffffffffffffffffffffffffffffffffffff82165b92915050565b60606100d482610102565b60408051808201909152600080825260208201526100d482610140565b60606100d460018360405160200161012c9190815181526020918201519181019190915260400190565b6040516020818303038152906040526101ce565b6040805180820190915260008082526020820152600061015f836101fa565b9050600161ffff821610156101ab576040517fb94fa72500000000000000000000000000000000000000000000000000000000815261ffff821660048201526024015b60405180910390fd5b6101b483610245565b8060200190518101906101c79190610543565b9392505050565b606082826040516020016101e3929190610575565b604051602081830303815290604052905092915050565b600060028251101561023a57816040517f659cf9fa0000000000000000000000000000000000000000000000000000000081526004016101a29190610423565b506020015160f01c90565b606060028251101561028557816040517f659cf9fa0000000000000000000000000000000000000000000000000000000081526004016101a29190610423565b81517ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe018067ffffffffffffffff8111156102c2576102c2610375565b6040519080825280601f01601f1916602001820160405280156102ec576020820181803683370190505b50915060008160208401836022870160045afa905080610338576040517f101e44fa00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5050919050565b60006020828403121561035157600080fd5b813573ffffffffffffffffffffffffffffffffffffffff811681146101c757600080fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040805190810167ffffffffffffffff811182821017156103c7576103c7610375565b60405290565b6000604082840312156103df57600080fd5b6103e76103a4565b82358152602083013560208201528091505092915050565b60005b8381101561041a578181015183820152602001610402565b50506000910152565b60208152600082518060208401526104428160408501602087016103ff565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169190910160400192915050565b60006020828403121561048657600080fd5b813567ffffffffffffffff8082111561049e57600080fd5b818401915084601f8301126104b257600080fd5b8135818111156104c4576104c4610375565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f0116810190838211818310171561050a5761050a610375565b8160405282815287602084870101111561052357600080fd5b826020860160208301376000928101602001929092525095945050505050565b60006040828403121561055557600080fd5b61055d6103a4565b82518152602083015160208201528091505092915050565b7fffff0000000000000000000000000000000000000000000000000000000000008360f01b168152600082516105b28160028501602087016103ff565b91909101600201939250505056fea26469706673582212202762f5810d1af93b5a8bc5d619102d7981ab2d211e9233305b7d1835cf5476d564736f6c63430008140033","runtime-code":"0x608060405234801561001057600080fd5b50600436106100415760003560e01c806382c947b714610046578063c551274c1461006c578063d5e788a01461008c575b600080fd5b61005961005436600461033f565b6100ba565b6040519081526020015b60405180910390f35b61007f61007a3660046103cd565b6100da565b6040516100639190610423565b61009f61009a366004610474565b6100e5565b60408051825181526020928301519281019290925201610063565b600073ffffffffffffffffffffffffffffffffffffffff82165b92915050565b60606100d482610102565b60408051808201909152600080825260208201526100d482610140565b60606100d460018360405160200161012c9190815181526020918201519181019190915260400190565b6040516020818303038152906040526101ce565b6040805180820190915260008082526020820152600061015f836101fa565b9050600161ffff821610156101ab576040517fb94fa72500000000000000000000000000000000000000000000000000000000815261ffff821660048201526024015b60405180910390fd5b6101b483610245565b8060200190518101906101c79190610543565b9392505050565b606082826040516020016101e3929190610575565b604051602081830303815290604052905092915050565b600060028251101561023a57816040517f659cf9fa0000000000000000000000000000000000000000000000000000000081526004016101a29190610423565b506020015160f01c90565b606060028251101561028557816040517f659cf9fa0000000000000000000000000000000000000000000000000000000081526004016101a29190610423565b81517ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe018067ffffffffffffffff8111156102c2576102c2610375565b6040519080825280601f01601f1916602001820160405280156102ec576020820181803683370190505b50915060008160208401836022870160045afa905080610338576040517f101e44fa00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5050919050565b60006020828403121561035157600080fd5b813573ffffffffffffffffffffffffffffffffffffffff811681146101c757600080fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040805190810167ffffffffffffffff811182821017156103c7576103c7610375565b60405290565b6000604082840312156103df57600080fd5b6103e76103a4565b82358152602083013560208201528091505092915050565b60005b8381101561041a578181015183820152602001610402565b50506000910152565b60208152600082518060208401526104428160408501602087016103ff565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169190910160400192915050565b60006020828403121561048657600080fd5b813567ffffffffffffffff8082111561049e57600080fd5b818401915084601f8301126104b257600080fd5b8135818111156104c4576104c4610375565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f0116810190838211818310171561050a5761050a610375565b8160405282815287602084870101111561052357600080fd5b826020860160208301376000928101602001929092525095945050505050565b60006040828403121561055557600080fd5b61055d6103a4565b82518152602083015160208201528091505092915050565b7fffff0000000000000000000000000000000000000000000000000000000000008360f01b168152600082516105b28160028501602087016103ff565b91909101600201939250505056fea26469706673582212202762f5810d1af93b5a8bc5d619102d7981ab2d211e9233305b7d1835cf5476d564736f6c63430008140033","info":{"source":"pragma solidity =0.8.20 ^0.8.0 ^0.8.13;\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/VersionedPayload.sol\n\n// solhint-disable no-inline-assembly\n// solhint-disable ordering\nlibrary VersionedPayloadLib {\n    /// @notice Amount of bytes reserved for the version (uint16) in the versioned payload\n    uint256 internal constant VERSION_LENGTH = 2;\n\n    error VersionedPayload__TooShort(bytes versionedPayload);\n    error VersionedPayload__PrecompileFailed();\n\n    /// @notice Encodes the versioned payload into a single bytes array.\n    /// @param version  The payload's version.\n    /// @param payload  The payload to encode.\n    function encodeVersionedPayload(uint16 version, bytes memory payload) internal pure returns (bytes memory) {\n        return abi.encodePacked(version, payload);\n    }\n\n    /// @notice Extracts the version from the versioned payload (calldata reference).\n    /// @param versionedPayload     The versioned payload (calldata reference).\n    function getVersion(bytes calldata versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            version := shr(240, calldataload(versionedPayload.offset))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (calldata reference).\n    /// @dev The extracted payload is also returned as a calldata reference.\n    /// @param versionedPayload     The versioned payload.\n    function getPayload(bytes calldata versionedPayload) internal pure returns (bytes calldata) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        return versionedPayload[VERSION_LENGTH:];\n    }\n\n    /// @notice Extracts the version from the versioned payload (memory reference).\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getVersionFromMemory(bytes memory versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            // We add 0x20 to skip the length of the bytes array.\n            version := shr(240, mload(add(versionedPayload, 0x20)))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (memory reference).\n    /// @dev The extracted payload is copied into a new memory location. Use `getPayload` when possible\n    /// to avoid extra memory allocation.\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getPayloadFromMemory(bytes memory versionedPayload) internal view returns (bytes memory payload) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        // Figure how many bytes to copy and allocate the memory for the extracted payload.\n        uint256 toCopy;\n        unchecked {\n            toCopy = versionedPayload.length - VERSION_LENGTH;\n        }\n        payload = new bytes(toCopy);\n        // Use identity precompile (0x04) to copy the payload. Unlike MCOPY, this is available on all EVM chains.\n        bool res;\n        assembly {\n            // We add 0x20 to skip the length of the bytes array.\n            // We add 0x02 to skip the 2 bytes reserved for the version.\n            // Copy the payload to the previously allocated memory.\n            res := staticcall(gas(), 0x04, add(versionedPayload, 0x22), toCopy, add(payload, 0x20), toCopy)\n        }\n        if (!res) {\n            revert VersionedPayload__PrecompileFailed();\n        }\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal view returns (OptionsV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (OptionsV1));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(OPTIONS_V1, abi.encode(options));\n    }\n}\n\n// contracts/mocks/OptionsLibExport.sol\n\ncontract OptionsLibMocks {\n    function encodeOptions(OptionsV1 memory options) public view returns (bytes memory) {\n        return OptionsLib.encodeOptionsV1(options);\n    }\n\n    function decodeOptions(bytes memory data) public view returns (OptionsV1 memory) {\n        return OptionsLib.decodeOptionsV1(data);\n    }\n\n    function addressToBytes32(address convertable) public view returns (bytes32) {\n        return TypeCasts.addressToBytes32(convertable);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"6014:465:0:-:0;;;;;;;;;;;;;;;;;;;","srcMapRuntime":"6014:465:0:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;6337:140;;;;;;:::i;:::-;;:::i;:::-;;;474:25:1;;;462:2;447:18;6337:140:0;;;;;;;;6045:143;;;;;;:::i;:::-;;:::i;:::-;;;;;;;:::i;6194:137::-;;;;;;:::i;:::-;;:::i;:::-;;;;3208:13:1;;3190:32;;3278:4;3266:17;;;3260:24;3238:20;;;3231:54;;;;3163:18;6194:137:0;2992:299:1;6337:140:0;6405:7;195:22;;;6431:39;6424:46;6337:140;-1:-1:-1;;6337:140:0:o;6045:143::-;6115:12;6146:35;6173:7;6146:26;:35::i;6194:137::-;-1:-1:-1;;;;;;;;;;;;;;;;;6292:32:0;6319:4;6292:26;:32::i;5782:187::-;5856:12;5887:75;4843:1;5953:7;5942:19;;;;;;;3208:13:1;;3190:32;;3278:4;3266:17;;;3260:24;3238:20;;;3231:54;;;;3178:2;3163:18;;2992:299;5942:19:0;;;;;;;;;;;;;5887:42;:75::i;5068:599::-;-1:-1:-1;;;;;;;;;;;;;;;;;5163:14:0;5180:27;:4;:25;:27::i;:::-;5163:44;-1:-1:-1;4843:1:0;5221:20;;;;5217:95;;;5264:37;;;;;3470:6:1;3458:19;;5264:37:0;;;3440:38:1;3413:18;;5264:37:0;;;;;;;;5217:95;5619:27;:4;:25;:27::i;:::-;5608:52;;;;;;;;;;;;:::i;:::-;5601:59;5068:599;-1:-1:-1;;;5068:599:0:o;916:165::-;1009:12;1057:7;1066;1040:34;;;;;;;;;:::i;:::-;;;;;;;;;;;;;1033:41;;916:165;;;;:::o;2354:496::-;2438:14;630:1;2468:16;:23;:40;2464:122;;;2558:16;2531:44;;;;;;;;;;;:::i;2464:122::-;-1:-1:-1;2827:4:0;2805:27;2799:34;2794:3;2790:44;;2354:496::o;3164:1053::-;3248:20;630:1;3284:16;:23;:40;3280:122;;;3374:16;3347:44;;;;;;;;;;;:::i;3280:122::-;3560:23;;:40;;;3630:17;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;3630:17:0;;3620:27;;3771:8;4107:6;4100:4;4091:7;4087:18;4079:6;4072:4;4054:16;4050:27;4044:4;4037:5;4026:88;4019:95;;4138:3;4133:78;;4164:36;;;;;;;;;;;;;;4133:78;3270:947;;3164:1053;;;:::o;14:309:1:-;73:6;126:2;114:9;105:7;101:23;97:32;94:52;;;142:1;139;132:12;94:52;181:9;168:23;231:42;224:5;220:54;213:5;210:65;200:93;;289:1;286;279:12;510:184;562:77;559:1;552:88;659:4;656:1;649:15;683:4;680:1;673:15;699:246;766:2;760:9;;;796:15;;841:18;826:34;;862:22;;;823:62;820:88;;;888:18;;:::i;:::-;924:2;917:22;699:246;:::o;950:339::-;1035:6;1088:2;1076:9;1067:7;1063:23;1059:32;1056:52;;;1104:1;1101;1094:12;1056:52;1130:17;;:::i;:::-;1183:9;1170:23;1163:5;1156:38;1254:2;1243:9;1239:18;1226:32;1221:2;1214:5;1210:14;1203:56;1278:5;1268:15;;;950:339;;;;:::o;1294:250::-;1379:1;1389:113;1403:6;1400:1;1397:13;1389:113;;;1479:11;;;1473:18;1460:11;;;1453:39;1425:2;1418:10;1389:113;;;-1:-1:-1;;1536:1:1;1518:16;;1511:27;1294:250::o;1549:453::-;1696:2;1685:9;1678:21;1659:4;1728:6;1722:13;1771:6;1766:2;1755:9;1751:18;1744:34;1787:79;1859:6;1854:2;1843:9;1839:18;1834:2;1826:6;1822:15;1787:79;:::i;:::-;1918:2;1906:15;1923:66;1902:88;1887:104;;;;1993:2;1883:113;;1549:453;-1:-1:-1;;1549:453:1:o;2007:980::-;2075:6;2128:2;2116:9;2107:7;2103:23;2099:32;2096:52;;;2144:1;2141;2134:12;2096:52;2184:9;2171:23;2213:18;2254:2;2246:6;2243:14;2240:34;;;2270:1;2267;2260:12;2240:34;2308:6;2297:9;2293:22;2283:32;;2353:7;2346:4;2342:2;2338:13;2334:27;2324:55;;2375:1;2372;2365:12;2324:55;2411:2;2398:16;2433:2;2429;2426:10;2423:36;;;2439:18;;:::i;:::-;2573:2;2567:9;2635:4;2627:13;;2478:66;2623:22;;;2647:2;2619:31;2615:40;2603:53;;;2671:18;;;2691:22;;;2668:46;2665:72;;;2717:18;;:::i;:::-;2757:10;2753:2;2746:22;2792:2;2784:6;2777:18;2832:7;2827:2;2822;2818;2814:11;2810:20;2807:33;2804:53;;;2853:1;2850;2843:12;2804:53;2909:2;2904;2900;2896:11;2891:2;2883:6;2879:15;2866:46;2954:1;2932:15;;;2949:2;2928:24;2921:35;;;;-1:-1:-1;2936:6:1;2007:980;-1:-1:-1;;;;;2007:980:1:o;3489:336::-;3585:6;3638:2;3626:9;3617:7;3613:23;3609:32;3606:52;;;3654:1;3651;3644:12;3606:52;3680:17;;:::i;:::-;3726:9;3720:16;3713:5;3706:31;3790:2;3779:9;3775:18;3769:25;3764:2;3757:5;3753:14;3746:49;3814:5;3804:15;;;3489:336;;;;:::o;3830:440::-;4037:66;4028:6;4023:3;4019:16;4015:89;4010:3;4003:102;3985:3;4134:6;4128:13;4150:74;4217:6;4213:1;4208:3;4204:11;4197:4;4189:6;4185:17;4150:74;:::i;:::-;4244:16;;;;4262:1;4240:24;;3830:440;-1:-1:-1;;;3830:440:1:o","abiDefinition":[{"inputs":[{"internalType":"uint16","name":"version","type":"uint16"}],"name":"OptionsLib__IncorrectVersion","type":"error"},{"inputs":[],"name":"VersionedPayload__PrecompileFailed","type":"error"},{"inputs":[{"internalType":"bytes","name":"versionedPayload","type":"bytes"}],"name":"VersionedPayload__TooShort","type":"error"},{"inputs":[{"internalType":"address","name":"convertable","type":"address"}],"name":"addressToBytes32","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes","name":"data","type":"bytes"}],"name":"decodeOptions","outputs":[{"components":[{"internalType":"uint256","name":"gasLimit","type":"uint256"},{"internalType":"uint256","name":"gasAirdrop","type":"uint256"}],"internalType":"struct OptionsV1","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[{"components":[{"internalType":"uint256","name":"gasLimit","type":"uint256"},{"internalType":"uint256","name":"gasAirdrop","type":"uint256"}],"internalType":"struct OptionsV1","name":"options","type":"tuple"}],"name":"encodeOptions","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"view","type":"function"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"version\",\"type\":\"uint16\"}],\"name\":\"OptionsLib__IncorrectVersion\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VersionedPayload__PrecompileFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"versionedPayload\",\"type\":\"bytes\"}],\"name\":\"VersionedPayload__TooShort\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"convertable\",\"type\":\"address\"}],\"name\":\"addressToBytes32\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"decodeOptions\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasAirdrop\",\"type\":\"uint256\"}],\"internalType\":\"struct OptionsV1\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasAirdrop\",\"type\":\"uint256\"}],\"internalType\":\"struct OptionsV1\",\"name\":\"options\",\"type\":\"tuple\"}],\"name\":\"encodeOptions\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/OptionsLibExport.sol\":\"OptionsLibMocks\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/OptionsLibExport.sol\":{\"keccak256\":\"0x4ce8e3db7bd6012066c69b2789cc045ff8633da199b576f9e1b6e6bf2801e39c\",\"urls\":[\"bzz-raw://3254d79e9717f010a0e672934fa720e8e2a21951f08ac3c30ee95a4bef05ced3\",\"dweb:/ipfs/QmNbxZoEWCwrxqfV8r7RfkheH6d34DpE8KuDh3Tgqp1XvN\"]}},\"version\":1}"},"hashes":{"addressToBytes32(address)":"82c947b7","decodeOptions(bytes)":"d5e788a0","encodeOptions((uint256,uint256))":"c551274c"}},"solidity/OptionsLibExport.sol:TypeCasts":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122011d41019079fd2883971fb523eac68f79dca9f5c9b1399e1d9ed07a58f02900864736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122011d41019079fd2883971fb523eac68f79dca9f5c9b1399e1d9ed07a58f02900864736f6c63430008140033","info":{"source":"pragma solidity =0.8.20 ^0.8.0 ^0.8.13;\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/VersionedPayload.sol\n\n// solhint-disable no-inline-assembly\n// solhint-disable ordering\nlibrary VersionedPayloadLib {\n    /// @notice Amount of bytes reserved for the version (uint16) in the versioned payload\n    uint256 internal constant VERSION_LENGTH = 2;\n\n    error VersionedPayload__TooShort(bytes versionedPayload);\n    error VersionedPayload__PrecompileFailed();\n\n    /// @notice Encodes the versioned payload into a single bytes array.\n    /// @param version  The payload's version.\n    /// @param payload  The payload to encode.\n    function encodeVersionedPayload(uint16 version, bytes memory payload) internal pure returns (bytes memory) {\n        return abi.encodePacked(version, payload);\n    }\n\n    /// @notice Extracts the version from the versioned payload (calldata reference).\n    /// @param versionedPayload     The versioned payload (calldata reference).\n    function getVersion(bytes calldata versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            version := shr(240, calldataload(versionedPayload.offset))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (calldata reference).\n    /// @dev The extracted payload is also returned as a calldata reference.\n    /// @param versionedPayload     The versioned payload.\n    function getPayload(bytes calldata versionedPayload) internal pure returns (bytes calldata) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        return versionedPayload[VERSION_LENGTH:];\n    }\n\n    /// @notice Extracts the version from the versioned payload (memory reference).\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getVersionFromMemory(bytes memory versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            // We add 0x20 to skip the length of the bytes array.\n            version := shr(240, mload(add(versionedPayload, 0x20)))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (memory reference).\n    /// @dev The extracted payload is copied into a new memory location. Use `getPayload` when possible\n    /// to avoid extra memory allocation.\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getPayloadFromMemory(bytes memory versionedPayload) internal view returns (bytes memory payload) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        // Figure how many bytes to copy and allocate the memory for the extracted payload.\n        uint256 toCopy;\n        unchecked {\n            toCopy = versionedPayload.length - VERSION_LENGTH;\n        }\n        payload = new bytes(toCopy);\n        // Use identity precompile (0x04) to copy the payload. Unlike MCOPY, this is available on all EVM chains.\n        bool res;\n        assembly {\n            // We add 0x20 to skip the length of the bytes array.\n            // We add 0x02 to skip the 2 bytes reserved for the version.\n            // Copy the payload to the previously allocated memory.\n            res := staticcall(gas(), 0x04, add(versionedPayload, 0x22), toCopy, add(payload, 0x20), toCopy)\n        }\n        if (!res) {\n            revert VersionedPayload__PrecompileFailed();\n        }\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal view returns (OptionsV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (OptionsV1));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(OPTIONS_V1, abi.encode(options));\n    }\n}\n\n// contracts/mocks/OptionsLibExport.sol\n\ncontract OptionsLibMocks {\n    function encodeOptions(OptionsV1 memory options) public view returns (bytes memory) {\n        return OptionsLib.encodeOptionsV1(options);\n    }\n\n    function decodeOptions(bytes memory data) public view returns (OptionsV1 memory) {\n        return OptionsLib.decodeOptionsV1(data);\n    }\n\n    function addressToBytes32(address convertable) public view returns (bytes32) {\n        return TypeCasts.addressToBytes32(convertable);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"74:280:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;74:280:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"74:280:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/OptionsLibExport.sol\":\"TypeCasts\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/OptionsLibExport.sol\":{\"keccak256\":\"0x4ce8e3db7bd6012066c69b2789cc045ff8633da199b576f9e1b6e6bf2801e39c\",\"urls\":[\"bzz-raw://3254d79e9717f010a0e672934fa720e8e2a21951f08ac3c30ee95a4bef05ced3\",\"dweb:/ipfs/QmNbxZoEWCwrxqfV8r7RfkheH6d34DpE8KuDh3Tgqp1XvN\"]}},\"version\":1}"},"hashes":{}},"solidity/OptionsLibExport.sol:VersionedPayloadLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220ae80c771c0d9e0079ecd5caa5e51872a85f846823e5d2e7f0d81e2cc91e6665364736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220ae80c771c0d9e0079ecd5caa5e51872a85f846823e5d2e7f0d81e2cc91e6665364736f6c63430008140033","info":{"source":"pragma solidity =0.8.20 ^0.8.0 ^0.8.13;\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/VersionedPayload.sol\n\n// solhint-disable no-inline-assembly\n// solhint-disable ordering\nlibrary VersionedPayloadLib {\n    /// @notice Amount of bytes reserved for the version (uint16) in the versioned payload\n    uint256 internal constant VERSION_LENGTH = 2;\n\n    error VersionedPayload__TooShort(bytes versionedPayload);\n    error VersionedPayload__PrecompileFailed();\n\n    /// @notice Encodes the versioned payload into a single bytes array.\n    /// @param version  The payload's version.\n    /// @param payload  The payload to encode.\n    function encodeVersionedPayload(uint16 version, bytes memory payload) internal pure returns (bytes memory) {\n        return abi.encodePacked(version, payload);\n    }\n\n    /// @notice Extracts the version from the versioned payload (calldata reference).\n    /// @param versionedPayload     The versioned payload (calldata reference).\n    function getVersion(bytes calldata versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            version := shr(240, calldataload(versionedPayload.offset))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (calldata reference).\n    /// @dev The extracted payload is also returned as a calldata reference.\n    /// @param versionedPayload     The versioned payload.\n    function getPayload(bytes calldata versionedPayload) internal pure returns (bytes calldata) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        return versionedPayload[VERSION_LENGTH:];\n    }\n\n    /// @notice Extracts the version from the versioned payload (memory reference).\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getVersionFromMemory(bytes memory versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            // We add 0x20 to skip the length of the bytes array.\n            version := shr(240, mload(add(versionedPayload, 0x20)))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (memory reference).\n    /// @dev The extracted payload is copied into a new memory location. Use `getPayload` when possible\n    /// to avoid extra memory allocation.\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getPayloadFromMemory(bytes memory versionedPayload) internal view returns (bytes memory payload) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        // Figure how many bytes to copy and allocate the memory for the extracted payload.\n        uint256 toCopy;\n        unchecked {\n            toCopy = versionedPayload.length - VERSION_LENGTH;\n        }\n        payload = new bytes(toCopy);\n        // Use identity precompile (0x04) to copy the payload. Unlike MCOPY, this is available on all EVM chains.\n        bool res;\n        assembly {\n            // We add 0x20 to skip the length of the bytes array.\n            // We add 0x02 to skip the 2 bytes reserved for the version.\n            // Copy the payload to the previously allocated memory.\n            res := staticcall(gas(), 0x04, add(versionedPayload, 0x22), toCopy, add(payload, 0x20), toCopy)\n        }\n        if (!res) {\n            revert VersionedPayload__PrecompileFailed();\n        }\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal view returns (OptionsV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (OptionsV1));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(OPTIONS_V1, abi.encode(options));\n    }\n}\n\n// contracts/mocks/OptionsLibExport.sol\n\ncontract OptionsLibMocks {\n    function encodeOptions(OptionsV1 memory options) public view returns (bytes memory) {\n        return OptionsLib.encodeOptionsV1(options);\n    }\n\n    function decodeOptions(bytes memory data) public view returns (OptionsV1 memory) {\n        return OptionsLib.decodeOptionsV1(data);\n    }\n\n    function addressToBytes32(address convertable) public view returns (bytes32) {\n        return TypeCasts.addressToBytes32(convertable);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"462:3757:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;462:3757:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"462:3757:0:-:0;;;;;;;;","abiDefinition":[{"inputs":[],"name":"VersionedPayload__PrecompileFailed","type":"error"},{"inputs":[{"internalType":"bytes","name":"versionedPayload","type":"bytes"}],"name":"VersionedPayload__TooShort","type":"error"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"VersionedPayload__PrecompileFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"versionedPayload\",\"type\":\"bytes\"}],\"name\":\"VersionedPayload__TooShort\",\"type\":\"error\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/OptionsLibExport.sol\":\"VersionedPayloadLib\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/OptionsLibExport.sol\":{\"keccak256\":\"0x4ce8e3db7bd6012066c69b2789cc045ff8633da199b576f9e1b6e6bf2801e39c\",\"urls\":[\"bzz-raw://3254d79e9717f010a0e672934fa720e8e2a21951f08ac3c30ee95a4bef05ced3\",\"dweb:/ipfs/QmNbxZoEWCwrxqfV8r7RfkheH6d34DpE8KuDh3Tgqp1XvN\"]}},\"version\":1}"},"hashes":{}}}