{"solidity/InterchainModuleMock.sol:IInterchainDB":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0;\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the entry on the source chain\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint256 srcChainId;\n    uint256 dbNonce;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint256 dbNonce,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            dbNonce: dbNonce,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce));\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing an entry from the local Interchain DataBase.\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    struct LocalEntry {\n        address writer;\n        bytes32 dataHash;\n    }\n\n    /// @notice Struct representing an entry from the remote Interchain DataBase verified by the Interchain Module\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param entryValue   The value of the entry: writer + dataHash hashed together\n    struct RemoteEntry {\n        uint256 verifiedAt;\n        bytes32 entryValue;\n    }\n\n    error InterchainDB__ConflictingEntries(bytes32 existingEntryValue, InterchainEntry newEntry);\n    error InterchainDB__EntryDoesNotExist(uint256 dbNonce);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId();\n\n    /// @notice Write data to the Interchain DataBase as a new entry.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `verifyEntry` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the written entry on this chain\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce);\n\n    /// @notice Request the given Interchain Modules to verify the already written entry on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any entry.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param destChainId   The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the written entry on this chain\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestVerification(uint256 destChainId, uint256 dbNonce, address[] memory srcModules) external payable;\n\n    /// @notice Write data to the Interchain DataBase,\n    /// and request the given Interchain Modules to verify it on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: additional verification for the same entry could be later done using `requestVerification`\n    /// by providing the returned `dbNonce`.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the written entry on this chain\n    function writeEntryWithVerification(\n        uint256 destChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 dbNonce);\n\n    /// @notice Allows the Interchain Module to verify the entry coming from a remote source chain.\n    /// @param entry        The Interchain Entry to confirm\n    function verifyEntry(InterchainEntry memory entry) external;\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 destChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Get the Interchain Entry by the writer and the writer nonce.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param dbNonce      The database nonce of the written entry on this chain\n    function getEntry(uint256 dbNonce) external view returns (InterchainEntry memory);\n\n    /// @notice Get the nonce of the database.\n    function getDBNonce() external view returns (uint256);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or zero if the module has not verified the entry.\n    function readEntry(\n        address dstModule,\n        InterchainEntry memory entry\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\n// contracts/interfaces/IInterchainModule.sol\n\n/// @notice Every Module may opt a different method to confirm the verified entries on destination chain,\n/// therefore this is not a part of a common interface.\ninterface IInterchainModule {\n    error InterchainModule__NotInterchainDB();\n    error InterchainModule__IncorrectSourceChainId(uint256 chainId);\n    error InterchainModule__InsufficientFee(uint256 actual, uint256 required);\n    error InterchainModule__SameChainId();\n\n    /// @notice Request the verification of an entry in the Interchain DataBase by the module.\n    /// Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`.\n    /// Note: this will eventually trigger `InterchainDB.verifyEntry(entry)` function on destination chain,\n    /// with no guarantee of ordering.\n    /// @dev Could be only called by the Interchain DataBase contract.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param entry        The entry to verify\n    function requestVerification(uint256 destChainId, InterchainEntry memory entry) external payable;\n\n    /// @notice Get the Module fee for verifying an entry on the specified destination chain\n    /// @param destChainId  The chain id of the destination chain\n    function getModuleFee(uint256 destChainId) external view returns (uint256);\n}\n\n// test/mocks/InterchainModuleMock.sol\n\ncontract InterchainModuleMock is IInterchainModule {\n    function requestVerification(uint256 destChainId, InterchainEntry memory entry) external payable {}\n\n    function getModuleFee(uint256 destChainId) external view returns (uint256) {}\n\n    function mockVerifyEntry(address interchainDB, InterchainEntry memory entry) external {\n        IInterchainDB(interchainDB).verifyEntry(entry);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"bytes32","name":"existingEntryValue","type":"bytes32"},{"components":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"bytes32","name":"srcWriter","type":"bytes32"},{"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"internalType":"struct InterchainEntry","name":"newEntry","type":"tuple"}],"name":"InterchainDB__ConflictingEntries","type":"error"},{"inputs":[{"internalType":"uint256","name":"dbNonce","type":"uint256"}],"name":"InterchainDB__EntryDoesNotExist","type":"error"},{"inputs":[{"internalType":"uint256","name":"actualFee","type":"uint256"},{"internalType":"uint256","name":"expectedFee","type":"uint256"}],"name":"InterchainDB__IncorrectFeeAmount","type":"error"},{"inputs":[],"name":"InterchainDB__NoModulesSpecified","type":"error"},{"inputs":[],"name":"InterchainDB__SameChainId","type":"error"},{"inputs":[],"name":"getDBNonce","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"dbNonce","type":"uint256"}],"name":"getEntry","outputs":[{"components":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"bytes32","name":"srcWriter","type":"bytes32"},{"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"internalType":"struct InterchainEntry","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"destChainId","type":"uint256"},{"internalType":"address[]","name":"srcModules","type":"address[]"}],"name":"getInterchainFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"dstModule","type":"address"},{"components":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"bytes32","name":"srcWriter","type":"bytes32"},{"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"internalType":"struct InterchainEntry","name":"entry","type":"tuple"}],"name":"readEntry","outputs":[{"internalType":"uint256","name":"moduleVerifiedAt","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"destChainId","type":"uint256"},{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"address[]","name":"srcModules","type":"address[]"}],"name":"requestVerification","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"components":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"bytes32","name":"srcWriter","type":"bytes32"},{"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"internalType":"struct InterchainEntry","name":"entry","type":"tuple"}],"name":"verifyEntry","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"name":"writeEntry","outputs":[{"internalType":"uint256","name":"dbNonce","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"destChainId","type":"uint256"},{"internalType":"bytes32","name":"dataHash","type":"bytes32"},{"internalType":"address[]","name":"srcModules","type":"address[]"}],"name":"writeEntryWithVerification","outputs":[{"internalType":"uint256","name":"dbNonce","type":"uint256"}],"stateMutability":"payable","type":"function"}],"userDoc":{"kind":"user","methods":{"getDBNonce()":{"notice":"Get the nonce of the database."},"getEntry(uint256)":{"notice":"Get the Interchain Entry by the writer and the writer nonce."},"getInterchainFee(uint256,address[])":{"notice":"Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain using the provided Interchain Modules."},"readEntry(address,(uint256,uint256,bytes32,bytes32))":{"notice":"Read the data written on specific source chain by a specific writer, and verify it on the destination chain using the provided Interchain Module. Note: returned zero value indicates that the module has not verified the entry."},"requestVerification(uint256,uint256,address[])":{"notice":"Request the given Interchain Modules to verify the already written entry on the destination chain. Note: every module has a separate fee paid in the native gas token of the source chain, and `msg.value` must be equal to the sum of all fees. Note: this method is permissionless, and anyone can request verification for any entry."},"verifyEntry((uint256,uint256,bytes32,bytes32))":{"notice":"Allows the Interchain Module to verify the entry coming from a remote source chain."},"writeEntry(bytes32)":{"notice":"Write data to the Interchain DataBase as a new entry. Note: there are no guarantees that this entry will be available for reading on any of the remote chains. Use `verifyEntry` to ensure that the entry is available for reading on the destination chain."},"writeEntryWithVerification(uint256,bytes32,address[])":{"notice":"Write data to the Interchain DataBase, and request the given Interchain Modules to verify it on the destination chain. Note: every module has a separate fee paid in the native gas token of the source chain, and `msg.value` must be equal to the sum of all fees. Note: additional verification for the same entry could be later done using `requestVerification` by providing the returned `dbNonce`."}},"version":1},"developerDoc":{"kind":"dev","methods":{"getEntry(uint256)":{"details":"Will revert if the entry with the given nonce does not exist.","params":{"dbNonce":"The database nonce of the written entry on this chain"}},"getInterchainFee(uint256,address[])":{"details":"Will revert if the empty array of modules is provided.","params":{"destChainId":"The chain id of the destination chain","srcModules":"The source chain addresses of the Interchain Modules to use for verification"}},"readEntry(address,(uint256,uint256,bytes32,bytes32))":{"params":{"dstModule":"The destination chain addresses of the Interchain Modules to use for verification","entry":"The Interchain Entry to read"},"returns":{"moduleVerifiedAt":"  The block timestamp at which the entry was verified by the module,                             or zero if the module has not verified the entry."}},"requestVerification(uint256,uint256,address[])":{"details":"Will revert if the entry with the given nonce does not exist.","params":{"dbNonce":"The database nonce of the written entry on this chain","destChainId":"The chain id of the destination chain","srcModules":"The source chain addresses of the Interchain Modules to use for verification"}},"verifyEntry((uint256,uint256,bytes32,bytes32))":{"params":{"entry":"The Interchain Entry to confirm"}},"writeEntry(bytes32)":{"params":{"dataHash":"The hash of the data to be written to the Interchain DataBase as a new entry"},"returns":{"dbNonce":"    The database nonce of the written entry on this chain"}},"writeEntryWithVerification(uint256,bytes32,address[])":{"details":"Will revert if the empty array of modules is provided.","params":{"dataHash":"The hash of the data to be written to the Interchain DataBase as a new entry","destChainId":"The chain id of the destination chain","srcModules":"The source chain addresses of the Interchain Modules to use for verification"},"returns":{"dbNonce":"    The database nonce of the written entry on this chain"}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"existingEntryValue\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"srcWriter\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"internalType\":\"struct InterchainEntry\",\"name\":\"newEntry\",\"type\":\"tuple\"}],\"name\":\"InterchainDB__ConflictingEntries\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"}],\"name\":\"InterchainDB__EntryDoesNotExist\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"actualFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expectedFee\",\"type\":\"uint256\"}],\"name\":\"InterchainDB__IncorrectFeeAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InterchainDB__NoModulesSpecified\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InterchainDB__SameChainId\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"getDBNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"}],\"name\":\"getEntry\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"srcWriter\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"internalType\":\"struct InterchainEntry\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"destChainId\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"}],\"name\":\"getInterchainFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dstModule\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"srcWriter\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"internalType\":\"struct InterchainEntry\",\"name\":\"entry\",\"type\":\"tuple\"}],\"name\":\"readEntry\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"moduleVerifiedAt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"destChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"}],\"name\":\"requestVerification\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"srcWriter\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"internalType\":\"struct InterchainEntry\",\"name\":\"entry\",\"type\":\"tuple\"}],\"name\":\"verifyEntry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"name\":\"writeEntry\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"destChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"}],\"name\":\"writeEntryWithVerification\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"getEntry(uint256)\":{\"details\":\"Will revert if the entry with the given nonce does not exist.\",\"params\":{\"dbNonce\":\"The database nonce of the written entry on this chain\"}},\"getInterchainFee(uint256,address[])\":{\"details\":\"Will revert if the empty array of modules is provided.\",\"params\":{\"destChainId\":\"The chain id of the destination chain\",\"srcModules\":\"The source chain addresses of the Interchain Modules to use for verification\"}},\"readEntry(address,(uint256,uint256,bytes32,bytes32))\":{\"params\":{\"dstModule\":\"The destination chain addresses of the Interchain Modules to use for verification\",\"entry\":\"The Interchain Entry to read\"},\"returns\":{\"moduleVerifiedAt\":\"  The block timestamp at which the entry was verified by the module,                             or zero if the module has not verified the entry.\"}},\"requestVerification(uint256,uint256,address[])\":{\"details\":\"Will revert if the entry with the given nonce does not exist.\",\"params\":{\"dbNonce\":\"The database nonce of the written entry on this chain\",\"destChainId\":\"The chain id of the destination chain\",\"srcModules\":\"The source chain addresses of the Interchain Modules to use for verification\"}},\"verifyEntry((uint256,uint256,bytes32,bytes32))\":{\"params\":{\"entry\":\"The Interchain Entry to confirm\"}},\"writeEntry(bytes32)\":{\"params\":{\"dataHash\":\"The hash of the data to be written to the Interchain DataBase as a new entry\"},\"returns\":{\"dbNonce\":\"    The database nonce of the written entry on this chain\"}},\"writeEntryWithVerification(uint256,bytes32,address[])\":{\"details\":\"Will revert if the empty array of modules is provided.\",\"params\":{\"dataHash\":\"The hash of the data to be written to the Interchain DataBase as a new entry\",\"destChainId\":\"The chain id of the destination chain\",\"srcModules\":\"The source chain addresses of the Interchain Modules to use for verification\"},\"returns\":{\"dbNonce\":\"    The database nonce of the written entry on this chain\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"getDBNonce()\":{\"notice\":\"Get the nonce of the database.\"},\"getEntry(uint256)\":{\"notice\":\"Get the Interchain Entry by the writer and the writer nonce.\"},\"getInterchainFee(uint256,address[])\":{\"notice\":\"Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain using the provided Interchain Modules.\"},\"readEntry(address,(uint256,uint256,bytes32,bytes32))\":{\"notice\":\"Read the data written on specific source chain by a specific writer, and verify it on the destination chain using the provided Interchain Module. Note: returned zero value indicates that the module has not verified the entry.\"},\"requestVerification(uint256,uint256,address[])\":{\"notice\":\"Request the given Interchain Modules to verify the already written entry on the destination chain. Note: every module has a separate fee paid in the native gas token of the source chain, and `msg.value` must be equal to the sum of all fees. Note: this method is permissionless, and anyone can request verification for any entry.\"},\"verifyEntry((uint256,uint256,bytes32,bytes32))\":{\"notice\":\"Allows the Interchain Module to verify the entry coming from a remote source chain.\"},\"writeEntry(bytes32)\":{\"notice\":\"Write data to the Interchain DataBase as a new entry. Note: there are no guarantees that this entry will be available for reading on any of the remote chains. Use `verifyEntry` to ensure that the entry is available for reading on the destination chain.\"},\"writeEntryWithVerification(uint256,bytes32,address[])\":{\"notice\":\"Write data to the Interchain DataBase, and request the given Interchain Modules to verify it on the destination chain. Note: every module has a separate fee paid in the native gas token of the source chain, and `msg.value` must be equal to the sum of all fees. Note: additional verification for the same entry could be later done using `requestVerification` by providing the returned `dbNonce`.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainModuleMock.sol\":\"IInterchainDB\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainModuleMock.sol\":{\"keccak256\":\"0x0ce1a1cc3d02118c1602316544734f33c7f7facbc689aaac219293dcf66bd5fe\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://3470d1c45573870049229ffe63deb4aab7df56ae242cf4bde445508e08a01f24\",\"dweb:/ipfs/QmbewvT5m3BtXzMpvtQfeRYJ6s4gRrSBfJJMEdDReZaeto\"]}},\"version\":1}"},"hashes":{"getDBNonce()":"f338140e","getEntry(uint256)":"bae78d7b","getInterchainFee(uint256,address[])":"fc7686ec","readEntry(address,(uint256,uint256,bytes32,bytes32))":"a9c9cff1","requestVerification(uint256,uint256,address[])":"81ab5b5a","verifyEntry((uint256,uint256,bytes32,bytes32))":"54941dfa","writeEntry(bytes32)":"2ad8c706","writeEntryWithVerification(uint256,bytes32,address[])":"67c769af"}},"solidity/InterchainModuleMock.sol:IInterchainModule":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0;\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the entry on the source chain\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint256 srcChainId;\n    uint256 dbNonce;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint256 dbNonce,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            dbNonce: dbNonce,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce));\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing an entry from the local Interchain DataBase.\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    struct LocalEntry {\n        address writer;\n        bytes32 dataHash;\n    }\n\n    /// @notice Struct representing an entry from the remote Interchain DataBase verified by the Interchain Module\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param entryValue   The value of the entry: writer + dataHash hashed together\n    struct RemoteEntry {\n        uint256 verifiedAt;\n        bytes32 entryValue;\n    }\n\n    error InterchainDB__ConflictingEntries(bytes32 existingEntryValue, InterchainEntry newEntry);\n    error InterchainDB__EntryDoesNotExist(uint256 dbNonce);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId();\n\n    /// @notice Write data to the Interchain DataBase as a new entry.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `verifyEntry` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the written entry on this chain\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce);\n\n    /// @notice Request the given Interchain Modules to verify the already written entry on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any entry.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param destChainId   The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the written entry on this chain\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestVerification(uint256 destChainId, uint256 dbNonce, address[] memory srcModules) external payable;\n\n    /// @notice Write data to the Interchain DataBase,\n    /// and request the given Interchain Modules to verify it on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: additional verification for the same entry could be later done using `requestVerification`\n    /// by providing the returned `dbNonce`.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the written entry on this chain\n    function writeEntryWithVerification(\n        uint256 destChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 dbNonce);\n\n    /// @notice Allows the Interchain Module to verify the entry coming from a remote source chain.\n    /// @param entry        The Interchain Entry to confirm\n    function verifyEntry(InterchainEntry memory entry) external;\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 destChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Get the Interchain Entry by the writer and the writer nonce.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param dbNonce      The database nonce of the written entry on this chain\n    function getEntry(uint256 dbNonce) external view returns (InterchainEntry memory);\n\n    /// @notice Get the nonce of the database.\n    function getDBNonce() external view returns (uint256);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or zero if the module has not verified the entry.\n    function readEntry(\n        address dstModule,\n        InterchainEntry memory entry\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\n// contracts/interfaces/IInterchainModule.sol\n\n/// @notice Every Module may opt a different method to confirm the verified entries on destination chain,\n/// therefore this is not a part of a common interface.\ninterface IInterchainModule {\n    error InterchainModule__NotInterchainDB();\n    error InterchainModule__IncorrectSourceChainId(uint256 chainId);\n    error InterchainModule__InsufficientFee(uint256 actual, uint256 required);\n    error InterchainModule__SameChainId();\n\n    /// @notice Request the verification of an entry in the Interchain DataBase by the module.\n    /// Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`.\n    /// Note: this will eventually trigger `InterchainDB.verifyEntry(entry)` function on destination chain,\n    /// with no guarantee of ordering.\n    /// @dev Could be only called by the Interchain DataBase contract.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param entry        The entry to verify\n    function requestVerification(uint256 destChainId, InterchainEntry memory entry) external payable;\n\n    /// @notice Get the Module fee for verifying an entry on the specified destination chain\n    /// @param destChainId  The chain id of the destination chain\n    function getModuleFee(uint256 destChainId) external view returns (uint256);\n}\n\n// test/mocks/InterchainModuleMock.sol\n\ncontract InterchainModuleMock is IInterchainModule {\n    function requestVerification(uint256 destChainId, InterchainEntry memory entry) external payable {}\n\n    function getModuleFee(uint256 destChainId) external view returns (uint256) {}\n\n    function mockVerifyEntry(address interchainDB, InterchainEntry memory entry) external {\n        IInterchainDB(interchainDB).verifyEntry(entry);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"}],"name":"InterchainModule__IncorrectSourceChainId","type":"error"},{"inputs":[{"internalType":"uint256","name":"actual","type":"uint256"},{"internalType":"uint256","name":"required","type":"uint256"}],"name":"InterchainModule__InsufficientFee","type":"error"},{"inputs":[],"name":"InterchainModule__NotInterchainDB","type":"error"},{"inputs":[],"name":"InterchainModule__SameChainId","type":"error"},{"inputs":[{"internalType":"uint256","name":"destChainId","type":"uint256"}],"name":"getModuleFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"destChainId","type":"uint256"},{"components":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"bytes32","name":"srcWriter","type":"bytes32"},{"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"internalType":"struct InterchainEntry","name":"entry","type":"tuple"}],"name":"requestVerification","outputs":[],"stateMutability":"payable","type":"function"}],"userDoc":{"kind":"user","methods":{"getModuleFee(uint256)":{"notice":"Get the Module fee for verifying an entry on the specified destination chain"},"requestVerification(uint256,(uint256,uint256,bytes32,bytes32))":{"notice":"Request the verification of an entry in the Interchain DataBase by the module. Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`. Note: this will eventually trigger `InterchainDB.verifyEntry(entry)` function on destination chain, with no guarantee of ordering."}},"notice":"Every Module may opt a different method to confirm the verified entries on destination chain, therefore this is not a part of a common interface.","version":1},"developerDoc":{"kind":"dev","methods":{"getModuleFee(uint256)":{"params":{"destChainId":"The chain id of the destination chain"}},"requestVerification(uint256,(uint256,uint256,bytes32,bytes32))":{"details":"Could be only called by the Interchain DataBase contract.","params":{"destChainId":"The chain id of the destination chain","entry":"The entry to verify"}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"InterchainModule__IncorrectSourceChainId\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"required\",\"type\":\"uint256\"}],\"name\":\"InterchainModule__InsufficientFee\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InterchainModule__NotInterchainDB\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InterchainModule__SameChainId\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"destChainId\",\"type\":\"uint256\"}],\"name\":\"getModuleFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"destChainId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"srcWriter\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"internalType\":\"struct InterchainEntry\",\"name\":\"entry\",\"type\":\"tuple\"}],\"name\":\"requestVerification\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"getModuleFee(uint256)\":{\"params\":{\"destChainId\":\"The chain id of the destination chain\"}},\"requestVerification(uint256,(uint256,uint256,bytes32,bytes32))\":{\"details\":\"Could be only called by the Interchain DataBase contract.\",\"params\":{\"destChainId\":\"The chain id of the destination chain\",\"entry\":\"The entry to verify\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"getModuleFee(uint256)\":{\"notice\":\"Get the Module fee for verifying an entry on the specified destination chain\"},\"requestVerification(uint256,(uint256,uint256,bytes32,bytes32))\":{\"notice\":\"Request the verification of an entry in the Interchain DataBase by the module. Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`. Note: this will eventually trigger `InterchainDB.verifyEntry(entry)` function on destination chain, with no guarantee of ordering.\"}},\"notice\":\"Every Module may opt a different method to confirm the verified entries on destination chain, therefore this is not a part of a common interface.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainModuleMock.sol\":\"IInterchainModule\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainModuleMock.sol\":{\"keccak256\":\"0x0ce1a1cc3d02118c1602316544734f33c7f7facbc689aaac219293dcf66bd5fe\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://3470d1c45573870049229ffe63deb4aab7df56ae242cf4bde445508e08a01f24\",\"dweb:/ipfs/QmbewvT5m3BtXzMpvtQfeRYJ6s4gRrSBfJJMEdDReZaeto\"]}},\"version\":1}"},"hashes":{"getModuleFee(uint256)":"dc8e4f89","requestVerification(uint256,(uint256,uint256,bytes32,bytes32))":"f6bc485f"}},"solidity/InterchainModuleMock.sol:InterchainEntryLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220c63d59eb3b04817f68e54479dde40afcdb8cedbced143addcb79af4492904b0964736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220c63d59eb3b04817f68e54479dde40afcdb8cedbced143addcb79af4492904b0964736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0;\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the entry on the source chain\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint256 srcChainId;\n    uint256 dbNonce;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint256 dbNonce,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            dbNonce: dbNonce,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce));\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing an entry from the local Interchain DataBase.\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    struct LocalEntry {\n        address writer;\n        bytes32 dataHash;\n    }\n\n    /// @notice Struct representing an entry from the remote Interchain DataBase verified by the Interchain Module\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param entryValue   The value of the entry: writer + dataHash hashed together\n    struct RemoteEntry {\n        uint256 verifiedAt;\n        bytes32 entryValue;\n    }\n\n    error InterchainDB__ConflictingEntries(bytes32 existingEntryValue, InterchainEntry newEntry);\n    error InterchainDB__EntryDoesNotExist(uint256 dbNonce);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId();\n\n    /// @notice Write data to the Interchain DataBase as a new entry.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `verifyEntry` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the written entry on this chain\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce);\n\n    /// @notice Request the given Interchain Modules to verify the already written entry on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any entry.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param destChainId   The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the written entry on this chain\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestVerification(uint256 destChainId, uint256 dbNonce, address[] memory srcModules) external payable;\n\n    /// @notice Write data to the Interchain DataBase,\n    /// and request the given Interchain Modules to verify it on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: additional verification for the same entry could be later done using `requestVerification`\n    /// by providing the returned `dbNonce`.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the written entry on this chain\n    function writeEntryWithVerification(\n        uint256 destChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 dbNonce);\n\n    /// @notice Allows the Interchain Module to verify the entry coming from a remote source chain.\n    /// @param entry        The Interchain Entry to confirm\n    function verifyEntry(InterchainEntry memory entry) external;\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 destChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Get the Interchain Entry by the writer and the writer nonce.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param dbNonce      The database nonce of the written entry on this chain\n    function getEntry(uint256 dbNonce) external view returns (InterchainEntry memory);\n\n    /// @notice Get the nonce of the database.\n    function getDBNonce() external view returns (uint256);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or zero if the module has not verified the entry.\n    function readEntry(\n        address dstModule,\n        InterchainEntry memory entry\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\n// contracts/interfaces/IInterchainModule.sol\n\n/// @notice Every Module may opt a different method to confirm the verified entries on destination chain,\n/// therefore this is not a part of a common interface.\ninterface IInterchainModule {\n    error InterchainModule__NotInterchainDB();\n    error InterchainModule__IncorrectSourceChainId(uint256 chainId);\n    error InterchainModule__InsufficientFee(uint256 actual, uint256 required);\n    error InterchainModule__SameChainId();\n\n    /// @notice Request the verification of an entry in the Interchain DataBase by the module.\n    /// Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`.\n    /// Note: this will eventually trigger `InterchainDB.verifyEntry(entry)` function on destination chain,\n    /// with no guarantee of ordering.\n    /// @dev Could be only called by the Interchain DataBase contract.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param entry        The entry to verify\n    function requestVerification(uint256 destChainId, InterchainEntry memory entry) external payable;\n\n    /// @notice Get the Module fee for verifying an entry on the specified destination chain\n    /// @param destChainId  The chain id of the destination chain\n    function getModuleFee(uint256 destChainId) external view returns (uint256);\n}\n\n// test/mocks/InterchainModuleMock.sol\n\ncontract InterchainModuleMock is IInterchainModule {\n    function requestVerification(uint256 destChainId, InterchainEntry memory entry) external payable {}\n\n    function getModuleFee(uint256 destChainId) external view returns (uint256) {}\n\n    function mockVerifyEntry(address interchainDB, InterchainEntry memory entry) external {\n        IInterchainDB(interchainDB).verifyEntry(entry);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"1010:1299:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;1010:1299:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"1010:1299:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainModuleMock.sol\":\"InterchainEntryLib\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainModuleMock.sol\":{\"keccak256\":\"0x0ce1a1cc3d02118c1602316544734f33c7f7facbc689aaac219293dcf66bd5fe\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://3470d1c45573870049229ffe63deb4aab7df56ae242cf4bde445508e08a01f24\",\"dweb:/ipfs/QmbewvT5m3BtXzMpvtQfeRYJ6s4gRrSBfJJMEdDReZaeto\"]}},\"version\":1}"},"hashes":{}},"solidity/InterchainModuleMock.sol:InterchainModuleMock":{"code":"0x608060405234801561001057600080fd5b50610291806100206000396000f3fe6080604052600436106100345760003560e01c8063b8b3d05814610039578063dc8e4f891461005b578063f6bc485f1461008e575b600080fd5b34801561004557600080fd5b506100596100543660046101cf565b6100a0565b005b34801561006757600080fd5b5061007c61007636600461021e565b50600090565b60405190815260200160405180910390f35b61005961009c366004610237565b5050565b604080517f54941dfa00000000000000000000000000000000000000000000000000000000815282516004820152602083015160248201529082015160448201526060820151606482015273ffffffffffffffffffffffffffffffffffffffff8316906354941dfa90608401600060405180830381600087803b15801561012657600080fd5b505af115801561013a573d6000803e3d6000fd5b505050505050565b60006080828403121561015457600080fd5b6040516080810181811067ffffffffffffffff8211171561019e577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b8060405250809150823581526020830135602082015260408301356040820152606083013560608201525092915050565b60008060a083850312156101e257600080fd5b823573ffffffffffffffffffffffffffffffffffffffff8116811461020657600080fd5b91506102158460208501610142565b90509250929050565b60006020828403121561023057600080fd5b5035919050565b60008060a0838503121561024a57600080fd5b82359150610215846020850161014256fea2646970667358221220c0168bba0ddcd15354dd5d9028e8f2be2227ba672e18433a96a82792713d342564736f6c63430008140033","runtime-code":"0x6080604052600436106100345760003560e01c8063b8b3d05814610039578063dc8e4f891461005b578063f6bc485f1461008e575b600080fd5b34801561004557600080fd5b506100596100543660046101cf565b6100a0565b005b34801561006757600080fd5b5061007c61007636600461021e565b50600090565b60405190815260200160405180910390f35b61005961009c366004610237565b5050565b604080517f54941dfa00000000000000000000000000000000000000000000000000000000815282516004820152602083015160248201529082015160448201526060820151606482015273ffffffffffffffffffffffffffffffffffffffff8316906354941dfa90608401600060405180830381600087803b15801561012657600080fd5b505af115801561013a573d6000803e3d6000fd5b505050505050565b60006080828403121561015457600080fd5b6040516080810181811067ffffffffffffffff8211171561019e577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b8060405250809150823581526020830135602082015260408301356040820152606083013560608201525092915050565b60008060a083850312156101e257600080fd5b823573ffffffffffffffffffffffffffffffffffffffff8116811461020657600080fd5b91506102158460208501610142565b90509250929050565b60006020828403121561023057600080fd5b5035919050565b60008060a0838503121561024a57600080fd5b82359150610215846020850161014256fea2646970667358221220c0168bba0ddcd15354dd5d9028e8f2be2227ba672e18433a96a82792713d342564736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0;\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the entry on the source chain\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint256 srcChainId;\n    uint256 dbNonce;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint256 dbNonce,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            dbNonce: dbNonce,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce));\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing an entry from the local Interchain DataBase.\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    struct LocalEntry {\n        address writer;\n        bytes32 dataHash;\n    }\n\n    /// @notice Struct representing an entry from the remote Interchain DataBase verified by the Interchain Module\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param entryValue   The value of the entry: writer + dataHash hashed together\n    struct RemoteEntry {\n        uint256 verifiedAt;\n        bytes32 entryValue;\n    }\n\n    error InterchainDB__ConflictingEntries(bytes32 existingEntryValue, InterchainEntry newEntry);\n    error InterchainDB__EntryDoesNotExist(uint256 dbNonce);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId();\n\n    /// @notice Write data to the Interchain DataBase as a new entry.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `verifyEntry` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the written entry on this chain\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce);\n\n    /// @notice Request the given Interchain Modules to verify the already written entry on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any entry.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param destChainId   The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the written entry on this chain\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestVerification(uint256 destChainId, uint256 dbNonce, address[] memory srcModules) external payable;\n\n    /// @notice Write data to the Interchain DataBase,\n    /// and request the given Interchain Modules to verify it on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: additional verification for the same entry could be later done using `requestVerification`\n    /// by providing the returned `dbNonce`.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the written entry on this chain\n    function writeEntryWithVerification(\n        uint256 destChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 dbNonce);\n\n    /// @notice Allows the Interchain Module to verify the entry coming from a remote source chain.\n    /// @param entry        The Interchain Entry to confirm\n    function verifyEntry(InterchainEntry memory entry) external;\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 destChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Get the Interchain Entry by the writer and the writer nonce.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param dbNonce      The database nonce of the written entry on this chain\n    function getEntry(uint256 dbNonce) external view returns (InterchainEntry memory);\n\n    /// @notice Get the nonce of the database.\n    function getDBNonce() external view returns (uint256);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or zero if the module has not verified the entry.\n    function readEntry(\n        address dstModule,\n        InterchainEntry memory entry\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\n// contracts/interfaces/IInterchainModule.sol\n\n/// @notice Every Module may opt a different method to confirm the verified entries on destination chain,\n/// therefore this is not a part of a common interface.\ninterface IInterchainModule {\n    error InterchainModule__NotInterchainDB();\n    error InterchainModule__IncorrectSourceChainId(uint256 chainId);\n    error InterchainModule__InsufficientFee(uint256 actual, uint256 required);\n    error InterchainModule__SameChainId();\n\n    /// @notice Request the verification of an entry in the Interchain DataBase by the module.\n    /// Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`.\n    /// Note: this will eventually trigger `InterchainDB.verifyEntry(entry)` function on destination chain,\n    /// with no guarantee of ordering.\n    /// @dev Could be only called by the Interchain DataBase contract.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param entry        The entry to verify\n    function requestVerification(uint256 destChainId, InterchainEntry memory entry) external payable;\n\n    /// @notice Get the Module fee for verifying an entry on the specified destination chain\n    /// @param destChainId  The chain id of the destination chain\n    function getModuleFee(uint256 destChainId) external view returns (uint256);\n}\n\n// test/mocks/InterchainModuleMock.sol\n\ncontract InterchainModuleMock is IInterchainModule {\n    function requestVerification(uint256 destChainId, InterchainEntry memory entry) external payable {}\n\n    function getModuleFee(uint256 destChainId) external view returns (uint256) {}\n\n    function mockVerifyEntry(address interchainDB, InterchainEntry memory entry) external {\n        IInterchainDB(interchainDB).verifyEntry(entry);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"9208:396:0:-:0;;;;;;;;;;;;;;;;;;;","srcMapRuntime":"9208:396:0:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;9453:149;;;;;;;;;;-1:-1:-1;9453:149:0;;;;;:::i;:::-;;:::i;:::-;;9370:77;;;;;;;;;;-1:-1:-1;9370:77:0;;;;;:::i;:::-;-1:-1:-1;9436:7:0;;9370:77;;;;1560:25:1;;;1548:2;1533:18;9370:77:0;;;;;;;9265:99;;;;;;:::i;:::-;;;;9453:149;9549:46;;;;;;2138:13:1;;9549:46:0;;;2120:32:1;2208:4;2196:17;;2190:24;2168:20;;;2161:54;2259:17;;;2253:24;2231:20;;;2224:54;2334:4;2322:17;;2316:24;2294:20;;;2287:54;9549:39:0;;;;;;2092:19:1;;9549:46:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;9453:149;;:::o;14:766:1:-;76:5;124:4;112:9;107:3;103:19;99:30;96:50;;;142:1;139;132:12;96:50;175:2;169:9;217:4;209:6;205:17;288:6;276:10;273:22;252:18;240:10;237:34;234:62;231:242;;;329:77;326:1;319:88;430:4;427:1;420:15;458:4;455:1;448:15;231:242;493:10;489:2;482:22;;522:6;513:15;;565:9;552:23;544:6;537:39;637:2;626:9;622:18;609:32;604:2;596:6;592:15;585:57;703:2;692:9;688:18;675:32;670:2;662:6;658:15;651:57;769:2;758:9;754:18;741:32;736:2;728:6;724:15;717:57;;14:766;;;;:::o;785:439::-;884:6;892;945:3;933:9;924:7;920:23;916:33;913:53;;;962:1;959;952:12;913:53;1001:9;988:23;1051:42;1044:5;1040:54;1033:5;1030:65;1020:93;;1109:1;1106;1099:12;1020:93;1132:5;-1:-1:-1;1156:62:1;1210:7;1205:2;1190:18;;1156:62;:::i;:::-;1146:72;;785:439;;;;;:::o;1229:180::-;1288:6;1341:2;1329:9;1320:7;1316:23;1312:32;1309:52;;;1357:1;1354;1347:12;1309:52;-1:-1:-1;1380:23:1;;1229:180;-1:-1:-1;1229:180:1:o;1596:310::-;1695:6;1703;1756:3;1744:9;1735:7;1731:23;1727:33;1724:53;;;1773:1;1770;1763:12;1724:53;1809:9;1796:23;1786:33;;1838:62;1892:7;1887:2;1876:9;1872:18;1838:62;:::i","abiDefinition":[{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"}],"name":"InterchainModule__IncorrectSourceChainId","type":"error"},{"inputs":[{"internalType":"uint256","name":"actual","type":"uint256"},{"internalType":"uint256","name":"required","type":"uint256"}],"name":"InterchainModule__InsufficientFee","type":"error"},{"inputs":[],"name":"InterchainModule__NotInterchainDB","type":"error"},{"inputs":[],"name":"InterchainModule__SameChainId","type":"error"},{"inputs":[{"internalType":"uint256","name":"destChainId","type":"uint256"}],"name":"getModuleFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"interchainDB","type":"address"},{"components":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"bytes32","name":"srcWriter","type":"bytes32"},{"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"internalType":"struct InterchainEntry","name":"entry","type":"tuple"}],"name":"mockVerifyEntry","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"destChainId","type":"uint256"},{"components":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"bytes32","name":"srcWriter","type":"bytes32"},{"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"internalType":"struct InterchainEntry","name":"entry","type":"tuple"}],"name":"requestVerification","outputs":[],"stateMutability":"payable","type":"function"}],"userDoc":{"kind":"user","methods":{"getModuleFee(uint256)":{"notice":"Get the Module fee for verifying an entry on the specified destination chain"},"requestVerification(uint256,(uint256,uint256,bytes32,bytes32))":{"notice":"Request the verification of an entry in the Interchain DataBase by the module. Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`. Note: this will eventually trigger `InterchainDB.verifyEntry(entry)` function on destination chain, with no guarantee of ordering."}},"version":1},"developerDoc":{"kind":"dev","methods":{"getModuleFee(uint256)":{"params":{"destChainId":"The chain id of the destination chain"}},"requestVerification(uint256,(uint256,uint256,bytes32,bytes32))":{"details":"Could be only called by the Interchain DataBase contract.","params":{"destChainId":"The chain id of the destination chain","entry":"The entry to verify"}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"InterchainModule__IncorrectSourceChainId\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"required\",\"type\":\"uint256\"}],\"name\":\"InterchainModule__InsufficientFee\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InterchainModule__NotInterchainDB\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InterchainModule__SameChainId\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"destChainId\",\"type\":\"uint256\"}],\"name\":\"getModuleFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"interchainDB\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"srcWriter\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"internalType\":\"struct InterchainEntry\",\"name\":\"entry\",\"type\":\"tuple\"}],\"name\":\"mockVerifyEntry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"destChainId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"srcWriter\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"internalType\":\"struct InterchainEntry\",\"name\":\"entry\",\"type\":\"tuple\"}],\"name\":\"requestVerification\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"getModuleFee(uint256)\":{\"params\":{\"destChainId\":\"The chain id of the destination chain\"}},\"requestVerification(uint256,(uint256,uint256,bytes32,bytes32))\":{\"details\":\"Could be only called by the Interchain DataBase contract.\",\"params\":{\"destChainId\":\"The chain id of the destination chain\",\"entry\":\"The entry to verify\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"getModuleFee(uint256)\":{\"notice\":\"Get the Module fee for verifying an entry on the specified destination chain\"},\"requestVerification(uint256,(uint256,uint256,bytes32,bytes32))\":{\"notice\":\"Request the verification of an entry in the Interchain DataBase by the module. Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`. Note: this will eventually trigger `InterchainDB.verifyEntry(entry)` function on destination chain, with no guarantee of ordering.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainModuleMock.sol\":\"InterchainModuleMock\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainModuleMock.sol\":{\"keccak256\":\"0x0ce1a1cc3d02118c1602316544734f33c7f7facbc689aaac219293dcf66bd5fe\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://3470d1c45573870049229ffe63deb4aab7df56ae242cf4bde445508e08a01f24\",\"dweb:/ipfs/QmbewvT5m3BtXzMpvtQfeRYJ6s4gRrSBfJJMEdDReZaeto\"]}},\"version\":1}"},"hashes":{"getModuleFee(uint256)":"dc8e4f89","mockVerifyEntry(address,(uint256,uint256,bytes32,bytes32))":"b8b3d058","requestVerification(uint256,(uint256,uint256,bytes32,bytes32))":"f6bc485f"}},"solidity/InterchainModuleMock.sol:TypeCasts":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220dbf0060a7b67795355bee94600d93d02fbbedb2bb529f77e77e8f99d1303906864736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220dbf0060a7b67795355bee94600d93d02fbbedb2bb529f77e77e8f99d1303906864736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0;\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the entry on the source chain\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint256 srcChainId;\n    uint256 dbNonce;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint256 dbNonce,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            dbNonce: dbNonce,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce));\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing an entry from the local Interchain DataBase.\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    struct LocalEntry {\n        address writer;\n        bytes32 dataHash;\n    }\n\n    /// @notice Struct representing an entry from the remote Interchain DataBase verified by the Interchain Module\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param entryValue   The value of the entry: writer + dataHash hashed together\n    struct RemoteEntry {\n        uint256 verifiedAt;\n        bytes32 entryValue;\n    }\n\n    error InterchainDB__ConflictingEntries(bytes32 existingEntryValue, InterchainEntry newEntry);\n    error InterchainDB__EntryDoesNotExist(uint256 dbNonce);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId();\n\n    /// @notice Write data to the Interchain DataBase as a new entry.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `verifyEntry` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the written entry on this chain\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce);\n\n    /// @notice Request the given Interchain Modules to verify the already written entry on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any entry.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param destChainId   The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the written entry on this chain\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestVerification(uint256 destChainId, uint256 dbNonce, address[] memory srcModules) external payable;\n\n    /// @notice Write data to the Interchain DataBase,\n    /// and request the given Interchain Modules to verify it on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: additional verification for the same entry could be later done using `requestVerification`\n    /// by providing the returned `dbNonce`.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the written entry on this chain\n    function writeEntryWithVerification(\n        uint256 destChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 dbNonce);\n\n    /// @notice Allows the Interchain Module to verify the entry coming from a remote source chain.\n    /// @param entry        The Interchain Entry to confirm\n    function verifyEntry(InterchainEntry memory entry) external;\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 destChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Get the Interchain Entry by the writer and the writer nonce.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param dbNonce      The database nonce of the written entry on this chain\n    function getEntry(uint256 dbNonce) external view returns (InterchainEntry memory);\n\n    /// @notice Get the nonce of the database.\n    function getDBNonce() external view returns (uint256);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or zero if the module has not verified the entry.\n    function readEntry(\n        address dstModule,\n        InterchainEntry memory entry\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\n// contracts/interfaces/IInterchainModule.sol\n\n/// @notice Every Module may opt a different method to confirm the verified entries on destination chain,\n/// therefore this is not a part of a common interface.\ninterface IInterchainModule {\n    error InterchainModule__NotInterchainDB();\n    error InterchainModule__IncorrectSourceChainId(uint256 chainId);\n    error InterchainModule__InsufficientFee(uint256 actual, uint256 required);\n    error InterchainModule__SameChainId();\n\n    /// @notice Request the verification of an entry in the Interchain DataBase by the module.\n    /// Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`.\n    /// Note: this will eventually trigger `InterchainDB.verifyEntry(entry)` function on destination chain,\n    /// with no guarantee of ordering.\n    /// @dev Could be only called by the Interchain DataBase contract.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param entry        The entry to verify\n    function requestVerification(uint256 destChainId, InterchainEntry memory entry) external payable;\n\n    /// @notice Get the Module fee for verifying an entry on the specified destination chain\n    /// @param destChainId  The chain id of the destination chain\n    function getModuleFee(uint256 destChainId) external view returns (uint256);\n}\n\n// test/mocks/InterchainModuleMock.sol\n\ncontract InterchainModuleMock is IInterchainModule {\n    function requestVerification(uint256 destChainId, InterchainEntry memory entry) external payable {}\n\n    function getModuleFee(uint256 destChainId) external view returns (uint256) {}\n\n    function mockVerifyEntry(address interchainDB, InterchainEntry memory entry) external {\n        IInterchainDB(interchainDB).verifyEntry(entry);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"98:280:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;98:280:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"98:280:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainModuleMock.sol\":\"TypeCasts\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainModuleMock.sol\":{\"keccak256\":\"0x0ce1a1cc3d02118c1602316544734f33c7f7facbc689aaac219293dcf66bd5fe\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://3470d1c45573870049229ffe63deb4aab7df56ae242cf4bde445508e08a01f24\",\"dweb:/ipfs/QmbewvT5m3BtXzMpvtQfeRYJ6s4gRrSBfJJMEdDReZaeto\"]}},\"version\":1}"},"hashes":{}}}