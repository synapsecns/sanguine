{"solidity/InterchainClientV1.sol:AppConfigLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220948fccf838429cd1916fb623f6ae4d21f8609511b6a640d6f818afc9fcdba01364736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220948fccf838429cd1916fb623f6ae4d21f8609511b6a640d6f818afc9fcdba01364736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainClientV1Events.sol\n\nabstract contract InterchainClientV1Events {\n    event ExecutionFeesSet(address executionFees);\n    event LinkedClientSet(uint64 chainId, bytes32 client);\n\n    // TODO: figure out indexing\n\n    event InterchainTransactionSent(\n        bytes32 indexed transactionId,\n        uint64 indexed dbNonce,\n        uint64 indexed entryIndex,\n        uint64 dstChainId,\n        bytes32 srcSender,\n        bytes32 dstReceiver,\n        uint256 verificationFee,\n        uint256 executionFee,\n        bytes options,\n        bytes message\n    );\n\n    event InterchainTransactionReceived(\n        bytes32 indexed transactionId,\n        uint64 indexed dbNonce,\n        uint64 indexed entryIndex,\n        uint64 srcChainId,\n        bytes32 srcSender,\n        bytes32 dstReceiver\n    );\n\n    event ExecutionProofWritten(\n        bytes32 indexed transactionId, uint64 indexed dbNonce, uint64 indexed entryIndex, address executor\n    );\n}\n\n// contracts/interfaces/IExecutionFees.sol\n\ninterface IExecutionFees {\n    error ExecutionFees__AlreadyRecorded(uint64 dstChainId, bytes32 transactionId, address executor);\n    error ExecutionFees__ZeroAddress();\n    error ExecutionFees__ZeroAmount();\n\n    /// @notice Add the execution fee for a transaction. The attached value will be added to the\n    /// rewards for the executor completing the transaction.\n    /// Note: this could be used to store the execution fee for a new transaction, or to add more\n    /// funds to the execution fee of an existing transaction. Therefore this function is payable,\n    /// and does not implement any caller restrictions.\n    /// @dev Will revert if the executor is already recorded for the transaction.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to add the execution fee to.\n    function addExecutionFee(uint64 dstChainId, bytes32 transactionId) external payable;\n\n    /// @notice Record the executor (who completed the transaction) for a transaction,\n    /// and update the accumulated rewards for the executor.\n    /// @dev Could only be called by the Recorder.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to record the executor for.\n    /// @param executor             The address of the executor who completed the transaction.\n    function recordExecutor(uint64 dstChainId, bytes32 transactionId, address executor) external;\n\n    /// @notice Allows the executor to claim their unclaimed rewards.\n    /// @dev Will revert if the executor has no unclaimed rewards.\n    function claimExecutionFees(address executor) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the accumulated rewards for an executor.\n    /// @param executor             The address of the executor to get the rewards for.\n    function accumulatedRewards(address executor) external view returns (uint256 accumulated);\n\n    /// @notice Get the unclaimed rewards for an executor.\n    /// @param executor             The address of the executor to get the rewards for.\n    function unclaimedRewards(address executor) external view returns (uint256 unclaimed);\n\n    /// @notice Get the total execution fee for a transaction.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to get the execution fee for.\n    function executionFee(uint64 dstChainId, bytes32 transactionId) external view returns (uint256 fee);\n\n    /// @notice Get the address of the recorded executor for a transaction.\n    /// @dev Will return address(0) if the executor is not recorded.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to get the recorded executor for.\n    function recordedExecutor(uint64 dstChainId, bytes32 transactionId) external view returns (address executor);\n}\n\n// contracts/interfaces/IExecutionService.sol\n\ninterface IExecutionService {\n    /// @notice Request the execution of an Interchain Transaction on a remote chain.\n    /// Note: the off-chain actor needs to fetch the transaction payload from the InterchainClient\n    /// event with the same transactionId, then execute the transaction on the remote chain:\n    /// `dstInterchainClient.executeTransaction(transactionPayload)`\n    /// Once the execution is confirmed on the source chain, the off-chain actor will be able\n    /// to claim `executionFee` in the ExecutionFees contract.\n    /// @dev Could only be called by `InterchainClient` contracts.\n    /// Will revert if the execution fee is not big enough.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param txPayloadSize        The size of the transaction payload to use for the execution.\n    /// @param transactionId        The id of the transaction to execute.\n    /// @param executionFee         The fee paid for the execution.\n    /// @param options              The options to use for the execution.\n    function requestExecution(\n        uint64 dstChainId,\n        uint256 txPayloadSize,\n        bytes32 transactionId,\n        uint256 executionFee,\n        bytes memory options\n    )\n        external;\n\n    /// @notice Get the address of the EOA account that will be used to execute transactions on the\n    /// remote chains.\n    function executorEOA() external view returns (address);\n\n    /// @notice Get the execution fee for executing an Interchain Transaction on a remote chain.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param txPayloadSize        The size of the transaction payload to use for the execution.\n    /// @param options              The options to use for the execution.\n    function getExecutionFee(\n        uint64 dstChainId,\n        uint256 txPayloadSize,\n        bytes memory options\n    )\n        external\n        view\n        returns (uint256);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    /// @notice Allows the Interchain Client to pass the message to the Interchain App.\n    /// @dev App is responsible for keeping track of interchain clients, and must verify the message sender.\n    /// @param srcChainId   Chain ID of the source chain, where the message was sent from.\n    /// @param sender       Sender address on the source chain, as a bytes32 value.\n    /// @param dbNonce      The Interchain DB nonce of the batch containing the message entry.\n    /// @param entryIndex   The index of the message entry within the batch.\n    /// @param message      The message being sent.\n    function appReceive(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /// @notice Returns the verification configuration of the Interchain App.\n    /// @dev This configuration is used by the Interchain Client to verify that message has been confirmed\n    /// by the Interchain Modules on the destination chain.\n    /// Note: V1 version of AppConfig includes the required responses count, and optimistic period after which\n    /// the message is considered confirmed by the module. Following versions may include additional fields.\n    /// @return appConfig    The versioned configuration of the Interchain App, encoded as bytes.\n    /// @return modules      The list of Interchain Modules that app is trusting to confirm the messages.\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/Math.sol\n\nlibrary MathLib {\n    /// @notice Rounds up to the nearest multiple of 32.\n    /// Note: Returns zero on overflows instead of reverting. This is fine for practical\n    /// use cases, as this is used for determining the size of the payload in memory.\n    function roundUpToWord(uint256 x) internal pure returns (uint256) {\n        unchecked {\n            return (x + 31) \u0026 ~uint256(31);\n        }\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/VersionedPayload.sol\n\n// solhint-disable no-inline-assembly\n// solhint-disable ordering\nlibrary VersionedPayloadLib {\n    /// @notice Amount of bytes reserved for the version (uint16) in the versioned payload\n    uint256 internal constant VERSION_LENGTH = 2;\n\n    error VersionedPayload__TooShort(bytes versionedPayload);\n    error VersionedPayload__PrecompileFailed();\n\n    /// @notice Encodes the versioned payload into a single bytes array.\n    /// @param version  The payload's version.\n    /// @param payload  The payload to encode.\n    function encodeVersionedPayload(uint16 version, bytes memory payload) internal pure returns (bytes memory) {\n        return abi.encodePacked(version, payload);\n    }\n\n    /// @notice Extracts the version from the versioned payload (calldata reference).\n    /// @param versionedPayload     The versioned payload (calldata reference).\n    function getVersion(bytes calldata versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            version := shr(240, calldataload(versionedPayload.offset))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (calldata reference).\n    /// @dev The extracted payload is also returned as a calldata reference.\n    /// @param versionedPayload     The versioned payload.\n    function getPayload(bytes calldata versionedPayload) internal pure returns (bytes calldata) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        return versionedPayload[VERSION_LENGTH:];\n    }\n\n    /// @notice Extracts the version from the versioned payload (memory reference).\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getVersionFromMemory(bytes memory versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            // We add 0x20 to skip the length of the bytes array.\n            version := shr(240, mload(add(versionedPayload, 0x20)))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (memory reference).\n    /// @dev The extracted payload is copied into a new memory location. Use `getPayload` when possible\n    /// to avoid extra memory allocation.\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getPayloadFromMemory(bytes memory versionedPayload) internal view returns (bytes memory payload) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        // Figure how many bytes to copy and allocate the memory for the extracted payload.\n        uint256 toCopy;\n        unchecked {\n            toCopy = versionedPayload.length - VERSION_LENGTH;\n        }\n        payload = new bytes(toCopy);\n        // Use identity precompile (0x04) to copy the payload. Unlike MCOPY, this is available on all EVM chains.\n        bool res;\n        assembly {\n            // We add 0x20 to skip the length of the bytes array.\n            // We add 0x02 to skip the 2 bytes reserved for the version.\n            // Copy the payload to the previously allocated memory.\n            res := staticcall(gas(), 0x04, add(versionedPayload, 0x22), toCopy, add(payload, 0x20), toCopy)\n        }\n        if (!res) {\n            revert VersionedPayload__PrecompileFailed();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SafeCast.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value \u003e type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value \u003e type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value \u003e type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value \u003e type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value \u003e type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value \u003e type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value \u003e type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value \u003e type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value \u003e type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value \u003e type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value \u003e type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value \u003e type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value \u003e type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value \u003e type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value \u003e type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value \u003e type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value \u003e type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value \u003e type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value \u003e type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value \u003e type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value \u003e type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value \u003e type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value \u003e type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value \u003e type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value \u003e type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value \u003e type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value \u003e type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value \u003e type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value \u003e type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value \u003e type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value \u003e type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value \u003c 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value \u003e uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal view returns (AppConfigV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (AppConfigV1));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal view returns (OptionsV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (OptionsV1));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(OPTIONS_V1, abi.encode(options));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/libs/InterchainBatch.sol\n\ntype BatchKey is uint128;\n\n/// @notice Struct representing a batch of entries in the Interchain DataBase.\n/// Batched entries are put together in a Merkle tree, which root is saved.\n/// Batch has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: batchRoot\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch\n/// @param batchRoot    The root of the Merkle tree containing the batched entries\nstruct InterchainBatch {\n    uint64 srcChainId;\n    uint64 dbNonce;\n    bytes32 batchRoot;\n}\n\nlibrary InterchainBatchLib {\n    using VersionedPayloadLib for bytes;\n\n    /// @notice Constructs an InterchainBatch struct to be saved on the local chain.\n    /// @param dbNonce      The database nonce of the batch\n    /// @param batchRoot    The root of the Merkle tree containing the batched entries\n    /// @return batch       The constructed InterchainBatch struct\n    function constructLocalBatch(\n        uint64 dbNonce,\n        bytes32 batchRoot\n    )\n        internal\n        view\n        returns (InterchainBatch memory batch)\n    {\n        return InterchainBatch({srcChainId: SafeCast.toUint64(block.chainid), dbNonce: dbNonce, batchRoot: batchRoot});\n    }\n\n    /// @notice Encodes the InterchainBatch struct into a non-versioned batch payload.\n    function encodeBatch(InterchainBatch memory batch) internal pure returns (bytes memory) {\n        return abi.encode(encodeBatchKey(batch.srcChainId, batch.dbNonce), batch.batchRoot);\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in calldata.\n    function decodeBatch(bytes calldata data) internal pure returns (InterchainBatch memory batch) {\n        BatchKey key;\n        (key, batch.batchRoot) = abi.decode(data, (BatchKey, bytes32));\n        (batch.srcChainId, batch.dbNonce) = decodeBatchKey(key);\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in memory.\n    function decodeBatchFromMemory(bytes memory data) internal pure returns (InterchainBatch memory batch) {\n        BatchKey key;\n        (key, batch.batchRoot) = abi.decode(data, (BatchKey, bytes32));\n        (batch.srcChainId, batch.dbNonce) = decodeBatchKey(key);\n    }\n\n    /// @notice Encodes the uint128 key of the batch from uint64 srcChainId and uint64 dbNonce.\n    function encodeBatchKey(uint64 srcChainId, uint64 dbNonce) internal pure returns (BatchKey) {\n        return BatchKey.wrap((uint128(srcChainId) \u003c\u003c 64) | dbNonce);\n    }\n\n    /// @notice Decodes the uint128 key of the batch into uint64 srcChainId and uint64 dbNonce.\n    function decodeBatchKey(BatchKey key) internal pure returns (uint64 srcChainId, uint64 dbNonce) {\n        srcChainId = uint64(BatchKey.unwrap(key) \u003e\u003e 64);\n        dbNonce = uint64(BatchKey.unwrap(key));\n    }\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce + entryIndex\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch containing the entry\n/// @param entryIndex   The index of the entry in the batch\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint64 srcChainId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nusing InterchainEntryLib for InterchainEntry global;\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint64 dbNonce,\n        uint64 entryIndex,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: SafeCast.toUint64(block.chainid),\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n}\n\n// contracts/libs/InterchainTransaction.sol\n\ntype ICTxHeader is uint256;\n\nstruct InterchainTransaction {\n    uint64 srcChainId;\n    uint64 dstChainId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcSender;\n    bytes32 dstReceiver;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    using MathLib for uint256;\n    using VersionedPayloadLib for bytes;\n\n    function constructLocalTransaction(\n        address srcSender,\n        uint64 dstChainId,\n        bytes32 dstReceiver,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: SafeCast.toUint64(block.chainid),\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            encodeTxHeader(transaction.srcChainId, transaction.dstChainId, transaction.dbNonce, transaction.entryIndex),\n            transaction.srcSender,\n            transaction.dstReceiver,\n            transaction.options,\n            transaction.message\n        );\n    }\n\n    function decodeTransaction(bytes calldata transaction) internal pure returns (InterchainTransaction memory icTx) {\n        ICTxHeader header;\n        (header, icTx.srcSender, icTx.dstReceiver, icTx.options, icTx.message) =\n            abi.decode(transaction, (ICTxHeader, bytes32, bytes32, bytes, bytes));\n        (icTx.srcChainId, icTx.dstChainId, icTx.dbNonce, icTx.entryIndex) = decodeTxHeader(header);\n    }\n\n    function payloadSize(uint256 optionsLen, uint256 messageLen) internal pure returns (uint256) {\n        // 2 bytes are reserved for the transaction version\n        // + 5 fields * 32 bytes (3 values for static, 2 offsets for dynamic) + 2 * 32 bytes (lengths for dynamic) = 226\n        // (srcChainId, dstChainId, dbNonce, entryIndex) are merged into a single 32 bytes field\n        // Both options and message are dynamic fields, which are padded up to 32 bytes\n        return 226 + optionsLen.roundUpToWord() + messageLen.roundUpToWord();\n    }\n\n    function encodeTxHeader(\n        uint64 srcChainId,\n        uint64 dstChainId,\n        uint64 dbNonce,\n        uint64 entryIndex\n    )\n        internal\n        pure\n        returns (ICTxHeader)\n    {\n        return ICTxHeader.wrap(\n            (uint256(srcChainId) \u003c\u003c 192) | (uint256(dstChainId) \u003c\u003c 128) | (uint256(dbNonce) \u003c\u003c 64) | uint256(entryIndex)\n        );\n    }\n\n    function decodeTxHeader(ICTxHeader header)\n        internal\n        pure\n        returns (uint64 srcChainId, uint64 dstChainId, uint64 dbNonce, uint64 entryIndex)\n    {\n        srcChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 192);\n        dstChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 128);\n        dbNonce = uint64(ICTxHeader.unwrap(header) \u003e\u003e 64);\n        entryIndex = uint64(ICTxHeader.unwrap(header));\n    }\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint64 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__InvalidTransactionVersion(uint16 version);\n    error InterchainClientV1__NoLinkedClient(uint64 chainId);\n    error InterchainClientV1__NotEnoughGasSupplied();\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint64 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint64 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint64 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint64 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param messageLen           The length of the message being sent.\n    function getInterchainFee(\n        uint64 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        uint256 messageLen\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint64 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint64 chainId) external view returns (address);\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing a batch of entries from the remote Interchain DataBase,\n    /// verified by the Interchain Module.\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param batchRoot    The Merkle root of the batch\n    struct RemoteBatch {\n        uint256 verifiedAt;\n        bytes32 batchRoot;\n    }\n\n    error InterchainDB__BatchDoesNotExist(uint64 dbNonce);\n    error InterchainDB__BatchNotFinalized(uint64 dbNonce);\n    error InterchainDB__ConflictingBatches(address module, bytes32 existingBatchRoot, InterchainBatch newBatch);\n    error InterchainDB__EntryIndexOutOfRange(uint64 dbNonce, uint64 entryIndex, uint64 batchSize);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__InvalidBatchVersion(uint16 version);\n    error InterchainDB__InvalidEntryRange(uint64 dbNonce, uint64 start, uint64 end);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId(uint64 chainId);\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `requestBatchVerification` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntry(bytes32 dataHash) external returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Request the given Interchain Modules to verify an existing batch.\n    /// If the batch is not finalized, the module will verify it after finalization.\n    /// For the finalized batch the batch root is already available, and the module can verify it immediately.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any batch.\n    /// @dev Will revert if the batch with the given nonce does not exist.\n    /// @param dstChainId    The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the existing batch\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestBatchVerification(\n        uint64 dstChainId,\n        uint64 dbNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Then request the Interchain Modules to verify the batch containing the written entry on the destination chain.\n    /// See `writeEntry` and `requestBatchVerification` for more details.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntryWithVerification(\n        uint64 dstChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Allows the Interchain Module to verify the batch coming from the remote chain.\n    /// Note: The DB will only accept the batch of the same version as the DB itself.\n    /// @param versionedBatch   The versioned Interchain Batch to verify\n    function verifyRemoteBatch(bytes memory versionedBatch) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint64 dstChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce.\n    /// Note: the leafs are ordered by the index of the written entry in the current batch,\n    /// and the leafs value match the value of the written entry (srcWriter + dataHash hashed together).\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchLeafs(uint64 dbNonce) external view returns (bytes32[] memory);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce,\n    /// paginated by the given start and end indexes. The end index is exclusive.\n    /// Note: this is useful when the batch contains a large number of leafs, and calling `getBatchLeafs`\n    /// would result in a gas limit exceeded error.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the provided range is invalid.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param start        The start index of the paginated leafs, inclusive\n    /// @param end          The end index of the paginated leafs, exclusive\n    function getBatchLeafsPaginated(\n        uint64 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory);\n\n    /// @notice Returns the size of the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchSize(uint64 dbNonce) external view returns (uint64);\n\n    /// @notice Get the finalized Interchain Batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatch(uint64 dbNonce) external view returns (InterchainBatch memory);\n\n    /// @notice Get the Interchain Entry's value written on the local chain with the given batch nonce and entry index.\n    /// Entry value is calculated as the hash of the writer address and the written data hash.\n    /// Note: the batch does not have to be finalized to fetch the entry value.\n    /// @dev Will revert if the batch with the given nonce does not exist,\n    /// or the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the existing batch\n    /// @param entryIndex   The index of the written entry within the batch\n    function getEntryValue(uint64 dbNonce, uint64 entryIndex) external view returns (bytes32);\n\n    /// @notice Get the Merkle proof of inclusion for the entry with the given index\n    /// in the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param entryIndex   The index of the written entry within the batch\n    /// @return proof       The Merkle proof of inclusion for the entry\n    function getEntryProof(uint64 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof);\n\n    /// @notice Get the nonce of the database, which is incremented every time a new batch is finalized.\n    /// This is the nonce of the current non-finalized batch.\n    function getDBNonce() external view returns (uint64);\n\n    /// @notice Get the index of the next entry to be written to the database.\n    /// @return dbNonce      The database nonce of the batch including the next entry\n    /// @return entryIndex   The index of the next entry within that batch\n    function getNextEntryIndex() external view returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or ZERO if the module has not verified the entry.\n    function checkVerification(\n        address dstModule,\n        InterchainEntry memory entry,\n        bytes32[] memory proof\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n\n    /// @notice Get the version of the Interchain DataBase.\n    // solhint-disable-next-line func-name-mixedcase\n    function DB_VERSION() external pure returns (uint16);\n}\n\n// contracts/InterchainClientV1.sol\n\n/**\n * @title InterchainClientV1\n * @dev Implements the operations of the Interchain Execution Layer.\n */\ncontract InterchainClientV1 is Ownable, InterchainClientV1Events, IInterchainClientV1 {\n    using AppConfigLib for bytes;\n    using OptionsLib for bytes;\n    using VersionedPayloadLib for bytes;\n\n    /// @notice Version of the InterchainClient contract. Sent and received transactions must have the same version.\n    uint16 public constant CLIENT_VERSION = 1;\n\n    /// @notice Address of the InterchainDB contract, set at the time of deployment.\n    address public immutable INTERCHAIN_DB;\n\n    /// @notice Address of the contract that handles execution fees. Can be updated by the owner.\n    address public executionFees;\n\n    /// @dev Address of the InterchainClient contract on the remote chain\n    mapping(uint64 chainId =\u003e bytes32 remoteClient) internal _linkedClient;\n    /// @dev Executor address that completed the transaction. Address(0) if not executed yet.\n    mapping(bytes32 transactionId =\u003e address executor) internal _txExecutor;\n\n    constructor(address interchainDB, address owner_) Ownable(owner_) {\n        INTERCHAIN_DB = interchainDB;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function setExecutionFees(address executionFees_) external onlyOwner {\n        executionFees = executionFees_;\n        emit ExecutionFeesSet(executionFees_);\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function setLinkedClient(uint64 chainId, bytes32 client) external onlyOwner {\n        _linkedClient[chainId] = client;\n        emit LinkedClientSet(chainId, client);\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _interchainSend(dstChainId, receiver, srcExecutionService, srcModules, options, message);\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function interchainSendEVM(\n        uint64 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc)\n    {\n        bytes32 receiverBytes32 = TypeCasts.addressToBytes32(receiver);\n        return _interchainSend(dstChainId, receiverBytes32, srcExecutionService, srcModules, options, message);\n    }\n\n    // TODO: Handle the case where receiver does not implement the IInterchainApp interface (or does not exist at all)\n    // @inheritdoc IInterchainClientV1\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable\n    {\n        InterchainTransaction memory icTx = _assertCorrectVersion(transaction);\n        bytes32 transactionId = keccak256(transaction);\n        _assertExecutable(icTx, transactionId, proof);\n        _txExecutor[transactionId] = msg.sender;\n\n        OptionsV1 memory decodedOptions = icTx.options.decodeOptionsV1();\n        if (msg.value != decodedOptions.gasAirdrop) {\n            revert InterchainClientV1__IncorrectMsgValue(msg.value, decodedOptions.gasAirdrop);\n        }\n        // We should always use at least as much as the requested gas limit.\n        // The executor can specify a higher gas limit if they wanted.\n        if (decodedOptions.gasLimit \u003e gasLimit) gasLimit = decodedOptions.gasLimit;\n        // Check the the Executor has provided big enough gas limit for the whole transaction.\n        if (gasleft() \u003c= gasLimit) {\n            revert InterchainClientV1__NotEnoughGasSupplied();\n        }\n        // Pass the full msg.value to the app: we have already checked that it matches the requested gas airdrop.\n        IInterchainApp(TypeCasts.bytes32ToAddress(icTx.dstReceiver)).appReceive{gas: gasLimit, value: msg.value}({\n            srcChainId: icTx.srcChainId,\n            sender: icTx.srcSender,\n            dbNonce: icTx.dbNonce,\n            entryIndex: icTx.entryIndex,\n            message: icTx.message\n        });\n        emit InterchainTransactionReceived(\n            transactionId, icTx.dbNonce, icTx.entryIndex, icTx.srcChainId, icTx.srcSender, icTx.dstReceiver\n        );\n    }\n\n    /// @inheritdoc IInterchainClientV1\n    function writeExecutionProof(bytes32 transactionId) external returns (uint64 dbNonce, uint64 entryIndex) {\n        address executor = _txExecutor[transactionId];\n        if (executor == address(0)) {\n            revert InterchainClientV1__TxNotExecuted(transactionId);\n        }\n        bytes memory proof = abi.encode(transactionId, executor);\n        (dbNonce, entryIndex) = IInterchainDB(INTERCHAIN_DB).writeEntry(keccak256(proof));\n        emit ExecutionProofWritten(transactionId, dbNonce, entryIndex, executor);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // @inheritdoc IInterchainClientV1\n    function isExecutable(bytes calldata encodedTx, bytes32[] calldata proof) external view returns (bool) {\n        InterchainTransaction memory icTx = _assertCorrectVersion(encodedTx);\n        // Check that options could be decoded\n        icTx.options.decodeOptionsV1();\n        bytes32 transactionId = keccak256(encodedTx);\n        _assertExecutable(icTx, transactionId, proof);\n        return true;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function getExecutor(bytes calldata encodedTx) external view returns (address) {\n        return _txExecutor[keccak256(encodedTx)];\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function getExecutorById(bytes32 transactionId) external view returns (address) {\n        return _txExecutor[transactionId];\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function getInterchainFee(\n        uint64 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        uint256 messageLen\n    )\n        external\n        view\n        returns (uint256 fee)\n    {\n        _assertLinkedClient(dstChainId);\n        // Check that options could be decoded on destination chain\n        options.decodeOptionsV1();\n        // Verification fee from InterchainDB\n        fee = IInterchainDB(INTERCHAIN_DB).getInterchainFee(dstChainId, srcModules);\n        // Add execution fee, if ExecutionService is provided\n        if (srcExecutionService != address(0)) {\n            uint256 payloadSize = InterchainTransactionLib.payloadSize(options.length, messageLen);\n            fee += IExecutionService(srcExecutionService).getExecutionFee(dstChainId, payloadSize, options);\n        }\n    }\n\n    /// @inheritdoc IInterchainClientV1\n    function getLinkedClient(uint64 chainId) external view returns (bytes32) {\n        if (chainId == block.chainid) {\n            revert InterchainClientV1__NotRemoteChainId(chainId);\n        }\n        return _linkedClient[chainId];\n    }\n\n    /// @inheritdoc IInterchainClientV1\n    function getLinkedClientEVM(uint64 chainId) external view returns (address linkedClientEVM) {\n        if (chainId == block.chainid) {\n            revert InterchainClientV1__NotRemoteChainId(chainId);\n        }\n        bytes32 linkedClient = _linkedClient[chainId];\n        linkedClientEVM = TypeCasts.bytes32ToAddress(linkedClient);\n        // Check that the linked client address fits into the EVM address space\n        if (TypeCasts.addressToBytes32(linkedClientEVM) != linkedClient) {\n            revert InterchainClientV1__NotEVMClient(linkedClient);\n        }\n    }\n\n    /// @notice Decodes the encoded options data into a OptionsV1 struct.\n    function decodeOptions(bytes memory encodedOptions) external view returns (OptionsV1 memory) {\n        return encodedOptions.decodeOptionsV1();\n    }\n\n    /// @notice Encodes the transaction data into a bytes format.\n    function encodeTransaction(InterchainTransaction memory icTx) public pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload({\n            version: CLIENT_VERSION,\n            payload: InterchainTransactionLib.encodeTransaction(icTx)\n        });\n    }\n\n    // ═════════════════════════════════════════════════ INTERNAL ══════════════════════════════════════════════════════\n\n    /// @dev Internal logic for sending a message to another chain.\n    function _interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        _assertLinkedClient(dstChainId);\n        if (receiver == 0) revert InterchainClientV1__ZeroReceiver();\n        // Check that options could be decoded on destination chain\n        options.decodeOptionsV1();\n        uint256 verificationFee = IInterchainDB(INTERCHAIN_DB).getInterchainFee(dstChainId, srcModules);\n        if (msg.value \u003c verificationFee) {\n            revert InterchainClientV1__FeeAmountTooLow(msg.value, verificationFee);\n        }\n        (desc.dbNonce, desc.entryIndex) = IInterchainDB(INTERCHAIN_DB).getNextEntryIndex();\n        InterchainTransaction memory icTx = InterchainTransactionLib.constructLocalTransaction({\n            srcSender: msg.sender,\n            dstReceiver: receiver,\n            dstChainId: dstChainId,\n            dbNonce: desc.dbNonce,\n            entryIndex: desc.entryIndex,\n            options: options,\n            message: message\n        });\n        desc.transactionId = keccak256(encodeTransaction(icTx));\n        // Sanity check: nonce returned from DB should match the nonce used to construct the transaction\n        {\n            (uint64 dbNonce, uint64 entryIndex) = IInterchainDB(INTERCHAIN_DB).writeEntryWithVerification{\n                value: verificationFee\n            }(icTx.dstChainId, desc.transactionId, srcModules);\n            assert(dbNonce == desc.dbNonce \u0026\u0026 entryIndex == desc.entryIndex);\n        }\n        uint256 executionFee;\n        unchecked {\n            executionFee = msg.value - verificationFee;\n        }\n        if (executionFee \u003e 0) {\n            IExecutionFees(executionFees).addExecutionFee{value: executionFee}(icTx.dstChainId, desc.transactionId);\n        }\n        // TODO: consider disallowing the use of empty srcExecutionService\n        if (srcExecutionService != address(0)) {\n            IExecutionService(srcExecutionService).requestExecution({\n                dstChainId: dstChainId,\n                txPayloadSize: InterchainTransactionLib.payloadSize(options.length, message.length),\n                transactionId: desc.transactionId,\n                executionFee: executionFee,\n                options: options\n            });\n            address srcExecutorEOA = IExecutionService(srcExecutionService).executorEOA();\n            IExecutionFees(executionFees).recordExecutor(icTx.dstChainId, desc.transactionId, srcExecutorEOA);\n        }\n        emit InterchainTransactionSent(\n            desc.transactionId,\n            icTx.dbNonce,\n            icTx.entryIndex,\n            icTx.dstChainId,\n            icTx.srcSender,\n            icTx.dstReceiver,\n            verificationFee,\n            executionFee,\n            icTx.options,\n            icTx.message\n        );\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Asserts that the transaction is executable.\n    function _assertExecutable(\n        InterchainTransaction memory icTx,\n        bytes32 transactionId,\n        bytes32[] calldata proof\n    )\n        internal\n        view\n    {\n        bytes32 linkedClient = _assertLinkedClient(icTx.srcChainId);\n        if (icTx.dstChainId != block.chainid) {\n            revert InterchainClientV1__IncorrectDstChainId(icTx.dstChainId);\n        }\n        if (_txExecutor[transactionId] != address(0)) {\n            revert InterchainClientV1__TxAlreadyExecuted(transactionId);\n        }\n        // Construct expected entry based on icTransaction data\n        InterchainEntry memory icEntry = InterchainEntry({\n            srcChainId: icTx.srcChainId,\n            dbNonce: icTx.dbNonce,\n            entryIndex: icTx.entryIndex,\n            srcWriter: linkedClient,\n            dataHash: transactionId\n        });\n        (bytes memory encodedAppConfig, address[] memory approvedDstModules) =\n            IInterchainApp(TypeCasts.bytes32ToAddress(icTx.dstReceiver)).getReceivingConfig();\n        AppConfigV1 memory appConfig = encodedAppConfig.decodeAppConfigV1();\n        if (appConfig.requiredResponses == 0) {\n            revert InterchainClientV1__ZeroRequiredResponses();\n        }\n        uint256 responses = _getFinalizedResponsesCount(approvedDstModules, icEntry, proof, appConfig.optimisticPeriod);\n        if (responses \u003c appConfig.requiredResponses) {\n            revert InterchainClientV1__NotEnoughResponses(responses, appConfig.requiredResponses);\n        }\n    }\n\n    /// @dev Asserts that the chain is linked and returns the linked client address.\n    function _assertLinkedClient(uint64 chainId) internal view returns (bytes32 linkedClient) {\n        if (chainId == block.chainid) {\n            revert InterchainClientV1__NotRemoteChainId(chainId);\n        }\n        linkedClient = _linkedClient[chainId];\n        if (linkedClient == 0) {\n            revert InterchainClientV1__NoLinkedClient(chainId);\n        }\n    }\n\n    /**\n     * @dev Calculates the number of responses that are considered finalized within the optimistic time period.\n     * @param approvedModules       Approved modules that could have confirmed the entry.\n     * @param icEntry               The InterchainEntry to confirm.\n     * @param optimisticPeriod      The time period in seconds within which a response is considered valid.\n     * @return finalizedResponses   The count of responses that are finalized within the optimistic time period.\n     */\n    function _getFinalizedResponsesCount(\n        address[] memory approvedModules,\n        InterchainEntry memory icEntry,\n        bytes32[] calldata proof,\n        uint256 optimisticPeriod\n    )\n        internal\n        view\n        returns (uint256 finalizedResponses)\n    {\n        for (uint256 i = 0; i \u003c approvedModules.length; ++i) {\n            uint256 confirmedAt = IInterchainDB(INTERCHAIN_DB).checkVerification(approvedModules[i], icEntry, proof);\n            // checkVerification() returns 0 if entry hasn't been confirmed by the module, so we check for that as well\n            if (confirmedAt != 0 \u0026\u0026 confirmedAt + optimisticPeriod \u003c block.timestamp) {\n                ++finalizedResponses;\n            }\n        }\n    }\n\n    /// @dev Asserts that the transaction version is correct. Returns the decoded transaction for chaining purposes.\n    function _assertCorrectVersion(bytes calldata versionedTx)\n        internal\n        pure\n        returns (InterchainTransaction memory icTx)\n    {\n        uint16 version = versionedTx.getVersion();\n        if (version != CLIENT_VERSION) {\n            revert InterchainClientV1__InvalidTransactionVersion(version);\n        }\n        icTx = InterchainTransactionLib.decodeTransaction(versionedTx.getPayload());\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"48582:1275:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;48582:1275:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"48582:1275:0:-:0;;;;;;;;","abiDefinition":[{"inputs":[{"internalType":"uint16","name":"version","type":"uint16"}],"name":"AppConfigLib__IncorrectVersion","type":"error"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"version\",\"type\":\"uint16\"}],\"name\":\"AppConfigLib__IncorrectVersion\",\"type\":\"error\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainClientV1.sol\":\"AppConfigLib\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainClientV1.sol\":{\"keccak256\":\"0xe270686a9bca05b4013610a4e8bb08040de32a0442edd218e1692edaca94e40e\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://727e84146369613e04e57a677f8bc6c709ee145df3eeb79f15ea5a922198d78f\",\"dweb:/ipfs/QmUXh2nDtHBnhYZSwCxcteN4be13S7dR9GbqqHT9mUxta3\"]}},\"version\":1}"},"hashes":{}},"solidity/InterchainClientV1.sol:Context":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainClientV1Events.sol\n\nabstract contract InterchainClientV1Events {\n    event ExecutionFeesSet(address executionFees);\n    event LinkedClientSet(uint64 chainId, bytes32 client);\n\n    // TODO: figure out indexing\n\n    event InterchainTransactionSent(\n        bytes32 indexed transactionId,\n        uint64 indexed dbNonce,\n        uint64 indexed entryIndex,\n        uint64 dstChainId,\n        bytes32 srcSender,\n        bytes32 dstReceiver,\n        uint256 verificationFee,\n        uint256 executionFee,\n        bytes options,\n        bytes message\n    );\n\n    event InterchainTransactionReceived(\n        bytes32 indexed transactionId,\n        uint64 indexed dbNonce,\n        uint64 indexed entryIndex,\n        uint64 srcChainId,\n        bytes32 srcSender,\n        bytes32 dstReceiver\n    );\n\n    event ExecutionProofWritten(\n        bytes32 indexed transactionId, uint64 indexed dbNonce, uint64 indexed entryIndex, address executor\n    );\n}\n\n// contracts/interfaces/IExecutionFees.sol\n\ninterface IExecutionFees {\n    error ExecutionFees__AlreadyRecorded(uint64 dstChainId, bytes32 transactionId, address executor);\n    error ExecutionFees__ZeroAddress();\n    error ExecutionFees__ZeroAmount();\n\n    /// @notice Add the execution fee for a transaction. The attached value will be added to the\n    /// rewards for the executor completing the transaction.\n    /// Note: this could be used to store the execution fee for a new transaction, or to add more\n    /// funds to the execution fee of an existing transaction. Therefore this function is payable,\n    /// and does not implement any caller restrictions.\n    /// @dev Will revert if the executor is already recorded for the transaction.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to add the execution fee to.\n    function addExecutionFee(uint64 dstChainId, bytes32 transactionId) external payable;\n\n    /// @notice Record the executor (who completed the transaction) for a transaction,\n    /// and update the accumulated rewards for the executor.\n    /// @dev Could only be called by the Recorder.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to record the executor for.\n    /// @param executor             The address of the executor who completed the transaction.\n    function recordExecutor(uint64 dstChainId, bytes32 transactionId, address executor) external;\n\n    /// @notice Allows the executor to claim their unclaimed rewards.\n    /// @dev Will revert if the executor has no unclaimed rewards.\n    function claimExecutionFees(address executor) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the accumulated rewards for an executor.\n    /// @param executor             The address of the executor to get the rewards for.\n    function accumulatedRewards(address executor) external view returns (uint256 accumulated);\n\n    /// @notice Get the unclaimed rewards for an executor.\n    /// @param executor             The address of the executor to get the rewards for.\n    function unclaimedRewards(address executor) external view returns (uint256 unclaimed);\n\n    /// @notice Get the total execution fee for a transaction.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to get the execution fee for.\n    function executionFee(uint64 dstChainId, bytes32 transactionId) external view returns (uint256 fee);\n\n    /// @notice Get the address of the recorded executor for a transaction.\n    /// @dev Will return address(0) if the executor is not recorded.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to get the recorded executor for.\n    function recordedExecutor(uint64 dstChainId, bytes32 transactionId) external view returns (address executor);\n}\n\n// contracts/interfaces/IExecutionService.sol\n\ninterface IExecutionService {\n    /// @notice Request the execution of an Interchain Transaction on a remote chain.\n    /// Note: the off-chain actor needs to fetch the transaction payload from the InterchainClient\n    /// event with the same transactionId, then execute the transaction on the remote chain:\n    /// `dstInterchainClient.executeTransaction(transactionPayload)`\n    /// Once the execution is confirmed on the source chain, the off-chain actor will be able\n    /// to claim `executionFee` in the ExecutionFees contract.\n    /// @dev Could only be called by `InterchainClient` contracts.\n    /// Will revert if the execution fee is not big enough.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param txPayloadSize        The size of the transaction payload to use for the execution.\n    /// @param transactionId        The id of the transaction to execute.\n    /// @param executionFee         The fee paid for the execution.\n    /// @param options              The options to use for the execution.\n    function requestExecution(\n        uint64 dstChainId,\n        uint256 txPayloadSize,\n        bytes32 transactionId,\n        uint256 executionFee,\n        bytes memory options\n    )\n        external;\n\n    /// @notice Get the address of the EOA account that will be used to execute transactions on the\n    /// remote chains.\n    function executorEOA() external view returns (address);\n\n    /// @notice Get the execution fee for executing an Interchain Transaction on a remote chain.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param txPayloadSize        The size of the transaction payload to use for the execution.\n    /// @param options              The options to use for the execution.\n    function getExecutionFee(\n        uint64 dstChainId,\n        uint256 txPayloadSize,\n        bytes memory options\n    )\n        external\n        view\n        returns (uint256);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    /// @notice Allows the Interchain Client to pass the message to the Interchain App.\n    /// @dev App is responsible for keeping track of interchain clients, and must verify the message sender.\n    /// @param srcChainId   Chain ID of the source chain, where the message was sent from.\n    /// @param sender       Sender address on the source chain, as a bytes32 value.\n    /// @param dbNonce      The Interchain DB nonce of the batch containing the message entry.\n    /// @param entryIndex   The index of the message entry within the batch.\n    /// @param message      The message being sent.\n    function appReceive(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /// @notice Returns the verification configuration of the Interchain App.\n    /// @dev This configuration is used by the Interchain Client to verify that message has been confirmed\n    /// by the Interchain Modules on the destination chain.\n    /// Note: V1 version of AppConfig includes the required responses count, and optimistic period after which\n    /// the message is considered confirmed by the module. Following versions may include additional fields.\n    /// @return appConfig    The versioned configuration of the Interchain App, encoded as bytes.\n    /// @return modules      The list of Interchain Modules that app is trusting to confirm the messages.\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/Math.sol\n\nlibrary MathLib {\n    /// @notice Rounds up to the nearest multiple of 32.\n    /// Note: Returns zero on overflows instead of reverting. This is fine for practical\n    /// use cases, as this is used for determining the size of the payload in memory.\n    function roundUpToWord(uint256 x) internal pure returns (uint256) {\n        unchecked {\n            return (x + 31) \u0026 ~uint256(31);\n        }\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/VersionedPayload.sol\n\n// solhint-disable no-inline-assembly\n// solhint-disable ordering\nlibrary VersionedPayloadLib {\n    /// @notice Amount of bytes reserved for the version (uint16) in the versioned payload\n    uint256 internal constant VERSION_LENGTH = 2;\n\n    error VersionedPayload__TooShort(bytes versionedPayload);\n    error VersionedPayload__PrecompileFailed();\n\n    /// @notice Encodes the versioned payload into a single bytes array.\n    /// @param version  The payload's version.\n    /// @param payload  The payload to encode.\n    function encodeVersionedPayload(uint16 version, bytes memory payload) internal pure returns (bytes memory) {\n        return abi.encodePacked(version, payload);\n    }\n\n    /// @notice Extracts the version from the versioned payload (calldata reference).\n    /// @param versionedPayload     The versioned payload (calldata reference).\n    function getVersion(bytes calldata versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            version := shr(240, calldataload(versionedPayload.offset))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (calldata reference).\n    /// @dev The extracted payload is also returned as a calldata reference.\n    /// @param versionedPayload     The versioned payload.\n    function getPayload(bytes calldata versionedPayload) internal pure returns (bytes calldata) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        return versionedPayload[VERSION_LENGTH:];\n    }\n\n    /// @notice Extracts the version from the versioned payload (memory reference).\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getVersionFromMemory(bytes memory versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            // We add 0x20 to skip the length of the bytes array.\n            version := shr(240, mload(add(versionedPayload, 0x20)))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (memory reference).\n    /// @dev The extracted payload is copied into a new memory location. Use `getPayload` when possible\n    /// to avoid extra memory allocation.\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getPayloadFromMemory(bytes memory versionedPayload) internal view returns (bytes memory payload) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        // Figure how many bytes to copy and allocate the memory for the extracted payload.\n        uint256 toCopy;\n        unchecked {\n            toCopy = versionedPayload.length - VERSION_LENGTH;\n        }\n        payload = new bytes(toCopy);\n        // Use identity precompile (0x04) to copy the payload. Unlike MCOPY, this is available on all EVM chains.\n        bool res;\n        assembly {\n            // We add 0x20 to skip the length of the bytes array.\n            // We add 0x02 to skip the 2 bytes reserved for the version.\n            // Copy the payload to the previously allocated memory.\n            res := staticcall(gas(), 0x04, add(versionedPayload, 0x22), toCopy, add(payload, 0x20), toCopy)\n        }\n        if (!res) {\n            revert VersionedPayload__PrecompileFailed();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SafeCast.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value \u003e type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value \u003e type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value \u003e type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value \u003e type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value \u003e type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value \u003e type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value \u003e type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value \u003e type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value \u003e type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value \u003e type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value \u003e type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value \u003e type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value \u003e type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value \u003e type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value \u003e type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value \u003e type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value \u003e type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value \u003e type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value \u003e type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value \u003e type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value \u003e type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value \u003e type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value \u003e type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value \u003e type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value \u003e type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value \u003e type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value \u003e type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value \u003e type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value \u003e type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value \u003e type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value \u003e type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value \u003c 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value \u003e uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal view returns (AppConfigV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (AppConfigV1));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal view returns (OptionsV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (OptionsV1));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(OPTIONS_V1, abi.encode(options));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/libs/InterchainBatch.sol\n\ntype BatchKey is uint128;\n\n/// @notice Struct representing a batch of entries in the Interchain DataBase.\n/// Batched entries are put together in a Merkle tree, which root is saved.\n/// Batch has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: batchRoot\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch\n/// @param batchRoot    The root of the Merkle tree containing the batched entries\nstruct InterchainBatch {\n    uint64 srcChainId;\n    uint64 dbNonce;\n    bytes32 batchRoot;\n}\n\nlibrary InterchainBatchLib {\n    using VersionedPayloadLib for bytes;\n\n    /// @notice Constructs an InterchainBatch struct to be saved on the local chain.\n    /// @param dbNonce      The database nonce of the batch\n    /// @param batchRoot    The root of the Merkle tree containing the batched entries\n    /// @return batch       The constructed InterchainBatch struct\n    function constructLocalBatch(\n        uint64 dbNonce,\n        bytes32 batchRoot\n    )\n        internal\n        view\n        returns (InterchainBatch memory batch)\n    {\n        return InterchainBatch({srcChainId: SafeCast.toUint64(block.chainid), dbNonce: dbNonce, batchRoot: batchRoot});\n    }\n\n    /// @notice Encodes the InterchainBatch struct into a non-versioned batch payload.\n    function encodeBatch(InterchainBatch memory batch) internal pure returns (bytes memory) {\n        return abi.encode(encodeBatchKey(batch.srcChainId, batch.dbNonce), batch.batchRoot);\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in calldata.\n    function decodeBatch(bytes calldata data) internal pure returns (InterchainBatch memory batch) {\n        BatchKey key;\n        (key, batch.batchRoot) = abi.decode(data, (BatchKey, bytes32));\n        (batch.srcChainId, batch.dbNonce) = decodeBatchKey(key);\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in memory.\n    function decodeBatchFromMemory(bytes memory data) internal pure returns (InterchainBatch memory batch) {\n        BatchKey key;\n        (key, batch.batchRoot) = abi.decode(data, (BatchKey, bytes32));\n        (batch.srcChainId, batch.dbNonce) = decodeBatchKey(key);\n    }\n\n    /// @notice Encodes the uint128 key of the batch from uint64 srcChainId and uint64 dbNonce.\n    function encodeBatchKey(uint64 srcChainId, uint64 dbNonce) internal pure returns (BatchKey) {\n        return BatchKey.wrap((uint128(srcChainId) \u003c\u003c 64) | dbNonce);\n    }\n\n    /// @notice Decodes the uint128 key of the batch into uint64 srcChainId and uint64 dbNonce.\n    function decodeBatchKey(BatchKey key) internal pure returns (uint64 srcChainId, uint64 dbNonce) {\n        srcChainId = uint64(BatchKey.unwrap(key) \u003e\u003e 64);\n        dbNonce = uint64(BatchKey.unwrap(key));\n    }\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce + entryIndex\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch containing the entry\n/// @param entryIndex   The index of the entry in the batch\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint64 srcChainId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nusing InterchainEntryLib for InterchainEntry global;\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint64 dbNonce,\n        uint64 entryIndex,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: SafeCast.toUint64(block.chainid),\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n}\n\n// contracts/libs/InterchainTransaction.sol\n\ntype ICTxHeader is uint256;\n\nstruct InterchainTransaction {\n    uint64 srcChainId;\n    uint64 dstChainId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcSender;\n    bytes32 dstReceiver;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    using MathLib for uint256;\n    using VersionedPayloadLib for bytes;\n\n    function constructLocalTransaction(\n        address srcSender,\n        uint64 dstChainId,\n        bytes32 dstReceiver,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: SafeCast.toUint64(block.chainid),\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            encodeTxHeader(transaction.srcChainId, transaction.dstChainId, transaction.dbNonce, transaction.entryIndex),\n            transaction.srcSender,\n            transaction.dstReceiver,\n            transaction.options,\n            transaction.message\n        );\n    }\n\n    function decodeTransaction(bytes calldata transaction) internal pure returns (InterchainTransaction memory icTx) {\n        ICTxHeader header;\n        (header, icTx.srcSender, icTx.dstReceiver, icTx.options, icTx.message) =\n            abi.decode(transaction, (ICTxHeader, bytes32, bytes32, bytes, bytes));\n        (icTx.srcChainId, icTx.dstChainId, icTx.dbNonce, icTx.entryIndex) = decodeTxHeader(header);\n    }\n\n    function payloadSize(uint256 optionsLen, uint256 messageLen) internal pure returns (uint256) {\n        // 2 bytes are reserved for the transaction version\n        // + 5 fields * 32 bytes (3 values for static, 2 offsets for dynamic) + 2 * 32 bytes (lengths for dynamic) = 226\n        // (srcChainId, dstChainId, dbNonce, entryIndex) are merged into a single 32 bytes field\n        // Both options and message are dynamic fields, which are padded up to 32 bytes\n        return 226 + optionsLen.roundUpToWord() + messageLen.roundUpToWord();\n    }\n\n    function encodeTxHeader(\n        uint64 srcChainId,\n        uint64 dstChainId,\n        uint64 dbNonce,\n        uint64 entryIndex\n    )\n        internal\n        pure\n        returns (ICTxHeader)\n    {\n        return ICTxHeader.wrap(\n            (uint256(srcChainId) \u003c\u003c 192) | (uint256(dstChainId) \u003c\u003c 128) | (uint256(dbNonce) \u003c\u003c 64) | uint256(entryIndex)\n        );\n    }\n\n    function decodeTxHeader(ICTxHeader header)\n        internal\n        pure\n        returns (uint64 srcChainId, uint64 dstChainId, uint64 dbNonce, uint64 entryIndex)\n    {\n        srcChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 192);\n        dstChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 128);\n        dbNonce = uint64(ICTxHeader.unwrap(header) \u003e\u003e 64);\n        entryIndex = uint64(ICTxHeader.unwrap(header));\n    }\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint64 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__InvalidTransactionVersion(uint16 version);\n    error InterchainClientV1__NoLinkedClient(uint64 chainId);\n    error InterchainClientV1__NotEnoughGasSupplied();\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint64 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint64 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint64 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint64 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param messageLen           The length of the message being sent.\n    function getInterchainFee(\n        uint64 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        uint256 messageLen\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint64 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint64 chainId) external view returns (address);\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing a batch of entries from the remote Interchain DataBase,\n    /// verified by the Interchain Module.\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param batchRoot    The Merkle root of the batch\n    struct RemoteBatch {\n        uint256 verifiedAt;\n        bytes32 batchRoot;\n    }\n\n    error InterchainDB__BatchDoesNotExist(uint64 dbNonce);\n    error InterchainDB__BatchNotFinalized(uint64 dbNonce);\n    error InterchainDB__ConflictingBatches(address module, bytes32 existingBatchRoot, InterchainBatch newBatch);\n    error InterchainDB__EntryIndexOutOfRange(uint64 dbNonce, uint64 entryIndex, uint64 batchSize);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__InvalidBatchVersion(uint16 version);\n    error InterchainDB__InvalidEntryRange(uint64 dbNonce, uint64 start, uint64 end);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId(uint64 chainId);\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `requestBatchVerification` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntry(bytes32 dataHash) external returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Request the given Interchain Modules to verify an existing batch.\n    /// If the batch is not finalized, the module will verify it after finalization.\n    /// For the finalized batch the batch root is already available, and the module can verify it immediately.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any batch.\n    /// @dev Will revert if the batch with the given nonce does not exist.\n    /// @param dstChainId    The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the existing batch\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestBatchVerification(\n        uint64 dstChainId,\n        uint64 dbNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Then request the Interchain Modules to verify the batch containing the written entry on the destination chain.\n    /// See `writeEntry` and `requestBatchVerification` for more details.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntryWithVerification(\n        uint64 dstChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Allows the Interchain Module to verify the batch coming from the remote chain.\n    /// Note: The DB will only accept the batch of the same version as the DB itself.\n    /// @param versionedBatch   The versioned Interchain Batch to verify\n    function verifyRemoteBatch(bytes memory versionedBatch) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint64 dstChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce.\n    /// Note: the leafs are ordered by the index of the written entry in the current batch,\n    /// and the leafs value match the value of the written entry (srcWriter + dataHash hashed together).\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchLeafs(uint64 dbNonce) external view returns (bytes32[] memory);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce,\n    /// paginated by the given start and end indexes. The end index is exclusive.\n    /// Note: this is useful when the batch contains a large number of leafs, and calling `getBatchLeafs`\n    /// would result in a gas limit exceeded error.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the provided range is invalid.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param start        The start index of the paginated leafs, inclusive\n    /// @param end          The end index of the paginated leafs, exclusive\n    function getBatchLeafsPaginated(\n        uint64 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory);\n\n    /// @notice Returns the size of the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchSize(uint64 dbNonce) external view returns (uint64);\n\n    /// @notice Get the finalized Interchain Batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatch(uint64 dbNonce) external view returns (InterchainBatch memory);\n\n    /// @notice Get the Interchain Entry's value written on the local chain with the given batch nonce and entry index.\n    /// Entry value is calculated as the hash of the writer address and the written data hash.\n    /// Note: the batch does not have to be finalized to fetch the entry value.\n    /// @dev Will revert if the batch with the given nonce does not exist,\n    /// or the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the existing batch\n    /// @param entryIndex   The index of the written entry within the batch\n    function getEntryValue(uint64 dbNonce, uint64 entryIndex) external view returns (bytes32);\n\n    /// @notice Get the Merkle proof of inclusion for the entry with the given index\n    /// in the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param entryIndex   The index of the written entry within the batch\n    /// @return proof       The Merkle proof of inclusion for the entry\n    function getEntryProof(uint64 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof);\n\n    /// @notice Get the nonce of the database, which is incremented every time a new batch is finalized.\n    /// This is the nonce of the current non-finalized batch.\n    function getDBNonce() external view returns (uint64);\n\n    /// @notice Get the index of the next entry to be written to the database.\n    /// @return dbNonce      The database nonce of the batch including the next entry\n    /// @return entryIndex   The index of the next entry within that batch\n    function getNextEntryIndex() external view returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or ZERO if the module has not verified the entry.\n    function checkVerification(\n        address dstModule,\n        InterchainEntry memory entry,\n        bytes32[] memory proof\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n\n    /// @notice Get the version of the Interchain DataBase.\n    // solhint-disable-next-line func-name-mixedcase\n    function DB_VERSION() external pure returns (uint16);\n}\n\n// contracts/InterchainClientV1.sol\n\n/**\n * @title InterchainClientV1\n * @dev Implements the operations of the Interchain Execution Layer.\n */\ncontract InterchainClientV1 is Ownable, InterchainClientV1Events, IInterchainClientV1 {\n    using AppConfigLib for bytes;\n    using OptionsLib for bytes;\n    using VersionedPayloadLib for bytes;\n\n    /// @notice Version of the InterchainClient contract. Sent and received transactions must have the same version.\n    uint16 public constant CLIENT_VERSION = 1;\n\n    /// @notice Address of the InterchainDB contract, set at the time of deployment.\n    address public immutable INTERCHAIN_DB;\n\n    /// @notice Address of the contract that handles execution fees. Can be updated by the owner.\n    address public executionFees;\n\n    /// @dev Address of the InterchainClient contract on the remote chain\n    mapping(uint64 chainId =\u003e bytes32 remoteClient) internal _linkedClient;\n    /// @dev Executor address that completed the transaction. Address(0) if not executed yet.\n    mapping(bytes32 transactionId =\u003e address executor) internal _txExecutor;\n\n    constructor(address interchainDB, address owner_) Ownable(owner_) {\n        INTERCHAIN_DB = interchainDB;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function setExecutionFees(address executionFees_) external onlyOwner {\n        executionFees = executionFees_;\n        emit ExecutionFeesSet(executionFees_);\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function setLinkedClient(uint64 chainId, bytes32 client) external onlyOwner {\n        _linkedClient[chainId] = client;\n        emit LinkedClientSet(chainId, client);\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _interchainSend(dstChainId, receiver, srcExecutionService, srcModules, options, message);\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function interchainSendEVM(\n        uint64 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc)\n    {\n        bytes32 receiverBytes32 = TypeCasts.addressToBytes32(receiver);\n        return _interchainSend(dstChainId, receiverBytes32, srcExecutionService, srcModules, options, message);\n    }\n\n    // TODO: Handle the case where receiver does not implement the IInterchainApp interface (or does not exist at all)\n    // @inheritdoc IInterchainClientV1\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable\n    {\n        InterchainTransaction memory icTx = _assertCorrectVersion(transaction);\n        bytes32 transactionId = keccak256(transaction);\n        _assertExecutable(icTx, transactionId, proof);\n        _txExecutor[transactionId] = msg.sender;\n\n        OptionsV1 memory decodedOptions = icTx.options.decodeOptionsV1();\n        if (msg.value != decodedOptions.gasAirdrop) {\n            revert InterchainClientV1__IncorrectMsgValue(msg.value, decodedOptions.gasAirdrop);\n        }\n        // We should always use at least as much as the requested gas limit.\n        // The executor can specify a higher gas limit if they wanted.\n        if (decodedOptions.gasLimit \u003e gasLimit) gasLimit = decodedOptions.gasLimit;\n        // Check the the Executor has provided big enough gas limit for the whole transaction.\n        if (gasleft() \u003c= gasLimit) {\n            revert InterchainClientV1__NotEnoughGasSupplied();\n        }\n        // Pass the full msg.value to the app: we have already checked that it matches the requested gas airdrop.\n        IInterchainApp(TypeCasts.bytes32ToAddress(icTx.dstReceiver)).appReceive{gas: gasLimit, value: msg.value}({\n            srcChainId: icTx.srcChainId,\n            sender: icTx.srcSender,\n            dbNonce: icTx.dbNonce,\n            entryIndex: icTx.entryIndex,\n            message: icTx.message\n        });\n        emit InterchainTransactionReceived(\n            transactionId, icTx.dbNonce, icTx.entryIndex, icTx.srcChainId, icTx.srcSender, icTx.dstReceiver\n        );\n    }\n\n    /// @inheritdoc IInterchainClientV1\n    function writeExecutionProof(bytes32 transactionId) external returns (uint64 dbNonce, uint64 entryIndex) {\n        address executor = _txExecutor[transactionId];\n        if (executor == address(0)) {\n            revert InterchainClientV1__TxNotExecuted(transactionId);\n        }\n        bytes memory proof = abi.encode(transactionId, executor);\n        (dbNonce, entryIndex) = IInterchainDB(INTERCHAIN_DB).writeEntry(keccak256(proof));\n        emit ExecutionProofWritten(transactionId, dbNonce, entryIndex, executor);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // @inheritdoc IInterchainClientV1\n    function isExecutable(bytes calldata encodedTx, bytes32[] calldata proof) external view returns (bool) {\n        InterchainTransaction memory icTx = _assertCorrectVersion(encodedTx);\n        // Check that options could be decoded\n        icTx.options.decodeOptionsV1();\n        bytes32 transactionId = keccak256(encodedTx);\n        _assertExecutable(icTx, transactionId, proof);\n        return true;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function getExecutor(bytes calldata encodedTx) external view returns (address) {\n        return _txExecutor[keccak256(encodedTx)];\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function getExecutorById(bytes32 transactionId) external view returns (address) {\n        return _txExecutor[transactionId];\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function getInterchainFee(\n        uint64 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        uint256 messageLen\n    )\n        external\n        view\n        returns (uint256 fee)\n    {\n        _assertLinkedClient(dstChainId);\n        // Check that options could be decoded on destination chain\n        options.decodeOptionsV1();\n        // Verification fee from InterchainDB\n        fee = IInterchainDB(INTERCHAIN_DB).getInterchainFee(dstChainId, srcModules);\n        // Add execution fee, if ExecutionService is provided\n        if (srcExecutionService != address(0)) {\n            uint256 payloadSize = InterchainTransactionLib.payloadSize(options.length, messageLen);\n            fee += IExecutionService(srcExecutionService).getExecutionFee(dstChainId, payloadSize, options);\n        }\n    }\n\n    /// @inheritdoc IInterchainClientV1\n    function getLinkedClient(uint64 chainId) external view returns (bytes32) {\n        if (chainId == block.chainid) {\n            revert InterchainClientV1__NotRemoteChainId(chainId);\n        }\n        return _linkedClient[chainId];\n    }\n\n    /// @inheritdoc IInterchainClientV1\n    function getLinkedClientEVM(uint64 chainId) external view returns (address linkedClientEVM) {\n        if (chainId == block.chainid) {\n            revert InterchainClientV1__NotRemoteChainId(chainId);\n        }\n        bytes32 linkedClient = _linkedClient[chainId];\n        linkedClientEVM = TypeCasts.bytes32ToAddress(linkedClient);\n        // Check that the linked client address fits into the EVM address space\n        if (TypeCasts.addressToBytes32(linkedClientEVM) != linkedClient) {\n            revert InterchainClientV1__NotEVMClient(linkedClient);\n        }\n    }\n\n    /// @notice Decodes the encoded options data into a OptionsV1 struct.\n    function decodeOptions(bytes memory encodedOptions) external view returns (OptionsV1 memory) {\n        return encodedOptions.decodeOptionsV1();\n    }\n\n    /// @notice Encodes the transaction data into a bytes format.\n    function encodeTransaction(InterchainTransaction memory icTx) public pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload({\n            version: CLIENT_VERSION,\n            payload: InterchainTransactionLib.encodeTransaction(icTx)\n        });\n    }\n\n    // ═════════════════════════════════════════════════ INTERNAL ══════════════════════════════════════════════════════\n\n    /// @dev Internal logic for sending a message to another chain.\n    function _interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        _assertLinkedClient(dstChainId);\n        if (receiver == 0) revert InterchainClientV1__ZeroReceiver();\n        // Check that options could be decoded on destination chain\n        options.decodeOptionsV1();\n        uint256 verificationFee = IInterchainDB(INTERCHAIN_DB).getInterchainFee(dstChainId, srcModules);\n        if (msg.value \u003c verificationFee) {\n            revert InterchainClientV1__FeeAmountTooLow(msg.value, verificationFee);\n        }\n        (desc.dbNonce, desc.entryIndex) = IInterchainDB(INTERCHAIN_DB).getNextEntryIndex();\n        InterchainTransaction memory icTx = InterchainTransactionLib.constructLocalTransaction({\n            srcSender: msg.sender,\n            dstReceiver: receiver,\n            dstChainId: dstChainId,\n            dbNonce: desc.dbNonce,\n            entryIndex: desc.entryIndex,\n            options: options,\n            message: message\n        });\n        desc.transactionId = keccak256(encodeTransaction(icTx));\n        // Sanity check: nonce returned from DB should match the nonce used to construct the transaction\n        {\n            (uint64 dbNonce, uint64 entryIndex) = IInterchainDB(INTERCHAIN_DB).writeEntryWithVerification{\n                value: verificationFee\n            }(icTx.dstChainId, desc.transactionId, srcModules);\n            assert(dbNonce == desc.dbNonce \u0026\u0026 entryIndex == desc.entryIndex);\n        }\n        uint256 executionFee;\n        unchecked {\n            executionFee = msg.value - verificationFee;\n        }\n        if (executionFee \u003e 0) {\n            IExecutionFees(executionFees).addExecutionFee{value: executionFee}(icTx.dstChainId, desc.transactionId);\n        }\n        // TODO: consider disallowing the use of empty srcExecutionService\n        if (srcExecutionService != address(0)) {\n            IExecutionService(srcExecutionService).requestExecution({\n                dstChainId: dstChainId,\n                txPayloadSize: InterchainTransactionLib.payloadSize(options.length, message.length),\n                transactionId: desc.transactionId,\n                executionFee: executionFee,\n                options: options\n            });\n            address srcExecutorEOA = IExecutionService(srcExecutionService).executorEOA();\n            IExecutionFees(executionFees).recordExecutor(icTx.dstChainId, desc.transactionId, srcExecutorEOA);\n        }\n        emit InterchainTransactionSent(\n            desc.transactionId,\n            icTx.dbNonce,\n            icTx.entryIndex,\n            icTx.dstChainId,\n            icTx.srcSender,\n            icTx.dstReceiver,\n            verificationFee,\n            executionFee,\n            icTx.options,\n            icTx.message\n        );\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Asserts that the transaction is executable.\n    function _assertExecutable(\n        InterchainTransaction memory icTx,\n        bytes32 transactionId,\n        bytes32[] calldata proof\n    )\n        internal\n        view\n    {\n        bytes32 linkedClient = _assertLinkedClient(icTx.srcChainId);\n        if (icTx.dstChainId != block.chainid) {\n            revert InterchainClientV1__IncorrectDstChainId(icTx.dstChainId);\n        }\n        if (_txExecutor[transactionId] != address(0)) {\n            revert InterchainClientV1__TxAlreadyExecuted(transactionId);\n        }\n        // Construct expected entry based on icTransaction data\n        InterchainEntry memory icEntry = InterchainEntry({\n            srcChainId: icTx.srcChainId,\n            dbNonce: icTx.dbNonce,\n            entryIndex: icTx.entryIndex,\n            srcWriter: linkedClient,\n            dataHash: transactionId\n        });\n        (bytes memory encodedAppConfig, address[] memory approvedDstModules) =\n            IInterchainApp(TypeCasts.bytes32ToAddress(icTx.dstReceiver)).getReceivingConfig();\n        AppConfigV1 memory appConfig = encodedAppConfig.decodeAppConfigV1();\n        if (appConfig.requiredResponses == 0) {\n            revert InterchainClientV1__ZeroRequiredResponses();\n        }\n        uint256 responses = _getFinalizedResponsesCount(approvedDstModules, icEntry, proof, appConfig.optimisticPeriod);\n        if (responses \u003c appConfig.requiredResponses) {\n            revert InterchainClientV1__NotEnoughResponses(responses, appConfig.requiredResponses);\n        }\n    }\n\n    /// @dev Asserts that the chain is linked and returns the linked client address.\n    function _assertLinkedClient(uint64 chainId) internal view returns (bytes32 linkedClient) {\n        if (chainId == block.chainid) {\n            revert InterchainClientV1__NotRemoteChainId(chainId);\n        }\n        linkedClient = _linkedClient[chainId];\n        if (linkedClient == 0) {\n            revert InterchainClientV1__NoLinkedClient(chainId);\n        }\n    }\n\n    /**\n     * @dev Calculates the number of responses that are considered finalized within the optimistic time period.\n     * @param approvedModules       Approved modules that could have confirmed the entry.\n     * @param icEntry               The InterchainEntry to confirm.\n     * @param optimisticPeriod      The time period in seconds within which a response is considered valid.\n     * @return finalizedResponses   The count of responses that are finalized within the optimistic time period.\n     */\n    function _getFinalizedResponsesCount(\n        address[] memory approvedModules,\n        InterchainEntry memory icEntry,\n        bytes32[] calldata proof,\n        uint256 optimisticPeriod\n    )\n        internal\n        view\n        returns (uint256 finalizedResponses)\n    {\n        for (uint256 i = 0; i \u003c approvedModules.length; ++i) {\n            uint256 confirmedAt = IInterchainDB(INTERCHAIN_DB).checkVerification(approvedModules[i], icEntry, proof);\n            // checkVerification() returns 0 if entry hasn't been confirmed by the module, so we check for that as well\n            if (confirmedAt != 0 \u0026\u0026 confirmedAt + optimisticPeriod \u003c block.timestamp) {\n                ++finalizedResponses;\n            }\n        }\n    }\n\n    /// @dev Asserts that the transaction version is correct. Returns the decoded transaction for chaining purposes.\n    function _assertCorrectVersion(bytes calldata versionedTx)\n        internal\n        pure\n        returns (InterchainTransaction memory icTx)\n    {\n        uint16 version = versionedTx.getVersion();\n        if (version != CLIENT_VERSION) {\n            revert InterchainClientV1__InvalidTransactionVersion(version);\n        }\n        icTx = InterchainTransactionLib.decodeTransaction(versionedTx.getPayload());\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"details":"Provides information about the current execution context, including the sender of the transaction and its data. While these are generally available via msg.sender and msg.data, they should not be accessed in such a direct manner, since when dealing with meta-transactions the account sending and paying for execution may not be the actual sender (as far as an application is concerned). This contract is only required for intermediate, library-like contracts.","kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"details\":\"Provides information about the current execution context, including the sender of the transaction and its data. While these are generally available via msg.sender and msg.data, they should not be accessed in such a direct manner, since when dealing with meta-transactions the account sending and paying for execution may not be the actual sender (as far as an application is concerned). This contract is only required for intermediate, library-like contracts.\",\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainClientV1.sol\":\"Context\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainClientV1.sol\":{\"keccak256\":\"0xe270686a9bca05b4013610a4e8bb08040de32a0442edd218e1692edaca94e40e\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://727e84146369613e04e57a677f8bc6c709ee145df3eeb79f15ea5a922198d78f\",\"dweb:/ipfs/QmUXh2nDtHBnhYZSwCxcteN4be13S7dR9GbqqHT9mUxta3\"]}},\"version\":1}"},"hashes":{}},"solidity/InterchainClientV1.sol:IExecutionFees":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainClientV1Events.sol\n\nabstract contract InterchainClientV1Events {\n    event ExecutionFeesSet(address executionFees);\n    event LinkedClientSet(uint64 chainId, bytes32 client);\n\n    // TODO: figure out indexing\n\n    event InterchainTransactionSent(\n        bytes32 indexed transactionId,\n        uint64 indexed dbNonce,\n        uint64 indexed entryIndex,\n        uint64 dstChainId,\n        bytes32 srcSender,\n        bytes32 dstReceiver,\n        uint256 verificationFee,\n        uint256 executionFee,\n        bytes options,\n        bytes message\n    );\n\n    event InterchainTransactionReceived(\n        bytes32 indexed transactionId,\n        uint64 indexed dbNonce,\n        uint64 indexed entryIndex,\n        uint64 srcChainId,\n        bytes32 srcSender,\n        bytes32 dstReceiver\n    );\n\n    event ExecutionProofWritten(\n        bytes32 indexed transactionId, uint64 indexed dbNonce, uint64 indexed entryIndex, address executor\n    );\n}\n\n// contracts/interfaces/IExecutionFees.sol\n\ninterface IExecutionFees {\n    error ExecutionFees__AlreadyRecorded(uint64 dstChainId, bytes32 transactionId, address executor);\n    error ExecutionFees__ZeroAddress();\n    error ExecutionFees__ZeroAmount();\n\n    /// @notice Add the execution fee for a transaction. The attached value will be added to the\n    /// rewards for the executor completing the transaction.\n    /// Note: this could be used to store the execution fee for a new transaction, or to add more\n    /// funds to the execution fee of an existing transaction. Therefore this function is payable,\n    /// and does not implement any caller restrictions.\n    /// @dev Will revert if the executor is already recorded for the transaction.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to add the execution fee to.\n    function addExecutionFee(uint64 dstChainId, bytes32 transactionId) external payable;\n\n    /// @notice Record the executor (who completed the transaction) for a transaction,\n    /// and update the accumulated rewards for the executor.\n    /// @dev Could only be called by the Recorder.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to record the executor for.\n    /// @param executor             The address of the executor who completed the transaction.\n    function recordExecutor(uint64 dstChainId, bytes32 transactionId, address executor) external;\n\n    /// @notice Allows the executor to claim their unclaimed rewards.\n    /// @dev Will revert if the executor has no unclaimed rewards.\n    function claimExecutionFees(address executor) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the accumulated rewards for an executor.\n    /// @param executor             The address of the executor to get the rewards for.\n    function accumulatedRewards(address executor) external view returns (uint256 accumulated);\n\n    /// @notice Get the unclaimed rewards for an executor.\n    /// @param executor             The address of the executor to get the rewards for.\n    function unclaimedRewards(address executor) external view returns (uint256 unclaimed);\n\n    /// @notice Get the total execution fee for a transaction.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to get the execution fee for.\n    function executionFee(uint64 dstChainId, bytes32 transactionId) external view returns (uint256 fee);\n\n    /// @notice Get the address of the recorded executor for a transaction.\n    /// @dev Will return address(0) if the executor is not recorded.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to get the recorded executor for.\n    function recordedExecutor(uint64 dstChainId, bytes32 transactionId) external view returns (address executor);\n}\n\n// contracts/interfaces/IExecutionService.sol\n\ninterface IExecutionService {\n    /// @notice Request the execution of an Interchain Transaction on a remote chain.\n    /// Note: the off-chain actor needs to fetch the transaction payload from the InterchainClient\n    /// event with the same transactionId, then execute the transaction on the remote chain:\n    /// `dstInterchainClient.executeTransaction(transactionPayload)`\n    /// Once the execution is confirmed on the source chain, the off-chain actor will be able\n    /// to claim `executionFee` in the ExecutionFees contract.\n    /// @dev Could only be called by `InterchainClient` contracts.\n    /// Will revert if the execution fee is not big enough.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param txPayloadSize        The size of the transaction payload to use for the execution.\n    /// @param transactionId        The id of the transaction to execute.\n    /// @param executionFee         The fee paid for the execution.\n    /// @param options              The options to use for the execution.\n    function requestExecution(\n        uint64 dstChainId,\n        uint256 txPayloadSize,\n        bytes32 transactionId,\n        uint256 executionFee,\n        bytes memory options\n    )\n        external;\n\n    /// @notice Get the address of the EOA account that will be used to execute transactions on the\n    /// remote chains.\n    function executorEOA() external view returns (address);\n\n    /// @notice Get the execution fee for executing an Interchain Transaction on a remote chain.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param txPayloadSize        The size of the transaction payload to use for the execution.\n    /// @param options              The options to use for the execution.\n    function getExecutionFee(\n        uint64 dstChainId,\n        uint256 txPayloadSize,\n        bytes memory options\n    )\n        external\n        view\n        returns (uint256);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    /// @notice Allows the Interchain Client to pass the message to the Interchain App.\n    /// @dev App is responsible for keeping track of interchain clients, and must verify the message sender.\n    /// @param srcChainId   Chain ID of the source chain, where the message was sent from.\n    /// @param sender       Sender address on the source chain, as a bytes32 value.\n    /// @param dbNonce      The Interchain DB nonce of the batch containing the message entry.\n    /// @param entryIndex   The index of the message entry within the batch.\n    /// @param message      The message being sent.\n    function appReceive(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /// @notice Returns the verification configuration of the Interchain App.\n    /// @dev This configuration is used by the Interchain Client to verify that message has been confirmed\n    /// by the Interchain Modules on the destination chain.\n    /// Note: V1 version of AppConfig includes the required responses count, and optimistic period after which\n    /// the message is considered confirmed by the module. Following versions may include additional fields.\n    /// @return appConfig    The versioned configuration of the Interchain App, encoded as bytes.\n    /// @return modules      The list of Interchain Modules that app is trusting to confirm the messages.\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/Math.sol\n\nlibrary MathLib {\n    /// @notice Rounds up to the nearest multiple of 32.\n    /// Note: Returns zero on overflows instead of reverting. This is fine for practical\n    /// use cases, as this is used for determining the size of the payload in memory.\n    function roundUpToWord(uint256 x) internal pure returns (uint256) {\n        unchecked {\n            return (x + 31) \u0026 ~uint256(31);\n        }\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/VersionedPayload.sol\n\n// solhint-disable no-inline-assembly\n// solhint-disable ordering\nlibrary VersionedPayloadLib {\n    /// @notice Amount of bytes reserved for the version (uint16) in the versioned payload\n    uint256 internal constant VERSION_LENGTH = 2;\n\n    error VersionedPayload__TooShort(bytes versionedPayload);\n    error VersionedPayload__PrecompileFailed();\n\n    /// @notice Encodes the versioned payload into a single bytes array.\n    /// @param version  The payload's version.\n    /// @param payload  The payload to encode.\n    function encodeVersionedPayload(uint16 version, bytes memory payload) internal pure returns (bytes memory) {\n        return abi.encodePacked(version, payload);\n    }\n\n    /// @notice Extracts the version from the versioned payload (calldata reference).\n    /// @param versionedPayload     The versioned payload (calldata reference).\n    function getVersion(bytes calldata versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            version := shr(240, calldataload(versionedPayload.offset))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (calldata reference).\n    /// @dev The extracted payload is also returned as a calldata reference.\n    /// @param versionedPayload     The versioned payload.\n    function getPayload(bytes calldata versionedPayload) internal pure returns (bytes calldata) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        return versionedPayload[VERSION_LENGTH:];\n    }\n\n    /// @notice Extracts the version from the versioned payload (memory reference).\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getVersionFromMemory(bytes memory versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            // We add 0x20 to skip the length of the bytes array.\n            version := shr(240, mload(add(versionedPayload, 0x20)))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (memory reference).\n    /// @dev The extracted payload is copied into a new memory location. Use `getPayload` when possible\n    /// to avoid extra memory allocation.\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getPayloadFromMemory(bytes memory versionedPayload) internal view returns (bytes memory payload) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        // Figure how many bytes to copy and allocate the memory for the extracted payload.\n        uint256 toCopy;\n        unchecked {\n            toCopy = versionedPayload.length - VERSION_LENGTH;\n        }\n        payload = new bytes(toCopy);\n        // Use identity precompile (0x04) to copy the payload. Unlike MCOPY, this is available on all EVM chains.\n        bool res;\n        assembly {\n            // We add 0x20 to skip the length of the bytes array.\n            // We add 0x02 to skip the 2 bytes reserved for the version.\n            // Copy the payload to the previously allocated memory.\n            res := staticcall(gas(), 0x04, add(versionedPayload, 0x22), toCopy, add(payload, 0x20), toCopy)\n        }\n        if (!res) {\n            revert VersionedPayload__PrecompileFailed();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SafeCast.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value \u003e type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value \u003e type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value \u003e type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value \u003e type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value \u003e type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value \u003e type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value \u003e type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value \u003e type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value \u003e type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value \u003e type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value \u003e type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value \u003e type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value \u003e type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value \u003e type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value \u003e type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value \u003e type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value \u003e type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value \u003e type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value \u003e type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value \u003e type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value \u003e type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value \u003e type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value \u003e type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value \u003e type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value \u003e type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value \u003e type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value \u003e type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value \u003e type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value \u003e type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value \u003e type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value \u003e type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value \u003c 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value \u003e uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal view returns (AppConfigV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (AppConfigV1));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal view returns (OptionsV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (OptionsV1));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(OPTIONS_V1, abi.encode(options));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/libs/InterchainBatch.sol\n\ntype BatchKey is uint128;\n\n/// @notice Struct representing a batch of entries in the Interchain DataBase.\n/// Batched entries are put together in a Merkle tree, which root is saved.\n/// Batch has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: batchRoot\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch\n/// @param batchRoot    The root of the Merkle tree containing the batched entries\nstruct InterchainBatch {\n    uint64 srcChainId;\n    uint64 dbNonce;\n    bytes32 batchRoot;\n}\n\nlibrary InterchainBatchLib {\n    using VersionedPayloadLib for bytes;\n\n    /// @notice Constructs an InterchainBatch struct to be saved on the local chain.\n    /// @param dbNonce      The database nonce of the batch\n    /// @param batchRoot    The root of the Merkle tree containing the batched entries\n    /// @return batch       The constructed InterchainBatch struct\n    function constructLocalBatch(\n        uint64 dbNonce,\n        bytes32 batchRoot\n    )\n        internal\n        view\n        returns (InterchainBatch memory batch)\n    {\n        return InterchainBatch({srcChainId: SafeCast.toUint64(block.chainid), dbNonce: dbNonce, batchRoot: batchRoot});\n    }\n\n    /// @notice Encodes the InterchainBatch struct into a non-versioned batch payload.\n    function encodeBatch(InterchainBatch memory batch) internal pure returns (bytes memory) {\n        return abi.encode(encodeBatchKey(batch.srcChainId, batch.dbNonce), batch.batchRoot);\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in calldata.\n    function decodeBatch(bytes calldata data) internal pure returns (InterchainBatch memory batch) {\n        BatchKey key;\n        (key, batch.batchRoot) = abi.decode(data, (BatchKey, bytes32));\n        (batch.srcChainId, batch.dbNonce) = decodeBatchKey(key);\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in memory.\n    function decodeBatchFromMemory(bytes memory data) internal pure returns (InterchainBatch memory batch) {\n        BatchKey key;\n        (key, batch.batchRoot) = abi.decode(data, (BatchKey, bytes32));\n        (batch.srcChainId, batch.dbNonce) = decodeBatchKey(key);\n    }\n\n    /// @notice Encodes the uint128 key of the batch from uint64 srcChainId and uint64 dbNonce.\n    function encodeBatchKey(uint64 srcChainId, uint64 dbNonce) internal pure returns (BatchKey) {\n        return BatchKey.wrap((uint128(srcChainId) \u003c\u003c 64) | dbNonce);\n    }\n\n    /// @notice Decodes the uint128 key of the batch into uint64 srcChainId and uint64 dbNonce.\n    function decodeBatchKey(BatchKey key) internal pure returns (uint64 srcChainId, uint64 dbNonce) {\n        srcChainId = uint64(BatchKey.unwrap(key) \u003e\u003e 64);\n        dbNonce = uint64(BatchKey.unwrap(key));\n    }\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce + entryIndex\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch containing the entry\n/// @param entryIndex   The index of the entry in the batch\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint64 srcChainId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nusing InterchainEntryLib for InterchainEntry global;\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint64 dbNonce,\n        uint64 entryIndex,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: SafeCast.toUint64(block.chainid),\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n}\n\n// contracts/libs/InterchainTransaction.sol\n\ntype ICTxHeader is uint256;\n\nstruct InterchainTransaction {\n    uint64 srcChainId;\n    uint64 dstChainId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcSender;\n    bytes32 dstReceiver;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    using MathLib for uint256;\n    using VersionedPayloadLib for bytes;\n\n    function constructLocalTransaction(\n        address srcSender,\n        uint64 dstChainId,\n        bytes32 dstReceiver,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: SafeCast.toUint64(block.chainid),\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            encodeTxHeader(transaction.srcChainId, transaction.dstChainId, transaction.dbNonce, transaction.entryIndex),\n            transaction.srcSender,\n            transaction.dstReceiver,\n            transaction.options,\n            transaction.message\n        );\n    }\n\n    function decodeTransaction(bytes calldata transaction) internal pure returns (InterchainTransaction memory icTx) {\n        ICTxHeader header;\n        (header, icTx.srcSender, icTx.dstReceiver, icTx.options, icTx.message) =\n            abi.decode(transaction, (ICTxHeader, bytes32, bytes32, bytes, bytes));\n        (icTx.srcChainId, icTx.dstChainId, icTx.dbNonce, icTx.entryIndex) = decodeTxHeader(header);\n    }\n\n    function payloadSize(uint256 optionsLen, uint256 messageLen) internal pure returns (uint256) {\n        // 2 bytes are reserved for the transaction version\n        // + 5 fields * 32 bytes (3 values for static, 2 offsets for dynamic) + 2 * 32 bytes (lengths for dynamic) = 226\n        // (srcChainId, dstChainId, dbNonce, entryIndex) are merged into a single 32 bytes field\n        // Both options and message are dynamic fields, which are padded up to 32 bytes\n        return 226 + optionsLen.roundUpToWord() + messageLen.roundUpToWord();\n    }\n\n    function encodeTxHeader(\n        uint64 srcChainId,\n        uint64 dstChainId,\n        uint64 dbNonce,\n        uint64 entryIndex\n    )\n        internal\n        pure\n        returns (ICTxHeader)\n    {\n        return ICTxHeader.wrap(\n            (uint256(srcChainId) \u003c\u003c 192) | (uint256(dstChainId) \u003c\u003c 128) | (uint256(dbNonce) \u003c\u003c 64) | uint256(entryIndex)\n        );\n    }\n\n    function decodeTxHeader(ICTxHeader header)\n        internal\n        pure\n        returns (uint64 srcChainId, uint64 dstChainId, uint64 dbNonce, uint64 entryIndex)\n    {\n        srcChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 192);\n        dstChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 128);\n        dbNonce = uint64(ICTxHeader.unwrap(header) \u003e\u003e 64);\n        entryIndex = uint64(ICTxHeader.unwrap(header));\n    }\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint64 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__InvalidTransactionVersion(uint16 version);\n    error InterchainClientV1__NoLinkedClient(uint64 chainId);\n    error InterchainClientV1__NotEnoughGasSupplied();\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint64 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint64 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint64 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint64 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param messageLen           The length of the message being sent.\n    function getInterchainFee(\n        uint64 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        uint256 messageLen\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint64 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint64 chainId) external view returns (address);\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing a batch of entries from the remote Interchain DataBase,\n    /// verified by the Interchain Module.\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param batchRoot    The Merkle root of the batch\n    struct RemoteBatch {\n        uint256 verifiedAt;\n        bytes32 batchRoot;\n    }\n\n    error InterchainDB__BatchDoesNotExist(uint64 dbNonce);\n    error InterchainDB__BatchNotFinalized(uint64 dbNonce);\n    error InterchainDB__ConflictingBatches(address module, bytes32 existingBatchRoot, InterchainBatch newBatch);\n    error InterchainDB__EntryIndexOutOfRange(uint64 dbNonce, uint64 entryIndex, uint64 batchSize);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__InvalidBatchVersion(uint16 version);\n    error InterchainDB__InvalidEntryRange(uint64 dbNonce, uint64 start, uint64 end);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId(uint64 chainId);\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `requestBatchVerification` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntry(bytes32 dataHash) external returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Request the given Interchain Modules to verify an existing batch.\n    /// If the batch is not finalized, the module will verify it after finalization.\n    /// For the finalized batch the batch root is already available, and the module can verify it immediately.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any batch.\n    /// @dev Will revert if the batch with the given nonce does not exist.\n    /// @param dstChainId    The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the existing batch\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestBatchVerification(\n        uint64 dstChainId,\n        uint64 dbNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Then request the Interchain Modules to verify the batch containing the written entry on the destination chain.\n    /// See `writeEntry` and `requestBatchVerification` for more details.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntryWithVerification(\n        uint64 dstChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Allows the Interchain Module to verify the batch coming from the remote chain.\n    /// Note: The DB will only accept the batch of the same version as the DB itself.\n    /// @param versionedBatch   The versioned Interchain Batch to verify\n    function verifyRemoteBatch(bytes memory versionedBatch) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint64 dstChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce.\n    /// Note: the leafs are ordered by the index of the written entry in the current batch,\n    /// and the leafs value match the value of the written entry (srcWriter + dataHash hashed together).\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchLeafs(uint64 dbNonce) external view returns (bytes32[] memory);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce,\n    /// paginated by the given start and end indexes. The end index is exclusive.\n    /// Note: this is useful when the batch contains a large number of leafs, and calling `getBatchLeafs`\n    /// would result in a gas limit exceeded error.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the provided range is invalid.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param start        The start index of the paginated leafs, inclusive\n    /// @param end          The end index of the paginated leafs, exclusive\n    function getBatchLeafsPaginated(\n        uint64 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory);\n\n    /// @notice Returns the size of the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchSize(uint64 dbNonce) external view returns (uint64);\n\n    /// @notice Get the finalized Interchain Batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatch(uint64 dbNonce) external view returns (InterchainBatch memory);\n\n    /// @notice Get the Interchain Entry's value written on the local chain with the given batch nonce and entry index.\n    /// Entry value is calculated as the hash of the writer address and the written data hash.\n    /// Note: the batch does not have to be finalized to fetch the entry value.\n    /// @dev Will revert if the batch with the given nonce does not exist,\n    /// or the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the existing batch\n    /// @param entryIndex   The index of the written entry within the batch\n    function getEntryValue(uint64 dbNonce, uint64 entryIndex) external view returns (bytes32);\n\n    /// @notice Get the Merkle proof of inclusion for the entry with the given index\n    /// in the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param entryIndex   The index of the written entry within the batch\n    /// @return proof       The Merkle proof of inclusion for the entry\n    function getEntryProof(uint64 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof);\n\n    /// @notice Get the nonce of the database, which is incremented every time a new batch is finalized.\n    /// This is the nonce of the current non-finalized batch.\n    function getDBNonce() external view returns (uint64);\n\n    /// @notice Get the index of the next entry to be written to the database.\n    /// @return dbNonce      The database nonce of the batch including the next entry\n    /// @return entryIndex   The index of the next entry within that batch\n    function getNextEntryIndex() external view returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or ZERO if the module has not verified the entry.\n    function checkVerification(\n        address dstModule,\n        InterchainEntry memory entry,\n        bytes32[] memory proof\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n\n    /// @notice Get the version of the Interchain DataBase.\n    // solhint-disable-next-line func-name-mixedcase\n    function DB_VERSION() external pure returns (uint16);\n}\n\n// contracts/InterchainClientV1.sol\n\n/**\n * @title InterchainClientV1\n * @dev Implements the operations of the Interchain Execution Layer.\n */\ncontract InterchainClientV1 is Ownable, InterchainClientV1Events, IInterchainClientV1 {\n    using AppConfigLib for bytes;\n    using OptionsLib for bytes;\n    using VersionedPayloadLib for bytes;\n\n    /// @notice Version of the InterchainClient contract. Sent and received transactions must have the same version.\n    uint16 public constant CLIENT_VERSION = 1;\n\n    /// @notice Address of the InterchainDB contract, set at the time of deployment.\n    address public immutable INTERCHAIN_DB;\n\n    /// @notice Address of the contract that handles execution fees. Can be updated by the owner.\n    address public executionFees;\n\n    /// @dev Address of the InterchainClient contract on the remote chain\n    mapping(uint64 chainId =\u003e bytes32 remoteClient) internal _linkedClient;\n    /// @dev Executor address that completed the transaction. Address(0) if not executed yet.\n    mapping(bytes32 transactionId =\u003e address executor) internal _txExecutor;\n\n    constructor(address interchainDB, address owner_) Ownable(owner_) {\n        INTERCHAIN_DB = interchainDB;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function setExecutionFees(address executionFees_) external onlyOwner {\n        executionFees = executionFees_;\n        emit ExecutionFeesSet(executionFees_);\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function setLinkedClient(uint64 chainId, bytes32 client) external onlyOwner {\n        _linkedClient[chainId] = client;\n        emit LinkedClientSet(chainId, client);\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _interchainSend(dstChainId, receiver, srcExecutionService, srcModules, options, message);\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function interchainSendEVM(\n        uint64 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc)\n    {\n        bytes32 receiverBytes32 = TypeCasts.addressToBytes32(receiver);\n        return _interchainSend(dstChainId, receiverBytes32, srcExecutionService, srcModules, options, message);\n    }\n\n    // TODO: Handle the case where receiver does not implement the IInterchainApp interface (or does not exist at all)\n    // @inheritdoc IInterchainClientV1\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable\n    {\n        InterchainTransaction memory icTx = _assertCorrectVersion(transaction);\n        bytes32 transactionId = keccak256(transaction);\n        _assertExecutable(icTx, transactionId, proof);\n        _txExecutor[transactionId] = msg.sender;\n\n        OptionsV1 memory decodedOptions = icTx.options.decodeOptionsV1();\n        if (msg.value != decodedOptions.gasAirdrop) {\n            revert InterchainClientV1__IncorrectMsgValue(msg.value, decodedOptions.gasAirdrop);\n        }\n        // We should always use at least as much as the requested gas limit.\n        // The executor can specify a higher gas limit if they wanted.\n        if (decodedOptions.gasLimit \u003e gasLimit) gasLimit = decodedOptions.gasLimit;\n        // Check the the Executor has provided big enough gas limit for the whole transaction.\n        if (gasleft() \u003c= gasLimit) {\n            revert InterchainClientV1__NotEnoughGasSupplied();\n        }\n        // Pass the full msg.value to the app: we have already checked that it matches the requested gas airdrop.\n        IInterchainApp(TypeCasts.bytes32ToAddress(icTx.dstReceiver)).appReceive{gas: gasLimit, value: msg.value}({\n            srcChainId: icTx.srcChainId,\n            sender: icTx.srcSender,\n            dbNonce: icTx.dbNonce,\n            entryIndex: icTx.entryIndex,\n            message: icTx.message\n        });\n        emit InterchainTransactionReceived(\n            transactionId, icTx.dbNonce, icTx.entryIndex, icTx.srcChainId, icTx.srcSender, icTx.dstReceiver\n        );\n    }\n\n    /// @inheritdoc IInterchainClientV1\n    function writeExecutionProof(bytes32 transactionId) external returns (uint64 dbNonce, uint64 entryIndex) {\n        address executor = _txExecutor[transactionId];\n        if (executor == address(0)) {\n            revert InterchainClientV1__TxNotExecuted(transactionId);\n        }\n        bytes memory proof = abi.encode(transactionId, executor);\n        (dbNonce, entryIndex) = IInterchainDB(INTERCHAIN_DB).writeEntry(keccak256(proof));\n        emit ExecutionProofWritten(transactionId, dbNonce, entryIndex, executor);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // @inheritdoc IInterchainClientV1\n    function isExecutable(bytes calldata encodedTx, bytes32[] calldata proof) external view returns (bool) {\n        InterchainTransaction memory icTx = _assertCorrectVersion(encodedTx);\n        // Check that options could be decoded\n        icTx.options.decodeOptionsV1();\n        bytes32 transactionId = keccak256(encodedTx);\n        _assertExecutable(icTx, transactionId, proof);\n        return true;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function getExecutor(bytes calldata encodedTx) external view returns (address) {\n        return _txExecutor[keccak256(encodedTx)];\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function getExecutorById(bytes32 transactionId) external view returns (address) {\n        return _txExecutor[transactionId];\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function getInterchainFee(\n        uint64 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        uint256 messageLen\n    )\n        external\n        view\n        returns (uint256 fee)\n    {\n        _assertLinkedClient(dstChainId);\n        // Check that options could be decoded on destination chain\n        options.decodeOptionsV1();\n        // Verification fee from InterchainDB\n        fee = IInterchainDB(INTERCHAIN_DB).getInterchainFee(dstChainId, srcModules);\n        // Add execution fee, if ExecutionService is provided\n        if (srcExecutionService != address(0)) {\n            uint256 payloadSize = InterchainTransactionLib.payloadSize(options.length, messageLen);\n            fee += IExecutionService(srcExecutionService).getExecutionFee(dstChainId, payloadSize, options);\n        }\n    }\n\n    /// @inheritdoc IInterchainClientV1\n    function getLinkedClient(uint64 chainId) external view returns (bytes32) {\n        if (chainId == block.chainid) {\n            revert InterchainClientV1__NotRemoteChainId(chainId);\n        }\n        return _linkedClient[chainId];\n    }\n\n    /// @inheritdoc IInterchainClientV1\n    function getLinkedClientEVM(uint64 chainId) external view returns (address linkedClientEVM) {\n        if (chainId == block.chainid) {\n            revert InterchainClientV1__NotRemoteChainId(chainId);\n        }\n        bytes32 linkedClient = _linkedClient[chainId];\n        linkedClientEVM = TypeCasts.bytes32ToAddress(linkedClient);\n        // Check that the linked client address fits into the EVM address space\n        if (TypeCasts.addressToBytes32(linkedClientEVM) != linkedClient) {\n            revert InterchainClientV1__NotEVMClient(linkedClient);\n        }\n    }\n\n    /// @notice Decodes the encoded options data into a OptionsV1 struct.\n    function decodeOptions(bytes memory encodedOptions) external view returns (OptionsV1 memory) {\n        return encodedOptions.decodeOptionsV1();\n    }\n\n    /// @notice Encodes the transaction data into a bytes format.\n    function encodeTransaction(InterchainTransaction memory icTx) public pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload({\n            version: CLIENT_VERSION,\n            payload: InterchainTransactionLib.encodeTransaction(icTx)\n        });\n    }\n\n    // ═════════════════════════════════════════════════ INTERNAL ══════════════════════════════════════════════════════\n\n    /// @dev Internal logic for sending a message to another chain.\n    function _interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        _assertLinkedClient(dstChainId);\n        if (receiver == 0) revert InterchainClientV1__ZeroReceiver();\n        // Check that options could be decoded on destination chain\n        options.decodeOptionsV1();\n        uint256 verificationFee = IInterchainDB(INTERCHAIN_DB).getInterchainFee(dstChainId, srcModules);\n        if (msg.value \u003c verificationFee) {\n            revert InterchainClientV1__FeeAmountTooLow(msg.value, verificationFee);\n        }\n        (desc.dbNonce, desc.entryIndex) = IInterchainDB(INTERCHAIN_DB).getNextEntryIndex();\n        InterchainTransaction memory icTx = InterchainTransactionLib.constructLocalTransaction({\n            srcSender: msg.sender,\n            dstReceiver: receiver,\n            dstChainId: dstChainId,\n            dbNonce: desc.dbNonce,\n            entryIndex: desc.entryIndex,\n            options: options,\n            message: message\n        });\n        desc.transactionId = keccak256(encodeTransaction(icTx));\n        // Sanity check: nonce returned from DB should match the nonce used to construct the transaction\n        {\n            (uint64 dbNonce, uint64 entryIndex) = IInterchainDB(INTERCHAIN_DB).writeEntryWithVerification{\n                value: verificationFee\n            }(icTx.dstChainId, desc.transactionId, srcModules);\n            assert(dbNonce == desc.dbNonce \u0026\u0026 entryIndex == desc.entryIndex);\n        }\n        uint256 executionFee;\n        unchecked {\n            executionFee = msg.value - verificationFee;\n        }\n        if (executionFee \u003e 0) {\n            IExecutionFees(executionFees).addExecutionFee{value: executionFee}(icTx.dstChainId, desc.transactionId);\n        }\n        // TODO: consider disallowing the use of empty srcExecutionService\n        if (srcExecutionService != address(0)) {\n            IExecutionService(srcExecutionService).requestExecution({\n                dstChainId: dstChainId,\n                txPayloadSize: InterchainTransactionLib.payloadSize(options.length, message.length),\n                transactionId: desc.transactionId,\n                executionFee: executionFee,\n                options: options\n            });\n            address srcExecutorEOA = IExecutionService(srcExecutionService).executorEOA();\n            IExecutionFees(executionFees).recordExecutor(icTx.dstChainId, desc.transactionId, srcExecutorEOA);\n        }\n        emit InterchainTransactionSent(\n            desc.transactionId,\n            icTx.dbNonce,\n            icTx.entryIndex,\n            icTx.dstChainId,\n            icTx.srcSender,\n            icTx.dstReceiver,\n            verificationFee,\n            executionFee,\n            icTx.options,\n            icTx.message\n        );\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Asserts that the transaction is executable.\n    function _assertExecutable(\n        InterchainTransaction memory icTx,\n        bytes32 transactionId,\n        bytes32[] calldata proof\n    )\n        internal\n        view\n    {\n        bytes32 linkedClient = _assertLinkedClient(icTx.srcChainId);\n        if (icTx.dstChainId != block.chainid) {\n            revert InterchainClientV1__IncorrectDstChainId(icTx.dstChainId);\n        }\n        if (_txExecutor[transactionId] != address(0)) {\n            revert InterchainClientV1__TxAlreadyExecuted(transactionId);\n        }\n        // Construct expected entry based on icTransaction data\n        InterchainEntry memory icEntry = InterchainEntry({\n            srcChainId: icTx.srcChainId,\n            dbNonce: icTx.dbNonce,\n            entryIndex: icTx.entryIndex,\n            srcWriter: linkedClient,\n            dataHash: transactionId\n        });\n        (bytes memory encodedAppConfig, address[] memory approvedDstModules) =\n            IInterchainApp(TypeCasts.bytes32ToAddress(icTx.dstReceiver)).getReceivingConfig();\n        AppConfigV1 memory appConfig = encodedAppConfig.decodeAppConfigV1();\n        if (appConfig.requiredResponses == 0) {\n            revert InterchainClientV1__ZeroRequiredResponses();\n        }\n        uint256 responses = _getFinalizedResponsesCount(approvedDstModules, icEntry, proof, appConfig.optimisticPeriod);\n        if (responses \u003c appConfig.requiredResponses) {\n            revert InterchainClientV1__NotEnoughResponses(responses, appConfig.requiredResponses);\n        }\n    }\n\n    /// @dev Asserts that the chain is linked and returns the linked client address.\n    function _assertLinkedClient(uint64 chainId) internal view returns (bytes32 linkedClient) {\n        if (chainId == block.chainid) {\n            revert InterchainClientV1__NotRemoteChainId(chainId);\n        }\n        linkedClient = _linkedClient[chainId];\n        if (linkedClient == 0) {\n            revert InterchainClientV1__NoLinkedClient(chainId);\n        }\n    }\n\n    /**\n     * @dev Calculates the number of responses that are considered finalized within the optimistic time period.\n     * @param approvedModules       Approved modules that could have confirmed the entry.\n     * @param icEntry               The InterchainEntry to confirm.\n     * @param optimisticPeriod      The time period in seconds within which a response is considered valid.\n     * @return finalizedResponses   The count of responses that are finalized within the optimistic time period.\n     */\n    function _getFinalizedResponsesCount(\n        address[] memory approvedModules,\n        InterchainEntry memory icEntry,\n        bytes32[] calldata proof,\n        uint256 optimisticPeriod\n    )\n        internal\n        view\n        returns (uint256 finalizedResponses)\n    {\n        for (uint256 i = 0; i \u003c approvedModules.length; ++i) {\n            uint256 confirmedAt = IInterchainDB(INTERCHAIN_DB).checkVerification(approvedModules[i], icEntry, proof);\n            // checkVerification() returns 0 if entry hasn't been confirmed by the module, so we check for that as well\n            if (confirmedAt != 0 \u0026\u0026 confirmedAt + optimisticPeriod \u003c block.timestamp) {\n                ++finalizedResponses;\n            }\n        }\n    }\n\n    /// @dev Asserts that the transaction version is correct. Returns the decoded transaction for chaining purposes.\n    function _assertCorrectVersion(bytes calldata versionedTx)\n        internal\n        pure\n        returns (InterchainTransaction memory icTx)\n    {\n        uint16 version = versionedTx.getVersion();\n        if (version != CLIENT_VERSION) {\n            revert InterchainClientV1__InvalidTransactionVersion(version);\n        }\n        icTx = InterchainTransactionLib.decodeTransaction(versionedTx.getPayload());\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"uint64","name":"dstChainId","type":"uint64"},{"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"internalType":"address","name":"executor","type":"address"}],"name":"ExecutionFees__AlreadyRecorded","type":"error"},{"inputs":[],"name":"ExecutionFees__ZeroAddress","type":"error"},{"inputs":[],"name":"ExecutionFees__ZeroAmount","type":"error"},{"inputs":[{"internalType":"address","name":"executor","type":"address"}],"name":"accumulatedRewards","outputs":[{"internalType":"uint256","name":"accumulated","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint64","name":"dstChainId","type":"uint64"},{"internalType":"bytes32","name":"transactionId","type":"bytes32"}],"name":"addExecutionFee","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"address","name":"executor","type":"address"}],"name":"claimExecutionFees","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint64","name":"dstChainId","type":"uint64"},{"internalType":"bytes32","name":"transactionId","type":"bytes32"}],"name":"executionFee","outputs":[{"internalType":"uint256","name":"fee","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint64","name":"dstChainId","type":"uint64"},{"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"internalType":"address","name":"executor","type":"address"}],"name":"recordExecutor","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint64","name":"dstChainId","type":"uint64"},{"internalType":"bytes32","name":"transactionId","type":"bytes32"}],"name":"recordedExecutor","outputs":[{"internalType":"address","name":"executor","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"executor","type":"address"}],"name":"unclaimedRewards","outputs":[{"internalType":"uint256","name":"unclaimed","type":"uint256"}],"stateMutability":"view","type":"function"}],"userDoc":{"kind":"user","methods":{"accumulatedRewards(address)":{"notice":"Get the accumulated rewards for an executor."},"addExecutionFee(uint64,bytes32)":{"notice":"Add the execution fee for a transaction. The attached value will be added to the rewards for the executor completing the transaction. Note: this could be used to store the execution fee for a new transaction, or to add more funds to the execution fee of an existing transaction. Therefore this function is payable, and does not implement any caller restrictions."},"claimExecutionFees(address)":{"notice":"Allows the executor to claim their unclaimed rewards."},"executionFee(uint64,bytes32)":{"notice":"Get the total execution fee for a transaction."},"recordExecutor(uint64,bytes32,address)":{"notice":"Record the executor (who completed the transaction) for a transaction, and update the accumulated rewards for the executor."},"recordedExecutor(uint64,bytes32)":{"notice":"Get the address of the recorded executor for a transaction."},"unclaimedRewards(address)":{"notice":"Get the unclaimed rewards for an executor."}},"version":1},"developerDoc":{"kind":"dev","methods":{"accumulatedRewards(address)":{"params":{"executor":"The address of the executor to get the rewards for."}},"addExecutionFee(uint64,bytes32)":{"details":"Will revert if the executor is already recorded for the transaction.","params":{"dstChainId":"The chain id of the destination chain.","transactionId":"The id of the transaction to add the execution fee to."}},"claimExecutionFees(address)":{"details":"Will revert if the executor has no unclaimed rewards."},"executionFee(uint64,bytes32)":{"params":{"dstChainId":"The chain id of the destination chain.","transactionId":"The id of the transaction to get the execution fee for."}},"recordExecutor(uint64,bytes32,address)":{"details":"Could only be called by the Recorder.","params":{"dstChainId":"The chain id of the destination chain.","executor":"The address of the executor who completed the transaction.","transactionId":"The id of the transaction to record the executor for."}},"recordedExecutor(uint64,bytes32)":{"details":"Will return address(0) if the executor is not recorded.","params":{"dstChainId":"The chain id of the destination chain.","transactionId":"The id of the transaction to get the recorded executor for."}},"unclaimedRewards(address)":{"params":{"executor":"The address of the executor to get the rewards for."}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"dstChainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"}],\"name\":\"ExecutionFees__AlreadyRecorded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ExecutionFees__ZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ExecutionFees__ZeroAmount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"}],\"name\":\"accumulatedRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"accumulated\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"dstChainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"}],\"name\":\"addExecutionFee\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"}],\"name\":\"claimExecutionFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"dstChainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"}],\"name\":\"executionFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"dstChainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"}],\"name\":\"recordExecutor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"dstChainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"}],\"name\":\"recordedExecutor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"}],\"name\":\"unclaimedRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"unclaimed\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"accumulatedRewards(address)\":{\"params\":{\"executor\":\"The address of the executor to get the rewards for.\"}},\"addExecutionFee(uint64,bytes32)\":{\"details\":\"Will revert if the executor is already recorded for the transaction.\",\"params\":{\"dstChainId\":\"The chain id of the destination chain.\",\"transactionId\":\"The id of the transaction to add the execution fee to.\"}},\"claimExecutionFees(address)\":{\"details\":\"Will revert if the executor has no unclaimed rewards.\"},\"executionFee(uint64,bytes32)\":{\"params\":{\"dstChainId\":\"The chain id of the destination chain.\",\"transactionId\":\"The id of the transaction to get the execution fee for.\"}},\"recordExecutor(uint64,bytes32,address)\":{\"details\":\"Could only be called by the Recorder.\",\"params\":{\"dstChainId\":\"The chain id of the destination chain.\",\"executor\":\"The address of the executor who completed the transaction.\",\"transactionId\":\"The id of the transaction to record the executor for.\"}},\"recordedExecutor(uint64,bytes32)\":{\"details\":\"Will return address(0) if the executor is not recorded.\",\"params\":{\"dstChainId\":\"The chain id of the destination chain.\",\"transactionId\":\"The id of the transaction to get the recorded executor for.\"}},\"unclaimedRewards(address)\":{\"params\":{\"executor\":\"The address of the executor to get the rewards for.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"accumulatedRewards(address)\":{\"notice\":\"Get the accumulated rewards for an executor.\"},\"addExecutionFee(uint64,bytes32)\":{\"notice\":\"Add the execution fee for a transaction. The attached value will be added to the rewards for the executor completing the transaction. Note: this could be used to store the execution fee for a new transaction, or to add more funds to the execution fee of an existing transaction. Therefore this function is payable, and does not implement any caller restrictions.\"},\"claimExecutionFees(address)\":{\"notice\":\"Allows the executor to claim their unclaimed rewards.\"},\"executionFee(uint64,bytes32)\":{\"notice\":\"Get the total execution fee for a transaction.\"},\"recordExecutor(uint64,bytes32,address)\":{\"notice\":\"Record the executor (who completed the transaction) for a transaction, and update the accumulated rewards for the executor.\"},\"recordedExecutor(uint64,bytes32)\":{\"notice\":\"Get the address of the recorded executor for a transaction.\"},\"unclaimedRewards(address)\":{\"notice\":\"Get the unclaimed rewards for an executor.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainClientV1.sol\":\"IExecutionFees\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainClientV1.sol\":{\"keccak256\":\"0xe270686a9bca05b4013610a4e8bb08040de32a0442edd218e1692edaca94e40e\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://727e84146369613e04e57a677f8bc6c709ee145df3eeb79f15ea5a922198d78f\",\"dweb:/ipfs/QmUXh2nDtHBnhYZSwCxcteN4be13S7dR9GbqqHT9mUxta3\"]}},\"version\":1}"},"hashes":{"accumulatedRewards(address)":"73f273fc","addExecutionFee(uint64,bytes32)":"7b18c25c","claimExecutionFees(address)":"4e497dac","executionFee(uint64,bytes32)":"656a96d9","recordExecutor(uint64,bytes32,address)":"fd411b43","recordedExecutor(uint64,bytes32)":"c2bc3357","unclaimedRewards(address)":"949813b8"}},"solidity/InterchainClientV1.sol:IExecutionService":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainClientV1Events.sol\n\nabstract contract InterchainClientV1Events {\n    event ExecutionFeesSet(address executionFees);\n    event LinkedClientSet(uint64 chainId, bytes32 client);\n\n    // TODO: figure out indexing\n\n    event InterchainTransactionSent(\n        bytes32 indexed transactionId,\n        uint64 indexed dbNonce,\n        uint64 indexed entryIndex,\n        uint64 dstChainId,\n        bytes32 srcSender,\n        bytes32 dstReceiver,\n        uint256 verificationFee,\n        uint256 executionFee,\n        bytes options,\n        bytes message\n    );\n\n    event InterchainTransactionReceived(\n        bytes32 indexed transactionId,\n        uint64 indexed dbNonce,\n        uint64 indexed entryIndex,\n        uint64 srcChainId,\n        bytes32 srcSender,\n        bytes32 dstReceiver\n    );\n\n    event ExecutionProofWritten(\n        bytes32 indexed transactionId, uint64 indexed dbNonce, uint64 indexed entryIndex, address executor\n    );\n}\n\n// contracts/interfaces/IExecutionFees.sol\n\ninterface IExecutionFees {\n    error ExecutionFees__AlreadyRecorded(uint64 dstChainId, bytes32 transactionId, address executor);\n    error ExecutionFees__ZeroAddress();\n    error ExecutionFees__ZeroAmount();\n\n    /// @notice Add the execution fee for a transaction. The attached value will be added to the\n    /// rewards for the executor completing the transaction.\n    /// Note: this could be used to store the execution fee for a new transaction, or to add more\n    /// funds to the execution fee of an existing transaction. Therefore this function is payable,\n    /// and does not implement any caller restrictions.\n    /// @dev Will revert if the executor is already recorded for the transaction.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to add the execution fee to.\n    function addExecutionFee(uint64 dstChainId, bytes32 transactionId) external payable;\n\n    /// @notice Record the executor (who completed the transaction) for a transaction,\n    /// and update the accumulated rewards for the executor.\n    /// @dev Could only be called by the Recorder.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to record the executor for.\n    /// @param executor             The address of the executor who completed the transaction.\n    function recordExecutor(uint64 dstChainId, bytes32 transactionId, address executor) external;\n\n    /// @notice Allows the executor to claim their unclaimed rewards.\n    /// @dev Will revert if the executor has no unclaimed rewards.\n    function claimExecutionFees(address executor) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the accumulated rewards for an executor.\n    /// @param executor             The address of the executor to get the rewards for.\n    function accumulatedRewards(address executor) external view returns (uint256 accumulated);\n\n    /// @notice Get the unclaimed rewards for an executor.\n    /// @param executor             The address of the executor to get the rewards for.\n    function unclaimedRewards(address executor) external view returns (uint256 unclaimed);\n\n    /// @notice Get the total execution fee for a transaction.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to get the execution fee for.\n    function executionFee(uint64 dstChainId, bytes32 transactionId) external view returns (uint256 fee);\n\n    /// @notice Get the address of the recorded executor for a transaction.\n    /// @dev Will return address(0) if the executor is not recorded.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to get the recorded executor for.\n    function recordedExecutor(uint64 dstChainId, bytes32 transactionId) external view returns (address executor);\n}\n\n// contracts/interfaces/IExecutionService.sol\n\ninterface IExecutionService {\n    /// @notice Request the execution of an Interchain Transaction on a remote chain.\n    /// Note: the off-chain actor needs to fetch the transaction payload from the InterchainClient\n    /// event with the same transactionId, then execute the transaction on the remote chain:\n    /// `dstInterchainClient.executeTransaction(transactionPayload)`\n    /// Once the execution is confirmed on the source chain, the off-chain actor will be able\n    /// to claim `executionFee` in the ExecutionFees contract.\n    /// @dev Could only be called by `InterchainClient` contracts.\n    /// Will revert if the execution fee is not big enough.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param txPayloadSize        The size of the transaction payload to use for the execution.\n    /// @param transactionId        The id of the transaction to execute.\n    /// @param executionFee         The fee paid for the execution.\n    /// @param options              The options to use for the execution.\n    function requestExecution(\n        uint64 dstChainId,\n        uint256 txPayloadSize,\n        bytes32 transactionId,\n        uint256 executionFee,\n        bytes memory options\n    )\n        external;\n\n    /// @notice Get the address of the EOA account that will be used to execute transactions on the\n    /// remote chains.\n    function executorEOA() external view returns (address);\n\n    /// @notice Get the execution fee for executing an Interchain Transaction on a remote chain.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param txPayloadSize        The size of the transaction payload to use for the execution.\n    /// @param options              The options to use for the execution.\n    function getExecutionFee(\n        uint64 dstChainId,\n        uint256 txPayloadSize,\n        bytes memory options\n    )\n        external\n        view\n        returns (uint256);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    /// @notice Allows the Interchain Client to pass the message to the Interchain App.\n    /// @dev App is responsible for keeping track of interchain clients, and must verify the message sender.\n    /// @param srcChainId   Chain ID of the source chain, where the message was sent from.\n    /// @param sender       Sender address on the source chain, as a bytes32 value.\n    /// @param dbNonce      The Interchain DB nonce of the batch containing the message entry.\n    /// @param entryIndex   The index of the message entry within the batch.\n    /// @param message      The message being sent.\n    function appReceive(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /// @notice Returns the verification configuration of the Interchain App.\n    /// @dev This configuration is used by the Interchain Client to verify that message has been confirmed\n    /// by the Interchain Modules on the destination chain.\n    /// Note: V1 version of AppConfig includes the required responses count, and optimistic period after which\n    /// the message is considered confirmed by the module. Following versions may include additional fields.\n    /// @return appConfig    The versioned configuration of the Interchain App, encoded as bytes.\n    /// @return modules      The list of Interchain Modules that app is trusting to confirm the messages.\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/Math.sol\n\nlibrary MathLib {\n    /// @notice Rounds up to the nearest multiple of 32.\n    /// Note: Returns zero on overflows instead of reverting. This is fine for practical\n    /// use cases, as this is used for determining the size of the payload in memory.\n    function roundUpToWord(uint256 x) internal pure returns (uint256) {\n        unchecked {\n            return (x + 31) \u0026 ~uint256(31);\n        }\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/VersionedPayload.sol\n\n// solhint-disable no-inline-assembly\n// solhint-disable ordering\nlibrary VersionedPayloadLib {\n    /// @notice Amount of bytes reserved for the version (uint16) in the versioned payload\n    uint256 internal constant VERSION_LENGTH = 2;\n\n    error VersionedPayload__TooShort(bytes versionedPayload);\n    error VersionedPayload__PrecompileFailed();\n\n    /// @notice Encodes the versioned payload into a single bytes array.\n    /// @param version  The payload's version.\n    /// @param payload  The payload to encode.\n    function encodeVersionedPayload(uint16 version, bytes memory payload) internal pure returns (bytes memory) {\n        return abi.encodePacked(version, payload);\n    }\n\n    /// @notice Extracts the version from the versioned payload (calldata reference).\n    /// @param versionedPayload     The versioned payload (calldata reference).\n    function getVersion(bytes calldata versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            version := shr(240, calldataload(versionedPayload.offset))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (calldata reference).\n    /// @dev The extracted payload is also returned as a calldata reference.\n    /// @param versionedPayload     The versioned payload.\n    function getPayload(bytes calldata versionedPayload) internal pure returns (bytes calldata) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        return versionedPayload[VERSION_LENGTH:];\n    }\n\n    /// @notice Extracts the version from the versioned payload (memory reference).\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getVersionFromMemory(bytes memory versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            // We add 0x20 to skip the length of the bytes array.\n            version := shr(240, mload(add(versionedPayload, 0x20)))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (memory reference).\n    /// @dev The extracted payload is copied into a new memory location. Use `getPayload` when possible\n    /// to avoid extra memory allocation.\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getPayloadFromMemory(bytes memory versionedPayload) internal view returns (bytes memory payload) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        // Figure how many bytes to copy and allocate the memory for the extracted payload.\n        uint256 toCopy;\n        unchecked {\n            toCopy = versionedPayload.length - VERSION_LENGTH;\n        }\n        payload = new bytes(toCopy);\n        // Use identity precompile (0x04) to copy the payload. Unlike MCOPY, this is available on all EVM chains.\n        bool res;\n        assembly {\n            // We add 0x20 to skip the length of the bytes array.\n            // We add 0x02 to skip the 2 bytes reserved for the version.\n            // Copy the payload to the previously allocated memory.\n            res := staticcall(gas(), 0x04, add(versionedPayload, 0x22), toCopy, add(payload, 0x20), toCopy)\n        }\n        if (!res) {\n            revert VersionedPayload__PrecompileFailed();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SafeCast.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value \u003e type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value \u003e type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value \u003e type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value \u003e type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value \u003e type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value \u003e type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value \u003e type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value \u003e type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value \u003e type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value \u003e type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value \u003e type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value \u003e type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value \u003e type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value \u003e type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value \u003e type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value \u003e type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value \u003e type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value \u003e type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value \u003e type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value \u003e type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value \u003e type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value \u003e type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value \u003e type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value \u003e type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value \u003e type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value \u003e type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value \u003e type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value \u003e type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value \u003e type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value \u003e type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value \u003e type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value \u003c 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value \u003e uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal view returns (AppConfigV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (AppConfigV1));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal view returns (OptionsV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (OptionsV1));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(OPTIONS_V1, abi.encode(options));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/libs/InterchainBatch.sol\n\ntype BatchKey is uint128;\n\n/// @notice Struct representing a batch of entries in the Interchain DataBase.\n/// Batched entries are put together in a Merkle tree, which root is saved.\n/// Batch has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: batchRoot\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch\n/// @param batchRoot    The root of the Merkle tree containing the batched entries\nstruct InterchainBatch {\n    uint64 srcChainId;\n    uint64 dbNonce;\n    bytes32 batchRoot;\n}\n\nlibrary InterchainBatchLib {\n    using VersionedPayloadLib for bytes;\n\n    /// @notice Constructs an InterchainBatch struct to be saved on the local chain.\n    /// @param dbNonce      The database nonce of the batch\n    /// @param batchRoot    The root of the Merkle tree containing the batched entries\n    /// @return batch       The constructed InterchainBatch struct\n    function constructLocalBatch(\n        uint64 dbNonce,\n        bytes32 batchRoot\n    )\n        internal\n        view\n        returns (InterchainBatch memory batch)\n    {\n        return InterchainBatch({srcChainId: SafeCast.toUint64(block.chainid), dbNonce: dbNonce, batchRoot: batchRoot});\n    }\n\n    /// @notice Encodes the InterchainBatch struct into a non-versioned batch payload.\n    function encodeBatch(InterchainBatch memory batch) internal pure returns (bytes memory) {\n        return abi.encode(encodeBatchKey(batch.srcChainId, batch.dbNonce), batch.batchRoot);\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in calldata.\n    function decodeBatch(bytes calldata data) internal pure returns (InterchainBatch memory batch) {\n        BatchKey key;\n        (key, batch.batchRoot) = abi.decode(data, (BatchKey, bytes32));\n        (batch.srcChainId, batch.dbNonce) = decodeBatchKey(key);\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in memory.\n    function decodeBatchFromMemory(bytes memory data) internal pure returns (InterchainBatch memory batch) {\n        BatchKey key;\n        (key, batch.batchRoot) = abi.decode(data, (BatchKey, bytes32));\n        (batch.srcChainId, batch.dbNonce) = decodeBatchKey(key);\n    }\n\n    /// @notice Encodes the uint128 key of the batch from uint64 srcChainId and uint64 dbNonce.\n    function encodeBatchKey(uint64 srcChainId, uint64 dbNonce) internal pure returns (BatchKey) {\n        return BatchKey.wrap((uint128(srcChainId) \u003c\u003c 64) | dbNonce);\n    }\n\n    /// @notice Decodes the uint128 key of the batch into uint64 srcChainId and uint64 dbNonce.\n    function decodeBatchKey(BatchKey key) internal pure returns (uint64 srcChainId, uint64 dbNonce) {\n        srcChainId = uint64(BatchKey.unwrap(key) \u003e\u003e 64);\n        dbNonce = uint64(BatchKey.unwrap(key));\n    }\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce + entryIndex\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch containing the entry\n/// @param entryIndex   The index of the entry in the batch\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint64 srcChainId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nusing InterchainEntryLib for InterchainEntry global;\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint64 dbNonce,\n        uint64 entryIndex,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: SafeCast.toUint64(block.chainid),\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n}\n\n// contracts/libs/InterchainTransaction.sol\n\ntype ICTxHeader is uint256;\n\nstruct InterchainTransaction {\n    uint64 srcChainId;\n    uint64 dstChainId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcSender;\n    bytes32 dstReceiver;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    using MathLib for uint256;\n    using VersionedPayloadLib for bytes;\n\n    function constructLocalTransaction(\n        address srcSender,\n        uint64 dstChainId,\n        bytes32 dstReceiver,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: SafeCast.toUint64(block.chainid),\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            encodeTxHeader(transaction.srcChainId, transaction.dstChainId, transaction.dbNonce, transaction.entryIndex),\n            transaction.srcSender,\n            transaction.dstReceiver,\n            transaction.options,\n            transaction.message\n        );\n    }\n\n    function decodeTransaction(bytes calldata transaction) internal pure returns (InterchainTransaction memory icTx) {\n        ICTxHeader header;\n        (header, icTx.srcSender, icTx.dstReceiver, icTx.options, icTx.message) =\n            abi.decode(transaction, (ICTxHeader, bytes32, bytes32, bytes, bytes));\n        (icTx.srcChainId, icTx.dstChainId, icTx.dbNonce, icTx.entryIndex) = decodeTxHeader(header);\n    }\n\n    function payloadSize(uint256 optionsLen, uint256 messageLen) internal pure returns (uint256) {\n        // 2 bytes are reserved for the transaction version\n        // + 5 fields * 32 bytes (3 values for static, 2 offsets for dynamic) + 2 * 32 bytes (lengths for dynamic) = 226\n        // (srcChainId, dstChainId, dbNonce, entryIndex) are merged into a single 32 bytes field\n        // Both options and message are dynamic fields, which are padded up to 32 bytes\n        return 226 + optionsLen.roundUpToWord() + messageLen.roundUpToWord();\n    }\n\n    function encodeTxHeader(\n        uint64 srcChainId,\n        uint64 dstChainId,\n        uint64 dbNonce,\n        uint64 entryIndex\n    )\n        internal\n        pure\n        returns (ICTxHeader)\n    {\n        return ICTxHeader.wrap(\n            (uint256(srcChainId) \u003c\u003c 192) | (uint256(dstChainId) \u003c\u003c 128) | (uint256(dbNonce) \u003c\u003c 64) | uint256(entryIndex)\n        );\n    }\n\n    function decodeTxHeader(ICTxHeader header)\n        internal\n        pure\n        returns (uint64 srcChainId, uint64 dstChainId, uint64 dbNonce, uint64 entryIndex)\n    {\n        srcChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 192);\n        dstChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 128);\n        dbNonce = uint64(ICTxHeader.unwrap(header) \u003e\u003e 64);\n        entryIndex = uint64(ICTxHeader.unwrap(header));\n    }\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint64 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__InvalidTransactionVersion(uint16 version);\n    error InterchainClientV1__NoLinkedClient(uint64 chainId);\n    error InterchainClientV1__NotEnoughGasSupplied();\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint64 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint64 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint64 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint64 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param messageLen           The length of the message being sent.\n    function getInterchainFee(\n        uint64 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        uint256 messageLen\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint64 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint64 chainId) external view returns (address);\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing a batch of entries from the remote Interchain DataBase,\n    /// verified by the Interchain Module.\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param batchRoot    The Merkle root of the batch\n    struct RemoteBatch {\n        uint256 verifiedAt;\n        bytes32 batchRoot;\n    }\n\n    error InterchainDB__BatchDoesNotExist(uint64 dbNonce);\n    error InterchainDB__BatchNotFinalized(uint64 dbNonce);\n    error InterchainDB__ConflictingBatches(address module, bytes32 existingBatchRoot, InterchainBatch newBatch);\n    error InterchainDB__EntryIndexOutOfRange(uint64 dbNonce, uint64 entryIndex, uint64 batchSize);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__InvalidBatchVersion(uint16 version);\n    error InterchainDB__InvalidEntryRange(uint64 dbNonce, uint64 start, uint64 end);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId(uint64 chainId);\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `requestBatchVerification` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntry(bytes32 dataHash) external returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Request the given Interchain Modules to verify an existing batch.\n    /// If the batch is not finalized, the module will verify it after finalization.\n    /// For the finalized batch the batch root is already available, and the module can verify it immediately.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any batch.\n    /// @dev Will revert if the batch with the given nonce does not exist.\n    /// @param dstChainId    The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the existing batch\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestBatchVerification(\n        uint64 dstChainId,\n        uint64 dbNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Then request the Interchain Modules to verify the batch containing the written entry on the destination chain.\n    /// See `writeEntry` and `requestBatchVerification` for more details.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntryWithVerification(\n        uint64 dstChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Allows the Interchain Module to verify the batch coming from the remote chain.\n    /// Note: The DB will only accept the batch of the same version as the DB itself.\n    /// @param versionedBatch   The versioned Interchain Batch to verify\n    function verifyRemoteBatch(bytes memory versionedBatch) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint64 dstChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce.\n    /// Note: the leafs are ordered by the index of the written entry in the current batch,\n    /// and the leafs value match the value of the written entry (srcWriter + dataHash hashed together).\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchLeafs(uint64 dbNonce) external view returns (bytes32[] memory);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce,\n    /// paginated by the given start and end indexes. The end index is exclusive.\n    /// Note: this is useful when the batch contains a large number of leafs, and calling `getBatchLeafs`\n    /// would result in a gas limit exceeded error.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the provided range is invalid.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param start        The start index of the paginated leafs, inclusive\n    /// @param end          The end index of the paginated leafs, exclusive\n    function getBatchLeafsPaginated(\n        uint64 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory);\n\n    /// @notice Returns the size of the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchSize(uint64 dbNonce) external view returns (uint64);\n\n    /// @notice Get the finalized Interchain Batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatch(uint64 dbNonce) external view returns (InterchainBatch memory);\n\n    /// @notice Get the Interchain Entry's value written on the local chain with the given batch nonce and entry index.\n    /// Entry value is calculated as the hash of the writer address and the written data hash.\n    /// Note: the batch does not have to be finalized to fetch the entry value.\n    /// @dev Will revert if the batch with the given nonce does not exist,\n    /// or the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the existing batch\n    /// @param entryIndex   The index of the written entry within the batch\n    function getEntryValue(uint64 dbNonce, uint64 entryIndex) external view returns (bytes32);\n\n    /// @notice Get the Merkle proof of inclusion for the entry with the given index\n    /// in the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param entryIndex   The index of the written entry within the batch\n    /// @return proof       The Merkle proof of inclusion for the entry\n    function getEntryProof(uint64 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof);\n\n    /// @notice Get the nonce of the database, which is incremented every time a new batch is finalized.\n    /// This is the nonce of the current non-finalized batch.\n    function getDBNonce() external view returns (uint64);\n\n    /// @notice Get the index of the next entry to be written to the database.\n    /// @return dbNonce      The database nonce of the batch including the next entry\n    /// @return entryIndex   The index of the next entry within that batch\n    function getNextEntryIndex() external view returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or ZERO if the module has not verified the entry.\n    function checkVerification(\n        address dstModule,\n        InterchainEntry memory entry,\n        bytes32[] memory proof\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n\n    /// @notice Get the version of the Interchain DataBase.\n    // solhint-disable-next-line func-name-mixedcase\n    function DB_VERSION() external pure returns (uint16);\n}\n\n// contracts/InterchainClientV1.sol\n\n/**\n * @title InterchainClientV1\n * @dev Implements the operations of the Interchain Execution Layer.\n */\ncontract InterchainClientV1 is Ownable, InterchainClientV1Events, IInterchainClientV1 {\n    using AppConfigLib for bytes;\n    using OptionsLib for bytes;\n    using VersionedPayloadLib for bytes;\n\n    /// @notice Version of the InterchainClient contract. Sent and received transactions must have the same version.\n    uint16 public constant CLIENT_VERSION = 1;\n\n    /// @notice Address of the InterchainDB contract, set at the time of deployment.\n    address public immutable INTERCHAIN_DB;\n\n    /// @notice Address of the contract that handles execution fees. Can be updated by the owner.\n    address public executionFees;\n\n    /// @dev Address of the InterchainClient contract on the remote chain\n    mapping(uint64 chainId =\u003e bytes32 remoteClient) internal _linkedClient;\n    /// @dev Executor address that completed the transaction. Address(0) if not executed yet.\n    mapping(bytes32 transactionId =\u003e address executor) internal _txExecutor;\n\n    constructor(address interchainDB, address owner_) Ownable(owner_) {\n        INTERCHAIN_DB = interchainDB;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function setExecutionFees(address executionFees_) external onlyOwner {\n        executionFees = executionFees_;\n        emit ExecutionFeesSet(executionFees_);\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function setLinkedClient(uint64 chainId, bytes32 client) external onlyOwner {\n        _linkedClient[chainId] = client;\n        emit LinkedClientSet(chainId, client);\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _interchainSend(dstChainId, receiver, srcExecutionService, srcModules, options, message);\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function interchainSendEVM(\n        uint64 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc)\n    {\n        bytes32 receiverBytes32 = TypeCasts.addressToBytes32(receiver);\n        return _interchainSend(dstChainId, receiverBytes32, srcExecutionService, srcModules, options, message);\n    }\n\n    // TODO: Handle the case where receiver does not implement the IInterchainApp interface (or does not exist at all)\n    // @inheritdoc IInterchainClientV1\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable\n    {\n        InterchainTransaction memory icTx = _assertCorrectVersion(transaction);\n        bytes32 transactionId = keccak256(transaction);\n        _assertExecutable(icTx, transactionId, proof);\n        _txExecutor[transactionId] = msg.sender;\n\n        OptionsV1 memory decodedOptions = icTx.options.decodeOptionsV1();\n        if (msg.value != decodedOptions.gasAirdrop) {\n            revert InterchainClientV1__IncorrectMsgValue(msg.value, decodedOptions.gasAirdrop);\n        }\n        // We should always use at least as much as the requested gas limit.\n        // The executor can specify a higher gas limit if they wanted.\n        if (decodedOptions.gasLimit \u003e gasLimit) gasLimit = decodedOptions.gasLimit;\n        // Check the the Executor has provided big enough gas limit for the whole transaction.\n        if (gasleft() \u003c= gasLimit) {\n            revert InterchainClientV1__NotEnoughGasSupplied();\n        }\n        // Pass the full msg.value to the app: we have already checked that it matches the requested gas airdrop.\n        IInterchainApp(TypeCasts.bytes32ToAddress(icTx.dstReceiver)).appReceive{gas: gasLimit, value: msg.value}({\n            srcChainId: icTx.srcChainId,\n            sender: icTx.srcSender,\n            dbNonce: icTx.dbNonce,\n            entryIndex: icTx.entryIndex,\n            message: icTx.message\n        });\n        emit InterchainTransactionReceived(\n            transactionId, icTx.dbNonce, icTx.entryIndex, icTx.srcChainId, icTx.srcSender, icTx.dstReceiver\n        );\n    }\n\n    /// @inheritdoc IInterchainClientV1\n    function writeExecutionProof(bytes32 transactionId) external returns (uint64 dbNonce, uint64 entryIndex) {\n        address executor = _txExecutor[transactionId];\n        if (executor == address(0)) {\n            revert InterchainClientV1__TxNotExecuted(transactionId);\n        }\n        bytes memory proof = abi.encode(transactionId, executor);\n        (dbNonce, entryIndex) = IInterchainDB(INTERCHAIN_DB).writeEntry(keccak256(proof));\n        emit ExecutionProofWritten(transactionId, dbNonce, entryIndex, executor);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // @inheritdoc IInterchainClientV1\n    function isExecutable(bytes calldata encodedTx, bytes32[] calldata proof) external view returns (bool) {\n        InterchainTransaction memory icTx = _assertCorrectVersion(encodedTx);\n        // Check that options could be decoded\n        icTx.options.decodeOptionsV1();\n        bytes32 transactionId = keccak256(encodedTx);\n        _assertExecutable(icTx, transactionId, proof);\n        return true;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function getExecutor(bytes calldata encodedTx) external view returns (address) {\n        return _txExecutor[keccak256(encodedTx)];\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function getExecutorById(bytes32 transactionId) external view returns (address) {\n        return _txExecutor[transactionId];\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function getInterchainFee(\n        uint64 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        uint256 messageLen\n    )\n        external\n        view\n        returns (uint256 fee)\n    {\n        _assertLinkedClient(dstChainId);\n        // Check that options could be decoded on destination chain\n        options.decodeOptionsV1();\n        // Verification fee from InterchainDB\n        fee = IInterchainDB(INTERCHAIN_DB).getInterchainFee(dstChainId, srcModules);\n        // Add execution fee, if ExecutionService is provided\n        if (srcExecutionService != address(0)) {\n            uint256 payloadSize = InterchainTransactionLib.payloadSize(options.length, messageLen);\n            fee += IExecutionService(srcExecutionService).getExecutionFee(dstChainId, payloadSize, options);\n        }\n    }\n\n    /// @inheritdoc IInterchainClientV1\n    function getLinkedClient(uint64 chainId) external view returns (bytes32) {\n        if (chainId == block.chainid) {\n            revert InterchainClientV1__NotRemoteChainId(chainId);\n        }\n        return _linkedClient[chainId];\n    }\n\n    /// @inheritdoc IInterchainClientV1\n    function getLinkedClientEVM(uint64 chainId) external view returns (address linkedClientEVM) {\n        if (chainId == block.chainid) {\n            revert InterchainClientV1__NotRemoteChainId(chainId);\n        }\n        bytes32 linkedClient = _linkedClient[chainId];\n        linkedClientEVM = TypeCasts.bytes32ToAddress(linkedClient);\n        // Check that the linked client address fits into the EVM address space\n        if (TypeCasts.addressToBytes32(linkedClientEVM) != linkedClient) {\n            revert InterchainClientV1__NotEVMClient(linkedClient);\n        }\n    }\n\n    /// @notice Decodes the encoded options data into a OptionsV1 struct.\n    function decodeOptions(bytes memory encodedOptions) external view returns (OptionsV1 memory) {\n        return encodedOptions.decodeOptionsV1();\n    }\n\n    /// @notice Encodes the transaction data into a bytes format.\n    function encodeTransaction(InterchainTransaction memory icTx) public pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload({\n            version: CLIENT_VERSION,\n            payload: InterchainTransactionLib.encodeTransaction(icTx)\n        });\n    }\n\n    // ═════════════════════════════════════════════════ INTERNAL ══════════════════════════════════════════════════════\n\n    /// @dev Internal logic for sending a message to another chain.\n    function _interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        _assertLinkedClient(dstChainId);\n        if (receiver == 0) revert InterchainClientV1__ZeroReceiver();\n        // Check that options could be decoded on destination chain\n        options.decodeOptionsV1();\n        uint256 verificationFee = IInterchainDB(INTERCHAIN_DB).getInterchainFee(dstChainId, srcModules);\n        if (msg.value \u003c verificationFee) {\n            revert InterchainClientV1__FeeAmountTooLow(msg.value, verificationFee);\n        }\n        (desc.dbNonce, desc.entryIndex) = IInterchainDB(INTERCHAIN_DB).getNextEntryIndex();\n        InterchainTransaction memory icTx = InterchainTransactionLib.constructLocalTransaction({\n            srcSender: msg.sender,\n            dstReceiver: receiver,\n            dstChainId: dstChainId,\n            dbNonce: desc.dbNonce,\n            entryIndex: desc.entryIndex,\n            options: options,\n            message: message\n        });\n        desc.transactionId = keccak256(encodeTransaction(icTx));\n        // Sanity check: nonce returned from DB should match the nonce used to construct the transaction\n        {\n            (uint64 dbNonce, uint64 entryIndex) = IInterchainDB(INTERCHAIN_DB).writeEntryWithVerification{\n                value: verificationFee\n            }(icTx.dstChainId, desc.transactionId, srcModules);\n            assert(dbNonce == desc.dbNonce \u0026\u0026 entryIndex == desc.entryIndex);\n        }\n        uint256 executionFee;\n        unchecked {\n            executionFee = msg.value - verificationFee;\n        }\n        if (executionFee \u003e 0) {\n            IExecutionFees(executionFees).addExecutionFee{value: executionFee}(icTx.dstChainId, desc.transactionId);\n        }\n        // TODO: consider disallowing the use of empty srcExecutionService\n        if (srcExecutionService != address(0)) {\n            IExecutionService(srcExecutionService).requestExecution({\n                dstChainId: dstChainId,\n                txPayloadSize: InterchainTransactionLib.payloadSize(options.length, message.length),\n                transactionId: desc.transactionId,\n                executionFee: executionFee,\n                options: options\n            });\n            address srcExecutorEOA = IExecutionService(srcExecutionService).executorEOA();\n            IExecutionFees(executionFees).recordExecutor(icTx.dstChainId, desc.transactionId, srcExecutorEOA);\n        }\n        emit InterchainTransactionSent(\n            desc.transactionId,\n            icTx.dbNonce,\n            icTx.entryIndex,\n            icTx.dstChainId,\n            icTx.srcSender,\n            icTx.dstReceiver,\n            verificationFee,\n            executionFee,\n            icTx.options,\n            icTx.message\n        );\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Asserts that the transaction is executable.\n    function _assertExecutable(\n        InterchainTransaction memory icTx,\n        bytes32 transactionId,\n        bytes32[] calldata proof\n    )\n        internal\n        view\n    {\n        bytes32 linkedClient = _assertLinkedClient(icTx.srcChainId);\n        if (icTx.dstChainId != block.chainid) {\n            revert InterchainClientV1__IncorrectDstChainId(icTx.dstChainId);\n        }\n        if (_txExecutor[transactionId] != address(0)) {\n            revert InterchainClientV1__TxAlreadyExecuted(transactionId);\n        }\n        // Construct expected entry based on icTransaction data\n        InterchainEntry memory icEntry = InterchainEntry({\n            srcChainId: icTx.srcChainId,\n            dbNonce: icTx.dbNonce,\n            entryIndex: icTx.entryIndex,\n            srcWriter: linkedClient,\n            dataHash: transactionId\n        });\n        (bytes memory encodedAppConfig, address[] memory approvedDstModules) =\n            IInterchainApp(TypeCasts.bytes32ToAddress(icTx.dstReceiver)).getReceivingConfig();\n        AppConfigV1 memory appConfig = encodedAppConfig.decodeAppConfigV1();\n        if (appConfig.requiredResponses == 0) {\n            revert InterchainClientV1__ZeroRequiredResponses();\n        }\n        uint256 responses = _getFinalizedResponsesCount(approvedDstModules, icEntry, proof, appConfig.optimisticPeriod);\n        if (responses \u003c appConfig.requiredResponses) {\n            revert InterchainClientV1__NotEnoughResponses(responses, appConfig.requiredResponses);\n        }\n    }\n\n    /// @dev Asserts that the chain is linked and returns the linked client address.\n    function _assertLinkedClient(uint64 chainId) internal view returns (bytes32 linkedClient) {\n        if (chainId == block.chainid) {\n            revert InterchainClientV1__NotRemoteChainId(chainId);\n        }\n        linkedClient = _linkedClient[chainId];\n        if (linkedClient == 0) {\n            revert InterchainClientV1__NoLinkedClient(chainId);\n        }\n    }\n\n    /**\n     * @dev Calculates the number of responses that are considered finalized within the optimistic time period.\n     * @param approvedModules       Approved modules that could have confirmed the entry.\n     * @param icEntry               The InterchainEntry to confirm.\n     * @param optimisticPeriod      The time period in seconds within which a response is considered valid.\n     * @return finalizedResponses   The count of responses that are finalized within the optimistic time period.\n     */\n    function _getFinalizedResponsesCount(\n        address[] memory approvedModules,\n        InterchainEntry memory icEntry,\n        bytes32[] calldata proof,\n        uint256 optimisticPeriod\n    )\n        internal\n        view\n        returns (uint256 finalizedResponses)\n    {\n        for (uint256 i = 0; i \u003c approvedModules.length; ++i) {\n            uint256 confirmedAt = IInterchainDB(INTERCHAIN_DB).checkVerification(approvedModules[i], icEntry, proof);\n            // checkVerification() returns 0 if entry hasn't been confirmed by the module, so we check for that as well\n            if (confirmedAt != 0 \u0026\u0026 confirmedAt + optimisticPeriod \u003c block.timestamp) {\n                ++finalizedResponses;\n            }\n        }\n    }\n\n    /// @dev Asserts that the transaction version is correct. Returns the decoded transaction for chaining purposes.\n    function _assertCorrectVersion(bytes calldata versionedTx)\n        internal\n        pure\n        returns (InterchainTransaction memory icTx)\n    {\n        uint16 version = versionedTx.getVersion();\n        if (version != CLIENT_VERSION) {\n            revert InterchainClientV1__InvalidTransactionVersion(version);\n        }\n        icTx = InterchainTransactionLib.decodeTransaction(versionedTx.getPayload());\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[],"name":"executorEOA","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint64","name":"dstChainId","type":"uint64"},{"internalType":"uint256","name":"txPayloadSize","type":"uint256"},{"internalType":"bytes","name":"options","type":"bytes"}],"name":"getExecutionFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint64","name":"dstChainId","type":"uint64"},{"internalType":"uint256","name":"txPayloadSize","type":"uint256"},{"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"internalType":"uint256","name":"executionFee","type":"uint256"},{"internalType":"bytes","name":"options","type":"bytes"}],"name":"requestExecution","outputs":[],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{"executorEOA()":{"notice":"Get the address of the EOA account that will be used to execute transactions on the remote chains."},"getExecutionFee(uint64,uint256,bytes)":{"notice":"Get the execution fee for executing an Interchain Transaction on a remote chain."},"requestExecution(uint64,uint256,bytes32,uint256,bytes)":{"notice":"Request the execution of an Interchain Transaction on a remote chain. Note: the off-chain actor needs to fetch the transaction payload from the InterchainClient event with the same transactionId, then execute the transaction on the remote chain: `dstInterchainClient.executeTransaction(transactionPayload)` Once the execution is confirmed on the source chain, the off-chain actor will be able to claim `executionFee` in the ExecutionFees contract."}},"version":1},"developerDoc":{"kind":"dev","methods":{"getExecutionFee(uint64,uint256,bytes)":{"params":{"dstChainId":"The chain id of the destination chain.","options":"The options to use for the execution.","txPayloadSize":"The size of the transaction payload to use for the execution."}},"requestExecution(uint64,uint256,bytes32,uint256,bytes)":{"details":"Could only be called by `InterchainClient` contracts. Will revert if the execution fee is not big enough.","params":{"dstChainId":"The chain id of the destination chain.","executionFee":"The fee paid for the execution.","options":"The options to use for the execution.","transactionId":"The id of the transaction to execute.","txPayloadSize":"The size of the transaction payload to use for the execution."}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"executorEOA\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"dstChainId\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"txPayloadSize\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"options\",\"type\":\"bytes\"}],\"name\":\"getExecutionFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"dstChainId\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"txPayloadSize\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"executionFee\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"options\",\"type\":\"bytes\"}],\"name\":\"requestExecution\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"getExecutionFee(uint64,uint256,bytes)\":{\"params\":{\"dstChainId\":\"The chain id of the destination chain.\",\"options\":\"The options to use for the execution.\",\"txPayloadSize\":\"The size of the transaction payload to use for the execution.\"}},\"requestExecution(uint64,uint256,bytes32,uint256,bytes)\":{\"details\":\"Could only be called by `InterchainClient` contracts. Will revert if the execution fee is not big enough.\",\"params\":{\"dstChainId\":\"The chain id of the destination chain.\",\"executionFee\":\"The fee paid for the execution.\",\"options\":\"The options to use for the execution.\",\"transactionId\":\"The id of the transaction to execute.\",\"txPayloadSize\":\"The size of the transaction payload to use for the execution.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"executorEOA()\":{\"notice\":\"Get the address of the EOA account that will be used to execute transactions on the remote chains.\"},\"getExecutionFee(uint64,uint256,bytes)\":{\"notice\":\"Get the execution fee for executing an Interchain Transaction on a remote chain.\"},\"requestExecution(uint64,uint256,bytes32,uint256,bytes)\":{\"notice\":\"Request the execution of an Interchain Transaction on a remote chain. Note: the off-chain actor needs to fetch the transaction payload from the InterchainClient event with the same transactionId, then execute the transaction on the remote chain: `dstInterchainClient.executeTransaction(transactionPayload)` Once the execution is confirmed on the source chain, the off-chain actor will be able to claim `executionFee` in the ExecutionFees contract.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainClientV1.sol\":\"IExecutionService\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainClientV1.sol\":{\"keccak256\":\"0xe270686a9bca05b4013610a4e8bb08040de32a0442edd218e1692edaca94e40e\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://727e84146369613e04e57a677f8bc6c709ee145df3eeb79f15ea5a922198d78f\",\"dweb:/ipfs/QmUXh2nDtHBnhYZSwCxcteN4be13S7dR9GbqqHT9mUxta3\"]}},\"version\":1}"},"hashes":{"executorEOA()":"62014bad","getExecutionFee(uint64,uint256,bytes)":"96fda4da","requestExecution(uint64,uint256,bytes32,uint256,bytes)":"592a8799"}},"solidity/InterchainClientV1.sol:IInterchainApp":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainClientV1Events.sol\n\nabstract contract InterchainClientV1Events {\n    event ExecutionFeesSet(address executionFees);\n    event LinkedClientSet(uint64 chainId, bytes32 client);\n\n    // TODO: figure out indexing\n\n    event InterchainTransactionSent(\n        bytes32 indexed transactionId,\n        uint64 indexed dbNonce,\n        uint64 indexed entryIndex,\n        uint64 dstChainId,\n        bytes32 srcSender,\n        bytes32 dstReceiver,\n        uint256 verificationFee,\n        uint256 executionFee,\n        bytes options,\n        bytes message\n    );\n\n    event InterchainTransactionReceived(\n        bytes32 indexed transactionId,\n        uint64 indexed dbNonce,\n        uint64 indexed entryIndex,\n        uint64 srcChainId,\n        bytes32 srcSender,\n        bytes32 dstReceiver\n    );\n\n    event ExecutionProofWritten(\n        bytes32 indexed transactionId, uint64 indexed dbNonce, uint64 indexed entryIndex, address executor\n    );\n}\n\n// contracts/interfaces/IExecutionFees.sol\n\ninterface IExecutionFees {\n    error ExecutionFees__AlreadyRecorded(uint64 dstChainId, bytes32 transactionId, address executor);\n    error ExecutionFees__ZeroAddress();\n    error ExecutionFees__ZeroAmount();\n\n    /// @notice Add the execution fee for a transaction. The attached value will be added to the\n    /// rewards for the executor completing the transaction.\n    /// Note: this could be used to store the execution fee for a new transaction, or to add more\n    /// funds to the execution fee of an existing transaction. Therefore this function is payable,\n    /// and does not implement any caller restrictions.\n    /// @dev Will revert if the executor is already recorded for the transaction.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to add the execution fee to.\n    function addExecutionFee(uint64 dstChainId, bytes32 transactionId) external payable;\n\n    /// @notice Record the executor (who completed the transaction) for a transaction,\n    /// and update the accumulated rewards for the executor.\n    /// @dev Could only be called by the Recorder.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to record the executor for.\n    /// @param executor             The address of the executor who completed the transaction.\n    function recordExecutor(uint64 dstChainId, bytes32 transactionId, address executor) external;\n\n    /// @notice Allows the executor to claim their unclaimed rewards.\n    /// @dev Will revert if the executor has no unclaimed rewards.\n    function claimExecutionFees(address executor) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the accumulated rewards for an executor.\n    /// @param executor             The address of the executor to get the rewards for.\n    function accumulatedRewards(address executor) external view returns (uint256 accumulated);\n\n    /// @notice Get the unclaimed rewards for an executor.\n    /// @param executor             The address of the executor to get the rewards for.\n    function unclaimedRewards(address executor) external view returns (uint256 unclaimed);\n\n    /// @notice Get the total execution fee for a transaction.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to get the execution fee for.\n    function executionFee(uint64 dstChainId, bytes32 transactionId) external view returns (uint256 fee);\n\n    /// @notice Get the address of the recorded executor for a transaction.\n    /// @dev Will return address(0) if the executor is not recorded.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to get the recorded executor for.\n    function recordedExecutor(uint64 dstChainId, bytes32 transactionId) external view returns (address executor);\n}\n\n// contracts/interfaces/IExecutionService.sol\n\ninterface IExecutionService {\n    /// @notice Request the execution of an Interchain Transaction on a remote chain.\n    /// Note: the off-chain actor needs to fetch the transaction payload from the InterchainClient\n    /// event with the same transactionId, then execute the transaction on the remote chain:\n    /// `dstInterchainClient.executeTransaction(transactionPayload)`\n    /// Once the execution is confirmed on the source chain, the off-chain actor will be able\n    /// to claim `executionFee` in the ExecutionFees contract.\n    /// @dev Could only be called by `InterchainClient` contracts.\n    /// Will revert if the execution fee is not big enough.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param txPayloadSize        The size of the transaction payload to use for the execution.\n    /// @param transactionId        The id of the transaction to execute.\n    /// @param executionFee         The fee paid for the execution.\n    /// @param options              The options to use for the execution.\n    function requestExecution(\n        uint64 dstChainId,\n        uint256 txPayloadSize,\n        bytes32 transactionId,\n        uint256 executionFee,\n        bytes memory options\n    )\n        external;\n\n    /// @notice Get the address of the EOA account that will be used to execute transactions on the\n    /// remote chains.\n    function executorEOA() external view returns (address);\n\n    /// @notice Get the execution fee for executing an Interchain Transaction on a remote chain.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param txPayloadSize        The size of the transaction payload to use for the execution.\n    /// @param options              The options to use for the execution.\n    function getExecutionFee(\n        uint64 dstChainId,\n        uint256 txPayloadSize,\n        bytes memory options\n    )\n        external\n        view\n        returns (uint256);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    /// @notice Allows the Interchain Client to pass the message to the Interchain App.\n    /// @dev App is responsible for keeping track of interchain clients, and must verify the message sender.\n    /// @param srcChainId   Chain ID of the source chain, where the message was sent from.\n    /// @param sender       Sender address on the source chain, as a bytes32 value.\n    /// @param dbNonce      The Interchain DB nonce of the batch containing the message entry.\n    /// @param entryIndex   The index of the message entry within the batch.\n    /// @param message      The message being sent.\n    function appReceive(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /// @notice Returns the verification configuration of the Interchain App.\n    /// @dev This configuration is used by the Interchain Client to verify that message has been confirmed\n    /// by the Interchain Modules on the destination chain.\n    /// Note: V1 version of AppConfig includes the required responses count, and optimistic period after which\n    /// the message is considered confirmed by the module. Following versions may include additional fields.\n    /// @return appConfig    The versioned configuration of the Interchain App, encoded as bytes.\n    /// @return modules      The list of Interchain Modules that app is trusting to confirm the messages.\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/Math.sol\n\nlibrary MathLib {\n    /// @notice Rounds up to the nearest multiple of 32.\n    /// Note: Returns zero on overflows instead of reverting. This is fine for practical\n    /// use cases, as this is used for determining the size of the payload in memory.\n    function roundUpToWord(uint256 x) internal pure returns (uint256) {\n        unchecked {\n            return (x + 31) \u0026 ~uint256(31);\n        }\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/VersionedPayload.sol\n\n// solhint-disable no-inline-assembly\n// solhint-disable ordering\nlibrary VersionedPayloadLib {\n    /// @notice Amount of bytes reserved for the version (uint16) in the versioned payload\n    uint256 internal constant VERSION_LENGTH = 2;\n\n    error VersionedPayload__TooShort(bytes versionedPayload);\n    error VersionedPayload__PrecompileFailed();\n\n    /// @notice Encodes the versioned payload into a single bytes array.\n    /// @param version  The payload's version.\n    /// @param payload  The payload to encode.\n    function encodeVersionedPayload(uint16 version, bytes memory payload) internal pure returns (bytes memory) {\n        return abi.encodePacked(version, payload);\n    }\n\n    /// @notice Extracts the version from the versioned payload (calldata reference).\n    /// @param versionedPayload     The versioned payload (calldata reference).\n    function getVersion(bytes calldata versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            version := shr(240, calldataload(versionedPayload.offset))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (calldata reference).\n    /// @dev The extracted payload is also returned as a calldata reference.\n    /// @param versionedPayload     The versioned payload.\n    function getPayload(bytes calldata versionedPayload) internal pure returns (bytes calldata) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        return versionedPayload[VERSION_LENGTH:];\n    }\n\n    /// @notice Extracts the version from the versioned payload (memory reference).\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getVersionFromMemory(bytes memory versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            // We add 0x20 to skip the length of the bytes array.\n            version := shr(240, mload(add(versionedPayload, 0x20)))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (memory reference).\n    /// @dev The extracted payload is copied into a new memory location. Use `getPayload` when possible\n    /// to avoid extra memory allocation.\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getPayloadFromMemory(bytes memory versionedPayload) internal view returns (bytes memory payload) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        // Figure how many bytes to copy and allocate the memory for the extracted payload.\n        uint256 toCopy;\n        unchecked {\n            toCopy = versionedPayload.length - VERSION_LENGTH;\n        }\n        payload = new bytes(toCopy);\n        // Use identity precompile (0x04) to copy the payload. Unlike MCOPY, this is available on all EVM chains.\n        bool res;\n        assembly {\n            // We add 0x20 to skip the length of the bytes array.\n            // We add 0x02 to skip the 2 bytes reserved for the version.\n            // Copy the payload to the previously allocated memory.\n            res := staticcall(gas(), 0x04, add(versionedPayload, 0x22), toCopy, add(payload, 0x20), toCopy)\n        }\n        if (!res) {\n            revert VersionedPayload__PrecompileFailed();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SafeCast.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value \u003e type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value \u003e type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value \u003e type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value \u003e type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value \u003e type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value \u003e type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value \u003e type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value \u003e type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value \u003e type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value \u003e type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value \u003e type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value \u003e type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value \u003e type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value \u003e type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value \u003e type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value \u003e type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value \u003e type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value \u003e type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value \u003e type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value \u003e type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value \u003e type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value \u003e type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value \u003e type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value \u003e type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value \u003e type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value \u003e type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value \u003e type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value \u003e type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value \u003e type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value \u003e type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value \u003e type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value \u003c 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value \u003e uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal view returns (AppConfigV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (AppConfigV1));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal view returns (OptionsV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (OptionsV1));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(OPTIONS_V1, abi.encode(options));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/libs/InterchainBatch.sol\n\ntype BatchKey is uint128;\n\n/// @notice Struct representing a batch of entries in the Interchain DataBase.\n/// Batched entries are put together in a Merkle tree, which root is saved.\n/// Batch has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: batchRoot\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch\n/// @param batchRoot    The root of the Merkle tree containing the batched entries\nstruct InterchainBatch {\n    uint64 srcChainId;\n    uint64 dbNonce;\n    bytes32 batchRoot;\n}\n\nlibrary InterchainBatchLib {\n    using VersionedPayloadLib for bytes;\n\n    /// @notice Constructs an InterchainBatch struct to be saved on the local chain.\n    /// @param dbNonce      The database nonce of the batch\n    /// @param batchRoot    The root of the Merkle tree containing the batched entries\n    /// @return batch       The constructed InterchainBatch struct\n    function constructLocalBatch(\n        uint64 dbNonce,\n        bytes32 batchRoot\n    )\n        internal\n        view\n        returns (InterchainBatch memory batch)\n    {\n        return InterchainBatch({srcChainId: SafeCast.toUint64(block.chainid), dbNonce: dbNonce, batchRoot: batchRoot});\n    }\n\n    /// @notice Encodes the InterchainBatch struct into a non-versioned batch payload.\n    function encodeBatch(InterchainBatch memory batch) internal pure returns (bytes memory) {\n        return abi.encode(encodeBatchKey(batch.srcChainId, batch.dbNonce), batch.batchRoot);\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in calldata.\n    function decodeBatch(bytes calldata data) internal pure returns (InterchainBatch memory batch) {\n        BatchKey key;\n        (key, batch.batchRoot) = abi.decode(data, (BatchKey, bytes32));\n        (batch.srcChainId, batch.dbNonce) = decodeBatchKey(key);\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in memory.\n    function decodeBatchFromMemory(bytes memory data) internal pure returns (InterchainBatch memory batch) {\n        BatchKey key;\n        (key, batch.batchRoot) = abi.decode(data, (BatchKey, bytes32));\n        (batch.srcChainId, batch.dbNonce) = decodeBatchKey(key);\n    }\n\n    /// @notice Encodes the uint128 key of the batch from uint64 srcChainId and uint64 dbNonce.\n    function encodeBatchKey(uint64 srcChainId, uint64 dbNonce) internal pure returns (BatchKey) {\n        return BatchKey.wrap((uint128(srcChainId) \u003c\u003c 64) | dbNonce);\n    }\n\n    /// @notice Decodes the uint128 key of the batch into uint64 srcChainId and uint64 dbNonce.\n    function decodeBatchKey(BatchKey key) internal pure returns (uint64 srcChainId, uint64 dbNonce) {\n        srcChainId = uint64(BatchKey.unwrap(key) \u003e\u003e 64);\n        dbNonce = uint64(BatchKey.unwrap(key));\n    }\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce + entryIndex\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch containing the entry\n/// @param entryIndex   The index of the entry in the batch\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint64 srcChainId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nusing InterchainEntryLib for InterchainEntry global;\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint64 dbNonce,\n        uint64 entryIndex,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: SafeCast.toUint64(block.chainid),\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n}\n\n// contracts/libs/InterchainTransaction.sol\n\ntype ICTxHeader is uint256;\n\nstruct InterchainTransaction {\n    uint64 srcChainId;\n    uint64 dstChainId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcSender;\n    bytes32 dstReceiver;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    using MathLib for uint256;\n    using VersionedPayloadLib for bytes;\n\n    function constructLocalTransaction(\n        address srcSender,\n        uint64 dstChainId,\n        bytes32 dstReceiver,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: SafeCast.toUint64(block.chainid),\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            encodeTxHeader(transaction.srcChainId, transaction.dstChainId, transaction.dbNonce, transaction.entryIndex),\n            transaction.srcSender,\n            transaction.dstReceiver,\n            transaction.options,\n            transaction.message\n        );\n    }\n\n    function decodeTransaction(bytes calldata transaction) internal pure returns (InterchainTransaction memory icTx) {\n        ICTxHeader header;\n        (header, icTx.srcSender, icTx.dstReceiver, icTx.options, icTx.message) =\n            abi.decode(transaction, (ICTxHeader, bytes32, bytes32, bytes, bytes));\n        (icTx.srcChainId, icTx.dstChainId, icTx.dbNonce, icTx.entryIndex) = decodeTxHeader(header);\n    }\n\n    function payloadSize(uint256 optionsLen, uint256 messageLen) internal pure returns (uint256) {\n        // 2 bytes are reserved for the transaction version\n        // + 5 fields * 32 bytes (3 values for static, 2 offsets for dynamic) + 2 * 32 bytes (lengths for dynamic) = 226\n        // (srcChainId, dstChainId, dbNonce, entryIndex) are merged into a single 32 bytes field\n        // Both options and message are dynamic fields, which are padded up to 32 bytes\n        return 226 + optionsLen.roundUpToWord() + messageLen.roundUpToWord();\n    }\n\n    function encodeTxHeader(\n        uint64 srcChainId,\n        uint64 dstChainId,\n        uint64 dbNonce,\n        uint64 entryIndex\n    )\n        internal\n        pure\n        returns (ICTxHeader)\n    {\n        return ICTxHeader.wrap(\n            (uint256(srcChainId) \u003c\u003c 192) | (uint256(dstChainId) \u003c\u003c 128) | (uint256(dbNonce) \u003c\u003c 64) | uint256(entryIndex)\n        );\n    }\n\n    function decodeTxHeader(ICTxHeader header)\n        internal\n        pure\n        returns (uint64 srcChainId, uint64 dstChainId, uint64 dbNonce, uint64 entryIndex)\n    {\n        srcChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 192);\n        dstChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 128);\n        dbNonce = uint64(ICTxHeader.unwrap(header) \u003e\u003e 64);\n        entryIndex = uint64(ICTxHeader.unwrap(header));\n    }\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint64 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__InvalidTransactionVersion(uint16 version);\n    error InterchainClientV1__NoLinkedClient(uint64 chainId);\n    error InterchainClientV1__NotEnoughGasSupplied();\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint64 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint64 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint64 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint64 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param messageLen           The length of the message being sent.\n    function getInterchainFee(\n        uint64 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        uint256 messageLen\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint64 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint64 chainId) external view returns (address);\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing a batch of entries from the remote Interchain DataBase,\n    /// verified by the Interchain Module.\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param batchRoot    The Merkle root of the batch\n    struct RemoteBatch {\n        uint256 verifiedAt;\n        bytes32 batchRoot;\n    }\n\n    error InterchainDB__BatchDoesNotExist(uint64 dbNonce);\n    error InterchainDB__BatchNotFinalized(uint64 dbNonce);\n    error InterchainDB__ConflictingBatches(address module, bytes32 existingBatchRoot, InterchainBatch newBatch);\n    error InterchainDB__EntryIndexOutOfRange(uint64 dbNonce, uint64 entryIndex, uint64 batchSize);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__InvalidBatchVersion(uint16 version);\n    error InterchainDB__InvalidEntryRange(uint64 dbNonce, uint64 start, uint64 end);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId(uint64 chainId);\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `requestBatchVerification` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntry(bytes32 dataHash) external returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Request the given Interchain Modules to verify an existing batch.\n    /// If the batch is not finalized, the module will verify it after finalization.\n    /// For the finalized batch the batch root is already available, and the module can verify it immediately.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any batch.\n    /// @dev Will revert if the batch with the given nonce does not exist.\n    /// @param dstChainId    The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the existing batch\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestBatchVerification(\n        uint64 dstChainId,\n        uint64 dbNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Then request the Interchain Modules to verify the batch containing the written entry on the destination chain.\n    /// See `writeEntry` and `requestBatchVerification` for more details.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntryWithVerification(\n        uint64 dstChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Allows the Interchain Module to verify the batch coming from the remote chain.\n    /// Note: The DB will only accept the batch of the same version as the DB itself.\n    /// @param versionedBatch   The versioned Interchain Batch to verify\n    function verifyRemoteBatch(bytes memory versionedBatch) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint64 dstChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce.\n    /// Note: the leafs are ordered by the index of the written entry in the current batch,\n    /// and the leafs value match the value of the written entry (srcWriter + dataHash hashed together).\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchLeafs(uint64 dbNonce) external view returns (bytes32[] memory);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce,\n    /// paginated by the given start and end indexes. The end index is exclusive.\n    /// Note: this is useful when the batch contains a large number of leafs, and calling `getBatchLeafs`\n    /// would result in a gas limit exceeded error.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the provided range is invalid.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param start        The start index of the paginated leafs, inclusive\n    /// @param end          The end index of the paginated leafs, exclusive\n    function getBatchLeafsPaginated(\n        uint64 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory);\n\n    /// @notice Returns the size of the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchSize(uint64 dbNonce) external view returns (uint64);\n\n    /// @notice Get the finalized Interchain Batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatch(uint64 dbNonce) external view returns (InterchainBatch memory);\n\n    /// @notice Get the Interchain Entry's value written on the local chain with the given batch nonce and entry index.\n    /// Entry value is calculated as the hash of the writer address and the written data hash.\n    /// Note: the batch does not have to be finalized to fetch the entry value.\n    /// @dev Will revert if the batch with the given nonce does not exist,\n    /// or the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the existing batch\n    /// @param entryIndex   The index of the written entry within the batch\n    function getEntryValue(uint64 dbNonce, uint64 entryIndex) external view returns (bytes32);\n\n    /// @notice Get the Merkle proof of inclusion for the entry with the given index\n    /// in the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param entryIndex   The index of the written entry within the batch\n    /// @return proof       The Merkle proof of inclusion for the entry\n    function getEntryProof(uint64 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof);\n\n    /// @notice Get the nonce of the database, which is incremented every time a new batch is finalized.\n    /// This is the nonce of the current non-finalized batch.\n    function getDBNonce() external view returns (uint64);\n\n    /// @notice Get the index of the next entry to be written to the database.\n    /// @return dbNonce      The database nonce of the batch including the next entry\n    /// @return entryIndex   The index of the next entry within that batch\n    function getNextEntryIndex() external view returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or ZERO if the module has not verified the entry.\n    function checkVerification(\n        address dstModule,\n        InterchainEntry memory entry,\n        bytes32[] memory proof\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n\n    /// @notice Get the version of the Interchain DataBase.\n    // solhint-disable-next-line func-name-mixedcase\n    function DB_VERSION() external pure returns (uint16);\n}\n\n// contracts/InterchainClientV1.sol\n\n/**\n * @title InterchainClientV1\n * @dev Implements the operations of the Interchain Execution Layer.\n */\ncontract InterchainClientV1 is Ownable, InterchainClientV1Events, IInterchainClientV1 {\n    using AppConfigLib for bytes;\n    using OptionsLib for bytes;\n    using VersionedPayloadLib for bytes;\n\n    /// @notice Version of the InterchainClient contract. Sent and received transactions must have the same version.\n    uint16 public constant CLIENT_VERSION = 1;\n\n    /// @notice Address of the InterchainDB contract, set at the time of deployment.\n    address public immutable INTERCHAIN_DB;\n\n    /// @notice Address of the contract that handles execution fees. Can be updated by the owner.\n    address public executionFees;\n\n    /// @dev Address of the InterchainClient contract on the remote chain\n    mapping(uint64 chainId =\u003e bytes32 remoteClient) internal _linkedClient;\n    /// @dev Executor address that completed the transaction. Address(0) if not executed yet.\n    mapping(bytes32 transactionId =\u003e address executor) internal _txExecutor;\n\n    constructor(address interchainDB, address owner_) Ownable(owner_) {\n        INTERCHAIN_DB = interchainDB;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function setExecutionFees(address executionFees_) external onlyOwner {\n        executionFees = executionFees_;\n        emit ExecutionFeesSet(executionFees_);\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function setLinkedClient(uint64 chainId, bytes32 client) external onlyOwner {\n        _linkedClient[chainId] = client;\n        emit LinkedClientSet(chainId, client);\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _interchainSend(dstChainId, receiver, srcExecutionService, srcModules, options, message);\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function interchainSendEVM(\n        uint64 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc)\n    {\n        bytes32 receiverBytes32 = TypeCasts.addressToBytes32(receiver);\n        return _interchainSend(dstChainId, receiverBytes32, srcExecutionService, srcModules, options, message);\n    }\n\n    // TODO: Handle the case where receiver does not implement the IInterchainApp interface (or does not exist at all)\n    // @inheritdoc IInterchainClientV1\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable\n    {\n        InterchainTransaction memory icTx = _assertCorrectVersion(transaction);\n        bytes32 transactionId = keccak256(transaction);\n        _assertExecutable(icTx, transactionId, proof);\n        _txExecutor[transactionId] = msg.sender;\n\n        OptionsV1 memory decodedOptions = icTx.options.decodeOptionsV1();\n        if (msg.value != decodedOptions.gasAirdrop) {\n            revert InterchainClientV1__IncorrectMsgValue(msg.value, decodedOptions.gasAirdrop);\n        }\n        // We should always use at least as much as the requested gas limit.\n        // The executor can specify a higher gas limit if they wanted.\n        if (decodedOptions.gasLimit \u003e gasLimit) gasLimit = decodedOptions.gasLimit;\n        // Check the the Executor has provided big enough gas limit for the whole transaction.\n        if (gasleft() \u003c= gasLimit) {\n            revert InterchainClientV1__NotEnoughGasSupplied();\n        }\n        // Pass the full msg.value to the app: we have already checked that it matches the requested gas airdrop.\n        IInterchainApp(TypeCasts.bytes32ToAddress(icTx.dstReceiver)).appReceive{gas: gasLimit, value: msg.value}({\n            srcChainId: icTx.srcChainId,\n            sender: icTx.srcSender,\n            dbNonce: icTx.dbNonce,\n            entryIndex: icTx.entryIndex,\n            message: icTx.message\n        });\n        emit InterchainTransactionReceived(\n            transactionId, icTx.dbNonce, icTx.entryIndex, icTx.srcChainId, icTx.srcSender, icTx.dstReceiver\n        );\n    }\n\n    /// @inheritdoc IInterchainClientV1\n    function writeExecutionProof(bytes32 transactionId) external returns (uint64 dbNonce, uint64 entryIndex) {\n        address executor = _txExecutor[transactionId];\n        if (executor == address(0)) {\n            revert InterchainClientV1__TxNotExecuted(transactionId);\n        }\n        bytes memory proof = abi.encode(transactionId, executor);\n        (dbNonce, entryIndex) = IInterchainDB(INTERCHAIN_DB).writeEntry(keccak256(proof));\n        emit ExecutionProofWritten(transactionId, dbNonce, entryIndex, executor);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // @inheritdoc IInterchainClientV1\n    function isExecutable(bytes calldata encodedTx, bytes32[] calldata proof) external view returns (bool) {\n        InterchainTransaction memory icTx = _assertCorrectVersion(encodedTx);\n        // Check that options could be decoded\n        icTx.options.decodeOptionsV1();\n        bytes32 transactionId = keccak256(encodedTx);\n        _assertExecutable(icTx, transactionId, proof);\n        return true;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function getExecutor(bytes calldata encodedTx) external view returns (address) {\n        return _txExecutor[keccak256(encodedTx)];\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function getExecutorById(bytes32 transactionId) external view returns (address) {\n        return _txExecutor[transactionId];\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function getInterchainFee(\n        uint64 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        uint256 messageLen\n    )\n        external\n        view\n        returns (uint256 fee)\n    {\n        _assertLinkedClient(dstChainId);\n        // Check that options could be decoded on destination chain\n        options.decodeOptionsV1();\n        // Verification fee from InterchainDB\n        fee = IInterchainDB(INTERCHAIN_DB).getInterchainFee(dstChainId, srcModules);\n        // Add execution fee, if ExecutionService is provided\n        if (srcExecutionService != address(0)) {\n            uint256 payloadSize = InterchainTransactionLib.payloadSize(options.length, messageLen);\n            fee += IExecutionService(srcExecutionService).getExecutionFee(dstChainId, payloadSize, options);\n        }\n    }\n\n    /// @inheritdoc IInterchainClientV1\n    function getLinkedClient(uint64 chainId) external view returns (bytes32) {\n        if (chainId == block.chainid) {\n            revert InterchainClientV1__NotRemoteChainId(chainId);\n        }\n        return _linkedClient[chainId];\n    }\n\n    /// @inheritdoc IInterchainClientV1\n    function getLinkedClientEVM(uint64 chainId) external view returns (address linkedClientEVM) {\n        if (chainId == block.chainid) {\n            revert InterchainClientV1__NotRemoteChainId(chainId);\n        }\n        bytes32 linkedClient = _linkedClient[chainId];\n        linkedClientEVM = TypeCasts.bytes32ToAddress(linkedClient);\n        // Check that the linked client address fits into the EVM address space\n        if (TypeCasts.addressToBytes32(linkedClientEVM) != linkedClient) {\n            revert InterchainClientV1__NotEVMClient(linkedClient);\n        }\n    }\n\n    /// @notice Decodes the encoded options data into a OptionsV1 struct.\n    function decodeOptions(bytes memory encodedOptions) external view returns (OptionsV1 memory) {\n        return encodedOptions.decodeOptionsV1();\n    }\n\n    /// @notice Encodes the transaction data into a bytes format.\n    function encodeTransaction(InterchainTransaction memory icTx) public pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload({\n            version: CLIENT_VERSION,\n            payload: InterchainTransactionLib.encodeTransaction(icTx)\n        });\n    }\n\n    // ═════════════════════════════════════════════════ INTERNAL ══════════════════════════════════════════════════════\n\n    /// @dev Internal logic for sending a message to another chain.\n    function _interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        _assertLinkedClient(dstChainId);\n        if (receiver == 0) revert InterchainClientV1__ZeroReceiver();\n        // Check that options could be decoded on destination chain\n        options.decodeOptionsV1();\n        uint256 verificationFee = IInterchainDB(INTERCHAIN_DB).getInterchainFee(dstChainId, srcModules);\n        if (msg.value \u003c verificationFee) {\n            revert InterchainClientV1__FeeAmountTooLow(msg.value, verificationFee);\n        }\n        (desc.dbNonce, desc.entryIndex) = IInterchainDB(INTERCHAIN_DB).getNextEntryIndex();\n        InterchainTransaction memory icTx = InterchainTransactionLib.constructLocalTransaction({\n            srcSender: msg.sender,\n            dstReceiver: receiver,\n            dstChainId: dstChainId,\n            dbNonce: desc.dbNonce,\n            entryIndex: desc.entryIndex,\n            options: options,\n            message: message\n        });\n        desc.transactionId = keccak256(encodeTransaction(icTx));\n        // Sanity check: nonce returned from DB should match the nonce used to construct the transaction\n        {\n            (uint64 dbNonce, uint64 entryIndex) = IInterchainDB(INTERCHAIN_DB).writeEntryWithVerification{\n                value: verificationFee\n            }(icTx.dstChainId, desc.transactionId, srcModules);\n            assert(dbNonce == desc.dbNonce \u0026\u0026 entryIndex == desc.entryIndex);\n        }\n        uint256 executionFee;\n        unchecked {\n            executionFee = msg.value - verificationFee;\n        }\n        if (executionFee \u003e 0) {\n            IExecutionFees(executionFees).addExecutionFee{value: executionFee}(icTx.dstChainId, desc.transactionId);\n        }\n        // TODO: consider disallowing the use of empty srcExecutionService\n        if (srcExecutionService != address(0)) {\n            IExecutionService(srcExecutionService).requestExecution({\n                dstChainId: dstChainId,\n                txPayloadSize: InterchainTransactionLib.payloadSize(options.length, message.length),\n                transactionId: desc.transactionId,\n                executionFee: executionFee,\n                options: options\n            });\n            address srcExecutorEOA = IExecutionService(srcExecutionService).executorEOA();\n            IExecutionFees(executionFees).recordExecutor(icTx.dstChainId, desc.transactionId, srcExecutorEOA);\n        }\n        emit InterchainTransactionSent(\n            desc.transactionId,\n            icTx.dbNonce,\n            icTx.entryIndex,\n            icTx.dstChainId,\n            icTx.srcSender,\n            icTx.dstReceiver,\n            verificationFee,\n            executionFee,\n            icTx.options,\n            icTx.message\n        );\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Asserts that the transaction is executable.\n    function _assertExecutable(\n        InterchainTransaction memory icTx,\n        bytes32 transactionId,\n        bytes32[] calldata proof\n    )\n        internal\n        view\n    {\n        bytes32 linkedClient = _assertLinkedClient(icTx.srcChainId);\n        if (icTx.dstChainId != block.chainid) {\n            revert InterchainClientV1__IncorrectDstChainId(icTx.dstChainId);\n        }\n        if (_txExecutor[transactionId] != address(0)) {\n            revert InterchainClientV1__TxAlreadyExecuted(transactionId);\n        }\n        // Construct expected entry based on icTransaction data\n        InterchainEntry memory icEntry = InterchainEntry({\n            srcChainId: icTx.srcChainId,\n            dbNonce: icTx.dbNonce,\n            entryIndex: icTx.entryIndex,\n            srcWriter: linkedClient,\n            dataHash: transactionId\n        });\n        (bytes memory encodedAppConfig, address[] memory approvedDstModules) =\n            IInterchainApp(TypeCasts.bytes32ToAddress(icTx.dstReceiver)).getReceivingConfig();\n        AppConfigV1 memory appConfig = encodedAppConfig.decodeAppConfigV1();\n        if (appConfig.requiredResponses == 0) {\n            revert InterchainClientV1__ZeroRequiredResponses();\n        }\n        uint256 responses = _getFinalizedResponsesCount(approvedDstModules, icEntry, proof, appConfig.optimisticPeriod);\n        if (responses \u003c appConfig.requiredResponses) {\n            revert InterchainClientV1__NotEnoughResponses(responses, appConfig.requiredResponses);\n        }\n    }\n\n    /// @dev Asserts that the chain is linked and returns the linked client address.\n    function _assertLinkedClient(uint64 chainId) internal view returns (bytes32 linkedClient) {\n        if (chainId == block.chainid) {\n            revert InterchainClientV1__NotRemoteChainId(chainId);\n        }\n        linkedClient = _linkedClient[chainId];\n        if (linkedClient == 0) {\n            revert InterchainClientV1__NoLinkedClient(chainId);\n        }\n    }\n\n    /**\n     * @dev Calculates the number of responses that are considered finalized within the optimistic time period.\n     * @param approvedModules       Approved modules that could have confirmed the entry.\n     * @param icEntry               The InterchainEntry to confirm.\n     * @param optimisticPeriod      The time period in seconds within which a response is considered valid.\n     * @return finalizedResponses   The count of responses that are finalized within the optimistic time period.\n     */\n    function _getFinalizedResponsesCount(\n        address[] memory approvedModules,\n        InterchainEntry memory icEntry,\n        bytes32[] calldata proof,\n        uint256 optimisticPeriod\n    )\n        internal\n        view\n        returns (uint256 finalizedResponses)\n    {\n        for (uint256 i = 0; i \u003c approvedModules.length; ++i) {\n            uint256 confirmedAt = IInterchainDB(INTERCHAIN_DB).checkVerification(approvedModules[i], icEntry, proof);\n            // checkVerification() returns 0 if entry hasn't been confirmed by the module, so we check for that as well\n            if (confirmedAt != 0 \u0026\u0026 confirmedAt + optimisticPeriod \u003c block.timestamp) {\n                ++finalizedResponses;\n            }\n        }\n    }\n\n    /// @dev Asserts that the transaction version is correct. Returns the decoded transaction for chaining purposes.\n    function _assertCorrectVersion(bytes calldata versionedTx)\n        internal\n        pure\n        returns (InterchainTransaction memory icTx)\n    {\n        uint16 version = versionedTx.getVersion();\n        if (version != CLIENT_VERSION) {\n            revert InterchainClientV1__InvalidTransactionVersion(version);\n        }\n        icTx = InterchainTransactionLib.decodeTransaction(versionedTx.getPayload());\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"uint64","name":"srcChainId","type":"uint64"},{"internalType":"bytes32","name":"sender","type":"bytes32"},{"internalType":"uint64","name":"dbNonce","type":"uint64"},{"internalType":"uint64","name":"entryIndex","type":"uint64"},{"internalType":"bytes","name":"message","type":"bytes"}],"name":"appReceive","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"getReceivingConfig","outputs":[{"internalType":"bytes","name":"appConfig","type":"bytes"},{"internalType":"address[]","name":"modules","type":"address[]"}],"stateMutability":"view","type":"function"}],"userDoc":{"kind":"user","methods":{"appReceive(uint64,bytes32,uint64,uint64,bytes)":{"notice":"Allows the Interchain Client to pass the message to the Interchain App."},"getReceivingConfig()":{"notice":"Returns the verification configuration of the Interchain App."}},"notice":"Minimal interface for the Interchain App to work with the Interchain Client.","version":1},"developerDoc":{"kind":"dev","methods":{"appReceive(uint64,bytes32,uint64,uint64,bytes)":{"details":"App is responsible for keeping track of interchain clients, and must verify the message sender.","params":{"dbNonce":"The Interchain DB nonce of the batch containing the message entry.","entryIndex":"The index of the message entry within the batch.","message":"The message being sent.","sender":"Sender address on the source chain, as a bytes32 value.","srcChainId":"Chain ID of the source chain, where the message was sent from."}},"getReceivingConfig()":{"details":"This configuration is used by the Interchain Client to verify that message has been confirmed by the Interchain Modules on the destination chain. Note: V1 version of AppConfig includes the required responses count, and optimistic period after which the message is considered confirmed by the module. Following versions may include additional fields.","returns":{"appConfig":"   The versioned configuration of the Interchain App, encoded as bytes.","modules":"     The list of Interchain Modules that app is trusting to confirm the messages."}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"srcChainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"appReceive\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReceivingConfig\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"appConfig\",\"type\":\"bytes\"},{\"internalType\":\"address[]\",\"name\":\"modules\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"appReceive(uint64,bytes32,uint64,uint64,bytes)\":{\"details\":\"App is responsible for keeping track of interchain clients, and must verify the message sender.\",\"params\":{\"dbNonce\":\"The Interchain DB nonce of the batch containing the message entry.\",\"entryIndex\":\"The index of the message entry within the batch.\",\"message\":\"The message being sent.\",\"sender\":\"Sender address on the source chain, as a bytes32 value.\",\"srcChainId\":\"Chain ID of the source chain, where the message was sent from.\"}},\"getReceivingConfig()\":{\"details\":\"This configuration is used by the Interchain Client to verify that message has been confirmed by the Interchain Modules on the destination chain. Note: V1 version of AppConfig includes the required responses count, and optimistic period after which the message is considered confirmed by the module. Following versions may include additional fields.\",\"returns\":{\"appConfig\":\"   The versioned configuration of the Interchain App, encoded as bytes.\",\"modules\":\"     The list of Interchain Modules that app is trusting to confirm the messages.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"appReceive(uint64,bytes32,uint64,uint64,bytes)\":{\"notice\":\"Allows the Interchain Client to pass the message to the Interchain App.\"},\"getReceivingConfig()\":{\"notice\":\"Returns the verification configuration of the Interchain App.\"}},\"notice\":\"Minimal interface for the Interchain App to work with the Interchain Client.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainClientV1.sol\":\"IInterchainApp\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainClientV1.sol\":{\"keccak256\":\"0xe270686a9bca05b4013610a4e8bb08040de32a0442edd218e1692edaca94e40e\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://727e84146369613e04e57a677f8bc6c709ee145df3eeb79f15ea5a922198d78f\",\"dweb:/ipfs/QmUXh2nDtHBnhYZSwCxcteN4be13S7dR9GbqqHT9mUxta3\"]}},\"version\":1}"},"hashes":{"appReceive(uint64,bytes32,uint64,uint64,bytes)":"6e9fd609","getReceivingConfig()":"287bc057"}},"solidity/InterchainClientV1.sol:IInterchainClientV1":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainClientV1Events.sol\n\nabstract contract InterchainClientV1Events {\n    event ExecutionFeesSet(address executionFees);\n    event LinkedClientSet(uint64 chainId, bytes32 client);\n\n    // TODO: figure out indexing\n\n    event InterchainTransactionSent(\n        bytes32 indexed transactionId,\n        uint64 indexed dbNonce,\n        uint64 indexed entryIndex,\n        uint64 dstChainId,\n        bytes32 srcSender,\n        bytes32 dstReceiver,\n        uint256 verificationFee,\n        uint256 executionFee,\n        bytes options,\n        bytes message\n    );\n\n    event InterchainTransactionReceived(\n        bytes32 indexed transactionId,\n        uint64 indexed dbNonce,\n        uint64 indexed entryIndex,\n        uint64 srcChainId,\n        bytes32 srcSender,\n        bytes32 dstReceiver\n    );\n\n    event ExecutionProofWritten(\n        bytes32 indexed transactionId, uint64 indexed dbNonce, uint64 indexed entryIndex, address executor\n    );\n}\n\n// contracts/interfaces/IExecutionFees.sol\n\ninterface IExecutionFees {\n    error ExecutionFees__AlreadyRecorded(uint64 dstChainId, bytes32 transactionId, address executor);\n    error ExecutionFees__ZeroAddress();\n    error ExecutionFees__ZeroAmount();\n\n    /// @notice Add the execution fee for a transaction. The attached value will be added to the\n    /// rewards for the executor completing the transaction.\n    /// Note: this could be used to store the execution fee for a new transaction, or to add more\n    /// funds to the execution fee of an existing transaction. Therefore this function is payable,\n    /// and does not implement any caller restrictions.\n    /// @dev Will revert if the executor is already recorded for the transaction.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to add the execution fee to.\n    function addExecutionFee(uint64 dstChainId, bytes32 transactionId) external payable;\n\n    /// @notice Record the executor (who completed the transaction) for a transaction,\n    /// and update the accumulated rewards for the executor.\n    /// @dev Could only be called by the Recorder.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to record the executor for.\n    /// @param executor             The address of the executor who completed the transaction.\n    function recordExecutor(uint64 dstChainId, bytes32 transactionId, address executor) external;\n\n    /// @notice Allows the executor to claim their unclaimed rewards.\n    /// @dev Will revert if the executor has no unclaimed rewards.\n    function claimExecutionFees(address executor) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the accumulated rewards for an executor.\n    /// @param executor             The address of the executor to get the rewards for.\n    function accumulatedRewards(address executor) external view returns (uint256 accumulated);\n\n    /// @notice Get the unclaimed rewards for an executor.\n    /// @param executor             The address of the executor to get the rewards for.\n    function unclaimedRewards(address executor) external view returns (uint256 unclaimed);\n\n    /// @notice Get the total execution fee for a transaction.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to get the execution fee for.\n    function executionFee(uint64 dstChainId, bytes32 transactionId) external view returns (uint256 fee);\n\n    /// @notice Get the address of the recorded executor for a transaction.\n    /// @dev Will return address(0) if the executor is not recorded.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to get the recorded executor for.\n    function recordedExecutor(uint64 dstChainId, bytes32 transactionId) external view returns (address executor);\n}\n\n// contracts/interfaces/IExecutionService.sol\n\ninterface IExecutionService {\n    /// @notice Request the execution of an Interchain Transaction on a remote chain.\n    /// Note: the off-chain actor needs to fetch the transaction payload from the InterchainClient\n    /// event with the same transactionId, then execute the transaction on the remote chain:\n    /// `dstInterchainClient.executeTransaction(transactionPayload)`\n    /// Once the execution is confirmed on the source chain, the off-chain actor will be able\n    /// to claim `executionFee` in the ExecutionFees contract.\n    /// @dev Could only be called by `InterchainClient` contracts.\n    /// Will revert if the execution fee is not big enough.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param txPayloadSize        The size of the transaction payload to use for the execution.\n    /// @param transactionId        The id of the transaction to execute.\n    /// @param executionFee         The fee paid for the execution.\n    /// @param options              The options to use for the execution.\n    function requestExecution(\n        uint64 dstChainId,\n        uint256 txPayloadSize,\n        bytes32 transactionId,\n        uint256 executionFee,\n        bytes memory options\n    )\n        external;\n\n    /// @notice Get the address of the EOA account that will be used to execute transactions on the\n    /// remote chains.\n    function executorEOA() external view returns (address);\n\n    /// @notice Get the execution fee for executing an Interchain Transaction on a remote chain.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param txPayloadSize        The size of the transaction payload to use for the execution.\n    /// @param options              The options to use for the execution.\n    function getExecutionFee(\n        uint64 dstChainId,\n        uint256 txPayloadSize,\n        bytes memory options\n    )\n        external\n        view\n        returns (uint256);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    /// @notice Allows the Interchain Client to pass the message to the Interchain App.\n    /// @dev App is responsible for keeping track of interchain clients, and must verify the message sender.\n    /// @param srcChainId   Chain ID of the source chain, where the message was sent from.\n    /// @param sender       Sender address on the source chain, as a bytes32 value.\n    /// @param dbNonce      The Interchain DB nonce of the batch containing the message entry.\n    /// @param entryIndex   The index of the message entry within the batch.\n    /// @param message      The message being sent.\n    function appReceive(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /// @notice Returns the verification configuration of the Interchain App.\n    /// @dev This configuration is used by the Interchain Client to verify that message has been confirmed\n    /// by the Interchain Modules on the destination chain.\n    /// Note: V1 version of AppConfig includes the required responses count, and optimistic period after which\n    /// the message is considered confirmed by the module. Following versions may include additional fields.\n    /// @return appConfig    The versioned configuration of the Interchain App, encoded as bytes.\n    /// @return modules      The list of Interchain Modules that app is trusting to confirm the messages.\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/Math.sol\n\nlibrary MathLib {\n    /// @notice Rounds up to the nearest multiple of 32.\n    /// Note: Returns zero on overflows instead of reverting. This is fine for practical\n    /// use cases, as this is used for determining the size of the payload in memory.\n    function roundUpToWord(uint256 x) internal pure returns (uint256) {\n        unchecked {\n            return (x + 31) \u0026 ~uint256(31);\n        }\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/VersionedPayload.sol\n\n// solhint-disable no-inline-assembly\n// solhint-disable ordering\nlibrary VersionedPayloadLib {\n    /// @notice Amount of bytes reserved for the version (uint16) in the versioned payload\n    uint256 internal constant VERSION_LENGTH = 2;\n\n    error VersionedPayload__TooShort(bytes versionedPayload);\n    error VersionedPayload__PrecompileFailed();\n\n    /// @notice Encodes the versioned payload into a single bytes array.\n    /// @param version  The payload's version.\n    /// @param payload  The payload to encode.\n    function encodeVersionedPayload(uint16 version, bytes memory payload) internal pure returns (bytes memory) {\n        return abi.encodePacked(version, payload);\n    }\n\n    /// @notice Extracts the version from the versioned payload (calldata reference).\n    /// @param versionedPayload     The versioned payload (calldata reference).\n    function getVersion(bytes calldata versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            version := shr(240, calldataload(versionedPayload.offset))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (calldata reference).\n    /// @dev The extracted payload is also returned as a calldata reference.\n    /// @param versionedPayload     The versioned payload.\n    function getPayload(bytes calldata versionedPayload) internal pure returns (bytes calldata) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        return versionedPayload[VERSION_LENGTH:];\n    }\n\n    /// @notice Extracts the version from the versioned payload (memory reference).\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getVersionFromMemory(bytes memory versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            // We add 0x20 to skip the length of the bytes array.\n            version := shr(240, mload(add(versionedPayload, 0x20)))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (memory reference).\n    /// @dev The extracted payload is copied into a new memory location. Use `getPayload` when possible\n    /// to avoid extra memory allocation.\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getPayloadFromMemory(bytes memory versionedPayload) internal view returns (bytes memory payload) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        // Figure how many bytes to copy and allocate the memory for the extracted payload.\n        uint256 toCopy;\n        unchecked {\n            toCopy = versionedPayload.length - VERSION_LENGTH;\n        }\n        payload = new bytes(toCopy);\n        // Use identity precompile (0x04) to copy the payload. Unlike MCOPY, this is available on all EVM chains.\n        bool res;\n        assembly {\n            // We add 0x20 to skip the length of the bytes array.\n            // We add 0x02 to skip the 2 bytes reserved for the version.\n            // Copy the payload to the previously allocated memory.\n            res := staticcall(gas(), 0x04, add(versionedPayload, 0x22), toCopy, add(payload, 0x20), toCopy)\n        }\n        if (!res) {\n            revert VersionedPayload__PrecompileFailed();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SafeCast.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value \u003e type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value \u003e type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value \u003e type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value \u003e type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value \u003e type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value \u003e type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value \u003e type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value \u003e type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value \u003e type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value \u003e type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value \u003e type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value \u003e type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value \u003e type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value \u003e type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value \u003e type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value \u003e type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value \u003e type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value \u003e type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value \u003e type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value \u003e type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value \u003e type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value \u003e type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value \u003e type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value \u003e type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value \u003e type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value \u003e type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value \u003e type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value \u003e type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value \u003e type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value \u003e type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value \u003e type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value \u003c 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value \u003e uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal view returns (AppConfigV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (AppConfigV1));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal view returns (OptionsV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (OptionsV1));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(OPTIONS_V1, abi.encode(options));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/libs/InterchainBatch.sol\n\ntype BatchKey is uint128;\n\n/// @notice Struct representing a batch of entries in the Interchain DataBase.\n/// Batched entries are put together in a Merkle tree, which root is saved.\n/// Batch has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: batchRoot\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch\n/// @param batchRoot    The root of the Merkle tree containing the batched entries\nstruct InterchainBatch {\n    uint64 srcChainId;\n    uint64 dbNonce;\n    bytes32 batchRoot;\n}\n\nlibrary InterchainBatchLib {\n    using VersionedPayloadLib for bytes;\n\n    /// @notice Constructs an InterchainBatch struct to be saved on the local chain.\n    /// @param dbNonce      The database nonce of the batch\n    /// @param batchRoot    The root of the Merkle tree containing the batched entries\n    /// @return batch       The constructed InterchainBatch struct\n    function constructLocalBatch(\n        uint64 dbNonce,\n        bytes32 batchRoot\n    )\n        internal\n        view\n        returns (InterchainBatch memory batch)\n    {\n        return InterchainBatch({srcChainId: SafeCast.toUint64(block.chainid), dbNonce: dbNonce, batchRoot: batchRoot});\n    }\n\n    /// @notice Encodes the InterchainBatch struct into a non-versioned batch payload.\n    function encodeBatch(InterchainBatch memory batch) internal pure returns (bytes memory) {\n        return abi.encode(encodeBatchKey(batch.srcChainId, batch.dbNonce), batch.batchRoot);\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in calldata.\n    function decodeBatch(bytes calldata data) internal pure returns (InterchainBatch memory batch) {\n        BatchKey key;\n        (key, batch.batchRoot) = abi.decode(data, (BatchKey, bytes32));\n        (batch.srcChainId, batch.dbNonce) = decodeBatchKey(key);\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in memory.\n    function decodeBatchFromMemory(bytes memory data) internal pure returns (InterchainBatch memory batch) {\n        BatchKey key;\n        (key, batch.batchRoot) = abi.decode(data, (BatchKey, bytes32));\n        (batch.srcChainId, batch.dbNonce) = decodeBatchKey(key);\n    }\n\n    /// @notice Encodes the uint128 key of the batch from uint64 srcChainId and uint64 dbNonce.\n    function encodeBatchKey(uint64 srcChainId, uint64 dbNonce) internal pure returns (BatchKey) {\n        return BatchKey.wrap((uint128(srcChainId) \u003c\u003c 64) | dbNonce);\n    }\n\n    /// @notice Decodes the uint128 key of the batch into uint64 srcChainId and uint64 dbNonce.\n    function decodeBatchKey(BatchKey key) internal pure returns (uint64 srcChainId, uint64 dbNonce) {\n        srcChainId = uint64(BatchKey.unwrap(key) \u003e\u003e 64);\n        dbNonce = uint64(BatchKey.unwrap(key));\n    }\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce + entryIndex\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch containing the entry\n/// @param entryIndex   The index of the entry in the batch\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint64 srcChainId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nusing InterchainEntryLib for InterchainEntry global;\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint64 dbNonce,\n        uint64 entryIndex,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: SafeCast.toUint64(block.chainid),\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n}\n\n// contracts/libs/InterchainTransaction.sol\n\ntype ICTxHeader is uint256;\n\nstruct InterchainTransaction {\n    uint64 srcChainId;\n    uint64 dstChainId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcSender;\n    bytes32 dstReceiver;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    using MathLib for uint256;\n    using VersionedPayloadLib for bytes;\n\n    function constructLocalTransaction(\n        address srcSender,\n        uint64 dstChainId,\n        bytes32 dstReceiver,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: SafeCast.toUint64(block.chainid),\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            encodeTxHeader(transaction.srcChainId, transaction.dstChainId, transaction.dbNonce, transaction.entryIndex),\n            transaction.srcSender,\n            transaction.dstReceiver,\n            transaction.options,\n            transaction.message\n        );\n    }\n\n    function decodeTransaction(bytes calldata transaction) internal pure returns (InterchainTransaction memory icTx) {\n        ICTxHeader header;\n        (header, icTx.srcSender, icTx.dstReceiver, icTx.options, icTx.message) =\n            abi.decode(transaction, (ICTxHeader, bytes32, bytes32, bytes, bytes));\n        (icTx.srcChainId, icTx.dstChainId, icTx.dbNonce, icTx.entryIndex) = decodeTxHeader(header);\n    }\n\n    function payloadSize(uint256 optionsLen, uint256 messageLen) internal pure returns (uint256) {\n        // 2 bytes are reserved for the transaction version\n        // + 5 fields * 32 bytes (3 values for static, 2 offsets for dynamic) + 2 * 32 bytes (lengths for dynamic) = 226\n        // (srcChainId, dstChainId, dbNonce, entryIndex) are merged into a single 32 bytes field\n        // Both options and message are dynamic fields, which are padded up to 32 bytes\n        return 226 + optionsLen.roundUpToWord() + messageLen.roundUpToWord();\n    }\n\n    function encodeTxHeader(\n        uint64 srcChainId,\n        uint64 dstChainId,\n        uint64 dbNonce,\n        uint64 entryIndex\n    )\n        internal\n        pure\n        returns (ICTxHeader)\n    {\n        return ICTxHeader.wrap(\n            (uint256(srcChainId) \u003c\u003c 192) | (uint256(dstChainId) \u003c\u003c 128) | (uint256(dbNonce) \u003c\u003c 64) | uint256(entryIndex)\n        );\n    }\n\n    function decodeTxHeader(ICTxHeader header)\n        internal\n        pure\n        returns (uint64 srcChainId, uint64 dstChainId, uint64 dbNonce, uint64 entryIndex)\n    {\n        srcChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 192);\n        dstChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 128);\n        dbNonce = uint64(ICTxHeader.unwrap(header) \u003e\u003e 64);\n        entryIndex = uint64(ICTxHeader.unwrap(header));\n    }\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint64 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__InvalidTransactionVersion(uint16 version);\n    error InterchainClientV1__NoLinkedClient(uint64 chainId);\n    error InterchainClientV1__NotEnoughGasSupplied();\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint64 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint64 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint64 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint64 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param messageLen           The length of the message being sent.\n    function getInterchainFee(\n        uint64 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        uint256 messageLen\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint64 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint64 chainId) external view returns (address);\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing a batch of entries from the remote Interchain DataBase,\n    /// verified by the Interchain Module.\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param batchRoot    The Merkle root of the batch\n    struct RemoteBatch {\n        uint256 verifiedAt;\n        bytes32 batchRoot;\n    }\n\n    error InterchainDB__BatchDoesNotExist(uint64 dbNonce);\n    error InterchainDB__BatchNotFinalized(uint64 dbNonce);\n    error InterchainDB__ConflictingBatches(address module, bytes32 existingBatchRoot, InterchainBatch newBatch);\n    error InterchainDB__EntryIndexOutOfRange(uint64 dbNonce, uint64 entryIndex, uint64 batchSize);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__InvalidBatchVersion(uint16 version);\n    error InterchainDB__InvalidEntryRange(uint64 dbNonce, uint64 start, uint64 end);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId(uint64 chainId);\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `requestBatchVerification` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntry(bytes32 dataHash) external returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Request the given Interchain Modules to verify an existing batch.\n    /// If the batch is not finalized, the module will verify it after finalization.\n    /// For the finalized batch the batch root is already available, and the module can verify it immediately.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any batch.\n    /// @dev Will revert if the batch with the given nonce does not exist.\n    /// @param dstChainId    The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the existing batch\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestBatchVerification(\n        uint64 dstChainId,\n        uint64 dbNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Then request the Interchain Modules to verify the batch containing the written entry on the destination chain.\n    /// See `writeEntry` and `requestBatchVerification` for more details.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntryWithVerification(\n        uint64 dstChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Allows the Interchain Module to verify the batch coming from the remote chain.\n    /// Note: The DB will only accept the batch of the same version as the DB itself.\n    /// @param versionedBatch   The versioned Interchain Batch to verify\n    function verifyRemoteBatch(bytes memory versionedBatch) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint64 dstChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce.\n    /// Note: the leafs are ordered by the index of the written entry in the current batch,\n    /// and the leafs value match the value of the written entry (srcWriter + dataHash hashed together).\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchLeafs(uint64 dbNonce) external view returns (bytes32[] memory);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce,\n    /// paginated by the given start and end indexes. The end index is exclusive.\n    /// Note: this is useful when the batch contains a large number of leafs, and calling `getBatchLeafs`\n    /// would result in a gas limit exceeded error.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the provided range is invalid.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param start        The start index of the paginated leafs, inclusive\n    /// @param end          The end index of the paginated leafs, exclusive\n    function getBatchLeafsPaginated(\n        uint64 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory);\n\n    /// @notice Returns the size of the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchSize(uint64 dbNonce) external view returns (uint64);\n\n    /// @notice Get the finalized Interchain Batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatch(uint64 dbNonce) external view returns (InterchainBatch memory);\n\n    /// @notice Get the Interchain Entry's value written on the local chain with the given batch nonce and entry index.\n    /// Entry value is calculated as the hash of the writer address and the written data hash.\n    /// Note: the batch does not have to be finalized to fetch the entry value.\n    /// @dev Will revert if the batch with the given nonce does not exist,\n    /// or the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the existing batch\n    /// @param entryIndex   The index of the written entry within the batch\n    function getEntryValue(uint64 dbNonce, uint64 entryIndex) external view returns (bytes32);\n\n    /// @notice Get the Merkle proof of inclusion for the entry with the given index\n    /// in the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param entryIndex   The index of the written entry within the batch\n    /// @return proof       The Merkle proof of inclusion for the entry\n    function getEntryProof(uint64 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof);\n\n    /// @notice Get the nonce of the database, which is incremented every time a new batch is finalized.\n    /// This is the nonce of the current non-finalized batch.\n    function getDBNonce() external view returns (uint64);\n\n    /// @notice Get the index of the next entry to be written to the database.\n    /// @return dbNonce      The database nonce of the batch including the next entry\n    /// @return entryIndex   The index of the next entry within that batch\n    function getNextEntryIndex() external view returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or ZERO if the module has not verified the entry.\n    function checkVerification(\n        address dstModule,\n        InterchainEntry memory entry,\n        bytes32[] memory proof\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n\n    /// @notice Get the version of the Interchain DataBase.\n    // solhint-disable-next-line func-name-mixedcase\n    function DB_VERSION() external pure returns (uint16);\n}\n\n// contracts/InterchainClientV1.sol\n\n/**\n * @title InterchainClientV1\n * @dev Implements the operations of the Interchain Execution Layer.\n */\ncontract InterchainClientV1 is Ownable, InterchainClientV1Events, IInterchainClientV1 {\n    using AppConfigLib for bytes;\n    using OptionsLib for bytes;\n    using VersionedPayloadLib for bytes;\n\n    /// @notice Version of the InterchainClient contract. Sent and received transactions must have the same version.\n    uint16 public constant CLIENT_VERSION = 1;\n\n    /// @notice Address of the InterchainDB contract, set at the time of deployment.\n    address public immutable INTERCHAIN_DB;\n\n    /// @notice Address of the contract that handles execution fees. Can be updated by the owner.\n    address public executionFees;\n\n    /// @dev Address of the InterchainClient contract on the remote chain\n    mapping(uint64 chainId =\u003e bytes32 remoteClient) internal _linkedClient;\n    /// @dev Executor address that completed the transaction. Address(0) if not executed yet.\n    mapping(bytes32 transactionId =\u003e address executor) internal _txExecutor;\n\n    constructor(address interchainDB, address owner_) Ownable(owner_) {\n        INTERCHAIN_DB = interchainDB;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function setExecutionFees(address executionFees_) external onlyOwner {\n        executionFees = executionFees_;\n        emit ExecutionFeesSet(executionFees_);\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function setLinkedClient(uint64 chainId, bytes32 client) external onlyOwner {\n        _linkedClient[chainId] = client;\n        emit LinkedClientSet(chainId, client);\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _interchainSend(dstChainId, receiver, srcExecutionService, srcModules, options, message);\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function interchainSendEVM(\n        uint64 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc)\n    {\n        bytes32 receiverBytes32 = TypeCasts.addressToBytes32(receiver);\n        return _interchainSend(dstChainId, receiverBytes32, srcExecutionService, srcModules, options, message);\n    }\n\n    // TODO: Handle the case where receiver does not implement the IInterchainApp interface (or does not exist at all)\n    // @inheritdoc IInterchainClientV1\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable\n    {\n        InterchainTransaction memory icTx = _assertCorrectVersion(transaction);\n        bytes32 transactionId = keccak256(transaction);\n        _assertExecutable(icTx, transactionId, proof);\n        _txExecutor[transactionId] = msg.sender;\n\n        OptionsV1 memory decodedOptions = icTx.options.decodeOptionsV1();\n        if (msg.value != decodedOptions.gasAirdrop) {\n            revert InterchainClientV1__IncorrectMsgValue(msg.value, decodedOptions.gasAirdrop);\n        }\n        // We should always use at least as much as the requested gas limit.\n        // The executor can specify a higher gas limit if they wanted.\n        if (decodedOptions.gasLimit \u003e gasLimit) gasLimit = decodedOptions.gasLimit;\n        // Check the the Executor has provided big enough gas limit for the whole transaction.\n        if (gasleft() \u003c= gasLimit) {\n            revert InterchainClientV1__NotEnoughGasSupplied();\n        }\n        // Pass the full msg.value to the app: we have already checked that it matches the requested gas airdrop.\n        IInterchainApp(TypeCasts.bytes32ToAddress(icTx.dstReceiver)).appReceive{gas: gasLimit, value: msg.value}({\n            srcChainId: icTx.srcChainId,\n            sender: icTx.srcSender,\n            dbNonce: icTx.dbNonce,\n            entryIndex: icTx.entryIndex,\n            message: icTx.message\n        });\n        emit InterchainTransactionReceived(\n            transactionId, icTx.dbNonce, icTx.entryIndex, icTx.srcChainId, icTx.srcSender, icTx.dstReceiver\n        );\n    }\n\n    /// @inheritdoc IInterchainClientV1\n    function writeExecutionProof(bytes32 transactionId) external returns (uint64 dbNonce, uint64 entryIndex) {\n        address executor = _txExecutor[transactionId];\n        if (executor == address(0)) {\n            revert InterchainClientV1__TxNotExecuted(transactionId);\n        }\n        bytes memory proof = abi.encode(transactionId, executor);\n        (dbNonce, entryIndex) = IInterchainDB(INTERCHAIN_DB).writeEntry(keccak256(proof));\n        emit ExecutionProofWritten(transactionId, dbNonce, entryIndex, executor);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // @inheritdoc IInterchainClientV1\n    function isExecutable(bytes calldata encodedTx, bytes32[] calldata proof) external view returns (bool) {\n        InterchainTransaction memory icTx = _assertCorrectVersion(encodedTx);\n        // Check that options could be decoded\n        icTx.options.decodeOptionsV1();\n        bytes32 transactionId = keccak256(encodedTx);\n        _assertExecutable(icTx, transactionId, proof);\n        return true;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function getExecutor(bytes calldata encodedTx) external view returns (address) {\n        return _txExecutor[keccak256(encodedTx)];\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function getExecutorById(bytes32 transactionId) external view returns (address) {\n        return _txExecutor[transactionId];\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function getInterchainFee(\n        uint64 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        uint256 messageLen\n    )\n        external\n        view\n        returns (uint256 fee)\n    {\n        _assertLinkedClient(dstChainId);\n        // Check that options could be decoded on destination chain\n        options.decodeOptionsV1();\n        // Verification fee from InterchainDB\n        fee = IInterchainDB(INTERCHAIN_DB).getInterchainFee(dstChainId, srcModules);\n        // Add execution fee, if ExecutionService is provided\n        if (srcExecutionService != address(0)) {\n            uint256 payloadSize = InterchainTransactionLib.payloadSize(options.length, messageLen);\n            fee += IExecutionService(srcExecutionService).getExecutionFee(dstChainId, payloadSize, options);\n        }\n    }\n\n    /// @inheritdoc IInterchainClientV1\n    function getLinkedClient(uint64 chainId) external view returns (bytes32) {\n        if (chainId == block.chainid) {\n            revert InterchainClientV1__NotRemoteChainId(chainId);\n        }\n        return _linkedClient[chainId];\n    }\n\n    /// @inheritdoc IInterchainClientV1\n    function getLinkedClientEVM(uint64 chainId) external view returns (address linkedClientEVM) {\n        if (chainId == block.chainid) {\n            revert InterchainClientV1__NotRemoteChainId(chainId);\n        }\n        bytes32 linkedClient = _linkedClient[chainId];\n        linkedClientEVM = TypeCasts.bytes32ToAddress(linkedClient);\n        // Check that the linked client address fits into the EVM address space\n        if (TypeCasts.addressToBytes32(linkedClientEVM) != linkedClient) {\n            revert InterchainClientV1__NotEVMClient(linkedClient);\n        }\n    }\n\n    /// @notice Decodes the encoded options data into a OptionsV1 struct.\n    function decodeOptions(bytes memory encodedOptions) external view returns (OptionsV1 memory) {\n        return encodedOptions.decodeOptionsV1();\n    }\n\n    /// @notice Encodes the transaction data into a bytes format.\n    function encodeTransaction(InterchainTransaction memory icTx) public pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload({\n            version: CLIENT_VERSION,\n            payload: InterchainTransactionLib.encodeTransaction(icTx)\n        });\n    }\n\n    // ═════════════════════════════════════════════════ INTERNAL ══════════════════════════════════════════════════════\n\n    /// @dev Internal logic for sending a message to another chain.\n    function _interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        _assertLinkedClient(dstChainId);\n        if (receiver == 0) revert InterchainClientV1__ZeroReceiver();\n        // Check that options could be decoded on destination chain\n        options.decodeOptionsV1();\n        uint256 verificationFee = IInterchainDB(INTERCHAIN_DB).getInterchainFee(dstChainId, srcModules);\n        if (msg.value \u003c verificationFee) {\n            revert InterchainClientV1__FeeAmountTooLow(msg.value, verificationFee);\n        }\n        (desc.dbNonce, desc.entryIndex) = IInterchainDB(INTERCHAIN_DB).getNextEntryIndex();\n        InterchainTransaction memory icTx = InterchainTransactionLib.constructLocalTransaction({\n            srcSender: msg.sender,\n            dstReceiver: receiver,\n            dstChainId: dstChainId,\n            dbNonce: desc.dbNonce,\n            entryIndex: desc.entryIndex,\n            options: options,\n            message: message\n        });\n        desc.transactionId = keccak256(encodeTransaction(icTx));\n        // Sanity check: nonce returned from DB should match the nonce used to construct the transaction\n        {\n            (uint64 dbNonce, uint64 entryIndex) = IInterchainDB(INTERCHAIN_DB).writeEntryWithVerification{\n                value: verificationFee\n            }(icTx.dstChainId, desc.transactionId, srcModules);\n            assert(dbNonce == desc.dbNonce \u0026\u0026 entryIndex == desc.entryIndex);\n        }\n        uint256 executionFee;\n        unchecked {\n            executionFee = msg.value - verificationFee;\n        }\n        if (executionFee \u003e 0) {\n            IExecutionFees(executionFees).addExecutionFee{value: executionFee}(icTx.dstChainId, desc.transactionId);\n        }\n        // TODO: consider disallowing the use of empty srcExecutionService\n        if (srcExecutionService != address(0)) {\n            IExecutionService(srcExecutionService).requestExecution({\n                dstChainId: dstChainId,\n                txPayloadSize: InterchainTransactionLib.payloadSize(options.length, message.length),\n                transactionId: desc.transactionId,\n                executionFee: executionFee,\n                options: options\n            });\n            address srcExecutorEOA = IExecutionService(srcExecutionService).executorEOA();\n            IExecutionFees(executionFees).recordExecutor(icTx.dstChainId, desc.transactionId, srcExecutorEOA);\n        }\n        emit InterchainTransactionSent(\n            desc.transactionId,\n            icTx.dbNonce,\n            icTx.entryIndex,\n            icTx.dstChainId,\n            icTx.srcSender,\n            icTx.dstReceiver,\n            verificationFee,\n            executionFee,\n            icTx.options,\n            icTx.message\n        );\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Asserts that the transaction is executable.\n    function _assertExecutable(\n        InterchainTransaction memory icTx,\n        bytes32 transactionId,\n        bytes32[] calldata proof\n    )\n        internal\n        view\n    {\n        bytes32 linkedClient = _assertLinkedClient(icTx.srcChainId);\n        if (icTx.dstChainId != block.chainid) {\n            revert InterchainClientV1__IncorrectDstChainId(icTx.dstChainId);\n        }\n        if (_txExecutor[transactionId] != address(0)) {\n            revert InterchainClientV1__TxAlreadyExecuted(transactionId);\n        }\n        // Construct expected entry based on icTransaction data\n        InterchainEntry memory icEntry = InterchainEntry({\n            srcChainId: icTx.srcChainId,\n            dbNonce: icTx.dbNonce,\n            entryIndex: icTx.entryIndex,\n            srcWriter: linkedClient,\n            dataHash: transactionId\n        });\n        (bytes memory encodedAppConfig, address[] memory approvedDstModules) =\n            IInterchainApp(TypeCasts.bytes32ToAddress(icTx.dstReceiver)).getReceivingConfig();\n        AppConfigV1 memory appConfig = encodedAppConfig.decodeAppConfigV1();\n        if (appConfig.requiredResponses == 0) {\n            revert InterchainClientV1__ZeroRequiredResponses();\n        }\n        uint256 responses = _getFinalizedResponsesCount(approvedDstModules, icEntry, proof, appConfig.optimisticPeriod);\n        if (responses \u003c appConfig.requiredResponses) {\n            revert InterchainClientV1__NotEnoughResponses(responses, appConfig.requiredResponses);\n        }\n    }\n\n    /// @dev Asserts that the chain is linked and returns the linked client address.\n    function _assertLinkedClient(uint64 chainId) internal view returns (bytes32 linkedClient) {\n        if (chainId == block.chainid) {\n            revert InterchainClientV1__NotRemoteChainId(chainId);\n        }\n        linkedClient = _linkedClient[chainId];\n        if (linkedClient == 0) {\n            revert InterchainClientV1__NoLinkedClient(chainId);\n        }\n    }\n\n    /**\n     * @dev Calculates the number of responses that are considered finalized within the optimistic time period.\n     * @param approvedModules       Approved modules that could have confirmed the entry.\n     * @param icEntry               The InterchainEntry to confirm.\n     * @param optimisticPeriod      The time period in seconds within which a response is considered valid.\n     * @return finalizedResponses   The count of responses that are finalized within the optimistic time period.\n     */\n    function _getFinalizedResponsesCount(\n        address[] memory approvedModules,\n        InterchainEntry memory icEntry,\n        bytes32[] calldata proof,\n        uint256 optimisticPeriod\n    )\n        internal\n        view\n        returns (uint256 finalizedResponses)\n    {\n        for (uint256 i = 0; i \u003c approvedModules.length; ++i) {\n            uint256 confirmedAt = IInterchainDB(INTERCHAIN_DB).checkVerification(approvedModules[i], icEntry, proof);\n            // checkVerification() returns 0 if entry hasn't been confirmed by the module, so we check for that as well\n            if (confirmedAt != 0 \u0026\u0026 confirmedAt + optimisticPeriod \u003c block.timestamp) {\n                ++finalizedResponses;\n            }\n        }\n    }\n\n    /// @dev Asserts that the transaction version is correct. Returns the decoded transaction for chaining purposes.\n    function _assertCorrectVersion(bytes calldata versionedTx)\n        internal\n        pure\n        returns (InterchainTransaction memory icTx)\n    {\n        uint16 version = versionedTx.getVersion();\n        if (version != CLIENT_VERSION) {\n            revert InterchainClientV1__InvalidTransactionVersion(version);\n        }\n        icTx = InterchainTransactionLib.decodeTransaction(versionedTx.getPayload());\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"uint256","name":"actual","type":"uint256"},{"internalType":"uint256","name":"required","type":"uint256"}],"name":"InterchainClientV1__FeeAmountTooLow","type":"error"},{"inputs":[{"internalType":"uint64","name":"chainId","type":"uint64"}],"name":"InterchainClientV1__IncorrectDstChainId","type":"error"},{"inputs":[{"internalType":"uint256","name":"actual","type":"uint256"},{"internalType":"uint256","name":"required","type":"uint256"}],"name":"InterchainClientV1__IncorrectMsgValue","type":"error"},{"inputs":[{"internalType":"uint16","name":"version","type":"uint16"}],"name":"InterchainClientV1__InvalidTransactionVersion","type":"error"},{"inputs":[{"internalType":"uint64","name":"chainId","type":"uint64"}],"name":"InterchainClientV1__NoLinkedClient","type":"error"},{"inputs":[{"internalType":"bytes32","name":"client","type":"bytes32"}],"name":"InterchainClientV1__NotEVMClient","type":"error"},{"inputs":[],"name":"InterchainClientV1__NotEnoughGasSupplied","type":"error"},{"inputs":[{"internalType":"uint256","name":"actual","type":"uint256"},{"internalType":"uint256","name":"required","type":"uint256"}],"name":"InterchainClientV1__NotEnoughResponses","type":"error"},{"inputs":[{"internalType":"uint64","name":"chainId","type":"uint64"}],"name":"InterchainClientV1__NotRemoteChainId","type":"error"},{"inputs":[{"internalType":"bytes32","name":"transactionId","type":"bytes32"}],"name":"InterchainClientV1__TxAlreadyExecuted","type":"error"},{"inputs":[{"internalType":"bytes32","name":"transactionId","type":"bytes32"}],"name":"InterchainClientV1__TxNotExecuted","type":"error"},{"inputs":[],"name":"InterchainClientV1__ZeroReceiver","type":"error"},{"inputs":[],"name":"InterchainClientV1__ZeroRequiredResponses","type":"error"},{"inputs":[{"internalType":"bytes","name":"transaction","type":"bytes"}],"name":"getExecutor","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"transactionId","type":"bytes32"}],"name":"getExecutorById","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint64","name":"dstChainId","type":"uint64"},{"internalType":"address","name":"srcExecutionService","type":"address"},{"internalType":"address[]","name":"srcModules","type":"address[]"},{"internalType":"bytes","name":"options","type":"bytes"},{"internalType":"uint256","name":"messageLen","type":"uint256"}],"name":"getInterchainFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint64","name":"chainId","type":"uint64"}],"name":"getLinkedClient","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint64","name":"chainId","type":"uint64"}],"name":"getLinkedClientEVM","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"gasLimit","type":"uint256"},{"internalType":"bytes","name":"transaction","type":"bytes"},{"internalType":"bytes32[]","name":"proof","type":"bytes32[]"}],"name":"interchainExecute","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint64","name":"dstChainId","type":"uint64"},{"internalType":"bytes32","name":"receiver","type":"bytes32"},{"internalType":"address","name":"srcExecutionService","type":"address"},{"internalType":"address[]","name":"srcModules","type":"address[]"},{"internalType":"bytes","name":"options","type":"bytes"},{"internalType":"bytes","name":"message","type":"bytes"}],"name":"interchainSend","outputs":[{"components":[{"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"internalType":"uint64","name":"dbNonce","type":"uint64"},{"internalType":"uint64","name":"entryIndex","type":"uint64"}],"internalType":"struct InterchainTxDescriptor","name":"desc","type":"tuple"}],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint64","name":"dstChainId","type":"uint64"},{"internalType":"address","name":"receiver","type":"address"},{"internalType":"address","name":"srcExecutionService","type":"address"},{"internalType":"address[]","name":"srcModules","type":"address[]"},{"internalType":"bytes","name":"options","type":"bytes"},{"internalType":"bytes","name":"message","type":"bytes"}],"name":"interchainSendEVM","outputs":[{"components":[{"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"internalType":"uint64","name":"dbNonce","type":"uint64"},{"internalType":"uint64","name":"entryIndex","type":"uint64"}],"internalType":"struct InterchainTxDescriptor","name":"desc","type":"tuple"}],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"bytes","name":"transaction","type":"bytes"},{"internalType":"bytes32[]","name":"proof","type":"bytes32[]"}],"name":"isExecutable","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"executionFees_","type":"address"}],"name":"setExecutionFees","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint64","name":"chainId","type":"uint64"},{"internalType":"bytes32","name":"client","type":"bytes32"}],"name":"setLinkedClient","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"transactionId","type":"bytes32"}],"name":"writeExecutionProof","outputs":[{"internalType":"uint64","name":"dbNonce","type":"uint64"},{"internalType":"uint64","name":"entryIndex","type":"uint64"}],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{"getExecutor(bytes)":{"notice":"Returns the address of the executor for a transaction that has been sent to the local chain."},"getExecutorById(bytes32)":{"notice":"Returns the address of the executor for a transaction that has been sent to the local chain."},"getInterchainFee(uint64,address,address[],bytes,uint256)":{"notice":"Returns the fee for sending an Interchain message."},"getLinkedClient(uint64)":{"notice":"Returns the address of the linked client (as bytes32) for a specific chain ID."},"getLinkedClientEVM(uint64)":{"notice":"Returns the EVM address of the linked client for a specific chain ID."},"interchainExecute(uint256,bytes,bytes32[])":{"notice":"Executes a transaction that has been sent via the Interchain."},"interchainSend(uint64,bytes32,address,address[],bytes,bytes)":{"notice":"Sends a message to another chain via the Interchain Communication Protocol."},"isExecutable(bytes,bytes32[])":{"notice":"Checks if a transaction is executable."},"setExecutionFees(address)":{"notice":"Sets the address of the ExecutionFees contract."},"setLinkedClient(uint64,bytes32)":{"notice":"Sets the linked client for a specific chain ID."},"writeExecutionProof(bytes32)":{"notice":"Writes the proof of execution for a transaction into the InterchainDB."}},"version":1},"developerDoc":{"kind":"dev","methods":{"getInterchainFee(uint64,address,address[],bytes,uint256)":{"params":{"dstChainId":"The chain ID of the destination chain.","messageLen":"The length of the message being sent.","options":"Execution options for the message sent, currently gas limit + native gas drop.","srcExecutionService":"The address of the execution service to use for the message.","srcModules":"The source modules involved in the message sending."}},"getLinkedClient(uint64)":{"details":"Will return 0x0 if no client is linked for the chain ID."},"getLinkedClientEVM(uint64)":{"details":"Will return 0x0 if no client is linked for the chain ID. Will revert if the client is not an EVM client."},"interchainExecute(uint256,bytes,bytes32[])":{"details":"The transaction must have been previously sent and recorded. Transaction data includes the requested gas limit, but the executors could specify a different gas limit. If the specified gas limit is lower than requested, the requested gas limit will be used. Otherwise, the specified gas limit will be used. This allows to execute the transactions with requested gas limit set too low.","params":{"gasLimit":"The gas limit to use for the execution.","proof":"The Merkle proof for transaction execution, fetched from the source chain.","transaction":"The transaction data."}},"interchainSend(uint64,bytes32,address,address[],bytes,bytes)":{"details":"Charges a fee for the message, which is payable upon calling this function: - Verification fees: paid to every module that verifies the message. - Execution fee: paid to the executor that executes the message. Note: while a specific execution service is specified to request the execution of the message, any executor is able to execute the message on destination chain, earning the execution fee.","params":{"dstChainId":"The chain ID of the destination chain.","message":"The message being sent.","options":"Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.","receiver":"The address of the receiver on the destination chain.","srcExecutionService":"The address of the execution service to use for the message.","srcModules":"The source modules involved in the message sending."},"returns":{"desc":"The descriptor of the sent transaction: - transactionId: the ID of the transaction that was sent. - dbNonce: the database nonce of the batch containing the written entry for transaction. - entryIndex: the index of the written entry for transaction within the batch."}},"isExecutable(bytes,bytes32[])":{"details":"Determines if a transaction meets the criteria to be executed based on: - If approved modules have written to the InterchainDB - If the threshold of approved modules have been met - If the optimistic window has passed for all modules","params":{"proof":"The Merkle proof for transaction execution, fetched from the source chain.","transaction":"The InterchainTransaction struct to be checked."},"returns":{"_0":"bool Returns true if the transaction is executable, false otherwise."}},"setExecutionFees(address)":{"details":"Only callable by the contract owner or an authorized account.","params":{"executionFees_":"The address of the ExecutionFees contract."}},"setLinkedClient(uint64,bytes32)":{"details":"Stores the address of the linked client in a mapping with the chain ID as the key.","params":{"chainId":"The chain ID for which the client is being set.","client":"The address of the client being linked."}},"writeExecutionProof(bytes32)":{"details":"Will revert if the transaction has not been executed.","params":{"transactionId":"The ID of the transaction to write the proof for."},"returns":{"dbNonce":"        The database nonce of the batch containing the written proof for transaction.","entryIndex":"     The index of the written proof for transaction within the batch."}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"required\",\"type\":\"uint256\"}],\"name\":\"InterchainClientV1__FeeAmountTooLow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"}],\"name\":\"InterchainClientV1__IncorrectDstChainId\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"required\",\"type\":\"uint256\"}],\"name\":\"InterchainClientV1__IncorrectMsgValue\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"version\",\"type\":\"uint16\"}],\"name\":\"InterchainClientV1__InvalidTransactionVersion\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"}],\"name\":\"InterchainClientV1__NoLinkedClient\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"client\",\"type\":\"bytes32\"}],\"name\":\"InterchainClientV1__NotEVMClient\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InterchainClientV1__NotEnoughGasSupplied\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"required\",\"type\":\"uint256\"}],\"name\":\"InterchainClientV1__NotEnoughResponses\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"}],\"name\":\"InterchainClientV1__NotRemoteChainId\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"}],\"name\":\"InterchainClientV1__TxAlreadyExecuted\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"}],\"name\":\"InterchainClientV1__TxNotExecuted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InterchainClientV1__ZeroReceiver\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InterchainClientV1__ZeroRequiredResponses\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"transaction\",\"type\":\"bytes\"}],\"name\":\"getExecutor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"}],\"name\":\"getExecutorById\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"dstChainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"srcExecutionService\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"},{\"internalType\":\"bytes\",\"name\":\"options\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"messageLen\",\"type\":\"uint256\"}],\"name\":\"getInterchainFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"}],\"name\":\"getLinkedClient\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"}],\"name\":\"getLinkedClientEVM\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"transaction\",\"type\":\"bytes\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"interchainExecute\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"dstChainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"receiver\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"srcExecutionService\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"},{\"internalType\":\"bytes\",\"name\":\"options\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"interchainSend\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"}],\"internalType\":\"struct InterchainTxDescriptor\",\"name\":\"desc\",\"type\":\"tuple\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"dstChainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"srcExecutionService\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"},{\"internalType\":\"bytes\",\"name\":\"options\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"interchainSendEVM\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"}],\"internalType\":\"struct InterchainTxDescriptor\",\"name\":\"desc\",\"type\":\"tuple\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"transaction\",\"type\":\"bytes\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"isExecutable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"executionFees_\",\"type\":\"address\"}],\"name\":\"setExecutionFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"client\",\"type\":\"bytes32\"}],\"name\":\"setLinkedClient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"}],\"name\":\"writeExecutionProof\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"getInterchainFee(uint64,address,address[],bytes,uint256)\":{\"params\":{\"dstChainId\":\"The chain ID of the destination chain.\",\"messageLen\":\"The length of the message being sent.\",\"options\":\"Execution options for the message sent, currently gas limit + native gas drop.\",\"srcExecutionService\":\"The address of the execution service to use for the message.\",\"srcModules\":\"The source modules involved in the message sending.\"}},\"getLinkedClient(uint64)\":{\"details\":\"Will return 0x0 if no client is linked for the chain ID.\"},\"getLinkedClientEVM(uint64)\":{\"details\":\"Will return 0x0 if no client is linked for the chain ID. Will revert if the client is not an EVM client.\"},\"interchainExecute(uint256,bytes,bytes32[])\":{\"details\":\"The transaction must have been previously sent and recorded. Transaction data includes the requested gas limit, but the executors could specify a different gas limit. If the specified gas limit is lower than requested, the requested gas limit will be used. Otherwise, the specified gas limit will be used. This allows to execute the transactions with requested gas limit set too low.\",\"params\":{\"gasLimit\":\"The gas limit to use for the execution.\",\"proof\":\"The Merkle proof for transaction execution, fetched from the source chain.\",\"transaction\":\"The transaction data.\"}},\"interchainSend(uint64,bytes32,address,address[],bytes,bytes)\":{\"details\":\"Charges a fee for the message, which is payable upon calling this function: - Verification fees: paid to every module that verifies the message. - Execution fee: paid to the executor that executes the message. Note: while a specific execution service is specified to request the execution of the message, any executor is able to execute the message on destination chain, earning the execution fee.\",\"params\":{\"dstChainId\":\"The chain ID of the destination chain.\",\"message\":\"The message being sent.\",\"options\":\"Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\",\"receiver\":\"The address of the receiver on the destination chain.\",\"srcExecutionService\":\"The address of the execution service to use for the message.\",\"srcModules\":\"The source modules involved in the message sending.\"},\"returns\":{\"desc\":\"The descriptor of the sent transaction: - transactionId: the ID of the transaction that was sent. - dbNonce: the database nonce of the batch containing the written entry for transaction. - entryIndex: the index of the written entry for transaction within the batch.\"}},\"isExecutable(bytes,bytes32[])\":{\"details\":\"Determines if a transaction meets the criteria to be executed based on: - If approved modules have written to the InterchainDB - If the threshold of approved modules have been met - If the optimistic window has passed for all modules\",\"params\":{\"proof\":\"The Merkle proof for transaction execution, fetched from the source chain.\",\"transaction\":\"The InterchainTransaction struct to be checked.\"},\"returns\":{\"_0\":\"bool Returns true if the transaction is executable, false otherwise.\"}},\"setExecutionFees(address)\":{\"details\":\"Only callable by the contract owner or an authorized account.\",\"params\":{\"executionFees_\":\"The address of the ExecutionFees contract.\"}},\"setLinkedClient(uint64,bytes32)\":{\"details\":\"Stores the address of the linked client in a mapping with the chain ID as the key.\",\"params\":{\"chainId\":\"The chain ID for which the client is being set.\",\"client\":\"The address of the client being linked.\"}},\"writeExecutionProof(bytes32)\":{\"details\":\"Will revert if the transaction has not been executed.\",\"params\":{\"transactionId\":\"The ID of the transaction to write the proof for.\"},\"returns\":{\"dbNonce\":\"        The database nonce of the batch containing the written proof for transaction.\",\"entryIndex\":\"     The index of the written proof for transaction within the batch.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"getExecutor(bytes)\":{\"notice\":\"Returns the address of the executor for a transaction that has been sent to the local chain.\"},\"getExecutorById(bytes32)\":{\"notice\":\"Returns the address of the executor for a transaction that has been sent to the local chain.\"},\"getInterchainFee(uint64,address,address[],bytes,uint256)\":{\"notice\":\"Returns the fee for sending an Interchain message.\"},\"getLinkedClient(uint64)\":{\"notice\":\"Returns the address of the linked client (as bytes32) for a specific chain ID.\"},\"getLinkedClientEVM(uint64)\":{\"notice\":\"Returns the EVM address of the linked client for a specific chain ID.\"},\"interchainExecute(uint256,bytes,bytes32[])\":{\"notice\":\"Executes a transaction that has been sent via the Interchain.\"},\"interchainSend(uint64,bytes32,address,address[],bytes,bytes)\":{\"notice\":\"Sends a message to another chain via the Interchain Communication Protocol.\"},\"isExecutable(bytes,bytes32[])\":{\"notice\":\"Checks if a transaction is executable.\"},\"setExecutionFees(address)\":{\"notice\":\"Sets the address of the ExecutionFees contract.\"},\"setLinkedClient(uint64,bytes32)\":{\"notice\":\"Sets the linked client for a specific chain ID.\"},\"writeExecutionProof(bytes32)\":{\"notice\":\"Writes the proof of execution for a transaction into the InterchainDB.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainClientV1.sol\":\"IInterchainClientV1\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainClientV1.sol\":{\"keccak256\":\"0xe270686a9bca05b4013610a4e8bb08040de32a0442edd218e1692edaca94e40e\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://727e84146369613e04e57a677f8bc6c709ee145df3eeb79f15ea5a922198d78f\",\"dweb:/ipfs/QmUXh2nDtHBnhYZSwCxcteN4be13S7dR9GbqqHT9mUxta3\"]}},\"version\":1}"},"hashes":{"getExecutor(bytes)":"f92a79ff","getExecutorById(bytes32)":"f1a61fac","getInterchainFee(uint64,address,address[],bytes,uint256)":"cbb3c631","getLinkedClient(uint64)":"2e568739","getLinkedClientEVM(uint64)":"35c4a191","interchainExecute(uint256,bytes,bytes32[])":"53b67d74","interchainSend(uint64,bytes32,address,address[],bytes,bytes)":"547efb84","interchainSendEVM(uint64,address,address,address[],bytes,bytes)":"3f34448e","isExecutable(bytes,bytes32[])":"1450c281","setExecutionFees(address)":"3dc68b87","setLinkedClient(uint64,bytes32)":"f3c66e2b","writeExecutionProof(bytes32)":"90e81077"}},"solidity/InterchainClientV1.sol:IInterchainDB":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainClientV1Events.sol\n\nabstract contract InterchainClientV1Events {\n    event ExecutionFeesSet(address executionFees);\n    event LinkedClientSet(uint64 chainId, bytes32 client);\n\n    // TODO: figure out indexing\n\n    event InterchainTransactionSent(\n        bytes32 indexed transactionId,\n        uint64 indexed dbNonce,\n        uint64 indexed entryIndex,\n        uint64 dstChainId,\n        bytes32 srcSender,\n        bytes32 dstReceiver,\n        uint256 verificationFee,\n        uint256 executionFee,\n        bytes options,\n        bytes message\n    );\n\n    event InterchainTransactionReceived(\n        bytes32 indexed transactionId,\n        uint64 indexed dbNonce,\n        uint64 indexed entryIndex,\n        uint64 srcChainId,\n        bytes32 srcSender,\n        bytes32 dstReceiver\n    );\n\n    event ExecutionProofWritten(\n        bytes32 indexed transactionId, uint64 indexed dbNonce, uint64 indexed entryIndex, address executor\n    );\n}\n\n// contracts/interfaces/IExecutionFees.sol\n\ninterface IExecutionFees {\n    error ExecutionFees__AlreadyRecorded(uint64 dstChainId, bytes32 transactionId, address executor);\n    error ExecutionFees__ZeroAddress();\n    error ExecutionFees__ZeroAmount();\n\n    /// @notice Add the execution fee for a transaction. The attached value will be added to the\n    /// rewards for the executor completing the transaction.\n    /// Note: this could be used to store the execution fee for a new transaction, or to add more\n    /// funds to the execution fee of an existing transaction. Therefore this function is payable,\n    /// and does not implement any caller restrictions.\n    /// @dev Will revert if the executor is already recorded for the transaction.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to add the execution fee to.\n    function addExecutionFee(uint64 dstChainId, bytes32 transactionId) external payable;\n\n    /// @notice Record the executor (who completed the transaction) for a transaction,\n    /// and update the accumulated rewards for the executor.\n    /// @dev Could only be called by the Recorder.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to record the executor for.\n    /// @param executor             The address of the executor who completed the transaction.\n    function recordExecutor(uint64 dstChainId, bytes32 transactionId, address executor) external;\n\n    /// @notice Allows the executor to claim their unclaimed rewards.\n    /// @dev Will revert if the executor has no unclaimed rewards.\n    function claimExecutionFees(address executor) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the accumulated rewards for an executor.\n    /// @param executor             The address of the executor to get the rewards for.\n    function accumulatedRewards(address executor) external view returns (uint256 accumulated);\n\n    /// @notice Get the unclaimed rewards for an executor.\n    /// @param executor             The address of the executor to get the rewards for.\n    function unclaimedRewards(address executor) external view returns (uint256 unclaimed);\n\n    /// @notice Get the total execution fee for a transaction.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to get the execution fee for.\n    function executionFee(uint64 dstChainId, bytes32 transactionId) external view returns (uint256 fee);\n\n    /// @notice Get the address of the recorded executor for a transaction.\n    /// @dev Will return address(0) if the executor is not recorded.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to get the recorded executor for.\n    function recordedExecutor(uint64 dstChainId, bytes32 transactionId) external view returns (address executor);\n}\n\n// contracts/interfaces/IExecutionService.sol\n\ninterface IExecutionService {\n    /// @notice Request the execution of an Interchain Transaction on a remote chain.\n    /// Note: the off-chain actor needs to fetch the transaction payload from the InterchainClient\n    /// event with the same transactionId, then execute the transaction on the remote chain:\n    /// `dstInterchainClient.executeTransaction(transactionPayload)`\n    /// Once the execution is confirmed on the source chain, the off-chain actor will be able\n    /// to claim `executionFee` in the ExecutionFees contract.\n    /// @dev Could only be called by `InterchainClient` contracts.\n    /// Will revert if the execution fee is not big enough.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param txPayloadSize        The size of the transaction payload to use for the execution.\n    /// @param transactionId        The id of the transaction to execute.\n    /// @param executionFee         The fee paid for the execution.\n    /// @param options              The options to use for the execution.\n    function requestExecution(\n        uint64 dstChainId,\n        uint256 txPayloadSize,\n        bytes32 transactionId,\n        uint256 executionFee,\n        bytes memory options\n    )\n        external;\n\n    /// @notice Get the address of the EOA account that will be used to execute transactions on the\n    /// remote chains.\n    function executorEOA() external view returns (address);\n\n    /// @notice Get the execution fee for executing an Interchain Transaction on a remote chain.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param txPayloadSize        The size of the transaction payload to use for the execution.\n    /// @param options              The options to use for the execution.\n    function getExecutionFee(\n        uint64 dstChainId,\n        uint256 txPayloadSize,\n        bytes memory options\n    )\n        external\n        view\n        returns (uint256);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    /// @notice Allows the Interchain Client to pass the message to the Interchain App.\n    /// @dev App is responsible for keeping track of interchain clients, and must verify the message sender.\n    /// @param srcChainId   Chain ID of the source chain, where the message was sent from.\n    /// @param sender       Sender address on the source chain, as a bytes32 value.\n    /// @param dbNonce      The Interchain DB nonce of the batch containing the message entry.\n    /// @param entryIndex   The index of the message entry within the batch.\n    /// @param message      The message being sent.\n    function appReceive(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /// @notice Returns the verification configuration of the Interchain App.\n    /// @dev This configuration is used by the Interchain Client to verify that message has been confirmed\n    /// by the Interchain Modules on the destination chain.\n    /// Note: V1 version of AppConfig includes the required responses count, and optimistic period after which\n    /// the message is considered confirmed by the module. Following versions may include additional fields.\n    /// @return appConfig    The versioned configuration of the Interchain App, encoded as bytes.\n    /// @return modules      The list of Interchain Modules that app is trusting to confirm the messages.\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/Math.sol\n\nlibrary MathLib {\n    /// @notice Rounds up to the nearest multiple of 32.\n    /// Note: Returns zero on overflows instead of reverting. This is fine for practical\n    /// use cases, as this is used for determining the size of the payload in memory.\n    function roundUpToWord(uint256 x) internal pure returns (uint256) {\n        unchecked {\n            return (x + 31) \u0026 ~uint256(31);\n        }\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/VersionedPayload.sol\n\n// solhint-disable no-inline-assembly\n// solhint-disable ordering\nlibrary VersionedPayloadLib {\n    /// @notice Amount of bytes reserved for the version (uint16) in the versioned payload\n    uint256 internal constant VERSION_LENGTH = 2;\n\n    error VersionedPayload__TooShort(bytes versionedPayload);\n    error VersionedPayload__PrecompileFailed();\n\n    /// @notice Encodes the versioned payload into a single bytes array.\n    /// @param version  The payload's version.\n    /// @param payload  The payload to encode.\n    function encodeVersionedPayload(uint16 version, bytes memory payload) internal pure returns (bytes memory) {\n        return abi.encodePacked(version, payload);\n    }\n\n    /// @notice Extracts the version from the versioned payload (calldata reference).\n    /// @param versionedPayload     The versioned payload (calldata reference).\n    function getVersion(bytes calldata versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            version := shr(240, calldataload(versionedPayload.offset))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (calldata reference).\n    /// @dev The extracted payload is also returned as a calldata reference.\n    /// @param versionedPayload     The versioned payload.\n    function getPayload(bytes calldata versionedPayload) internal pure returns (bytes calldata) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        return versionedPayload[VERSION_LENGTH:];\n    }\n\n    /// @notice Extracts the version from the versioned payload (memory reference).\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getVersionFromMemory(bytes memory versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            // We add 0x20 to skip the length of the bytes array.\n            version := shr(240, mload(add(versionedPayload, 0x20)))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (memory reference).\n    /// @dev The extracted payload is copied into a new memory location. Use `getPayload` when possible\n    /// to avoid extra memory allocation.\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getPayloadFromMemory(bytes memory versionedPayload) internal view returns (bytes memory payload) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        // Figure how many bytes to copy and allocate the memory for the extracted payload.\n        uint256 toCopy;\n        unchecked {\n            toCopy = versionedPayload.length - VERSION_LENGTH;\n        }\n        payload = new bytes(toCopy);\n        // Use identity precompile (0x04) to copy the payload. Unlike MCOPY, this is available on all EVM chains.\n        bool res;\n        assembly {\n            // We add 0x20 to skip the length of the bytes array.\n            // We add 0x02 to skip the 2 bytes reserved for the version.\n            // Copy the payload to the previously allocated memory.\n            res := staticcall(gas(), 0x04, add(versionedPayload, 0x22), toCopy, add(payload, 0x20), toCopy)\n        }\n        if (!res) {\n            revert VersionedPayload__PrecompileFailed();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SafeCast.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value \u003e type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value \u003e type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value \u003e type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value \u003e type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value \u003e type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value \u003e type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value \u003e type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value \u003e type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value \u003e type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value \u003e type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value \u003e type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value \u003e type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value \u003e type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value \u003e type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value \u003e type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value \u003e type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value \u003e type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value \u003e type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value \u003e type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value \u003e type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value \u003e type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value \u003e type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value \u003e type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value \u003e type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value \u003e type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value \u003e type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value \u003e type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value \u003e type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value \u003e type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value \u003e type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value \u003e type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value \u003c 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value \u003e uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal view returns (AppConfigV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (AppConfigV1));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal view returns (OptionsV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (OptionsV1));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(OPTIONS_V1, abi.encode(options));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/libs/InterchainBatch.sol\n\ntype BatchKey is uint128;\n\n/// @notice Struct representing a batch of entries in the Interchain DataBase.\n/// Batched entries are put together in a Merkle tree, which root is saved.\n/// Batch has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: batchRoot\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch\n/// @param batchRoot    The root of the Merkle tree containing the batched entries\nstruct InterchainBatch {\n    uint64 srcChainId;\n    uint64 dbNonce;\n    bytes32 batchRoot;\n}\n\nlibrary InterchainBatchLib {\n    using VersionedPayloadLib for bytes;\n\n    /// @notice Constructs an InterchainBatch struct to be saved on the local chain.\n    /// @param dbNonce      The database nonce of the batch\n    /// @param batchRoot    The root of the Merkle tree containing the batched entries\n    /// @return batch       The constructed InterchainBatch struct\n    function constructLocalBatch(\n        uint64 dbNonce,\n        bytes32 batchRoot\n    )\n        internal\n        view\n        returns (InterchainBatch memory batch)\n    {\n        return InterchainBatch({srcChainId: SafeCast.toUint64(block.chainid), dbNonce: dbNonce, batchRoot: batchRoot});\n    }\n\n    /// @notice Encodes the InterchainBatch struct into a non-versioned batch payload.\n    function encodeBatch(InterchainBatch memory batch) internal pure returns (bytes memory) {\n        return abi.encode(encodeBatchKey(batch.srcChainId, batch.dbNonce), batch.batchRoot);\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in calldata.\n    function decodeBatch(bytes calldata data) internal pure returns (InterchainBatch memory batch) {\n        BatchKey key;\n        (key, batch.batchRoot) = abi.decode(data, (BatchKey, bytes32));\n        (batch.srcChainId, batch.dbNonce) = decodeBatchKey(key);\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in memory.\n    function decodeBatchFromMemory(bytes memory data) internal pure returns (InterchainBatch memory batch) {\n        BatchKey key;\n        (key, batch.batchRoot) = abi.decode(data, (BatchKey, bytes32));\n        (batch.srcChainId, batch.dbNonce) = decodeBatchKey(key);\n    }\n\n    /// @notice Encodes the uint128 key of the batch from uint64 srcChainId and uint64 dbNonce.\n    function encodeBatchKey(uint64 srcChainId, uint64 dbNonce) internal pure returns (BatchKey) {\n        return BatchKey.wrap((uint128(srcChainId) \u003c\u003c 64) | dbNonce);\n    }\n\n    /// @notice Decodes the uint128 key of the batch into uint64 srcChainId and uint64 dbNonce.\n    function decodeBatchKey(BatchKey key) internal pure returns (uint64 srcChainId, uint64 dbNonce) {\n        srcChainId = uint64(BatchKey.unwrap(key) \u003e\u003e 64);\n        dbNonce = uint64(BatchKey.unwrap(key));\n    }\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce + entryIndex\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch containing the entry\n/// @param entryIndex   The index of the entry in the batch\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint64 srcChainId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nusing InterchainEntryLib for InterchainEntry global;\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint64 dbNonce,\n        uint64 entryIndex,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: SafeCast.toUint64(block.chainid),\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n}\n\n// contracts/libs/InterchainTransaction.sol\n\ntype ICTxHeader is uint256;\n\nstruct InterchainTransaction {\n    uint64 srcChainId;\n    uint64 dstChainId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcSender;\n    bytes32 dstReceiver;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    using MathLib for uint256;\n    using VersionedPayloadLib for bytes;\n\n    function constructLocalTransaction(\n        address srcSender,\n        uint64 dstChainId,\n        bytes32 dstReceiver,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: SafeCast.toUint64(block.chainid),\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            encodeTxHeader(transaction.srcChainId, transaction.dstChainId, transaction.dbNonce, transaction.entryIndex),\n            transaction.srcSender,\n            transaction.dstReceiver,\n            transaction.options,\n            transaction.message\n        );\n    }\n\n    function decodeTransaction(bytes calldata transaction) internal pure returns (InterchainTransaction memory icTx) {\n        ICTxHeader header;\n        (header, icTx.srcSender, icTx.dstReceiver, icTx.options, icTx.message) =\n            abi.decode(transaction, (ICTxHeader, bytes32, bytes32, bytes, bytes));\n        (icTx.srcChainId, icTx.dstChainId, icTx.dbNonce, icTx.entryIndex) = decodeTxHeader(header);\n    }\n\n    function payloadSize(uint256 optionsLen, uint256 messageLen) internal pure returns (uint256) {\n        // 2 bytes are reserved for the transaction version\n        // + 5 fields * 32 bytes (3 values for static, 2 offsets for dynamic) + 2 * 32 bytes (lengths for dynamic) = 226\n        // (srcChainId, dstChainId, dbNonce, entryIndex) are merged into a single 32 bytes field\n        // Both options and message are dynamic fields, which are padded up to 32 bytes\n        return 226 + optionsLen.roundUpToWord() + messageLen.roundUpToWord();\n    }\n\n    function encodeTxHeader(\n        uint64 srcChainId,\n        uint64 dstChainId,\n        uint64 dbNonce,\n        uint64 entryIndex\n    )\n        internal\n        pure\n        returns (ICTxHeader)\n    {\n        return ICTxHeader.wrap(\n            (uint256(srcChainId) \u003c\u003c 192) | (uint256(dstChainId) \u003c\u003c 128) | (uint256(dbNonce) \u003c\u003c 64) | uint256(entryIndex)\n        );\n    }\n\n    function decodeTxHeader(ICTxHeader header)\n        internal\n        pure\n        returns (uint64 srcChainId, uint64 dstChainId, uint64 dbNonce, uint64 entryIndex)\n    {\n        srcChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 192);\n        dstChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 128);\n        dbNonce = uint64(ICTxHeader.unwrap(header) \u003e\u003e 64);\n        entryIndex = uint64(ICTxHeader.unwrap(header));\n    }\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint64 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__InvalidTransactionVersion(uint16 version);\n    error InterchainClientV1__NoLinkedClient(uint64 chainId);\n    error InterchainClientV1__NotEnoughGasSupplied();\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint64 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint64 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint64 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint64 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param messageLen           The length of the message being sent.\n    function getInterchainFee(\n        uint64 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        uint256 messageLen\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint64 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint64 chainId) external view returns (address);\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing a batch of entries from the remote Interchain DataBase,\n    /// verified by the Interchain Module.\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param batchRoot    The Merkle root of the batch\n    struct RemoteBatch {\n        uint256 verifiedAt;\n        bytes32 batchRoot;\n    }\n\n    error InterchainDB__BatchDoesNotExist(uint64 dbNonce);\n    error InterchainDB__BatchNotFinalized(uint64 dbNonce);\n    error InterchainDB__ConflictingBatches(address module, bytes32 existingBatchRoot, InterchainBatch newBatch);\n    error InterchainDB__EntryIndexOutOfRange(uint64 dbNonce, uint64 entryIndex, uint64 batchSize);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__InvalidBatchVersion(uint16 version);\n    error InterchainDB__InvalidEntryRange(uint64 dbNonce, uint64 start, uint64 end);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId(uint64 chainId);\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `requestBatchVerification` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntry(bytes32 dataHash) external returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Request the given Interchain Modules to verify an existing batch.\n    /// If the batch is not finalized, the module will verify it after finalization.\n    /// For the finalized batch the batch root is already available, and the module can verify it immediately.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any batch.\n    /// @dev Will revert if the batch with the given nonce does not exist.\n    /// @param dstChainId    The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the existing batch\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestBatchVerification(\n        uint64 dstChainId,\n        uint64 dbNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Then request the Interchain Modules to verify the batch containing the written entry on the destination chain.\n    /// See `writeEntry` and `requestBatchVerification` for more details.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntryWithVerification(\n        uint64 dstChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Allows the Interchain Module to verify the batch coming from the remote chain.\n    /// Note: The DB will only accept the batch of the same version as the DB itself.\n    /// @param versionedBatch   The versioned Interchain Batch to verify\n    function verifyRemoteBatch(bytes memory versionedBatch) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint64 dstChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce.\n    /// Note: the leafs are ordered by the index of the written entry in the current batch,\n    /// and the leafs value match the value of the written entry (srcWriter + dataHash hashed together).\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchLeafs(uint64 dbNonce) external view returns (bytes32[] memory);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce,\n    /// paginated by the given start and end indexes. The end index is exclusive.\n    /// Note: this is useful when the batch contains a large number of leafs, and calling `getBatchLeafs`\n    /// would result in a gas limit exceeded error.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the provided range is invalid.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param start        The start index of the paginated leafs, inclusive\n    /// @param end          The end index of the paginated leafs, exclusive\n    function getBatchLeafsPaginated(\n        uint64 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory);\n\n    /// @notice Returns the size of the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchSize(uint64 dbNonce) external view returns (uint64);\n\n    /// @notice Get the finalized Interchain Batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatch(uint64 dbNonce) external view returns (InterchainBatch memory);\n\n    /// @notice Get the Interchain Entry's value written on the local chain with the given batch nonce and entry index.\n    /// Entry value is calculated as the hash of the writer address and the written data hash.\n    /// Note: the batch does not have to be finalized to fetch the entry value.\n    /// @dev Will revert if the batch with the given nonce does not exist,\n    /// or the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the existing batch\n    /// @param entryIndex   The index of the written entry within the batch\n    function getEntryValue(uint64 dbNonce, uint64 entryIndex) external view returns (bytes32);\n\n    /// @notice Get the Merkle proof of inclusion for the entry with the given index\n    /// in the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param entryIndex   The index of the written entry within the batch\n    /// @return proof       The Merkle proof of inclusion for the entry\n    function getEntryProof(uint64 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof);\n\n    /// @notice Get the nonce of the database, which is incremented every time a new batch is finalized.\n    /// This is the nonce of the current non-finalized batch.\n    function getDBNonce() external view returns (uint64);\n\n    /// @notice Get the index of the next entry to be written to the database.\n    /// @return dbNonce      The database nonce of the batch including the next entry\n    /// @return entryIndex   The index of the next entry within that batch\n    function getNextEntryIndex() external view returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or ZERO if the module has not verified the entry.\n    function checkVerification(\n        address dstModule,\n        InterchainEntry memory entry,\n        bytes32[] memory proof\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n\n    /// @notice Get the version of the Interchain DataBase.\n    // solhint-disable-next-line func-name-mixedcase\n    function DB_VERSION() external pure returns (uint16);\n}\n\n// contracts/InterchainClientV1.sol\n\n/**\n * @title InterchainClientV1\n * @dev Implements the operations of the Interchain Execution Layer.\n */\ncontract InterchainClientV1 is Ownable, InterchainClientV1Events, IInterchainClientV1 {\n    using AppConfigLib for bytes;\n    using OptionsLib for bytes;\n    using VersionedPayloadLib for bytes;\n\n    /// @notice Version of the InterchainClient contract. Sent and received transactions must have the same version.\n    uint16 public constant CLIENT_VERSION = 1;\n\n    /// @notice Address of the InterchainDB contract, set at the time of deployment.\n    address public immutable INTERCHAIN_DB;\n\n    /// @notice Address of the contract that handles execution fees. Can be updated by the owner.\n    address public executionFees;\n\n    /// @dev Address of the InterchainClient contract on the remote chain\n    mapping(uint64 chainId =\u003e bytes32 remoteClient) internal _linkedClient;\n    /// @dev Executor address that completed the transaction. Address(0) if not executed yet.\n    mapping(bytes32 transactionId =\u003e address executor) internal _txExecutor;\n\n    constructor(address interchainDB, address owner_) Ownable(owner_) {\n        INTERCHAIN_DB = interchainDB;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function setExecutionFees(address executionFees_) external onlyOwner {\n        executionFees = executionFees_;\n        emit ExecutionFeesSet(executionFees_);\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function setLinkedClient(uint64 chainId, bytes32 client) external onlyOwner {\n        _linkedClient[chainId] = client;\n        emit LinkedClientSet(chainId, client);\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _interchainSend(dstChainId, receiver, srcExecutionService, srcModules, options, message);\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function interchainSendEVM(\n        uint64 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc)\n    {\n        bytes32 receiverBytes32 = TypeCasts.addressToBytes32(receiver);\n        return _interchainSend(dstChainId, receiverBytes32, srcExecutionService, srcModules, options, message);\n    }\n\n    // TODO: Handle the case where receiver does not implement the IInterchainApp interface (or does not exist at all)\n    // @inheritdoc IInterchainClientV1\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable\n    {\n        InterchainTransaction memory icTx = _assertCorrectVersion(transaction);\n        bytes32 transactionId = keccak256(transaction);\n        _assertExecutable(icTx, transactionId, proof);\n        _txExecutor[transactionId] = msg.sender;\n\n        OptionsV1 memory decodedOptions = icTx.options.decodeOptionsV1();\n        if (msg.value != decodedOptions.gasAirdrop) {\n            revert InterchainClientV1__IncorrectMsgValue(msg.value, decodedOptions.gasAirdrop);\n        }\n        // We should always use at least as much as the requested gas limit.\n        // The executor can specify a higher gas limit if they wanted.\n        if (decodedOptions.gasLimit \u003e gasLimit) gasLimit = decodedOptions.gasLimit;\n        // Check the the Executor has provided big enough gas limit for the whole transaction.\n        if (gasleft() \u003c= gasLimit) {\n            revert InterchainClientV1__NotEnoughGasSupplied();\n        }\n        // Pass the full msg.value to the app: we have already checked that it matches the requested gas airdrop.\n        IInterchainApp(TypeCasts.bytes32ToAddress(icTx.dstReceiver)).appReceive{gas: gasLimit, value: msg.value}({\n            srcChainId: icTx.srcChainId,\n            sender: icTx.srcSender,\n            dbNonce: icTx.dbNonce,\n            entryIndex: icTx.entryIndex,\n            message: icTx.message\n        });\n        emit InterchainTransactionReceived(\n            transactionId, icTx.dbNonce, icTx.entryIndex, icTx.srcChainId, icTx.srcSender, icTx.dstReceiver\n        );\n    }\n\n    /// @inheritdoc IInterchainClientV1\n    function writeExecutionProof(bytes32 transactionId) external returns (uint64 dbNonce, uint64 entryIndex) {\n        address executor = _txExecutor[transactionId];\n        if (executor == address(0)) {\n            revert InterchainClientV1__TxNotExecuted(transactionId);\n        }\n        bytes memory proof = abi.encode(transactionId, executor);\n        (dbNonce, entryIndex) = IInterchainDB(INTERCHAIN_DB).writeEntry(keccak256(proof));\n        emit ExecutionProofWritten(transactionId, dbNonce, entryIndex, executor);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // @inheritdoc IInterchainClientV1\n    function isExecutable(bytes calldata encodedTx, bytes32[] calldata proof) external view returns (bool) {\n        InterchainTransaction memory icTx = _assertCorrectVersion(encodedTx);\n        // Check that options could be decoded\n        icTx.options.decodeOptionsV1();\n        bytes32 transactionId = keccak256(encodedTx);\n        _assertExecutable(icTx, transactionId, proof);\n        return true;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function getExecutor(bytes calldata encodedTx) external view returns (address) {\n        return _txExecutor[keccak256(encodedTx)];\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function getExecutorById(bytes32 transactionId) external view returns (address) {\n        return _txExecutor[transactionId];\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function getInterchainFee(\n        uint64 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        uint256 messageLen\n    )\n        external\n        view\n        returns (uint256 fee)\n    {\n        _assertLinkedClient(dstChainId);\n        // Check that options could be decoded on destination chain\n        options.decodeOptionsV1();\n        // Verification fee from InterchainDB\n        fee = IInterchainDB(INTERCHAIN_DB).getInterchainFee(dstChainId, srcModules);\n        // Add execution fee, if ExecutionService is provided\n        if (srcExecutionService != address(0)) {\n            uint256 payloadSize = InterchainTransactionLib.payloadSize(options.length, messageLen);\n            fee += IExecutionService(srcExecutionService).getExecutionFee(dstChainId, payloadSize, options);\n        }\n    }\n\n    /// @inheritdoc IInterchainClientV1\n    function getLinkedClient(uint64 chainId) external view returns (bytes32) {\n        if (chainId == block.chainid) {\n            revert InterchainClientV1__NotRemoteChainId(chainId);\n        }\n        return _linkedClient[chainId];\n    }\n\n    /// @inheritdoc IInterchainClientV1\n    function getLinkedClientEVM(uint64 chainId) external view returns (address linkedClientEVM) {\n        if (chainId == block.chainid) {\n            revert InterchainClientV1__NotRemoteChainId(chainId);\n        }\n        bytes32 linkedClient = _linkedClient[chainId];\n        linkedClientEVM = TypeCasts.bytes32ToAddress(linkedClient);\n        // Check that the linked client address fits into the EVM address space\n        if (TypeCasts.addressToBytes32(linkedClientEVM) != linkedClient) {\n            revert InterchainClientV1__NotEVMClient(linkedClient);\n        }\n    }\n\n    /// @notice Decodes the encoded options data into a OptionsV1 struct.\n    function decodeOptions(bytes memory encodedOptions) external view returns (OptionsV1 memory) {\n        return encodedOptions.decodeOptionsV1();\n    }\n\n    /// @notice Encodes the transaction data into a bytes format.\n    function encodeTransaction(InterchainTransaction memory icTx) public pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload({\n            version: CLIENT_VERSION,\n            payload: InterchainTransactionLib.encodeTransaction(icTx)\n        });\n    }\n\n    // ═════════════════════════════════════════════════ INTERNAL ══════════════════════════════════════════════════════\n\n    /// @dev Internal logic for sending a message to another chain.\n    function _interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        _assertLinkedClient(dstChainId);\n        if (receiver == 0) revert InterchainClientV1__ZeroReceiver();\n        // Check that options could be decoded on destination chain\n        options.decodeOptionsV1();\n        uint256 verificationFee = IInterchainDB(INTERCHAIN_DB).getInterchainFee(dstChainId, srcModules);\n        if (msg.value \u003c verificationFee) {\n            revert InterchainClientV1__FeeAmountTooLow(msg.value, verificationFee);\n        }\n        (desc.dbNonce, desc.entryIndex) = IInterchainDB(INTERCHAIN_DB).getNextEntryIndex();\n        InterchainTransaction memory icTx = InterchainTransactionLib.constructLocalTransaction({\n            srcSender: msg.sender,\n            dstReceiver: receiver,\n            dstChainId: dstChainId,\n            dbNonce: desc.dbNonce,\n            entryIndex: desc.entryIndex,\n            options: options,\n            message: message\n        });\n        desc.transactionId = keccak256(encodeTransaction(icTx));\n        // Sanity check: nonce returned from DB should match the nonce used to construct the transaction\n        {\n            (uint64 dbNonce, uint64 entryIndex) = IInterchainDB(INTERCHAIN_DB).writeEntryWithVerification{\n                value: verificationFee\n            }(icTx.dstChainId, desc.transactionId, srcModules);\n            assert(dbNonce == desc.dbNonce \u0026\u0026 entryIndex == desc.entryIndex);\n        }\n        uint256 executionFee;\n        unchecked {\n            executionFee = msg.value - verificationFee;\n        }\n        if (executionFee \u003e 0) {\n            IExecutionFees(executionFees).addExecutionFee{value: executionFee}(icTx.dstChainId, desc.transactionId);\n        }\n        // TODO: consider disallowing the use of empty srcExecutionService\n        if (srcExecutionService != address(0)) {\n            IExecutionService(srcExecutionService).requestExecution({\n                dstChainId: dstChainId,\n                txPayloadSize: InterchainTransactionLib.payloadSize(options.length, message.length),\n                transactionId: desc.transactionId,\n                executionFee: executionFee,\n                options: options\n            });\n            address srcExecutorEOA = IExecutionService(srcExecutionService).executorEOA();\n            IExecutionFees(executionFees).recordExecutor(icTx.dstChainId, desc.transactionId, srcExecutorEOA);\n        }\n        emit InterchainTransactionSent(\n            desc.transactionId,\n            icTx.dbNonce,\n            icTx.entryIndex,\n            icTx.dstChainId,\n            icTx.srcSender,\n            icTx.dstReceiver,\n            verificationFee,\n            executionFee,\n            icTx.options,\n            icTx.message\n        );\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Asserts that the transaction is executable.\n    function _assertExecutable(\n        InterchainTransaction memory icTx,\n        bytes32 transactionId,\n        bytes32[] calldata proof\n    )\n        internal\n        view\n    {\n        bytes32 linkedClient = _assertLinkedClient(icTx.srcChainId);\n        if (icTx.dstChainId != block.chainid) {\n            revert InterchainClientV1__IncorrectDstChainId(icTx.dstChainId);\n        }\n        if (_txExecutor[transactionId] != address(0)) {\n            revert InterchainClientV1__TxAlreadyExecuted(transactionId);\n        }\n        // Construct expected entry based on icTransaction data\n        InterchainEntry memory icEntry = InterchainEntry({\n            srcChainId: icTx.srcChainId,\n            dbNonce: icTx.dbNonce,\n            entryIndex: icTx.entryIndex,\n            srcWriter: linkedClient,\n            dataHash: transactionId\n        });\n        (bytes memory encodedAppConfig, address[] memory approvedDstModules) =\n            IInterchainApp(TypeCasts.bytes32ToAddress(icTx.dstReceiver)).getReceivingConfig();\n        AppConfigV1 memory appConfig = encodedAppConfig.decodeAppConfigV1();\n        if (appConfig.requiredResponses == 0) {\n            revert InterchainClientV1__ZeroRequiredResponses();\n        }\n        uint256 responses = _getFinalizedResponsesCount(approvedDstModules, icEntry, proof, appConfig.optimisticPeriod);\n        if (responses \u003c appConfig.requiredResponses) {\n            revert InterchainClientV1__NotEnoughResponses(responses, appConfig.requiredResponses);\n        }\n    }\n\n    /// @dev Asserts that the chain is linked and returns the linked client address.\n    function _assertLinkedClient(uint64 chainId) internal view returns (bytes32 linkedClient) {\n        if (chainId == block.chainid) {\n            revert InterchainClientV1__NotRemoteChainId(chainId);\n        }\n        linkedClient = _linkedClient[chainId];\n        if (linkedClient == 0) {\n            revert InterchainClientV1__NoLinkedClient(chainId);\n        }\n    }\n\n    /**\n     * @dev Calculates the number of responses that are considered finalized within the optimistic time period.\n     * @param approvedModules       Approved modules that could have confirmed the entry.\n     * @param icEntry               The InterchainEntry to confirm.\n     * @param optimisticPeriod      The time period in seconds within which a response is considered valid.\n     * @return finalizedResponses   The count of responses that are finalized within the optimistic time period.\n     */\n    function _getFinalizedResponsesCount(\n        address[] memory approvedModules,\n        InterchainEntry memory icEntry,\n        bytes32[] calldata proof,\n        uint256 optimisticPeriod\n    )\n        internal\n        view\n        returns (uint256 finalizedResponses)\n    {\n        for (uint256 i = 0; i \u003c approvedModules.length; ++i) {\n            uint256 confirmedAt = IInterchainDB(INTERCHAIN_DB).checkVerification(approvedModules[i], icEntry, proof);\n            // checkVerification() returns 0 if entry hasn't been confirmed by the module, so we check for that as well\n            if (confirmedAt != 0 \u0026\u0026 confirmedAt + optimisticPeriod \u003c block.timestamp) {\n                ++finalizedResponses;\n            }\n        }\n    }\n\n    /// @dev Asserts that the transaction version is correct. Returns the decoded transaction for chaining purposes.\n    function _assertCorrectVersion(bytes calldata versionedTx)\n        internal\n        pure\n        returns (InterchainTransaction memory icTx)\n    {\n        uint16 version = versionedTx.getVersion();\n        if (version != CLIENT_VERSION) {\n            revert InterchainClientV1__InvalidTransactionVersion(version);\n        }\n        icTx = InterchainTransactionLib.decodeTransaction(versionedTx.getPayload());\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"uint64","name":"dbNonce","type":"uint64"}],"name":"InterchainDB__BatchDoesNotExist","type":"error"},{"inputs":[{"internalType":"uint64","name":"dbNonce","type":"uint64"}],"name":"InterchainDB__BatchNotFinalized","type":"error"},{"inputs":[{"internalType":"address","name":"module","type":"address"},{"internalType":"bytes32","name":"existingBatchRoot","type":"bytes32"},{"components":[{"internalType":"uint64","name":"srcChainId","type":"uint64"},{"internalType":"uint64","name":"dbNonce","type":"uint64"},{"internalType":"bytes32","name":"batchRoot","type":"bytes32"}],"internalType":"struct InterchainBatch","name":"newBatch","type":"tuple"}],"name":"InterchainDB__ConflictingBatches","type":"error"},{"inputs":[{"internalType":"uint64","name":"dbNonce","type":"uint64"},{"internalType":"uint64","name":"entryIndex","type":"uint64"},{"internalType":"uint64","name":"batchSize","type":"uint64"}],"name":"InterchainDB__EntryIndexOutOfRange","type":"error"},{"inputs":[{"internalType":"uint256","name":"actualFee","type":"uint256"},{"internalType":"uint256","name":"expectedFee","type":"uint256"}],"name":"InterchainDB__IncorrectFeeAmount","type":"error"},{"inputs":[{"internalType":"uint16","name":"version","type":"uint16"}],"name":"InterchainDB__InvalidBatchVersion","type":"error"},{"inputs":[{"internalType":"uint64","name":"dbNonce","type":"uint64"},{"internalType":"uint64","name":"start","type":"uint64"},{"internalType":"uint64","name":"end","type":"uint64"}],"name":"InterchainDB__InvalidEntryRange","type":"error"},{"inputs":[],"name":"InterchainDB__NoModulesSpecified","type":"error"},{"inputs":[{"internalType":"uint64","name":"chainId","type":"uint64"}],"name":"InterchainDB__SameChainId","type":"error"},{"inputs":[],"name":"DB_VERSION","outputs":[{"internalType":"uint16","name":"","type":"uint16"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"address","name":"dstModule","type":"address"},{"components":[{"internalType":"uint64","name":"srcChainId","type":"uint64"},{"internalType":"uint64","name":"dbNonce","type":"uint64"},{"internalType":"uint64","name":"entryIndex","type":"uint64"},{"internalType":"bytes32","name":"srcWriter","type":"bytes32"},{"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"internalType":"struct InterchainEntry","name":"entry","type":"tuple"},{"internalType":"bytes32[]","name":"proof","type":"bytes32[]"}],"name":"checkVerification","outputs":[{"internalType":"uint256","name":"moduleVerifiedAt","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint64","name":"dbNonce","type":"uint64"}],"name":"getBatch","outputs":[{"components":[{"internalType":"uint64","name":"srcChainId","type":"uint64"},{"internalType":"uint64","name":"dbNonce","type":"uint64"},{"internalType":"bytes32","name":"batchRoot","type":"bytes32"}],"internalType":"struct InterchainBatch","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint64","name":"dbNonce","type":"uint64"}],"name":"getBatchLeafs","outputs":[{"internalType":"bytes32[]","name":"","type":"bytes32[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint64","name":"dbNonce","type":"uint64"},{"internalType":"uint64","name":"start","type":"uint64"},{"internalType":"uint64","name":"end","type":"uint64"}],"name":"getBatchLeafsPaginated","outputs":[{"internalType":"bytes32[]","name":"","type":"bytes32[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint64","name":"dbNonce","type":"uint64"}],"name":"getBatchSize","outputs":[{"internalType":"uint64","name":"","type":"uint64"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getDBNonce","outputs":[{"internalType":"uint64","name":"","type":"uint64"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint64","name":"dbNonce","type":"uint64"},{"internalType":"uint64","name":"entryIndex","type":"uint64"}],"name":"getEntryProof","outputs":[{"internalType":"bytes32[]","name":"proof","type":"bytes32[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint64","name":"dbNonce","type":"uint64"},{"internalType":"uint64","name":"entryIndex","type":"uint64"}],"name":"getEntryValue","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint64","name":"dstChainId","type":"uint64"},{"internalType":"address[]","name":"srcModules","type":"address[]"}],"name":"getInterchainFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getNextEntryIndex","outputs":[{"internalType":"uint64","name":"dbNonce","type":"uint64"},{"internalType":"uint64","name":"entryIndex","type":"uint64"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint64","name":"dstChainId","type":"uint64"},{"internalType":"uint64","name":"dbNonce","type":"uint64"},{"internalType":"address[]","name":"srcModules","type":"address[]"}],"name":"requestBatchVerification","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"bytes","name":"versionedBatch","type":"bytes"}],"name":"verifyRemoteBatch","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"name":"writeEntry","outputs":[{"internalType":"uint64","name":"dbNonce","type":"uint64"},{"internalType":"uint64","name":"entryIndex","type":"uint64"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint64","name":"dstChainId","type":"uint64"},{"internalType":"bytes32","name":"dataHash","type":"bytes32"},{"internalType":"address[]","name":"srcModules","type":"address[]"}],"name":"writeEntryWithVerification","outputs":[{"internalType":"uint64","name":"dbNonce","type":"uint64"},{"internalType":"uint64","name":"entryIndex","type":"uint64"}],"stateMutability":"payable","type":"function"}],"userDoc":{"kind":"user","methods":{"DB_VERSION()":{"notice":"Get the version of the Interchain DataBase."},"checkVerification(address,(uint64,uint64,uint64,bytes32,bytes32),bytes32[])":{"notice":"Read the data written on specific source chain by a specific writer, and verify it on the destination chain using the provided Interchain Module. Note: returned zero value indicates that the module has not verified the entry."},"getBatch(uint64)":{"notice":"Get the finalized Interchain Batch with the given nonce."},"getBatchLeafs(uint64)":{"notice":"Returns the list of leafs of the finalized batch with the given nonce. Note: the leafs are ordered by the index of the written entry in the current batch, and the leafs value match the value of the written entry (srcWriter + dataHash hashed together)."},"getBatchLeafsPaginated(uint64,uint64,uint64)":{"notice":"Returns the list of leafs of the finalized batch with the given nonce, paginated by the given start and end indexes. The end index is exclusive. Note: this is useful when the batch contains a large number of leafs, and calling `getBatchLeafs` would result in a gas limit exceeded error."},"getBatchSize(uint64)":{"notice":"Returns the size of the finalized batch with the given nonce."},"getDBNonce()":{"notice":"Get the nonce of the database, which is incremented every time a new batch is finalized. This is the nonce of the current non-finalized batch."},"getEntryProof(uint64,uint64)":{"notice":"Get the Merkle proof of inclusion for the entry with the given index in the finalized batch with the given nonce."},"getEntryValue(uint64,uint64)":{"notice":"Get the Interchain Entry's value written on the local chain with the given batch nonce and entry index. Entry value is calculated as the hash of the writer address and the written data hash. Note: the batch does not have to be finalized to fetch the entry value."},"getInterchainFee(uint64,address[])":{"notice":"Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain using the provided Interchain Modules."},"getNextEntryIndex()":{"notice":"Get the index of the next entry to be written to the database."},"requestBatchVerification(uint64,uint64,address[])":{"notice":"Request the given Interchain Modules to verify an existing batch. If the batch is not finalized, the module will verify it after finalization. For the finalized batch the batch root is already available, and the module can verify it immediately. Note: every module has a separate fee paid in the native gas token of the source chain, and `msg.value` must be equal to the sum of all fees. Note: this method is permissionless, and anyone can request verification for any batch."},"verifyRemoteBatch(bytes)":{"notice":"Allows the Interchain Module to verify the batch coming from the remote chain. Note: The DB will only accept the batch of the same version as the DB itself."},"writeEntry(bytes32)":{"notice":"Write data to the Interchain DataBase as a new entry in the current batch. Note: there are no guarantees that this entry will be available for reading on any of the remote chains. Use `requestBatchVerification` to ensure that the entry is available for reading on the destination chain."},"writeEntryWithVerification(uint64,bytes32,address[])":{"notice":"Write data to the Interchain DataBase as a new entry in the current batch. Then request the Interchain Modules to verify the batch containing the written entry on the destination chain. See `writeEntry` and `requestBatchVerification` for more details."}},"version":1},"developerDoc":{"kind":"dev","methods":{"checkVerification(address,(uint64,uint64,uint64,bytes32,bytes32),bytes32[])":{"params":{"dstModule":"The destination chain addresses of the Interchain Modules to use for verification","entry":"The Interchain Entry to read"},"returns":{"moduleVerifiedAt":"  The block timestamp at which the entry was verified by the module,                             or ZERO if the module has not verified the entry."}},"getBatch(uint64)":{"details":"Will revert if the batch with the given nonce does not exist, or is not finalized.","params":{"dbNonce":"The database nonce of the finalized batch"}},"getBatchLeafs(uint64)":{"details":"Will revert if the batch with the given nonce does not exist, or is not finalized.","params":{"dbNonce":"The database nonce of the finalized batch"}},"getBatchLeafsPaginated(uint64,uint64,uint64)":{"details":"Will revert if the batch with the given nonce does not exist, or is not finalized. Will revert if the provided range is invalid.","params":{"dbNonce":"The database nonce of the finalized batch","end":"The end index of the paginated leafs, exclusive","start":"The start index of the paginated leafs, inclusive"}},"getBatchSize(uint64)":{"details":"Will revert if the batch with the given nonce does not exist, or is not finalized.","params":{"dbNonce":"The database nonce of the finalized batch"}},"getEntryProof(uint64,uint64)":{"details":"Will revert if the batch with the given nonce does not exist, or is not finalized. Will revert if the entry with the given index does not exist within the batch.","params":{"dbNonce":"The database nonce of the finalized batch","entryIndex":"The index of the written entry within the batch"},"returns":{"proof":"      The Merkle proof of inclusion for the entry"}},"getEntryValue(uint64,uint64)":{"details":"Will revert if the batch with the given nonce does not exist, or the entry with the given index does not exist within the batch.","params":{"dbNonce":"The database nonce of the existing batch","entryIndex":"The index of the written entry within the batch"}},"getInterchainFee(uint64,address[])":{"details":"Will revert if the empty array of modules is provided.","params":{"dstChainId":"The chain id of the destination chain","srcModules":"The source chain addresses of the Interchain Modules to use for verification"}},"getNextEntryIndex()":{"returns":{"dbNonce":"     The database nonce of the batch including the next entry","entryIndex":"  The index of the next entry within that batch"}},"requestBatchVerification(uint64,uint64,address[])":{"details":"Will revert if the batch with the given nonce does not exist.","params":{"dbNonce":"The database nonce of the existing batch","dstChainId":"The chain id of the destination chain","srcModules":"The source chain addresses of the Interchain Modules to use for verification"}},"verifyRemoteBatch(bytes)":{"params":{"versionedBatch":"The versioned Interchain Batch to verify"}},"writeEntry(bytes32)":{"params":{"dataHash":"The hash of the data to be written to the Interchain DataBase as a new entry"},"returns":{"dbNonce":"    The database nonce of the batch containing the written entry","entryIndex":" The index of the written entry within the batch"}},"writeEntryWithVerification(uint64,bytes32,address[])":{"details":"Will revert if the empty array of modules is provided.","params":{"dataHash":"The hash of the data to be written to the Interchain DataBase as a new entry","dstChainId":"The chain id of the destination chain","srcModules":"The source chain addresses of the Interchain Modules to use for verification"},"returns":{"dbNonce":"    The database nonce of the batch containing the written entry","entryIndex":" The index of the written entry within the batch"}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"}],\"name\":\"InterchainDB__BatchDoesNotExist\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"}],\"name\":\"InterchainDB__BatchNotFinalized\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"existingBatchRoot\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"srcChainId\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"batchRoot\",\"type\":\"bytes32\"}],\"internalType\":\"struct InterchainBatch\",\"name\":\"newBatch\",\"type\":\"tuple\"}],\"name\":\"InterchainDB__ConflictingBatches\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"batchSize\",\"type\":\"uint64\"}],\"name\":\"InterchainDB__EntryIndexOutOfRange\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"actualFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expectedFee\",\"type\":\"uint256\"}],\"name\":\"InterchainDB__IncorrectFeeAmount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"version\",\"type\":\"uint16\"}],\"name\":\"InterchainDB__InvalidBatchVersion\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"start\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"end\",\"type\":\"uint64\"}],\"name\":\"InterchainDB__InvalidEntryRange\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InterchainDB__NoModulesSpecified\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"}],\"name\":\"InterchainDB__SameChainId\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DB_VERSION\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dstModule\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"srcChainId\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"srcWriter\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"internalType\":\"struct InterchainEntry\",\"name\":\"entry\",\"type\":\"tuple\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"checkVerification\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"moduleVerifiedAt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"}],\"name\":\"getBatch\",\"outputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"srcChainId\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"batchRoot\",\"type\":\"bytes32\"}],\"internalType\":\"struct InterchainBatch\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"}],\"name\":\"getBatchLeafs\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"start\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"end\",\"type\":\"uint64\"}],\"name\":\"getBatchLeafsPaginated\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"}],\"name\":\"getBatchSize\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDBNonce\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"}],\"name\":\"getEntryProof\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"}],\"name\":\"getEntryValue\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"dstChainId\",\"type\":\"uint64\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"}],\"name\":\"getInterchainFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNextEntryIndex\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"dstChainId\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"}],\"name\":\"requestBatchVerification\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"versionedBatch\",\"type\":\"bytes\"}],\"name\":\"verifyRemoteBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"name\":\"writeEntry\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"dstChainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"}],\"name\":\"writeEntryWithVerification\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"}],\"stateMutability\":\"payable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"checkVerification(address,(uint64,uint64,uint64,bytes32,bytes32),bytes32[])\":{\"params\":{\"dstModule\":\"The destination chain addresses of the Interchain Modules to use for verification\",\"entry\":\"The Interchain Entry to read\"},\"returns\":{\"moduleVerifiedAt\":\"  The block timestamp at which the entry was verified by the module,                             or ZERO if the module has not verified the entry.\"}},\"getBatch(uint64)\":{\"details\":\"Will revert if the batch with the given nonce does not exist, or is not finalized.\",\"params\":{\"dbNonce\":\"The database nonce of the finalized batch\"}},\"getBatchLeafs(uint64)\":{\"details\":\"Will revert if the batch with the given nonce does not exist, or is not finalized.\",\"params\":{\"dbNonce\":\"The database nonce of the finalized batch\"}},\"getBatchLeafsPaginated(uint64,uint64,uint64)\":{\"details\":\"Will revert if the batch with the given nonce does not exist, or is not finalized. Will revert if the provided range is invalid.\",\"params\":{\"dbNonce\":\"The database nonce of the finalized batch\",\"end\":\"The end index of the paginated leafs, exclusive\",\"start\":\"The start index of the paginated leafs, inclusive\"}},\"getBatchSize(uint64)\":{\"details\":\"Will revert if the batch with the given nonce does not exist, or is not finalized.\",\"params\":{\"dbNonce\":\"The database nonce of the finalized batch\"}},\"getEntryProof(uint64,uint64)\":{\"details\":\"Will revert if the batch with the given nonce does not exist, or is not finalized. Will revert if the entry with the given index does not exist within the batch.\",\"params\":{\"dbNonce\":\"The database nonce of the finalized batch\",\"entryIndex\":\"The index of the written entry within the batch\"},\"returns\":{\"proof\":\"      The Merkle proof of inclusion for the entry\"}},\"getEntryValue(uint64,uint64)\":{\"details\":\"Will revert if the batch with the given nonce does not exist, or the entry with the given index does not exist within the batch.\",\"params\":{\"dbNonce\":\"The database nonce of the existing batch\",\"entryIndex\":\"The index of the written entry within the batch\"}},\"getInterchainFee(uint64,address[])\":{\"details\":\"Will revert if the empty array of modules is provided.\",\"params\":{\"dstChainId\":\"The chain id of the destination chain\",\"srcModules\":\"The source chain addresses of the Interchain Modules to use for verification\"}},\"getNextEntryIndex()\":{\"returns\":{\"dbNonce\":\"     The database nonce of the batch including the next entry\",\"entryIndex\":\"  The index of the next entry within that batch\"}},\"requestBatchVerification(uint64,uint64,address[])\":{\"details\":\"Will revert if the batch with the given nonce does not exist.\",\"params\":{\"dbNonce\":\"The database nonce of the existing batch\",\"dstChainId\":\"The chain id of the destination chain\",\"srcModules\":\"The source chain addresses of the Interchain Modules to use for verification\"}},\"verifyRemoteBatch(bytes)\":{\"params\":{\"versionedBatch\":\"The versioned Interchain Batch to verify\"}},\"writeEntry(bytes32)\":{\"params\":{\"dataHash\":\"The hash of the data to be written to the Interchain DataBase as a new entry\"},\"returns\":{\"dbNonce\":\"    The database nonce of the batch containing the written entry\",\"entryIndex\":\" The index of the written entry within the batch\"}},\"writeEntryWithVerification(uint64,bytes32,address[])\":{\"details\":\"Will revert if the empty array of modules is provided.\",\"params\":{\"dataHash\":\"The hash of the data to be written to the Interchain DataBase as a new entry\",\"dstChainId\":\"The chain id of the destination chain\",\"srcModules\":\"The source chain addresses of the Interchain Modules to use for verification\"},\"returns\":{\"dbNonce\":\"    The database nonce of the batch containing the written entry\",\"entryIndex\":\" The index of the written entry within the batch\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"DB_VERSION()\":{\"notice\":\"Get the version of the Interchain DataBase.\"},\"checkVerification(address,(uint64,uint64,uint64,bytes32,bytes32),bytes32[])\":{\"notice\":\"Read the data written on specific source chain by a specific writer, and verify it on the destination chain using the provided Interchain Module. Note: returned zero value indicates that the module has not verified the entry.\"},\"getBatch(uint64)\":{\"notice\":\"Get the finalized Interchain Batch with the given nonce.\"},\"getBatchLeafs(uint64)\":{\"notice\":\"Returns the list of leafs of the finalized batch with the given nonce. Note: the leafs are ordered by the index of the written entry in the current batch, and the leafs value match the value of the written entry (srcWriter + dataHash hashed together).\"},\"getBatchLeafsPaginated(uint64,uint64,uint64)\":{\"notice\":\"Returns the list of leafs of the finalized batch with the given nonce, paginated by the given start and end indexes. The end index is exclusive. Note: this is useful when the batch contains a large number of leafs, and calling `getBatchLeafs` would result in a gas limit exceeded error.\"},\"getBatchSize(uint64)\":{\"notice\":\"Returns the size of the finalized batch with the given nonce.\"},\"getDBNonce()\":{\"notice\":\"Get the nonce of the database, which is incremented every time a new batch is finalized. This is the nonce of the current non-finalized batch.\"},\"getEntryProof(uint64,uint64)\":{\"notice\":\"Get the Merkle proof of inclusion for the entry with the given index in the finalized batch with the given nonce.\"},\"getEntryValue(uint64,uint64)\":{\"notice\":\"Get the Interchain Entry's value written on the local chain with the given batch nonce and entry index. Entry value is calculated as the hash of the writer address and the written data hash. Note: the batch does not have to be finalized to fetch the entry value.\"},\"getInterchainFee(uint64,address[])\":{\"notice\":\"Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain using the provided Interchain Modules.\"},\"getNextEntryIndex()\":{\"notice\":\"Get the index of the next entry to be written to the database.\"},\"requestBatchVerification(uint64,uint64,address[])\":{\"notice\":\"Request the given Interchain Modules to verify an existing batch. If the batch is not finalized, the module will verify it after finalization. For the finalized batch the batch root is already available, and the module can verify it immediately. Note: every module has a separate fee paid in the native gas token of the source chain, and `msg.value` must be equal to the sum of all fees. Note: this method is permissionless, and anyone can request verification for any batch.\"},\"verifyRemoteBatch(bytes)\":{\"notice\":\"Allows the Interchain Module to verify the batch coming from the remote chain. Note: The DB will only accept the batch of the same version as the DB itself.\"},\"writeEntry(bytes32)\":{\"notice\":\"Write data to the Interchain DataBase as a new entry in the current batch. Note: there are no guarantees that this entry will be available for reading on any of the remote chains. Use `requestBatchVerification` to ensure that the entry is available for reading on the destination chain.\"},\"writeEntryWithVerification(uint64,bytes32,address[])\":{\"notice\":\"Write data to the Interchain DataBase as a new entry in the current batch. Then request the Interchain Modules to verify the batch containing the written entry on the destination chain. See `writeEntry` and `requestBatchVerification` for more details.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainClientV1.sol\":\"IInterchainDB\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainClientV1.sol\":{\"keccak256\":\"0xe270686a9bca05b4013610a4e8bb08040de32a0442edd218e1692edaca94e40e\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://727e84146369613e04e57a677f8bc6c709ee145df3eeb79f15ea5a922198d78f\",\"dweb:/ipfs/QmUXh2nDtHBnhYZSwCxcteN4be13S7dR9GbqqHT9mUxta3\"]}},\"version\":1}"},"hashes":{"DB_VERSION()":"15f53956","checkVerification(address,(uint64,uint64,uint64,bytes32,bytes32),bytes32[])":"1e5df4c4","getBatch(uint64)":"888775d9","getBatchLeafs(uint64)":"fc1ebc91","getBatchLeafsPaginated(uint64,uint64,uint64)":"1c679ac1","getBatchSize(uint64)":"727a5f91","getDBNonce()":"f338140e","getEntryProof(uint64,uint64)":"fec8dfb9","getEntryValue(uint64,uint64)":"d180db6f","getInterchainFee(uint64,address[])":"b8ba4ba1","getNextEntryIndex()":"aa2f06ae","requestBatchVerification(uint64,uint64,address[])":"6c49312c","verifyRemoteBatch(bytes)":"d961a48e","writeEntry(bytes32)":"2ad8c706","writeEntryWithVerification(uint64,bytes32,address[])":"eb20fbfd"}},"solidity/InterchainClientV1.sol:InterchainBatchLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220274e85ccbfc0513744f1422f22ab4b09f12adde4015ad7d411ae2edeca1d568e64736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220274e85ccbfc0513744f1422f22ab4b09f12adde4015ad7d411ae2edeca1d568e64736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainClientV1Events.sol\n\nabstract contract InterchainClientV1Events {\n    event ExecutionFeesSet(address executionFees);\n    event LinkedClientSet(uint64 chainId, bytes32 client);\n\n    // TODO: figure out indexing\n\n    event InterchainTransactionSent(\n        bytes32 indexed transactionId,\n        uint64 indexed dbNonce,\n        uint64 indexed entryIndex,\n        uint64 dstChainId,\n        bytes32 srcSender,\n        bytes32 dstReceiver,\n        uint256 verificationFee,\n        uint256 executionFee,\n        bytes options,\n        bytes message\n    );\n\n    event InterchainTransactionReceived(\n        bytes32 indexed transactionId,\n        uint64 indexed dbNonce,\n        uint64 indexed entryIndex,\n        uint64 srcChainId,\n        bytes32 srcSender,\n        bytes32 dstReceiver\n    );\n\n    event ExecutionProofWritten(\n        bytes32 indexed transactionId, uint64 indexed dbNonce, uint64 indexed entryIndex, address executor\n    );\n}\n\n// contracts/interfaces/IExecutionFees.sol\n\ninterface IExecutionFees {\n    error ExecutionFees__AlreadyRecorded(uint64 dstChainId, bytes32 transactionId, address executor);\n    error ExecutionFees__ZeroAddress();\n    error ExecutionFees__ZeroAmount();\n\n    /// @notice Add the execution fee for a transaction. The attached value will be added to the\n    /// rewards for the executor completing the transaction.\n    /// Note: this could be used to store the execution fee for a new transaction, or to add more\n    /// funds to the execution fee of an existing transaction. Therefore this function is payable,\n    /// and does not implement any caller restrictions.\n    /// @dev Will revert if the executor is already recorded for the transaction.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to add the execution fee to.\n    function addExecutionFee(uint64 dstChainId, bytes32 transactionId) external payable;\n\n    /// @notice Record the executor (who completed the transaction) for a transaction,\n    /// and update the accumulated rewards for the executor.\n    /// @dev Could only be called by the Recorder.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to record the executor for.\n    /// @param executor             The address of the executor who completed the transaction.\n    function recordExecutor(uint64 dstChainId, bytes32 transactionId, address executor) external;\n\n    /// @notice Allows the executor to claim their unclaimed rewards.\n    /// @dev Will revert if the executor has no unclaimed rewards.\n    function claimExecutionFees(address executor) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the accumulated rewards for an executor.\n    /// @param executor             The address of the executor to get the rewards for.\n    function accumulatedRewards(address executor) external view returns (uint256 accumulated);\n\n    /// @notice Get the unclaimed rewards for an executor.\n    /// @param executor             The address of the executor to get the rewards for.\n    function unclaimedRewards(address executor) external view returns (uint256 unclaimed);\n\n    /// @notice Get the total execution fee for a transaction.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to get the execution fee for.\n    function executionFee(uint64 dstChainId, bytes32 transactionId) external view returns (uint256 fee);\n\n    /// @notice Get the address of the recorded executor for a transaction.\n    /// @dev Will return address(0) if the executor is not recorded.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to get the recorded executor for.\n    function recordedExecutor(uint64 dstChainId, bytes32 transactionId) external view returns (address executor);\n}\n\n// contracts/interfaces/IExecutionService.sol\n\ninterface IExecutionService {\n    /// @notice Request the execution of an Interchain Transaction on a remote chain.\n    /// Note: the off-chain actor needs to fetch the transaction payload from the InterchainClient\n    /// event with the same transactionId, then execute the transaction on the remote chain:\n    /// `dstInterchainClient.executeTransaction(transactionPayload)`\n    /// Once the execution is confirmed on the source chain, the off-chain actor will be able\n    /// to claim `executionFee` in the ExecutionFees contract.\n    /// @dev Could only be called by `InterchainClient` contracts.\n    /// Will revert if the execution fee is not big enough.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param txPayloadSize        The size of the transaction payload to use for the execution.\n    /// @param transactionId        The id of the transaction to execute.\n    /// @param executionFee         The fee paid for the execution.\n    /// @param options              The options to use for the execution.\n    function requestExecution(\n        uint64 dstChainId,\n        uint256 txPayloadSize,\n        bytes32 transactionId,\n        uint256 executionFee,\n        bytes memory options\n    )\n        external;\n\n    /// @notice Get the address of the EOA account that will be used to execute transactions on the\n    /// remote chains.\n    function executorEOA() external view returns (address);\n\n    /// @notice Get the execution fee for executing an Interchain Transaction on a remote chain.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param txPayloadSize        The size of the transaction payload to use for the execution.\n    /// @param options              The options to use for the execution.\n    function getExecutionFee(\n        uint64 dstChainId,\n        uint256 txPayloadSize,\n        bytes memory options\n    )\n        external\n        view\n        returns (uint256);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    /// @notice Allows the Interchain Client to pass the message to the Interchain App.\n    /// @dev App is responsible for keeping track of interchain clients, and must verify the message sender.\n    /// @param srcChainId   Chain ID of the source chain, where the message was sent from.\n    /// @param sender       Sender address on the source chain, as a bytes32 value.\n    /// @param dbNonce      The Interchain DB nonce of the batch containing the message entry.\n    /// @param entryIndex   The index of the message entry within the batch.\n    /// @param message      The message being sent.\n    function appReceive(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /// @notice Returns the verification configuration of the Interchain App.\n    /// @dev This configuration is used by the Interchain Client to verify that message has been confirmed\n    /// by the Interchain Modules on the destination chain.\n    /// Note: V1 version of AppConfig includes the required responses count, and optimistic period after which\n    /// the message is considered confirmed by the module. Following versions may include additional fields.\n    /// @return appConfig    The versioned configuration of the Interchain App, encoded as bytes.\n    /// @return modules      The list of Interchain Modules that app is trusting to confirm the messages.\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/Math.sol\n\nlibrary MathLib {\n    /// @notice Rounds up to the nearest multiple of 32.\n    /// Note: Returns zero on overflows instead of reverting. This is fine for practical\n    /// use cases, as this is used for determining the size of the payload in memory.\n    function roundUpToWord(uint256 x) internal pure returns (uint256) {\n        unchecked {\n            return (x + 31) \u0026 ~uint256(31);\n        }\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/VersionedPayload.sol\n\n// solhint-disable no-inline-assembly\n// solhint-disable ordering\nlibrary VersionedPayloadLib {\n    /// @notice Amount of bytes reserved for the version (uint16) in the versioned payload\n    uint256 internal constant VERSION_LENGTH = 2;\n\n    error VersionedPayload__TooShort(bytes versionedPayload);\n    error VersionedPayload__PrecompileFailed();\n\n    /// @notice Encodes the versioned payload into a single bytes array.\n    /// @param version  The payload's version.\n    /// @param payload  The payload to encode.\n    function encodeVersionedPayload(uint16 version, bytes memory payload) internal pure returns (bytes memory) {\n        return abi.encodePacked(version, payload);\n    }\n\n    /// @notice Extracts the version from the versioned payload (calldata reference).\n    /// @param versionedPayload     The versioned payload (calldata reference).\n    function getVersion(bytes calldata versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            version := shr(240, calldataload(versionedPayload.offset))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (calldata reference).\n    /// @dev The extracted payload is also returned as a calldata reference.\n    /// @param versionedPayload     The versioned payload.\n    function getPayload(bytes calldata versionedPayload) internal pure returns (bytes calldata) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        return versionedPayload[VERSION_LENGTH:];\n    }\n\n    /// @notice Extracts the version from the versioned payload (memory reference).\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getVersionFromMemory(bytes memory versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            // We add 0x20 to skip the length of the bytes array.\n            version := shr(240, mload(add(versionedPayload, 0x20)))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (memory reference).\n    /// @dev The extracted payload is copied into a new memory location. Use `getPayload` when possible\n    /// to avoid extra memory allocation.\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getPayloadFromMemory(bytes memory versionedPayload) internal view returns (bytes memory payload) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        // Figure how many bytes to copy and allocate the memory for the extracted payload.\n        uint256 toCopy;\n        unchecked {\n            toCopy = versionedPayload.length - VERSION_LENGTH;\n        }\n        payload = new bytes(toCopy);\n        // Use identity precompile (0x04) to copy the payload. Unlike MCOPY, this is available on all EVM chains.\n        bool res;\n        assembly {\n            // We add 0x20 to skip the length of the bytes array.\n            // We add 0x02 to skip the 2 bytes reserved for the version.\n            // Copy the payload to the previously allocated memory.\n            res := staticcall(gas(), 0x04, add(versionedPayload, 0x22), toCopy, add(payload, 0x20), toCopy)\n        }\n        if (!res) {\n            revert VersionedPayload__PrecompileFailed();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SafeCast.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value \u003e type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value \u003e type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value \u003e type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value \u003e type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value \u003e type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value \u003e type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value \u003e type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value \u003e type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value \u003e type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value \u003e type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value \u003e type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value \u003e type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value \u003e type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value \u003e type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value \u003e type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value \u003e type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value \u003e type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value \u003e type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value \u003e type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value \u003e type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value \u003e type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value \u003e type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value \u003e type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value \u003e type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value \u003e type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value \u003e type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value \u003e type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value \u003e type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value \u003e type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value \u003e type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value \u003e type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value \u003c 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value \u003e uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal view returns (AppConfigV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (AppConfigV1));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal view returns (OptionsV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (OptionsV1));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(OPTIONS_V1, abi.encode(options));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/libs/InterchainBatch.sol\n\ntype BatchKey is uint128;\n\n/// @notice Struct representing a batch of entries in the Interchain DataBase.\n/// Batched entries are put together in a Merkle tree, which root is saved.\n/// Batch has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: batchRoot\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch\n/// @param batchRoot    The root of the Merkle tree containing the batched entries\nstruct InterchainBatch {\n    uint64 srcChainId;\n    uint64 dbNonce;\n    bytes32 batchRoot;\n}\n\nlibrary InterchainBatchLib {\n    using VersionedPayloadLib for bytes;\n\n    /// @notice Constructs an InterchainBatch struct to be saved on the local chain.\n    /// @param dbNonce      The database nonce of the batch\n    /// @param batchRoot    The root of the Merkle tree containing the batched entries\n    /// @return batch       The constructed InterchainBatch struct\n    function constructLocalBatch(\n        uint64 dbNonce,\n        bytes32 batchRoot\n    )\n        internal\n        view\n        returns (InterchainBatch memory batch)\n    {\n        return InterchainBatch({srcChainId: SafeCast.toUint64(block.chainid), dbNonce: dbNonce, batchRoot: batchRoot});\n    }\n\n    /// @notice Encodes the InterchainBatch struct into a non-versioned batch payload.\n    function encodeBatch(InterchainBatch memory batch) internal pure returns (bytes memory) {\n        return abi.encode(encodeBatchKey(batch.srcChainId, batch.dbNonce), batch.batchRoot);\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in calldata.\n    function decodeBatch(bytes calldata data) internal pure returns (InterchainBatch memory batch) {\n        BatchKey key;\n        (key, batch.batchRoot) = abi.decode(data, (BatchKey, bytes32));\n        (batch.srcChainId, batch.dbNonce) = decodeBatchKey(key);\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in memory.\n    function decodeBatchFromMemory(bytes memory data) internal pure returns (InterchainBatch memory batch) {\n        BatchKey key;\n        (key, batch.batchRoot) = abi.decode(data, (BatchKey, bytes32));\n        (batch.srcChainId, batch.dbNonce) = decodeBatchKey(key);\n    }\n\n    /// @notice Encodes the uint128 key of the batch from uint64 srcChainId and uint64 dbNonce.\n    function encodeBatchKey(uint64 srcChainId, uint64 dbNonce) internal pure returns (BatchKey) {\n        return BatchKey.wrap((uint128(srcChainId) \u003c\u003c 64) | dbNonce);\n    }\n\n    /// @notice Decodes the uint128 key of the batch into uint64 srcChainId and uint64 dbNonce.\n    function decodeBatchKey(BatchKey key) internal pure returns (uint64 srcChainId, uint64 dbNonce) {\n        srcChainId = uint64(BatchKey.unwrap(key) \u003e\u003e 64);\n        dbNonce = uint64(BatchKey.unwrap(key));\n    }\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce + entryIndex\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch containing the entry\n/// @param entryIndex   The index of the entry in the batch\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint64 srcChainId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nusing InterchainEntryLib for InterchainEntry global;\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint64 dbNonce,\n        uint64 entryIndex,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: SafeCast.toUint64(block.chainid),\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n}\n\n// contracts/libs/InterchainTransaction.sol\n\ntype ICTxHeader is uint256;\n\nstruct InterchainTransaction {\n    uint64 srcChainId;\n    uint64 dstChainId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcSender;\n    bytes32 dstReceiver;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    using MathLib for uint256;\n    using VersionedPayloadLib for bytes;\n\n    function constructLocalTransaction(\n        address srcSender,\n        uint64 dstChainId,\n        bytes32 dstReceiver,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: SafeCast.toUint64(block.chainid),\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            encodeTxHeader(transaction.srcChainId, transaction.dstChainId, transaction.dbNonce, transaction.entryIndex),\n            transaction.srcSender,\n            transaction.dstReceiver,\n            transaction.options,\n            transaction.message\n        );\n    }\n\n    function decodeTransaction(bytes calldata transaction) internal pure returns (InterchainTransaction memory icTx) {\n        ICTxHeader header;\n        (header, icTx.srcSender, icTx.dstReceiver, icTx.options, icTx.message) =\n            abi.decode(transaction, (ICTxHeader, bytes32, bytes32, bytes, bytes));\n        (icTx.srcChainId, icTx.dstChainId, icTx.dbNonce, icTx.entryIndex) = decodeTxHeader(header);\n    }\n\n    function payloadSize(uint256 optionsLen, uint256 messageLen) internal pure returns (uint256) {\n        // 2 bytes are reserved for the transaction version\n        // + 5 fields * 32 bytes (3 values for static, 2 offsets for dynamic) + 2 * 32 bytes (lengths for dynamic) = 226\n        // (srcChainId, dstChainId, dbNonce, entryIndex) are merged into a single 32 bytes field\n        // Both options and message are dynamic fields, which are padded up to 32 bytes\n        return 226 + optionsLen.roundUpToWord() + messageLen.roundUpToWord();\n    }\n\n    function encodeTxHeader(\n        uint64 srcChainId,\n        uint64 dstChainId,\n        uint64 dbNonce,\n        uint64 entryIndex\n    )\n        internal\n        pure\n        returns (ICTxHeader)\n    {\n        return ICTxHeader.wrap(\n            (uint256(srcChainId) \u003c\u003c 192) | (uint256(dstChainId) \u003c\u003c 128) | (uint256(dbNonce) \u003c\u003c 64) | uint256(entryIndex)\n        );\n    }\n\n    function decodeTxHeader(ICTxHeader header)\n        internal\n        pure\n        returns (uint64 srcChainId, uint64 dstChainId, uint64 dbNonce, uint64 entryIndex)\n    {\n        srcChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 192);\n        dstChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 128);\n        dbNonce = uint64(ICTxHeader.unwrap(header) \u003e\u003e 64);\n        entryIndex = uint64(ICTxHeader.unwrap(header));\n    }\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint64 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__InvalidTransactionVersion(uint16 version);\n    error InterchainClientV1__NoLinkedClient(uint64 chainId);\n    error InterchainClientV1__NotEnoughGasSupplied();\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint64 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint64 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint64 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint64 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param messageLen           The length of the message being sent.\n    function getInterchainFee(\n        uint64 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        uint256 messageLen\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint64 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint64 chainId) external view returns (address);\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing a batch of entries from the remote Interchain DataBase,\n    /// verified by the Interchain Module.\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param batchRoot    The Merkle root of the batch\n    struct RemoteBatch {\n        uint256 verifiedAt;\n        bytes32 batchRoot;\n    }\n\n    error InterchainDB__BatchDoesNotExist(uint64 dbNonce);\n    error InterchainDB__BatchNotFinalized(uint64 dbNonce);\n    error InterchainDB__ConflictingBatches(address module, bytes32 existingBatchRoot, InterchainBatch newBatch);\n    error InterchainDB__EntryIndexOutOfRange(uint64 dbNonce, uint64 entryIndex, uint64 batchSize);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__InvalidBatchVersion(uint16 version);\n    error InterchainDB__InvalidEntryRange(uint64 dbNonce, uint64 start, uint64 end);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId(uint64 chainId);\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `requestBatchVerification` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntry(bytes32 dataHash) external returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Request the given Interchain Modules to verify an existing batch.\n    /// If the batch is not finalized, the module will verify it after finalization.\n    /// For the finalized batch the batch root is already available, and the module can verify it immediately.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any batch.\n    /// @dev Will revert if the batch with the given nonce does not exist.\n    /// @param dstChainId    The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the existing batch\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestBatchVerification(\n        uint64 dstChainId,\n        uint64 dbNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Then request the Interchain Modules to verify the batch containing the written entry on the destination chain.\n    /// See `writeEntry` and `requestBatchVerification` for more details.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntryWithVerification(\n        uint64 dstChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Allows the Interchain Module to verify the batch coming from the remote chain.\n    /// Note: The DB will only accept the batch of the same version as the DB itself.\n    /// @param versionedBatch   The versioned Interchain Batch to verify\n    function verifyRemoteBatch(bytes memory versionedBatch) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint64 dstChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce.\n    /// Note: the leafs are ordered by the index of the written entry in the current batch,\n    /// and the leafs value match the value of the written entry (srcWriter + dataHash hashed together).\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchLeafs(uint64 dbNonce) external view returns (bytes32[] memory);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce,\n    /// paginated by the given start and end indexes. The end index is exclusive.\n    /// Note: this is useful when the batch contains a large number of leafs, and calling `getBatchLeafs`\n    /// would result in a gas limit exceeded error.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the provided range is invalid.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param start        The start index of the paginated leafs, inclusive\n    /// @param end          The end index of the paginated leafs, exclusive\n    function getBatchLeafsPaginated(\n        uint64 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory);\n\n    /// @notice Returns the size of the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchSize(uint64 dbNonce) external view returns (uint64);\n\n    /// @notice Get the finalized Interchain Batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatch(uint64 dbNonce) external view returns (InterchainBatch memory);\n\n    /// @notice Get the Interchain Entry's value written on the local chain with the given batch nonce and entry index.\n    /// Entry value is calculated as the hash of the writer address and the written data hash.\n    /// Note: the batch does not have to be finalized to fetch the entry value.\n    /// @dev Will revert if the batch with the given nonce does not exist,\n    /// or the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the existing batch\n    /// @param entryIndex   The index of the written entry within the batch\n    function getEntryValue(uint64 dbNonce, uint64 entryIndex) external view returns (bytes32);\n\n    /// @notice Get the Merkle proof of inclusion for the entry with the given index\n    /// in the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param entryIndex   The index of the written entry within the batch\n    /// @return proof       The Merkle proof of inclusion for the entry\n    function getEntryProof(uint64 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof);\n\n    /// @notice Get the nonce of the database, which is incremented every time a new batch is finalized.\n    /// This is the nonce of the current non-finalized batch.\n    function getDBNonce() external view returns (uint64);\n\n    /// @notice Get the index of the next entry to be written to the database.\n    /// @return dbNonce      The database nonce of the batch including the next entry\n    /// @return entryIndex   The index of the next entry within that batch\n    function getNextEntryIndex() external view returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or ZERO if the module has not verified the entry.\n    function checkVerification(\n        address dstModule,\n        InterchainEntry memory entry,\n        bytes32[] memory proof\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n\n    /// @notice Get the version of the Interchain DataBase.\n    // solhint-disable-next-line func-name-mixedcase\n    function DB_VERSION() external pure returns (uint16);\n}\n\n// contracts/InterchainClientV1.sol\n\n/**\n * @title InterchainClientV1\n * @dev Implements the operations of the Interchain Execution Layer.\n */\ncontract InterchainClientV1 is Ownable, InterchainClientV1Events, IInterchainClientV1 {\n    using AppConfigLib for bytes;\n    using OptionsLib for bytes;\n    using VersionedPayloadLib for bytes;\n\n    /// @notice Version of the InterchainClient contract. Sent and received transactions must have the same version.\n    uint16 public constant CLIENT_VERSION = 1;\n\n    /// @notice Address of the InterchainDB contract, set at the time of deployment.\n    address public immutable INTERCHAIN_DB;\n\n    /// @notice Address of the contract that handles execution fees. Can be updated by the owner.\n    address public executionFees;\n\n    /// @dev Address of the InterchainClient contract on the remote chain\n    mapping(uint64 chainId =\u003e bytes32 remoteClient) internal _linkedClient;\n    /// @dev Executor address that completed the transaction. Address(0) if not executed yet.\n    mapping(bytes32 transactionId =\u003e address executor) internal _txExecutor;\n\n    constructor(address interchainDB, address owner_) Ownable(owner_) {\n        INTERCHAIN_DB = interchainDB;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function setExecutionFees(address executionFees_) external onlyOwner {\n        executionFees = executionFees_;\n        emit ExecutionFeesSet(executionFees_);\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function setLinkedClient(uint64 chainId, bytes32 client) external onlyOwner {\n        _linkedClient[chainId] = client;\n        emit LinkedClientSet(chainId, client);\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _interchainSend(dstChainId, receiver, srcExecutionService, srcModules, options, message);\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function interchainSendEVM(\n        uint64 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc)\n    {\n        bytes32 receiverBytes32 = TypeCasts.addressToBytes32(receiver);\n        return _interchainSend(dstChainId, receiverBytes32, srcExecutionService, srcModules, options, message);\n    }\n\n    // TODO: Handle the case where receiver does not implement the IInterchainApp interface (or does not exist at all)\n    // @inheritdoc IInterchainClientV1\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable\n    {\n        InterchainTransaction memory icTx = _assertCorrectVersion(transaction);\n        bytes32 transactionId = keccak256(transaction);\n        _assertExecutable(icTx, transactionId, proof);\n        _txExecutor[transactionId] = msg.sender;\n\n        OptionsV1 memory decodedOptions = icTx.options.decodeOptionsV1();\n        if (msg.value != decodedOptions.gasAirdrop) {\n            revert InterchainClientV1__IncorrectMsgValue(msg.value, decodedOptions.gasAirdrop);\n        }\n        // We should always use at least as much as the requested gas limit.\n        // The executor can specify a higher gas limit if they wanted.\n        if (decodedOptions.gasLimit \u003e gasLimit) gasLimit = decodedOptions.gasLimit;\n        // Check the the Executor has provided big enough gas limit for the whole transaction.\n        if (gasleft() \u003c= gasLimit) {\n            revert InterchainClientV1__NotEnoughGasSupplied();\n        }\n        // Pass the full msg.value to the app: we have already checked that it matches the requested gas airdrop.\n        IInterchainApp(TypeCasts.bytes32ToAddress(icTx.dstReceiver)).appReceive{gas: gasLimit, value: msg.value}({\n            srcChainId: icTx.srcChainId,\n            sender: icTx.srcSender,\n            dbNonce: icTx.dbNonce,\n            entryIndex: icTx.entryIndex,\n            message: icTx.message\n        });\n        emit InterchainTransactionReceived(\n            transactionId, icTx.dbNonce, icTx.entryIndex, icTx.srcChainId, icTx.srcSender, icTx.dstReceiver\n        );\n    }\n\n    /// @inheritdoc IInterchainClientV1\n    function writeExecutionProof(bytes32 transactionId) external returns (uint64 dbNonce, uint64 entryIndex) {\n        address executor = _txExecutor[transactionId];\n        if (executor == address(0)) {\n            revert InterchainClientV1__TxNotExecuted(transactionId);\n        }\n        bytes memory proof = abi.encode(transactionId, executor);\n        (dbNonce, entryIndex) = IInterchainDB(INTERCHAIN_DB).writeEntry(keccak256(proof));\n        emit ExecutionProofWritten(transactionId, dbNonce, entryIndex, executor);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // @inheritdoc IInterchainClientV1\n    function isExecutable(bytes calldata encodedTx, bytes32[] calldata proof) external view returns (bool) {\n        InterchainTransaction memory icTx = _assertCorrectVersion(encodedTx);\n        // Check that options could be decoded\n        icTx.options.decodeOptionsV1();\n        bytes32 transactionId = keccak256(encodedTx);\n        _assertExecutable(icTx, transactionId, proof);\n        return true;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function getExecutor(bytes calldata encodedTx) external view returns (address) {\n        return _txExecutor[keccak256(encodedTx)];\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function getExecutorById(bytes32 transactionId) external view returns (address) {\n        return _txExecutor[transactionId];\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function getInterchainFee(\n        uint64 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        uint256 messageLen\n    )\n        external\n        view\n        returns (uint256 fee)\n    {\n        _assertLinkedClient(dstChainId);\n        // Check that options could be decoded on destination chain\n        options.decodeOptionsV1();\n        // Verification fee from InterchainDB\n        fee = IInterchainDB(INTERCHAIN_DB).getInterchainFee(dstChainId, srcModules);\n        // Add execution fee, if ExecutionService is provided\n        if (srcExecutionService != address(0)) {\n            uint256 payloadSize = InterchainTransactionLib.payloadSize(options.length, messageLen);\n            fee += IExecutionService(srcExecutionService).getExecutionFee(dstChainId, payloadSize, options);\n        }\n    }\n\n    /// @inheritdoc IInterchainClientV1\n    function getLinkedClient(uint64 chainId) external view returns (bytes32) {\n        if (chainId == block.chainid) {\n            revert InterchainClientV1__NotRemoteChainId(chainId);\n        }\n        return _linkedClient[chainId];\n    }\n\n    /// @inheritdoc IInterchainClientV1\n    function getLinkedClientEVM(uint64 chainId) external view returns (address linkedClientEVM) {\n        if (chainId == block.chainid) {\n            revert InterchainClientV1__NotRemoteChainId(chainId);\n        }\n        bytes32 linkedClient = _linkedClient[chainId];\n        linkedClientEVM = TypeCasts.bytes32ToAddress(linkedClient);\n        // Check that the linked client address fits into the EVM address space\n        if (TypeCasts.addressToBytes32(linkedClientEVM) != linkedClient) {\n            revert InterchainClientV1__NotEVMClient(linkedClient);\n        }\n    }\n\n    /// @notice Decodes the encoded options data into a OptionsV1 struct.\n    function decodeOptions(bytes memory encodedOptions) external view returns (OptionsV1 memory) {\n        return encodedOptions.decodeOptionsV1();\n    }\n\n    /// @notice Encodes the transaction data into a bytes format.\n    function encodeTransaction(InterchainTransaction memory icTx) public pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload({\n            version: CLIENT_VERSION,\n            payload: InterchainTransactionLib.encodeTransaction(icTx)\n        });\n    }\n\n    // ═════════════════════════════════════════════════ INTERNAL ══════════════════════════════════════════════════════\n\n    /// @dev Internal logic for sending a message to another chain.\n    function _interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        _assertLinkedClient(dstChainId);\n        if (receiver == 0) revert InterchainClientV1__ZeroReceiver();\n        // Check that options could be decoded on destination chain\n        options.decodeOptionsV1();\n        uint256 verificationFee = IInterchainDB(INTERCHAIN_DB).getInterchainFee(dstChainId, srcModules);\n        if (msg.value \u003c verificationFee) {\n            revert InterchainClientV1__FeeAmountTooLow(msg.value, verificationFee);\n        }\n        (desc.dbNonce, desc.entryIndex) = IInterchainDB(INTERCHAIN_DB).getNextEntryIndex();\n        InterchainTransaction memory icTx = InterchainTransactionLib.constructLocalTransaction({\n            srcSender: msg.sender,\n            dstReceiver: receiver,\n            dstChainId: dstChainId,\n            dbNonce: desc.dbNonce,\n            entryIndex: desc.entryIndex,\n            options: options,\n            message: message\n        });\n        desc.transactionId = keccak256(encodeTransaction(icTx));\n        // Sanity check: nonce returned from DB should match the nonce used to construct the transaction\n        {\n            (uint64 dbNonce, uint64 entryIndex) = IInterchainDB(INTERCHAIN_DB).writeEntryWithVerification{\n                value: verificationFee\n            }(icTx.dstChainId, desc.transactionId, srcModules);\n            assert(dbNonce == desc.dbNonce \u0026\u0026 entryIndex == desc.entryIndex);\n        }\n        uint256 executionFee;\n        unchecked {\n            executionFee = msg.value - verificationFee;\n        }\n        if (executionFee \u003e 0) {\n            IExecutionFees(executionFees).addExecutionFee{value: executionFee}(icTx.dstChainId, desc.transactionId);\n        }\n        // TODO: consider disallowing the use of empty srcExecutionService\n        if (srcExecutionService != address(0)) {\n            IExecutionService(srcExecutionService).requestExecution({\n                dstChainId: dstChainId,\n                txPayloadSize: InterchainTransactionLib.payloadSize(options.length, message.length),\n                transactionId: desc.transactionId,\n                executionFee: executionFee,\n                options: options\n            });\n            address srcExecutorEOA = IExecutionService(srcExecutionService).executorEOA();\n            IExecutionFees(executionFees).recordExecutor(icTx.dstChainId, desc.transactionId, srcExecutorEOA);\n        }\n        emit InterchainTransactionSent(\n            desc.transactionId,\n            icTx.dbNonce,\n            icTx.entryIndex,\n            icTx.dstChainId,\n            icTx.srcSender,\n            icTx.dstReceiver,\n            verificationFee,\n            executionFee,\n            icTx.options,\n            icTx.message\n        );\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Asserts that the transaction is executable.\n    function _assertExecutable(\n        InterchainTransaction memory icTx,\n        bytes32 transactionId,\n        bytes32[] calldata proof\n    )\n        internal\n        view\n    {\n        bytes32 linkedClient = _assertLinkedClient(icTx.srcChainId);\n        if (icTx.dstChainId != block.chainid) {\n            revert InterchainClientV1__IncorrectDstChainId(icTx.dstChainId);\n        }\n        if (_txExecutor[transactionId] != address(0)) {\n            revert InterchainClientV1__TxAlreadyExecuted(transactionId);\n        }\n        // Construct expected entry based on icTransaction data\n        InterchainEntry memory icEntry = InterchainEntry({\n            srcChainId: icTx.srcChainId,\n            dbNonce: icTx.dbNonce,\n            entryIndex: icTx.entryIndex,\n            srcWriter: linkedClient,\n            dataHash: transactionId\n        });\n        (bytes memory encodedAppConfig, address[] memory approvedDstModules) =\n            IInterchainApp(TypeCasts.bytes32ToAddress(icTx.dstReceiver)).getReceivingConfig();\n        AppConfigV1 memory appConfig = encodedAppConfig.decodeAppConfigV1();\n        if (appConfig.requiredResponses == 0) {\n            revert InterchainClientV1__ZeroRequiredResponses();\n        }\n        uint256 responses = _getFinalizedResponsesCount(approvedDstModules, icEntry, proof, appConfig.optimisticPeriod);\n        if (responses \u003c appConfig.requiredResponses) {\n            revert InterchainClientV1__NotEnoughResponses(responses, appConfig.requiredResponses);\n        }\n    }\n\n    /// @dev Asserts that the chain is linked and returns the linked client address.\n    function _assertLinkedClient(uint64 chainId) internal view returns (bytes32 linkedClient) {\n        if (chainId == block.chainid) {\n            revert InterchainClientV1__NotRemoteChainId(chainId);\n        }\n        linkedClient = _linkedClient[chainId];\n        if (linkedClient == 0) {\n            revert InterchainClientV1__NoLinkedClient(chainId);\n        }\n    }\n\n    /**\n     * @dev Calculates the number of responses that are considered finalized within the optimistic time period.\n     * @param approvedModules       Approved modules that could have confirmed the entry.\n     * @param icEntry               The InterchainEntry to confirm.\n     * @param optimisticPeriod      The time period in seconds within which a response is considered valid.\n     * @return finalizedResponses   The count of responses that are finalized within the optimistic time period.\n     */\n    function _getFinalizedResponsesCount(\n        address[] memory approvedModules,\n        InterchainEntry memory icEntry,\n        bytes32[] calldata proof,\n        uint256 optimisticPeriod\n    )\n        internal\n        view\n        returns (uint256 finalizedResponses)\n    {\n        for (uint256 i = 0; i \u003c approvedModules.length; ++i) {\n            uint256 confirmedAt = IInterchainDB(INTERCHAIN_DB).checkVerification(approvedModules[i], icEntry, proof);\n            // checkVerification() returns 0 if entry hasn't been confirmed by the module, so we check for that as well\n            if (confirmedAt != 0 \u0026\u0026 confirmedAt + optimisticPeriod \u003c block.timestamp) {\n                ++finalizedResponses;\n            }\n        }\n    }\n\n    /// @dev Asserts that the transaction version is correct. Returns the decoded transaction for chaining purposes.\n    function _assertCorrectVersion(bytes calldata versionedTx)\n        internal\n        pure\n        returns (InterchainTransaction memory icTx)\n    {\n        uint16 version = versionedTx.getVersion();\n        if (version != CLIENT_VERSION) {\n            revert InterchainClientV1__InvalidTransactionVersion(version);\n        }\n        icTx = InterchainTransactionLib.decodeTransaction(versionedTx.getPayload());\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"55297:2269:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;55297:2269:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"55297:2269:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainClientV1.sol\":\"InterchainBatchLib\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainClientV1.sol\":{\"keccak256\":\"0xe270686a9bca05b4013610a4e8bb08040de32a0442edd218e1692edaca94e40e\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://727e84146369613e04e57a677f8bc6c709ee145df3eeb79f15ea5a922198d78f\",\"dweb:/ipfs/QmUXh2nDtHBnhYZSwCxcteN4be13S7dR9GbqqHT9mUxta3\"]}},\"version\":1}"},"hashes":{}},"solidity/InterchainClientV1.sol:InterchainClientV1":{"code":"0x60a06040523480156200001157600080fd5b5060405162002fed38038062002fed8339810160408190526200003491620000f0565b806001600160a01b0381166200006457604051631e4fbdf760e01b81526000600482015260240160405180910390fd5b6200006f8162000083565b50506001600160a01b031660805262000128565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b80516001600160a01b0381168114620000eb57600080fd5b919050565b600080604083850312156200010457600080fd5b6200010f83620000d3565b91506200011f60208401620000d3565b90509250929050565b608051612e7f6200016e6000396000818161040b01528181610a9d01528181610c0f01528181611354015281816114150152818161158e0152611ed60152612e7f6000f3fe60806040526004361061015f5760003560e01c80638654ddd4116100c0578063e4c6124711610074578063f2fde38b11610059578063f2fde38b14610470578063f3c66e2b14610490578063f92a79ff146104b057600080fd5b8063e4c61247146103f9578063f1a61fac1461042d57600080fd5b806390e81077116100a557806390e810771461035d578063cbb3c6311461039e578063d5e788a0146103be57600080fd5b80638654ddd4146103055780638da5cb5b1461033257600080fd5b806353b67d7411610117578063715018a6116100fc578063715018a61461029b5780637341eaf9146102b05780637813cd52146102dd57600080fd5b806353b67d7414610275578063547efb841461028857600080fd5b806335c4a1911161014857806335c4a191146101c75780633dc68b871461020c5780633f34448e1461022e57600080fd5b80631450c281146101645780632e56873914610199575b600080fd5b34801561017057600080fd5b5061018461017f366004612183565b6104d0565b60405190151581526020015b60405180910390f35b3480156101a557600080fd5b506101b96101b4366004612210565b610522565b604051908152602001610190565b3480156101d357600080fd5b506101e76101e2366004612210565b610595565b60405173ffffffffffffffffffffffffffffffffffffffff9091168152602001610190565b34801561021857600080fd5b5061022c61022736600461224f565b61065a565b005b61024161023c36600461226c565b6106db565b604080518251815260208084015167ffffffffffffffff908116918301919091529282015190921690820152606001610190565b61022c610283366004612340565b61072f565b6102416102963660046123ba565b610959565b3480156102a757600080fd5b5061022c610995565b3480156102bc57600080fd5b506001546101e79073ffffffffffffffffffffffffffffffffffffffff1681565b3480156102e957600080fd5b506102f2600181565b60405161ffff9091168152602001610190565b34801561031157600080fd5b50610325610320366004612502565b6109a9565b604051610190919061263c565b34801561033e57600080fd5b5060005473ffffffffffffffffffffffffffffffffffffffff166101e7565b34801561036957600080fd5b5061037d61037836600461264f565b6109c4565b6040805167ffffffffffffffff938416815292909116602083015201610190565b3480156103aa57600080fd5b506101b96103b9366004612668565b610b86565b3480156103ca57600080fd5b506103de6103d9366004612706565b610d68565b60408051825181526020928301519281019290925201610190565b34801561040557600080fd5b506101e77f000000000000000000000000000000000000000000000000000000000000000081565b34801561043957600080fd5b506101e761044836600461264f565b60009081526003602052604090205473ffffffffffffffffffffffffffffffffffffffff1690565b34801561047c57600080fd5b5061022c61048b36600461224f565b610d85565b34801561049c57600080fd5b5061022c6104ab36600461273b565b610de9565b3480156104bc57600080fd5b506101e76104cb366004612767565b610e4a565b6000806104dd8686610e97565b90506104ec8160c00151610f41565b50600086866040516104ff9291906127a9565b6040518091039020905061051582828787610fca565b5060019695505050505050565b6000468267ffffffffffffffff1603610578576040517f3da4f44e00000000000000000000000000000000000000000000000000000000815267ffffffffffffffff831660048201526024015b60405180910390fd5b5067ffffffffffffffff1660009081526002602052604090205490565b6000468267ffffffffffffffff16036105e6576040517f3da4f44e00000000000000000000000000000000000000000000000000000000815267ffffffffffffffff8316600482015260240161056f565b5067ffffffffffffffff81166000908152600260205260409020548073ffffffffffffffffffffffffffffffffffffffff81168114610654576040517f0a55a4eb0000000000000000000000000000000000000000000000000000000081526004810182905260240161056f565b50919050565b61066261121f565b600180547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff83169081179091556040519081527fec02f15d78cdfc4beeba45f31cfad25089004e5e3d72727168dd96a77d1f2f829060200160405180910390a150565b604080516060810182526000808252602082018190529181019190915273ffffffffffffffffffffffffffffffffffffffff89166107208b828b8b8b8b8b8b8b611272565b9b9a5050505050505050505050565b600061073b8585610e97565b90506000858560405161074f9291906127a9565b6040518091039020905061076582828686610fca565b600081815260036020526040812080547fffffffffffffffffffffffff0000000000000000000000000000000000000000163317905560c08301516107a990610f41565b9050806020015134146107f75760208101516040517f2b361025000000000000000000000000000000000000000000000000000000008152346004820152602481019190915260440161056f565b805188101561080557805197505b875a1161083e576040517fe9b8315600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60a083015173ffffffffffffffffffffffffffffffffffffffff16636e9fd609893486600001518760800151886040015189606001518a60e001516040518863ffffffff1660e01b81526004016108999594939291906127b9565b6000604051808303818589803b1580156108b257600080fd5b5088f11580156108c6573d6000803e3d6000fd5b505050505050826060015167ffffffffffffffff16836040015167ffffffffffffffff16837f589f737f4049c62fcbcd8274eeacc86e17d29c6621f36e698bcc4c90525ce28f866000015187608001518860a001516040516109479392919067ffffffffffffffff9390931683526020830191909152604082015260600190565b60405180910390a45050505050505050565b60408051606081018252600080825260208201819052918101919091526109878a8a8a8a8a8a8a8a8a611272565b9a9950505050505050505050565b61099d61121f565b6109a76000611987565b565b60606109be60016109b9846119fc565b611ac6565b92915050565b600081815260036020526040812054819073ffffffffffffffffffffffffffffffffffffffff1680610a25576040517fe99eb48d0000000000000000000000000000000000000000000000000000000081526004810185905260240161056f565b60008482604051602001610a5992919091825273ffffffffffffffffffffffffffffffffffffffff16602082015260400190565b60408051808303601f1901815290829052805160208201207f2ad8c706000000000000000000000000000000000000000000000000000000008352600483015291507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1690632ad8c7069060240160408051808303816000875af1158015610afa573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b1e91906127f4565b60405173ffffffffffffffffffffffffffffffffffffffff85168152919550935067ffffffffffffffff808516919086169087907f1c45fee34c18589980aa86a2b9910fac2a0be9beca86376b6d93fa4ce7f010ae9060200160405180910390a45050915091565b6000610b9188611af2565b50610bd184848080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250610f4192505050565b506040517fb8ba4ba100000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000169063b8ba4ba190610c48908b908a908a90600401612884565b602060405180830381865afa158015610c65573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c8991906128b1565b905073ffffffffffffffffffffffffffffffffffffffff871615610d5d576000610cb38484611ba9565b6040517f96fda4da00000000000000000000000000000000000000000000000000000000815290915073ffffffffffffffffffffffffffffffffffffffff8916906396fda4da90610d0e908c9085908a908a906004016128f5565b602060405180830381865afa158015610d2b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d4f91906128b1565b610d599083612958565b9150505b979650505050505050565b60408051808201909152600080825260208201526109be82610f41565b610d8d61121f565b73ffffffffffffffffffffffffffffffffffffffff8116610ddd576040517f1e4fbdf70000000000000000000000000000000000000000000000000000000081526000600482015260240161056f565b610de681611987565b50565b610df161121f565b67ffffffffffffffff8216600081815260026020908152604091829020849055815192835282018390527ffdc2498138df0de25c8fc9bd75bb8e856dac69aaf28d3dd5e0fc48e5e9f6e93f910160405180910390a15050565b6000600360008484604051610e609291906127a9565b604080519182900390912082526020820192909252016000205473ffffffffffffffffffffffffffffffffffffffff169392505050565b604080516101008101825260008082526020820181905291810182905260608082018390526080820183905260a0820183905260c0820181905260e082015290610ee18484611bd0565b905061ffff8116600114610f27576040517f0fda659b00000000000000000000000000000000000000000000000000000000815261ffff8216600482015260240161056f565b610f39610f348585611c1a565b611c75565b949350505050565b60408051808201909152600080825260208201526000610f6083611d1a565b9050600161ffff82161015610fa7576040517fb94fa72500000000000000000000000000000000000000000000000000000000815261ffff8216600482015260240161056f565b610fb083611d65565b806020019051810190610fc391906129ba565b9392505050565b6000610fd98560000151611af2565b905046856020015167ffffffffffffffff16146110345760208501516040517f28dcee4300000000000000000000000000000000000000000000000000000000815267ffffffffffffffff909116600482015260240161056f565b60008481526003602052604090205473ffffffffffffffffffffffffffffffffffffffff1615611093576040517fd80aeb910000000000000000000000000000000000000000000000000000000081526004810185905260240161056f565b60006040518060a00160405280876000015167ffffffffffffffff168152602001876040015167ffffffffffffffff168152602001876060015167ffffffffffffffff1681526020018381526020018681525090506000806110f68860a0015190565b73ffffffffffffffffffffffffffffffffffffffff1663287bc0576040518163ffffffff1660e01b8152600401600060405180830381865afa158015611140573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405261116891908101906129d6565b91509150600061117783611e5f565b80519091506000036111b5576040517fa09e214300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60006111c883868a8a8660200151611ec5565b82519091508110156112135781516040517f0bce4e8500000000000000000000000000000000000000000000000000000000815261056f918391600401918252602082015260400190565b50505050505050505050565b60005473ffffffffffffffffffffffffffffffffffffffff1633146109a7576040517f118cdaa700000000000000000000000000000000000000000000000000000000815233600482015260240161056f565b60408051606081018252600080825260208201819052918101919091526112988a611af2565b5060008990036112d4576040517f0b3e41a600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b61131385858080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250610f4192505050565b506040517fb8ba4ba100000000000000000000000000000000000000000000000000000000815260009073ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000169063b8ba4ba19061138d908e908c908c90600401612884565b602060405180830381865afa1580156113aa573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113ce91906128b1565b905080341015611413576040517f9557ee490000000000000000000000000000000000000000000000000000000081523460048201526024810182905260440161056f565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663aa2f06ae6040518163ffffffff1660e01b81526004016040805180830381865afa15801561147d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906114a191906127f4565b83602001846040018267ffffffffffffffff1667ffffffffffffffff168152508267ffffffffffffffff1667ffffffffffffffff168152505050600061156e338d8d866020015187604001518c8c8080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f820116905080830192505050505050508b8b8080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250611fd292505050565b9050611579816109a9565b805190602001208360000181815250506000807f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663eb20fbfd85856020015188600001518f8f6040518663ffffffff1660e01b81526004016115f49493929190612aeb565b604080518083038185885af1158015611611573d6000803e3d6000fd5b50505050506040513d601f19601f8201168201806040525081019061163691906127f4565b91509150846020015167ffffffffffffffff168267ffffffffffffffff161480156116785750846040015167ffffffffffffffff168167ffffffffffffffff16145b61168457611684612b15565b50503482810390831461172e57600154602083015185516040517f7b18c25c00000000000000000000000000000000000000000000000000000000815267ffffffffffffffff9092166004830152602482015273ffffffffffffffffffffffffffffffffffffffff90911690637b18c25c9083906044016000604051808303818588803b15801561171457600080fd5b505af1158015611728573d6000803e3d6000fd5b50505050505b73ffffffffffffffffffffffffffffffffffffffff8b16156118fd5773ffffffffffffffffffffffffffffffffffffffff8b1663592a87998e6117718a89611ba9565b87516040517fffffffff0000000000000000000000000000000000000000000000000000000060e086901b1681526117b49392919087908f908f90600401612b44565b600060405180830381600087803b1580156117ce57600080fd5b505af11580156117e2573d6000803e3d6000fd5b5050505060008b73ffffffffffffffffffffffffffffffffffffffff166362014bad6040518163ffffffff1660e01b8152600401602060405180830381865afa158015611833573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906118579190612b86565b600154602085015187516040517ffd411b4300000000000000000000000000000000000000000000000000000000815267ffffffffffffffff9092166004830152602482015273ffffffffffffffffffffffffffffffffffffffff808416604483015292935091169063fd411b4390606401600060405180830381600087803b1580156118e357600080fd5b505af11580156118f7573d6000803e3d6000fd5b50505050505b816060015167ffffffffffffffff16826040015167ffffffffffffffff1685600001517f73b3ea77e781779ca7d3bd994ecd1ad739e22cda0120925bbf4e30de70ebc7e8856020015186608001518760a0015189888a60c001518b60e0015160405161196f9796959493929190612ba3565b60405180910390a45050509998505050505050505050565b6000805473ffffffffffffffffffffffffffffffffffffffff8381167fffffffffffffffffffffffff0000000000000000000000000000000000000000831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6060611a8882600001518360200151846040015185606001517fffffffffffffffff00000000000000000000000000000000000000000000000060c085901b1677ffffffffffffffff00000000000000000000000000000000608085901b16176fffffffffffffffff0000000000000000604084901b161767ffffffffffffffff821617949350505050565b82608001518360a001518460c001518560e00151604051602001611ab0959493929190612bf0565b6040516020818303038152906040529050919050565b60608282604051602001611adb929190612c27565b604051602081830303815290604052905092915050565b6000468267ffffffffffffffff1603611b43576040517f3da4f44e00000000000000000000000000000000000000000000000000000000815267ffffffffffffffff8316600482015260240161056f565b5067ffffffffffffffff811660009081526002602052604081205490819003611ba4576040517f0dbcef6b00000000000000000000000000000000000000000000000000000000815267ffffffffffffffff8316600482015260240161056f565b919050565b6000601f19601f830116601f19601f850116611bc69060e2612958565b610fc39190612958565b60006002821015611c115782826040517f659cf9fa00000000000000000000000000000000000000000000000000000000815260040161056f929190612c72565b50503560f01c90565b3660006002831015611c5c5783836040517f659cf9fa00000000000000000000000000000000000000000000000000000000815260040161056f929190612c72565b611c698360028187612c86565b915091505b9250929050565b604080516101008101825260008082526020820181905291810182905260608082018390526080820183905260a0820183905260c0820181905260e082015290611cc184840185612cb0565b60e087015260c086015260a085015260808401529050611cef8160c081901c91608082901c91604081901c91565b67ffffffffffffffff9081166060870152908116604086015290811660208501521682525092915050565b6000600282511015611d5a57816040517f659cf9fa00000000000000000000000000000000000000000000000000000000815260040161056f919061263c565b506020015160f01c90565b6060600282511015611da557816040517f659cf9fa00000000000000000000000000000000000000000000000000000000815260040161056f919061263c565b81517ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe018067ffffffffffffffff811115611de257611de26123fa565b6040519080825280601f01601f191660200182016040528015611e0c576020820181803683370190505b50915060008160208401836022870160045afa905080611e58576040517f101e44fa00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5050919050565b60408051808201909152600080825260208201526000611e7e83611d1a565b9050600161ffff82161015610fa7576040517faac8bd2300000000000000000000000000000000000000000000000000000000815261ffff8216600482015260240161056f565b6000805b8651811015611fc85760007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16631e5df4c4898481518110611f2257611f22612d31565b60200260200101518989896040518563ffffffff1660e01b8152600401611f4c9493929190612d60565b602060405180830381865afa158015611f69573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611f8d91906128b1565b90508015801590611fa6575042611fa48583612958565b105b15611fb757611fb483612e11565b92505b50611fc181612e11565b9050611ec9565b5095945050505050565b604080516101008101825260008082526020820181905291810182905260608082018390526080820183905260a082019290925260c0810182905260e081019190915260405180610100016040528061202a466120a8565b67ffffffffffffffff1681526020018867ffffffffffffffff1681526020018667ffffffffffffffff1681526020018567ffffffffffffffff1681526020016120868a73ffffffffffffffffffffffffffffffffffffffff1690565b8152602001878152602001848152602001838152509050979650505050505050565b600067ffffffffffffffff8211156120f857604080517f6dfcc65000000000000000000000000000000000000000000000000000000000815260048101919091526024810183905260440161056f565b5090565b60008083601f84011261210e57600080fd5b50813567ffffffffffffffff81111561212657600080fd5b602083019150836020828501011115611c6e57600080fd5b60008083601f84011261215057600080fd5b50813567ffffffffffffffff81111561216857600080fd5b6020830191508360208260051b8501011115611c6e57600080fd5b6000806000806040858703121561219957600080fd5b843567ffffffffffffffff808211156121b157600080fd5b6121bd888389016120fc565b909650945060208701359150808211156121d657600080fd5b506121e38782880161213e565b95989497509550505050565b67ffffffffffffffff81168114610de657600080fd5b8035611ba4816121ef565b60006020828403121561222257600080fd5b8135610fc3816121ef565b73ffffffffffffffffffffffffffffffffffffffff81168114610de657600080fd5b60006020828403121561226157600080fd5b8135610fc38161222d565b600080600080600080600080600060c08a8c03121561228a57600080fd5b8935612295816121ef565b985060208a01356122a58161222d565b975060408a01356122b58161222d565b965060608a013567ffffffffffffffff808211156122d257600080fd5b6122de8d838e0161213e565b909850965060808c01359150808211156122f757600080fd5b6123038d838e016120fc565b909650945060a08c013591508082111561231c57600080fd5b506123298c828d016120fc565b915080935050809150509295985092959850929598565b60008060008060006060868803121561235857600080fd5b85359450602086013567ffffffffffffffff8082111561237757600080fd5b61238389838a016120fc565b9096509450604088013591508082111561239c57600080fd5b506123a98882890161213e565b969995985093965092949392505050565b600080600080600080600080600060c08a8c0312156123d857600080fd5b89356123e3816121ef565b985060208a0135975060408a01356122b58161222d565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b604051610100810167ffffffffffffffff8111828210171561244d5761244d6123fa565b60405290565b604051601f8201601f1916810167ffffffffffffffff8111828210171561247c5761247c6123fa565b604052919050565b600067ffffffffffffffff82111561249e5761249e6123fa565b50601f01601f191660200190565b600082601f8301126124bd57600080fd5b81356124d06124cb82612484565b612453565b8181528460208386010111156124e557600080fd5b816020850160208301376000918101602001919091529392505050565b60006020828403121561251457600080fd5b813567ffffffffffffffff8082111561252c57600080fd5b90830190610100828603121561254157600080fd5b612549612429565b61255283612205565b815261256060208401612205565b602082015261257160408401612205565b604082015261258260608401612205565b60608201526080830135608082015260a083013560a082015260c0830135828111156125ad57600080fd5b6125b9878286016124ac565b60c08301525060e0830135828111156125d157600080fd5b6125dd878286016124ac565b60e08301525095945050505050565b60005b838110156126075781810151838201526020016125ef565b50506000910152565b600081518084526126288160208601602086016125ec565b601f01601f19169290920160200192915050565b602081526000610fc36020830184612610565b60006020828403121561266157600080fd5b5035919050565b600080600080600080600060a0888a03121561268357600080fd5b873561268e816121ef565b9650602088013561269e8161222d565b9550604088013567ffffffffffffffff808211156126bb57600080fd5b6126c78b838c0161213e565b909750955060608a01359150808211156126e057600080fd5b506126ed8a828b016120fc565b989b979a50959894979596608090950135949350505050565b60006020828403121561271857600080fd5b813567ffffffffffffffff81111561272f57600080fd5b610f39848285016124ac565b6000806040838503121561274e57600080fd5b8235612759816121ef565b946020939093013593505050565b6000806020838503121561277a57600080fd5b823567ffffffffffffffff81111561279157600080fd5b61279d858286016120fc565b90969095509350505050565b8183823760009101908152919050565b600067ffffffffffffffff8088168352866020840152808616604084015280851660608401525060a06080830152610d5d60a0830184612610565b6000806040838503121561280757600080fd5b8251612812816121ef565b6020840151909250612823816121ef565b809150509250929050565b8183526000602080850194508260005b858110156128795781356128518161222d565b73ffffffffffffffffffffffffffffffffffffffff168752958201959082019060010161283e565b509495945050505050565b67ffffffffffffffff841681526040602082015260006128a860408301848661282e565b95945050505050565b6000602082840312156128c357600080fd5b5051919050565b818352818160208501375060006020828401015260006020601f19601f840116840101905092915050565b67ffffffffffffffff8516815283602082015260606040820152600061291f6060830184866128ca565b9695505050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b808201808211156109be576109be612929565b60006040828403121561297d57600080fd5b6040516040810181811067ffffffffffffffff821117156129a0576129a06123fa565b604052825181526020928301519281019290925250919050565b6000604082840312156129cc57600080fd5b610fc3838361296b565b600080604083850312156129e957600080fd5b825167ffffffffffffffff80821115612a0157600080fd5b818501915085601f830112612a1557600080fd5b81516020612a256124cb83612484565b8281528882848701011115612a3957600080fd5b612a48838383018488016125ec565b87820151909650935082841115612a5e57600080fd5b838701935087601f850112612a7257600080fd5b8351915082821115612a8657612a866123fa565b8160051b9250612a97818401612453565b8281529284018101928181019089851115612ab157600080fd5b948201945b84861015612adb5785519350612acb8461222d565b8382529482019490820190612ab6565b8096505050505050509250929050565b67ffffffffffffffff8516815283602082015260606040820152600061291f60608301848661282e565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052600160045260246000fd5b67ffffffffffffffff8716815285602082015284604082015283606082015260a060808201526000612b7a60a0830184866128ca565b98975050505050505050565b600060208284031215612b9857600080fd5b8151610fc38161222d565b67ffffffffffffffff8816815286602082015285604082015284606082015283608082015260e060a08201526000612bde60e0830185612610565b82810360c08401526109878185612610565b85815284602082015283604082015260a060608201526000612c1560a0830185612610565b8281036080840152612b7a8185612610565b7fffff0000000000000000000000000000000000000000000000000000000000008360f01b16815260008251612c648160028501602087016125ec565b919091016002019392505050565b602081526000610f396020830184866128ca565b60008085851115612c9657600080fd5b83861115612ca357600080fd5b5050820193919092039150565b600080600080600060a08688031215612cc857600080fd5b853594506020860135935060408601359250606086013567ffffffffffffffff80821115612cf557600080fd5b612d0189838a016124ac565b93506080880135915080821115612d1757600080fd5b50612d24888289016124ac565b9150509295509295909350565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b73ffffffffffffffffffffffffffffffffffffffff85168152600067ffffffffffffffff8086511660208401528060208701511660408401528060408701511660608401525060608501516080830152608085015160a083015260e060c08301528260e08301526101007f07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff841115612df757600080fd5b8360051b8086838601379290920190910195945050505050565b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203612e4257612e42612929565b506001019056fea2646970667358221220ba960c2a8b7a24c8869861c6a0fba38348675114c8ab0b78469cd22c4bc0ab7f64736f6c63430008140033","runtime-code":"0x60806040526004361061015f5760003560e01c80638654ddd4116100c0578063e4c6124711610074578063f2fde38b11610059578063f2fde38b14610470578063f3c66e2b14610490578063f92a79ff146104b057600080fd5b8063e4c61247146103f9578063f1a61fac1461042d57600080fd5b806390e81077116100a557806390e810771461035d578063cbb3c6311461039e578063d5e788a0146103be57600080fd5b80638654ddd4146103055780638da5cb5b1461033257600080fd5b806353b67d7411610117578063715018a6116100fc578063715018a61461029b5780637341eaf9146102b05780637813cd52146102dd57600080fd5b806353b67d7414610275578063547efb841461028857600080fd5b806335c4a1911161014857806335c4a191146101c75780633dc68b871461020c5780633f34448e1461022e57600080fd5b80631450c281146101645780632e56873914610199575b600080fd5b34801561017057600080fd5b5061018461017f366004612183565b6104d0565b60405190151581526020015b60405180910390f35b3480156101a557600080fd5b506101b96101b4366004612210565b610522565b604051908152602001610190565b3480156101d357600080fd5b506101e76101e2366004612210565b610595565b60405173ffffffffffffffffffffffffffffffffffffffff9091168152602001610190565b34801561021857600080fd5b5061022c61022736600461224f565b61065a565b005b61024161023c36600461226c565b6106db565b604080518251815260208084015167ffffffffffffffff908116918301919091529282015190921690820152606001610190565b61022c610283366004612340565b61072f565b6102416102963660046123ba565b610959565b3480156102a757600080fd5b5061022c610995565b3480156102bc57600080fd5b506001546101e79073ffffffffffffffffffffffffffffffffffffffff1681565b3480156102e957600080fd5b506102f2600181565b60405161ffff9091168152602001610190565b34801561031157600080fd5b50610325610320366004612502565b6109a9565b604051610190919061263c565b34801561033e57600080fd5b5060005473ffffffffffffffffffffffffffffffffffffffff166101e7565b34801561036957600080fd5b5061037d61037836600461264f565b6109c4565b6040805167ffffffffffffffff938416815292909116602083015201610190565b3480156103aa57600080fd5b506101b96103b9366004612668565b610b86565b3480156103ca57600080fd5b506103de6103d9366004612706565b610d68565b60408051825181526020928301519281019290925201610190565b34801561040557600080fd5b506101e77f000000000000000000000000000000000000000000000000000000000000000081565b34801561043957600080fd5b506101e761044836600461264f565b60009081526003602052604090205473ffffffffffffffffffffffffffffffffffffffff1690565b34801561047c57600080fd5b5061022c61048b36600461224f565b610d85565b34801561049c57600080fd5b5061022c6104ab36600461273b565b610de9565b3480156104bc57600080fd5b506101e76104cb366004612767565b610e4a565b6000806104dd8686610e97565b90506104ec8160c00151610f41565b50600086866040516104ff9291906127a9565b6040518091039020905061051582828787610fca565b5060019695505050505050565b6000468267ffffffffffffffff1603610578576040517f3da4f44e00000000000000000000000000000000000000000000000000000000815267ffffffffffffffff831660048201526024015b60405180910390fd5b5067ffffffffffffffff1660009081526002602052604090205490565b6000468267ffffffffffffffff16036105e6576040517f3da4f44e00000000000000000000000000000000000000000000000000000000815267ffffffffffffffff8316600482015260240161056f565b5067ffffffffffffffff81166000908152600260205260409020548073ffffffffffffffffffffffffffffffffffffffff81168114610654576040517f0a55a4eb0000000000000000000000000000000000000000000000000000000081526004810182905260240161056f565b50919050565b61066261121f565b600180547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff83169081179091556040519081527fec02f15d78cdfc4beeba45f31cfad25089004e5e3d72727168dd96a77d1f2f829060200160405180910390a150565b604080516060810182526000808252602082018190529181019190915273ffffffffffffffffffffffffffffffffffffffff89166107208b828b8b8b8b8b8b8b611272565b9b9a5050505050505050505050565b600061073b8585610e97565b90506000858560405161074f9291906127a9565b6040518091039020905061076582828686610fca565b600081815260036020526040812080547fffffffffffffffffffffffff0000000000000000000000000000000000000000163317905560c08301516107a990610f41565b9050806020015134146107f75760208101516040517f2b361025000000000000000000000000000000000000000000000000000000008152346004820152602481019190915260440161056f565b805188101561080557805197505b875a1161083e576040517fe9b8315600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60a083015173ffffffffffffffffffffffffffffffffffffffff16636e9fd609893486600001518760800151886040015189606001518a60e001516040518863ffffffff1660e01b81526004016108999594939291906127b9565b6000604051808303818589803b1580156108b257600080fd5b5088f11580156108c6573d6000803e3d6000fd5b505050505050826060015167ffffffffffffffff16836040015167ffffffffffffffff16837f589f737f4049c62fcbcd8274eeacc86e17d29c6621f36e698bcc4c90525ce28f866000015187608001518860a001516040516109479392919067ffffffffffffffff9390931683526020830191909152604082015260600190565b60405180910390a45050505050505050565b60408051606081018252600080825260208201819052918101919091526109878a8a8a8a8a8a8a8a8a611272565b9a9950505050505050505050565b61099d61121f565b6109a76000611987565b565b60606109be60016109b9846119fc565b611ac6565b92915050565b600081815260036020526040812054819073ffffffffffffffffffffffffffffffffffffffff1680610a25576040517fe99eb48d0000000000000000000000000000000000000000000000000000000081526004810185905260240161056f565b60008482604051602001610a5992919091825273ffffffffffffffffffffffffffffffffffffffff16602082015260400190565b60408051808303601f1901815290829052805160208201207f2ad8c706000000000000000000000000000000000000000000000000000000008352600483015291507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1690632ad8c7069060240160408051808303816000875af1158015610afa573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b1e91906127f4565b60405173ffffffffffffffffffffffffffffffffffffffff85168152919550935067ffffffffffffffff808516919086169087907f1c45fee34c18589980aa86a2b9910fac2a0be9beca86376b6d93fa4ce7f010ae9060200160405180910390a45050915091565b6000610b9188611af2565b50610bd184848080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250610f4192505050565b506040517fb8ba4ba100000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000169063b8ba4ba190610c48908b908a908a90600401612884565b602060405180830381865afa158015610c65573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c8991906128b1565b905073ffffffffffffffffffffffffffffffffffffffff871615610d5d576000610cb38484611ba9565b6040517f96fda4da00000000000000000000000000000000000000000000000000000000815290915073ffffffffffffffffffffffffffffffffffffffff8916906396fda4da90610d0e908c9085908a908a906004016128f5565b602060405180830381865afa158015610d2b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d4f91906128b1565b610d599083612958565b9150505b979650505050505050565b60408051808201909152600080825260208201526109be82610f41565b610d8d61121f565b73ffffffffffffffffffffffffffffffffffffffff8116610ddd576040517f1e4fbdf70000000000000000000000000000000000000000000000000000000081526000600482015260240161056f565b610de681611987565b50565b610df161121f565b67ffffffffffffffff8216600081815260026020908152604091829020849055815192835282018390527ffdc2498138df0de25c8fc9bd75bb8e856dac69aaf28d3dd5e0fc48e5e9f6e93f910160405180910390a15050565b6000600360008484604051610e609291906127a9565b604080519182900390912082526020820192909252016000205473ffffffffffffffffffffffffffffffffffffffff169392505050565b604080516101008101825260008082526020820181905291810182905260608082018390526080820183905260a0820183905260c0820181905260e082015290610ee18484611bd0565b905061ffff8116600114610f27576040517f0fda659b00000000000000000000000000000000000000000000000000000000815261ffff8216600482015260240161056f565b610f39610f348585611c1a565b611c75565b949350505050565b60408051808201909152600080825260208201526000610f6083611d1a565b9050600161ffff82161015610fa7576040517fb94fa72500000000000000000000000000000000000000000000000000000000815261ffff8216600482015260240161056f565b610fb083611d65565b806020019051810190610fc391906129ba565b9392505050565b6000610fd98560000151611af2565b905046856020015167ffffffffffffffff16146110345760208501516040517f28dcee4300000000000000000000000000000000000000000000000000000000815267ffffffffffffffff909116600482015260240161056f565b60008481526003602052604090205473ffffffffffffffffffffffffffffffffffffffff1615611093576040517fd80aeb910000000000000000000000000000000000000000000000000000000081526004810185905260240161056f565b60006040518060a00160405280876000015167ffffffffffffffff168152602001876040015167ffffffffffffffff168152602001876060015167ffffffffffffffff1681526020018381526020018681525090506000806110f68860a0015190565b73ffffffffffffffffffffffffffffffffffffffff1663287bc0576040518163ffffffff1660e01b8152600401600060405180830381865afa158015611140573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405261116891908101906129d6565b91509150600061117783611e5f565b80519091506000036111b5576040517fa09e214300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60006111c883868a8a8660200151611ec5565b82519091508110156112135781516040517f0bce4e8500000000000000000000000000000000000000000000000000000000815261056f918391600401918252602082015260400190565b50505050505050505050565b60005473ffffffffffffffffffffffffffffffffffffffff1633146109a7576040517f118cdaa700000000000000000000000000000000000000000000000000000000815233600482015260240161056f565b60408051606081018252600080825260208201819052918101919091526112988a611af2565b5060008990036112d4576040517f0b3e41a600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b61131385858080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250610f4192505050565b506040517fb8ba4ba100000000000000000000000000000000000000000000000000000000815260009073ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000169063b8ba4ba19061138d908e908c908c90600401612884565b602060405180830381865afa1580156113aa573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113ce91906128b1565b905080341015611413576040517f9557ee490000000000000000000000000000000000000000000000000000000081523460048201526024810182905260440161056f565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663aa2f06ae6040518163ffffffff1660e01b81526004016040805180830381865afa15801561147d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906114a191906127f4565b83602001846040018267ffffffffffffffff1667ffffffffffffffff168152508267ffffffffffffffff1667ffffffffffffffff168152505050600061156e338d8d866020015187604001518c8c8080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f820116905080830192505050505050508b8b8080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250611fd292505050565b9050611579816109a9565b805190602001208360000181815250506000807f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663eb20fbfd85856020015188600001518f8f6040518663ffffffff1660e01b81526004016115f49493929190612aeb565b604080518083038185885af1158015611611573d6000803e3d6000fd5b50505050506040513d601f19601f8201168201806040525081019061163691906127f4565b91509150846020015167ffffffffffffffff168267ffffffffffffffff161480156116785750846040015167ffffffffffffffff168167ffffffffffffffff16145b61168457611684612b15565b50503482810390831461172e57600154602083015185516040517f7b18c25c00000000000000000000000000000000000000000000000000000000815267ffffffffffffffff9092166004830152602482015273ffffffffffffffffffffffffffffffffffffffff90911690637b18c25c9083906044016000604051808303818588803b15801561171457600080fd5b505af1158015611728573d6000803e3d6000fd5b50505050505b73ffffffffffffffffffffffffffffffffffffffff8b16156118fd5773ffffffffffffffffffffffffffffffffffffffff8b1663592a87998e6117718a89611ba9565b87516040517fffffffff0000000000000000000000000000000000000000000000000000000060e086901b1681526117b49392919087908f908f90600401612b44565b600060405180830381600087803b1580156117ce57600080fd5b505af11580156117e2573d6000803e3d6000fd5b5050505060008b73ffffffffffffffffffffffffffffffffffffffff166362014bad6040518163ffffffff1660e01b8152600401602060405180830381865afa158015611833573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906118579190612b86565b600154602085015187516040517ffd411b4300000000000000000000000000000000000000000000000000000000815267ffffffffffffffff9092166004830152602482015273ffffffffffffffffffffffffffffffffffffffff808416604483015292935091169063fd411b4390606401600060405180830381600087803b1580156118e357600080fd5b505af11580156118f7573d6000803e3d6000fd5b50505050505b816060015167ffffffffffffffff16826040015167ffffffffffffffff1685600001517f73b3ea77e781779ca7d3bd994ecd1ad739e22cda0120925bbf4e30de70ebc7e8856020015186608001518760a0015189888a60c001518b60e0015160405161196f9796959493929190612ba3565b60405180910390a45050509998505050505050505050565b6000805473ffffffffffffffffffffffffffffffffffffffff8381167fffffffffffffffffffffffff0000000000000000000000000000000000000000831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6060611a8882600001518360200151846040015185606001517fffffffffffffffff00000000000000000000000000000000000000000000000060c085901b1677ffffffffffffffff00000000000000000000000000000000608085901b16176fffffffffffffffff0000000000000000604084901b161767ffffffffffffffff821617949350505050565b82608001518360a001518460c001518560e00151604051602001611ab0959493929190612bf0565b6040516020818303038152906040529050919050565b60608282604051602001611adb929190612c27565b604051602081830303815290604052905092915050565b6000468267ffffffffffffffff1603611b43576040517f3da4f44e00000000000000000000000000000000000000000000000000000000815267ffffffffffffffff8316600482015260240161056f565b5067ffffffffffffffff811660009081526002602052604081205490819003611ba4576040517f0dbcef6b00000000000000000000000000000000000000000000000000000000815267ffffffffffffffff8316600482015260240161056f565b919050565b6000601f19601f830116601f19601f850116611bc69060e2612958565b610fc39190612958565b60006002821015611c115782826040517f659cf9fa00000000000000000000000000000000000000000000000000000000815260040161056f929190612c72565b50503560f01c90565b3660006002831015611c5c5783836040517f659cf9fa00000000000000000000000000000000000000000000000000000000815260040161056f929190612c72565b611c698360028187612c86565b915091505b9250929050565b604080516101008101825260008082526020820181905291810182905260608082018390526080820183905260a0820183905260c0820181905260e082015290611cc184840185612cb0565b60e087015260c086015260a085015260808401529050611cef8160c081901c91608082901c91604081901c91565b67ffffffffffffffff9081166060870152908116604086015290811660208501521682525092915050565b6000600282511015611d5a57816040517f659cf9fa00000000000000000000000000000000000000000000000000000000815260040161056f919061263c565b506020015160f01c90565b6060600282511015611da557816040517f659cf9fa00000000000000000000000000000000000000000000000000000000815260040161056f919061263c565b81517ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe018067ffffffffffffffff811115611de257611de26123fa565b6040519080825280601f01601f191660200182016040528015611e0c576020820181803683370190505b50915060008160208401836022870160045afa905080611e58576040517f101e44fa00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5050919050565b60408051808201909152600080825260208201526000611e7e83611d1a565b9050600161ffff82161015610fa7576040517faac8bd2300000000000000000000000000000000000000000000000000000000815261ffff8216600482015260240161056f565b6000805b8651811015611fc85760007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16631e5df4c4898481518110611f2257611f22612d31565b60200260200101518989896040518563ffffffff1660e01b8152600401611f4c9493929190612d60565b602060405180830381865afa158015611f69573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611f8d91906128b1565b90508015801590611fa6575042611fa48583612958565b105b15611fb757611fb483612e11565b92505b50611fc181612e11565b9050611ec9565b5095945050505050565b604080516101008101825260008082526020820181905291810182905260608082018390526080820183905260a082019290925260c0810182905260e081019190915260405180610100016040528061202a466120a8565b67ffffffffffffffff1681526020018867ffffffffffffffff1681526020018667ffffffffffffffff1681526020018567ffffffffffffffff1681526020016120868a73ffffffffffffffffffffffffffffffffffffffff1690565b8152602001878152602001848152602001838152509050979650505050505050565b600067ffffffffffffffff8211156120f857604080517f6dfcc65000000000000000000000000000000000000000000000000000000000815260048101919091526024810183905260440161056f565b5090565b60008083601f84011261210e57600080fd5b50813567ffffffffffffffff81111561212657600080fd5b602083019150836020828501011115611c6e57600080fd5b60008083601f84011261215057600080fd5b50813567ffffffffffffffff81111561216857600080fd5b6020830191508360208260051b8501011115611c6e57600080fd5b6000806000806040858703121561219957600080fd5b843567ffffffffffffffff808211156121b157600080fd5b6121bd888389016120fc565b909650945060208701359150808211156121d657600080fd5b506121e38782880161213e565b95989497509550505050565b67ffffffffffffffff81168114610de657600080fd5b8035611ba4816121ef565b60006020828403121561222257600080fd5b8135610fc3816121ef565b73ffffffffffffffffffffffffffffffffffffffff81168114610de657600080fd5b60006020828403121561226157600080fd5b8135610fc38161222d565b600080600080600080600080600060c08a8c03121561228a57600080fd5b8935612295816121ef565b985060208a01356122a58161222d565b975060408a01356122b58161222d565b965060608a013567ffffffffffffffff808211156122d257600080fd5b6122de8d838e0161213e565b909850965060808c01359150808211156122f757600080fd5b6123038d838e016120fc565b909650945060a08c013591508082111561231c57600080fd5b506123298c828d016120fc565b915080935050809150509295985092959850929598565b60008060008060006060868803121561235857600080fd5b85359450602086013567ffffffffffffffff8082111561237757600080fd5b61238389838a016120fc565b9096509450604088013591508082111561239c57600080fd5b506123a98882890161213e565b969995985093965092949392505050565b600080600080600080600080600060c08a8c0312156123d857600080fd5b89356123e3816121ef565b985060208a0135975060408a01356122b58161222d565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b604051610100810167ffffffffffffffff8111828210171561244d5761244d6123fa565b60405290565b604051601f8201601f1916810167ffffffffffffffff8111828210171561247c5761247c6123fa565b604052919050565b600067ffffffffffffffff82111561249e5761249e6123fa565b50601f01601f191660200190565b600082601f8301126124bd57600080fd5b81356124d06124cb82612484565b612453565b8181528460208386010111156124e557600080fd5b816020850160208301376000918101602001919091529392505050565b60006020828403121561251457600080fd5b813567ffffffffffffffff8082111561252c57600080fd5b90830190610100828603121561254157600080fd5b612549612429565b61255283612205565b815261256060208401612205565b602082015261257160408401612205565b604082015261258260608401612205565b60608201526080830135608082015260a083013560a082015260c0830135828111156125ad57600080fd5b6125b9878286016124ac565b60c08301525060e0830135828111156125d157600080fd5b6125dd878286016124ac565b60e08301525095945050505050565b60005b838110156126075781810151838201526020016125ef565b50506000910152565b600081518084526126288160208601602086016125ec565b601f01601f19169290920160200192915050565b602081526000610fc36020830184612610565b60006020828403121561266157600080fd5b5035919050565b600080600080600080600060a0888a03121561268357600080fd5b873561268e816121ef565b9650602088013561269e8161222d565b9550604088013567ffffffffffffffff808211156126bb57600080fd5b6126c78b838c0161213e565b909750955060608a01359150808211156126e057600080fd5b506126ed8a828b016120fc565b989b979a50959894979596608090950135949350505050565b60006020828403121561271857600080fd5b813567ffffffffffffffff81111561272f57600080fd5b610f39848285016124ac565b6000806040838503121561274e57600080fd5b8235612759816121ef565b946020939093013593505050565b6000806020838503121561277a57600080fd5b823567ffffffffffffffff81111561279157600080fd5b61279d858286016120fc565b90969095509350505050565b8183823760009101908152919050565b600067ffffffffffffffff8088168352866020840152808616604084015280851660608401525060a06080830152610d5d60a0830184612610565b6000806040838503121561280757600080fd5b8251612812816121ef565b6020840151909250612823816121ef565b809150509250929050565b8183526000602080850194508260005b858110156128795781356128518161222d565b73ffffffffffffffffffffffffffffffffffffffff168752958201959082019060010161283e565b509495945050505050565b67ffffffffffffffff841681526040602082015260006128a860408301848661282e565b95945050505050565b6000602082840312156128c357600080fd5b5051919050565b818352818160208501375060006020828401015260006020601f19601f840116840101905092915050565b67ffffffffffffffff8516815283602082015260606040820152600061291f6060830184866128ca565b9695505050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b808201808211156109be576109be612929565b60006040828403121561297d57600080fd5b6040516040810181811067ffffffffffffffff821117156129a0576129a06123fa565b604052825181526020928301519281019290925250919050565b6000604082840312156129cc57600080fd5b610fc3838361296b565b600080604083850312156129e957600080fd5b825167ffffffffffffffff80821115612a0157600080fd5b818501915085601f830112612a1557600080fd5b81516020612a256124cb83612484565b8281528882848701011115612a3957600080fd5b612a48838383018488016125ec565b87820151909650935082841115612a5e57600080fd5b838701935087601f850112612a7257600080fd5b8351915082821115612a8657612a866123fa565b8160051b9250612a97818401612453565b8281529284018101928181019089851115612ab157600080fd5b948201945b84861015612adb5785519350612acb8461222d565b8382529482019490820190612ab6565b8096505050505050509250929050565b67ffffffffffffffff8516815283602082015260606040820152600061291f60608301848661282e565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052600160045260246000fd5b67ffffffffffffffff8716815285602082015284604082015283606082015260a060808201526000612b7a60a0830184866128ca565b98975050505050505050565b600060208284031215612b9857600080fd5b8151610fc38161222d565b67ffffffffffffffff8816815286602082015285604082015284606082015283608082015260e060a08201526000612bde60e0830185612610565b82810360c08401526109878185612610565b85815284602082015283604082015260a060608201526000612c1560a0830185612610565b8281036080840152612b7a8185612610565b7fffff0000000000000000000000000000000000000000000000000000000000008360f01b16815260008251612c648160028501602087016125ec565b919091016002019392505050565b602081526000610f396020830184866128ca565b60008085851115612c9657600080fd5b83861115612ca357600080fd5b5050820193919092039150565b600080600080600060a08688031215612cc857600080fd5b853594506020860135935060408601359250606086013567ffffffffffffffff80821115612cf557600080fd5b612d0189838a016124ac565b93506080880135915080821115612d1757600080fd5b50612d24888289016124ac565b9150509295509295909350565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b73ffffffffffffffffffffffffffffffffffffffff85168152600067ffffffffffffffff8086511660208401528060208701511660408401528060408701511660608401525060608501516080830152608085015160a083015260e060c08301528260e08301526101007f07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff841115612df757600080fd5b8360051b8086838601379290920190910195945050505050565b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203612e4257612e42612929565b506001019056fea2646970667358221220ba960c2a8b7a24c8869861c6a0fba38348675114c8ab0b78469cd22c4bc0ab7f64736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainClientV1Events.sol\n\nabstract contract InterchainClientV1Events {\n    event ExecutionFeesSet(address executionFees);\n    event LinkedClientSet(uint64 chainId, bytes32 client);\n\n    // TODO: figure out indexing\n\n    event InterchainTransactionSent(\n        bytes32 indexed transactionId,\n        uint64 indexed dbNonce,\n        uint64 indexed entryIndex,\n        uint64 dstChainId,\n        bytes32 srcSender,\n        bytes32 dstReceiver,\n        uint256 verificationFee,\n        uint256 executionFee,\n        bytes options,\n        bytes message\n    );\n\n    event InterchainTransactionReceived(\n        bytes32 indexed transactionId,\n        uint64 indexed dbNonce,\n        uint64 indexed entryIndex,\n        uint64 srcChainId,\n        bytes32 srcSender,\n        bytes32 dstReceiver\n    );\n\n    event ExecutionProofWritten(\n        bytes32 indexed transactionId, uint64 indexed dbNonce, uint64 indexed entryIndex, address executor\n    );\n}\n\n// contracts/interfaces/IExecutionFees.sol\n\ninterface IExecutionFees {\n    error ExecutionFees__AlreadyRecorded(uint64 dstChainId, bytes32 transactionId, address executor);\n    error ExecutionFees__ZeroAddress();\n    error ExecutionFees__ZeroAmount();\n\n    /// @notice Add the execution fee for a transaction. The attached value will be added to the\n    /// rewards for the executor completing the transaction.\n    /// Note: this could be used to store the execution fee for a new transaction, or to add more\n    /// funds to the execution fee of an existing transaction. Therefore this function is payable,\n    /// and does not implement any caller restrictions.\n    /// @dev Will revert if the executor is already recorded for the transaction.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to add the execution fee to.\n    function addExecutionFee(uint64 dstChainId, bytes32 transactionId) external payable;\n\n    /// @notice Record the executor (who completed the transaction) for a transaction,\n    /// and update the accumulated rewards for the executor.\n    /// @dev Could only be called by the Recorder.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to record the executor for.\n    /// @param executor             The address of the executor who completed the transaction.\n    function recordExecutor(uint64 dstChainId, bytes32 transactionId, address executor) external;\n\n    /// @notice Allows the executor to claim their unclaimed rewards.\n    /// @dev Will revert if the executor has no unclaimed rewards.\n    function claimExecutionFees(address executor) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the accumulated rewards for an executor.\n    /// @param executor             The address of the executor to get the rewards for.\n    function accumulatedRewards(address executor) external view returns (uint256 accumulated);\n\n    /// @notice Get the unclaimed rewards for an executor.\n    /// @param executor             The address of the executor to get the rewards for.\n    function unclaimedRewards(address executor) external view returns (uint256 unclaimed);\n\n    /// @notice Get the total execution fee for a transaction.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to get the execution fee for.\n    function executionFee(uint64 dstChainId, bytes32 transactionId) external view returns (uint256 fee);\n\n    /// @notice Get the address of the recorded executor for a transaction.\n    /// @dev Will return address(0) if the executor is not recorded.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to get the recorded executor for.\n    function recordedExecutor(uint64 dstChainId, bytes32 transactionId) external view returns (address executor);\n}\n\n// contracts/interfaces/IExecutionService.sol\n\ninterface IExecutionService {\n    /// @notice Request the execution of an Interchain Transaction on a remote chain.\n    /// Note: the off-chain actor needs to fetch the transaction payload from the InterchainClient\n    /// event with the same transactionId, then execute the transaction on the remote chain:\n    /// `dstInterchainClient.executeTransaction(transactionPayload)`\n    /// Once the execution is confirmed on the source chain, the off-chain actor will be able\n    /// to claim `executionFee` in the ExecutionFees contract.\n    /// @dev Could only be called by `InterchainClient` contracts.\n    /// Will revert if the execution fee is not big enough.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param txPayloadSize        The size of the transaction payload to use for the execution.\n    /// @param transactionId        The id of the transaction to execute.\n    /// @param executionFee         The fee paid for the execution.\n    /// @param options              The options to use for the execution.\n    function requestExecution(\n        uint64 dstChainId,\n        uint256 txPayloadSize,\n        bytes32 transactionId,\n        uint256 executionFee,\n        bytes memory options\n    )\n        external;\n\n    /// @notice Get the address of the EOA account that will be used to execute transactions on the\n    /// remote chains.\n    function executorEOA() external view returns (address);\n\n    /// @notice Get the execution fee for executing an Interchain Transaction on a remote chain.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param txPayloadSize        The size of the transaction payload to use for the execution.\n    /// @param options              The options to use for the execution.\n    function getExecutionFee(\n        uint64 dstChainId,\n        uint256 txPayloadSize,\n        bytes memory options\n    )\n        external\n        view\n        returns (uint256);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    /// @notice Allows the Interchain Client to pass the message to the Interchain App.\n    /// @dev App is responsible for keeping track of interchain clients, and must verify the message sender.\n    /// @param srcChainId   Chain ID of the source chain, where the message was sent from.\n    /// @param sender       Sender address on the source chain, as a bytes32 value.\n    /// @param dbNonce      The Interchain DB nonce of the batch containing the message entry.\n    /// @param entryIndex   The index of the message entry within the batch.\n    /// @param message      The message being sent.\n    function appReceive(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /// @notice Returns the verification configuration of the Interchain App.\n    /// @dev This configuration is used by the Interchain Client to verify that message has been confirmed\n    /// by the Interchain Modules on the destination chain.\n    /// Note: V1 version of AppConfig includes the required responses count, and optimistic period after which\n    /// the message is considered confirmed by the module. Following versions may include additional fields.\n    /// @return appConfig    The versioned configuration of the Interchain App, encoded as bytes.\n    /// @return modules      The list of Interchain Modules that app is trusting to confirm the messages.\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/Math.sol\n\nlibrary MathLib {\n    /// @notice Rounds up to the nearest multiple of 32.\n    /// Note: Returns zero on overflows instead of reverting. This is fine for practical\n    /// use cases, as this is used for determining the size of the payload in memory.\n    function roundUpToWord(uint256 x) internal pure returns (uint256) {\n        unchecked {\n            return (x + 31) \u0026 ~uint256(31);\n        }\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/VersionedPayload.sol\n\n// solhint-disable no-inline-assembly\n// solhint-disable ordering\nlibrary VersionedPayloadLib {\n    /// @notice Amount of bytes reserved for the version (uint16) in the versioned payload\n    uint256 internal constant VERSION_LENGTH = 2;\n\n    error VersionedPayload__TooShort(bytes versionedPayload);\n    error VersionedPayload__PrecompileFailed();\n\n    /// @notice Encodes the versioned payload into a single bytes array.\n    /// @param version  The payload's version.\n    /// @param payload  The payload to encode.\n    function encodeVersionedPayload(uint16 version, bytes memory payload) internal pure returns (bytes memory) {\n        return abi.encodePacked(version, payload);\n    }\n\n    /// @notice Extracts the version from the versioned payload (calldata reference).\n    /// @param versionedPayload     The versioned payload (calldata reference).\n    function getVersion(bytes calldata versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            version := shr(240, calldataload(versionedPayload.offset))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (calldata reference).\n    /// @dev The extracted payload is also returned as a calldata reference.\n    /// @param versionedPayload     The versioned payload.\n    function getPayload(bytes calldata versionedPayload) internal pure returns (bytes calldata) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        return versionedPayload[VERSION_LENGTH:];\n    }\n\n    /// @notice Extracts the version from the versioned payload (memory reference).\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getVersionFromMemory(bytes memory versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            // We add 0x20 to skip the length of the bytes array.\n            version := shr(240, mload(add(versionedPayload, 0x20)))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (memory reference).\n    /// @dev The extracted payload is copied into a new memory location. Use `getPayload` when possible\n    /// to avoid extra memory allocation.\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getPayloadFromMemory(bytes memory versionedPayload) internal view returns (bytes memory payload) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        // Figure how many bytes to copy and allocate the memory for the extracted payload.\n        uint256 toCopy;\n        unchecked {\n            toCopy = versionedPayload.length - VERSION_LENGTH;\n        }\n        payload = new bytes(toCopy);\n        // Use identity precompile (0x04) to copy the payload. Unlike MCOPY, this is available on all EVM chains.\n        bool res;\n        assembly {\n            // We add 0x20 to skip the length of the bytes array.\n            // We add 0x02 to skip the 2 bytes reserved for the version.\n            // Copy the payload to the previously allocated memory.\n            res := staticcall(gas(), 0x04, add(versionedPayload, 0x22), toCopy, add(payload, 0x20), toCopy)\n        }\n        if (!res) {\n            revert VersionedPayload__PrecompileFailed();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SafeCast.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value \u003e type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value \u003e type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value \u003e type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value \u003e type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value \u003e type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value \u003e type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value \u003e type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value \u003e type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value \u003e type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value \u003e type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value \u003e type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value \u003e type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value \u003e type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value \u003e type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value \u003e type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value \u003e type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value \u003e type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value \u003e type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value \u003e type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value \u003e type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value \u003e type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value \u003e type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value \u003e type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value \u003e type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value \u003e type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value \u003e type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value \u003e type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value \u003e type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value \u003e type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value \u003e type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value \u003e type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value \u003c 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value \u003e uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal view returns (AppConfigV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (AppConfigV1));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal view returns (OptionsV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (OptionsV1));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(OPTIONS_V1, abi.encode(options));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/libs/InterchainBatch.sol\n\ntype BatchKey is uint128;\n\n/// @notice Struct representing a batch of entries in the Interchain DataBase.\n/// Batched entries are put together in a Merkle tree, which root is saved.\n/// Batch has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: batchRoot\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch\n/// @param batchRoot    The root of the Merkle tree containing the batched entries\nstruct InterchainBatch {\n    uint64 srcChainId;\n    uint64 dbNonce;\n    bytes32 batchRoot;\n}\n\nlibrary InterchainBatchLib {\n    using VersionedPayloadLib for bytes;\n\n    /// @notice Constructs an InterchainBatch struct to be saved on the local chain.\n    /// @param dbNonce      The database nonce of the batch\n    /// @param batchRoot    The root of the Merkle tree containing the batched entries\n    /// @return batch       The constructed InterchainBatch struct\n    function constructLocalBatch(\n        uint64 dbNonce,\n        bytes32 batchRoot\n    )\n        internal\n        view\n        returns (InterchainBatch memory batch)\n    {\n        return InterchainBatch({srcChainId: SafeCast.toUint64(block.chainid), dbNonce: dbNonce, batchRoot: batchRoot});\n    }\n\n    /// @notice Encodes the InterchainBatch struct into a non-versioned batch payload.\n    function encodeBatch(InterchainBatch memory batch) internal pure returns (bytes memory) {\n        return abi.encode(encodeBatchKey(batch.srcChainId, batch.dbNonce), batch.batchRoot);\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in calldata.\n    function decodeBatch(bytes calldata data) internal pure returns (InterchainBatch memory batch) {\n        BatchKey key;\n        (key, batch.batchRoot) = abi.decode(data, (BatchKey, bytes32));\n        (batch.srcChainId, batch.dbNonce) = decodeBatchKey(key);\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in memory.\n    function decodeBatchFromMemory(bytes memory data) internal pure returns (InterchainBatch memory batch) {\n        BatchKey key;\n        (key, batch.batchRoot) = abi.decode(data, (BatchKey, bytes32));\n        (batch.srcChainId, batch.dbNonce) = decodeBatchKey(key);\n    }\n\n    /// @notice Encodes the uint128 key of the batch from uint64 srcChainId and uint64 dbNonce.\n    function encodeBatchKey(uint64 srcChainId, uint64 dbNonce) internal pure returns (BatchKey) {\n        return BatchKey.wrap((uint128(srcChainId) \u003c\u003c 64) | dbNonce);\n    }\n\n    /// @notice Decodes the uint128 key of the batch into uint64 srcChainId and uint64 dbNonce.\n    function decodeBatchKey(BatchKey key) internal pure returns (uint64 srcChainId, uint64 dbNonce) {\n        srcChainId = uint64(BatchKey.unwrap(key) \u003e\u003e 64);\n        dbNonce = uint64(BatchKey.unwrap(key));\n    }\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce + entryIndex\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch containing the entry\n/// @param entryIndex   The index of the entry in the batch\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint64 srcChainId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nusing InterchainEntryLib for InterchainEntry global;\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint64 dbNonce,\n        uint64 entryIndex,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: SafeCast.toUint64(block.chainid),\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n}\n\n// contracts/libs/InterchainTransaction.sol\n\ntype ICTxHeader is uint256;\n\nstruct InterchainTransaction {\n    uint64 srcChainId;\n    uint64 dstChainId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcSender;\n    bytes32 dstReceiver;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    using MathLib for uint256;\n    using VersionedPayloadLib for bytes;\n\n    function constructLocalTransaction(\n        address srcSender,\n        uint64 dstChainId,\n        bytes32 dstReceiver,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: SafeCast.toUint64(block.chainid),\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            encodeTxHeader(transaction.srcChainId, transaction.dstChainId, transaction.dbNonce, transaction.entryIndex),\n            transaction.srcSender,\n            transaction.dstReceiver,\n            transaction.options,\n            transaction.message\n        );\n    }\n\n    function decodeTransaction(bytes calldata transaction) internal pure returns (InterchainTransaction memory icTx) {\n        ICTxHeader header;\n        (header, icTx.srcSender, icTx.dstReceiver, icTx.options, icTx.message) =\n            abi.decode(transaction, (ICTxHeader, bytes32, bytes32, bytes, bytes));\n        (icTx.srcChainId, icTx.dstChainId, icTx.dbNonce, icTx.entryIndex) = decodeTxHeader(header);\n    }\n\n    function payloadSize(uint256 optionsLen, uint256 messageLen) internal pure returns (uint256) {\n        // 2 bytes are reserved for the transaction version\n        // + 5 fields * 32 bytes (3 values for static, 2 offsets for dynamic) + 2 * 32 bytes (lengths for dynamic) = 226\n        // (srcChainId, dstChainId, dbNonce, entryIndex) are merged into a single 32 bytes field\n        // Both options and message are dynamic fields, which are padded up to 32 bytes\n        return 226 + optionsLen.roundUpToWord() + messageLen.roundUpToWord();\n    }\n\n    function encodeTxHeader(\n        uint64 srcChainId,\n        uint64 dstChainId,\n        uint64 dbNonce,\n        uint64 entryIndex\n    )\n        internal\n        pure\n        returns (ICTxHeader)\n    {\n        return ICTxHeader.wrap(\n            (uint256(srcChainId) \u003c\u003c 192) | (uint256(dstChainId) \u003c\u003c 128) | (uint256(dbNonce) \u003c\u003c 64) | uint256(entryIndex)\n        );\n    }\n\n    function decodeTxHeader(ICTxHeader header)\n        internal\n        pure\n        returns (uint64 srcChainId, uint64 dstChainId, uint64 dbNonce, uint64 entryIndex)\n    {\n        srcChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 192);\n        dstChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 128);\n        dbNonce = uint64(ICTxHeader.unwrap(header) \u003e\u003e 64);\n        entryIndex = uint64(ICTxHeader.unwrap(header));\n    }\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint64 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__InvalidTransactionVersion(uint16 version);\n    error InterchainClientV1__NoLinkedClient(uint64 chainId);\n    error InterchainClientV1__NotEnoughGasSupplied();\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint64 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint64 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint64 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint64 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param messageLen           The length of the message being sent.\n    function getInterchainFee(\n        uint64 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        uint256 messageLen\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint64 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint64 chainId) external view returns (address);\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing a batch of entries from the remote Interchain DataBase,\n    /// verified by the Interchain Module.\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param batchRoot    The Merkle root of the batch\n    struct RemoteBatch {\n        uint256 verifiedAt;\n        bytes32 batchRoot;\n    }\n\n    error InterchainDB__BatchDoesNotExist(uint64 dbNonce);\n    error InterchainDB__BatchNotFinalized(uint64 dbNonce);\n    error InterchainDB__ConflictingBatches(address module, bytes32 existingBatchRoot, InterchainBatch newBatch);\n    error InterchainDB__EntryIndexOutOfRange(uint64 dbNonce, uint64 entryIndex, uint64 batchSize);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__InvalidBatchVersion(uint16 version);\n    error InterchainDB__InvalidEntryRange(uint64 dbNonce, uint64 start, uint64 end);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId(uint64 chainId);\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `requestBatchVerification` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntry(bytes32 dataHash) external returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Request the given Interchain Modules to verify an existing batch.\n    /// If the batch is not finalized, the module will verify it after finalization.\n    /// For the finalized batch the batch root is already available, and the module can verify it immediately.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any batch.\n    /// @dev Will revert if the batch with the given nonce does not exist.\n    /// @param dstChainId    The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the existing batch\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestBatchVerification(\n        uint64 dstChainId,\n        uint64 dbNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Then request the Interchain Modules to verify the batch containing the written entry on the destination chain.\n    /// See `writeEntry` and `requestBatchVerification` for more details.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntryWithVerification(\n        uint64 dstChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Allows the Interchain Module to verify the batch coming from the remote chain.\n    /// Note: The DB will only accept the batch of the same version as the DB itself.\n    /// @param versionedBatch   The versioned Interchain Batch to verify\n    function verifyRemoteBatch(bytes memory versionedBatch) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint64 dstChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce.\n    /// Note: the leafs are ordered by the index of the written entry in the current batch,\n    /// and the leafs value match the value of the written entry (srcWriter + dataHash hashed together).\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchLeafs(uint64 dbNonce) external view returns (bytes32[] memory);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce,\n    /// paginated by the given start and end indexes. The end index is exclusive.\n    /// Note: this is useful when the batch contains a large number of leafs, and calling `getBatchLeafs`\n    /// would result in a gas limit exceeded error.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the provided range is invalid.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param start        The start index of the paginated leafs, inclusive\n    /// @param end          The end index of the paginated leafs, exclusive\n    function getBatchLeafsPaginated(\n        uint64 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory);\n\n    /// @notice Returns the size of the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchSize(uint64 dbNonce) external view returns (uint64);\n\n    /// @notice Get the finalized Interchain Batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatch(uint64 dbNonce) external view returns (InterchainBatch memory);\n\n    /// @notice Get the Interchain Entry's value written on the local chain with the given batch nonce and entry index.\n    /// Entry value is calculated as the hash of the writer address and the written data hash.\n    /// Note: the batch does not have to be finalized to fetch the entry value.\n    /// @dev Will revert if the batch with the given nonce does not exist,\n    /// or the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the existing batch\n    /// @param entryIndex   The index of the written entry within the batch\n    function getEntryValue(uint64 dbNonce, uint64 entryIndex) external view returns (bytes32);\n\n    /// @notice Get the Merkle proof of inclusion for the entry with the given index\n    /// in the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param entryIndex   The index of the written entry within the batch\n    /// @return proof       The Merkle proof of inclusion for the entry\n    function getEntryProof(uint64 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof);\n\n    /// @notice Get the nonce of the database, which is incremented every time a new batch is finalized.\n    /// This is the nonce of the current non-finalized batch.\n    function getDBNonce() external view returns (uint64);\n\n    /// @notice Get the index of the next entry to be written to the database.\n    /// @return dbNonce      The database nonce of the batch including the next entry\n    /// @return entryIndex   The index of the next entry within that batch\n    function getNextEntryIndex() external view returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or ZERO if the module has not verified the entry.\n    function checkVerification(\n        address dstModule,\n        InterchainEntry memory entry,\n        bytes32[] memory proof\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n\n    /// @notice Get the version of the Interchain DataBase.\n    // solhint-disable-next-line func-name-mixedcase\n    function DB_VERSION() external pure returns (uint16);\n}\n\n// contracts/InterchainClientV1.sol\n\n/**\n * @title InterchainClientV1\n * @dev Implements the operations of the Interchain Execution Layer.\n */\ncontract InterchainClientV1 is Ownable, InterchainClientV1Events, IInterchainClientV1 {\n    using AppConfigLib for bytes;\n    using OptionsLib for bytes;\n    using VersionedPayloadLib for bytes;\n\n    /// @notice Version of the InterchainClient contract. Sent and received transactions must have the same version.\n    uint16 public constant CLIENT_VERSION = 1;\n\n    /// @notice Address of the InterchainDB contract, set at the time of deployment.\n    address public immutable INTERCHAIN_DB;\n\n    /// @notice Address of the contract that handles execution fees. Can be updated by the owner.\n    address public executionFees;\n\n    /// @dev Address of the InterchainClient contract on the remote chain\n    mapping(uint64 chainId =\u003e bytes32 remoteClient) internal _linkedClient;\n    /// @dev Executor address that completed the transaction. Address(0) if not executed yet.\n    mapping(bytes32 transactionId =\u003e address executor) internal _txExecutor;\n\n    constructor(address interchainDB, address owner_) Ownable(owner_) {\n        INTERCHAIN_DB = interchainDB;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function setExecutionFees(address executionFees_) external onlyOwner {\n        executionFees = executionFees_;\n        emit ExecutionFeesSet(executionFees_);\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function setLinkedClient(uint64 chainId, bytes32 client) external onlyOwner {\n        _linkedClient[chainId] = client;\n        emit LinkedClientSet(chainId, client);\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _interchainSend(dstChainId, receiver, srcExecutionService, srcModules, options, message);\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function interchainSendEVM(\n        uint64 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc)\n    {\n        bytes32 receiverBytes32 = TypeCasts.addressToBytes32(receiver);\n        return _interchainSend(dstChainId, receiverBytes32, srcExecutionService, srcModules, options, message);\n    }\n\n    // TODO: Handle the case where receiver does not implement the IInterchainApp interface (or does not exist at all)\n    // @inheritdoc IInterchainClientV1\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable\n    {\n        InterchainTransaction memory icTx = _assertCorrectVersion(transaction);\n        bytes32 transactionId = keccak256(transaction);\n        _assertExecutable(icTx, transactionId, proof);\n        _txExecutor[transactionId] = msg.sender;\n\n        OptionsV1 memory decodedOptions = icTx.options.decodeOptionsV1();\n        if (msg.value != decodedOptions.gasAirdrop) {\n            revert InterchainClientV1__IncorrectMsgValue(msg.value, decodedOptions.gasAirdrop);\n        }\n        // We should always use at least as much as the requested gas limit.\n        // The executor can specify a higher gas limit if they wanted.\n        if (decodedOptions.gasLimit \u003e gasLimit) gasLimit = decodedOptions.gasLimit;\n        // Check the the Executor has provided big enough gas limit for the whole transaction.\n        if (gasleft() \u003c= gasLimit) {\n            revert InterchainClientV1__NotEnoughGasSupplied();\n        }\n        // Pass the full msg.value to the app: we have already checked that it matches the requested gas airdrop.\n        IInterchainApp(TypeCasts.bytes32ToAddress(icTx.dstReceiver)).appReceive{gas: gasLimit, value: msg.value}({\n            srcChainId: icTx.srcChainId,\n            sender: icTx.srcSender,\n            dbNonce: icTx.dbNonce,\n            entryIndex: icTx.entryIndex,\n            message: icTx.message\n        });\n        emit InterchainTransactionReceived(\n            transactionId, icTx.dbNonce, icTx.entryIndex, icTx.srcChainId, icTx.srcSender, icTx.dstReceiver\n        );\n    }\n\n    /// @inheritdoc IInterchainClientV1\n    function writeExecutionProof(bytes32 transactionId) external returns (uint64 dbNonce, uint64 entryIndex) {\n        address executor = _txExecutor[transactionId];\n        if (executor == address(0)) {\n            revert InterchainClientV1__TxNotExecuted(transactionId);\n        }\n        bytes memory proof = abi.encode(transactionId, executor);\n        (dbNonce, entryIndex) = IInterchainDB(INTERCHAIN_DB).writeEntry(keccak256(proof));\n        emit ExecutionProofWritten(transactionId, dbNonce, entryIndex, executor);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // @inheritdoc IInterchainClientV1\n    function isExecutable(bytes calldata encodedTx, bytes32[] calldata proof) external view returns (bool) {\n        InterchainTransaction memory icTx = _assertCorrectVersion(encodedTx);\n        // Check that options could be decoded\n        icTx.options.decodeOptionsV1();\n        bytes32 transactionId = keccak256(encodedTx);\n        _assertExecutable(icTx, transactionId, proof);\n        return true;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function getExecutor(bytes calldata encodedTx) external view returns (address) {\n        return _txExecutor[keccak256(encodedTx)];\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function getExecutorById(bytes32 transactionId) external view returns (address) {\n        return _txExecutor[transactionId];\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function getInterchainFee(\n        uint64 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        uint256 messageLen\n    )\n        external\n        view\n        returns (uint256 fee)\n    {\n        _assertLinkedClient(dstChainId);\n        // Check that options could be decoded on destination chain\n        options.decodeOptionsV1();\n        // Verification fee from InterchainDB\n        fee = IInterchainDB(INTERCHAIN_DB).getInterchainFee(dstChainId, srcModules);\n        // Add execution fee, if ExecutionService is provided\n        if (srcExecutionService != address(0)) {\n            uint256 payloadSize = InterchainTransactionLib.payloadSize(options.length, messageLen);\n            fee += IExecutionService(srcExecutionService).getExecutionFee(dstChainId, payloadSize, options);\n        }\n    }\n\n    /// @inheritdoc IInterchainClientV1\n    function getLinkedClient(uint64 chainId) external view returns (bytes32) {\n        if (chainId == block.chainid) {\n            revert InterchainClientV1__NotRemoteChainId(chainId);\n        }\n        return _linkedClient[chainId];\n    }\n\n    /// @inheritdoc IInterchainClientV1\n    function getLinkedClientEVM(uint64 chainId) external view returns (address linkedClientEVM) {\n        if (chainId == block.chainid) {\n            revert InterchainClientV1__NotRemoteChainId(chainId);\n        }\n        bytes32 linkedClient = _linkedClient[chainId];\n        linkedClientEVM = TypeCasts.bytes32ToAddress(linkedClient);\n        // Check that the linked client address fits into the EVM address space\n        if (TypeCasts.addressToBytes32(linkedClientEVM) != linkedClient) {\n            revert InterchainClientV1__NotEVMClient(linkedClient);\n        }\n    }\n\n    /// @notice Decodes the encoded options data into a OptionsV1 struct.\n    function decodeOptions(bytes memory encodedOptions) external view returns (OptionsV1 memory) {\n        return encodedOptions.decodeOptionsV1();\n    }\n\n    /// @notice Encodes the transaction data into a bytes format.\n    function encodeTransaction(InterchainTransaction memory icTx) public pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload({\n            version: CLIENT_VERSION,\n            payload: InterchainTransactionLib.encodeTransaction(icTx)\n        });\n    }\n\n    // ═════════════════════════════════════════════════ INTERNAL ══════════════════════════════════════════════════════\n\n    /// @dev Internal logic for sending a message to another chain.\n    function _interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        _assertLinkedClient(dstChainId);\n        if (receiver == 0) revert InterchainClientV1__ZeroReceiver();\n        // Check that options could be decoded on destination chain\n        options.decodeOptionsV1();\n        uint256 verificationFee = IInterchainDB(INTERCHAIN_DB).getInterchainFee(dstChainId, srcModules);\n        if (msg.value \u003c verificationFee) {\n            revert InterchainClientV1__FeeAmountTooLow(msg.value, verificationFee);\n        }\n        (desc.dbNonce, desc.entryIndex) = IInterchainDB(INTERCHAIN_DB).getNextEntryIndex();\n        InterchainTransaction memory icTx = InterchainTransactionLib.constructLocalTransaction({\n            srcSender: msg.sender,\n            dstReceiver: receiver,\n            dstChainId: dstChainId,\n            dbNonce: desc.dbNonce,\n            entryIndex: desc.entryIndex,\n            options: options,\n            message: message\n        });\n        desc.transactionId = keccak256(encodeTransaction(icTx));\n        // Sanity check: nonce returned from DB should match the nonce used to construct the transaction\n        {\n            (uint64 dbNonce, uint64 entryIndex) = IInterchainDB(INTERCHAIN_DB).writeEntryWithVerification{\n                value: verificationFee\n            }(icTx.dstChainId, desc.transactionId, srcModules);\n            assert(dbNonce == desc.dbNonce \u0026\u0026 entryIndex == desc.entryIndex);\n        }\n        uint256 executionFee;\n        unchecked {\n            executionFee = msg.value - verificationFee;\n        }\n        if (executionFee \u003e 0) {\n            IExecutionFees(executionFees).addExecutionFee{value: executionFee}(icTx.dstChainId, desc.transactionId);\n        }\n        // TODO: consider disallowing the use of empty srcExecutionService\n        if (srcExecutionService != address(0)) {\n            IExecutionService(srcExecutionService).requestExecution({\n                dstChainId: dstChainId,\n                txPayloadSize: InterchainTransactionLib.payloadSize(options.length, message.length),\n                transactionId: desc.transactionId,\n                executionFee: executionFee,\n                options: options\n            });\n            address srcExecutorEOA = IExecutionService(srcExecutionService).executorEOA();\n            IExecutionFees(executionFees).recordExecutor(icTx.dstChainId, desc.transactionId, srcExecutorEOA);\n        }\n        emit InterchainTransactionSent(\n            desc.transactionId,\n            icTx.dbNonce,\n            icTx.entryIndex,\n            icTx.dstChainId,\n            icTx.srcSender,\n            icTx.dstReceiver,\n            verificationFee,\n            executionFee,\n            icTx.options,\n            icTx.message\n        );\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Asserts that the transaction is executable.\n    function _assertExecutable(\n        InterchainTransaction memory icTx,\n        bytes32 transactionId,\n        bytes32[] calldata proof\n    )\n        internal\n        view\n    {\n        bytes32 linkedClient = _assertLinkedClient(icTx.srcChainId);\n        if (icTx.dstChainId != block.chainid) {\n            revert InterchainClientV1__IncorrectDstChainId(icTx.dstChainId);\n        }\n        if (_txExecutor[transactionId] != address(0)) {\n            revert InterchainClientV1__TxAlreadyExecuted(transactionId);\n        }\n        // Construct expected entry based on icTransaction data\n        InterchainEntry memory icEntry = InterchainEntry({\n            srcChainId: icTx.srcChainId,\n            dbNonce: icTx.dbNonce,\n            entryIndex: icTx.entryIndex,\n            srcWriter: linkedClient,\n            dataHash: transactionId\n        });\n        (bytes memory encodedAppConfig, address[] memory approvedDstModules) =\n            IInterchainApp(TypeCasts.bytes32ToAddress(icTx.dstReceiver)).getReceivingConfig();\n        AppConfigV1 memory appConfig = encodedAppConfig.decodeAppConfigV1();\n        if (appConfig.requiredResponses == 0) {\n            revert InterchainClientV1__ZeroRequiredResponses();\n        }\n        uint256 responses = _getFinalizedResponsesCount(approvedDstModules, icEntry, proof, appConfig.optimisticPeriod);\n        if (responses \u003c appConfig.requiredResponses) {\n            revert InterchainClientV1__NotEnoughResponses(responses, appConfig.requiredResponses);\n        }\n    }\n\n    /// @dev Asserts that the chain is linked and returns the linked client address.\n    function _assertLinkedClient(uint64 chainId) internal view returns (bytes32 linkedClient) {\n        if (chainId == block.chainid) {\n            revert InterchainClientV1__NotRemoteChainId(chainId);\n        }\n        linkedClient = _linkedClient[chainId];\n        if (linkedClient == 0) {\n            revert InterchainClientV1__NoLinkedClient(chainId);\n        }\n    }\n\n    /**\n     * @dev Calculates the number of responses that are considered finalized within the optimistic time period.\n     * @param approvedModules       Approved modules that could have confirmed the entry.\n     * @param icEntry               The InterchainEntry to confirm.\n     * @param optimisticPeriod      The time period in seconds within which a response is considered valid.\n     * @return finalizedResponses   The count of responses that are finalized within the optimistic time period.\n     */\n    function _getFinalizedResponsesCount(\n        address[] memory approvedModules,\n        InterchainEntry memory icEntry,\n        bytes32[] calldata proof,\n        uint256 optimisticPeriod\n    )\n        internal\n        view\n        returns (uint256 finalizedResponses)\n    {\n        for (uint256 i = 0; i \u003c approvedModules.length; ++i) {\n            uint256 confirmedAt = IInterchainDB(INTERCHAIN_DB).checkVerification(approvedModules[i], icEntry, proof);\n            // checkVerification() returns 0 if entry hasn't been confirmed by the module, so we check for that as well\n            if (confirmedAt != 0 \u0026\u0026 confirmedAt + optimisticPeriod \u003c block.timestamp) {\n                ++finalizedResponses;\n            }\n        }\n    }\n\n    /// @dev Asserts that the transaction version is correct. Returns the decoded transaction for chaining purposes.\n    function _assertCorrectVersion(bytes calldata versionedTx)\n        internal\n        pure\n        returns (InterchainTransaction memory icTx)\n    {\n        uint16 version = versionedTx.getVersion();\n        if (version != CLIENT_VERSION) {\n            revert InterchainClientV1__InvalidTransactionVersion(version);\n        }\n        icTx = InterchainTransactionLib.decodeTransaction(versionedTx.getPayload());\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"80510:15960:0:-:0;;;81460:111;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;81518:6;-1:-1:-1;;;;;52839:26:0;;52835:95;;52888:31;;-1:-1:-1;;;52888:31:0;;52916:1;52888:31;;;640:51:1;613:18;;52888:31:0;;;;;;;52835:95;52939:32;52958:12;52939:18;:32::i;:::-;-1:-1:-1;;;;;;;81536:28:0::1;;::::0;80510:15960;;54478:187;54551:16;54570:6;;-1:-1:-1;;;;;54586:17:0;;;-1:-1:-1;;;;;;54586:17:0;;;;;;54618:40;;54570:6;;;;;;;54618:40;;54551:16;54618:40;54541:124;54478:187;:::o;14:177:1:-;93:13;;-1:-1:-1;;;;;135:31:1;;125:42;;115:70;;181:1;178;171:12;115:70;14:177;;;:::o;196:293::-;275:6;283;336:2;324:9;315:7;311:23;307:32;304:52;;;352:1;349;342:12;304:52;375:40;405:9;375:40;:::i;:::-;365:50;;434:49;479:2;468:9;464:18;434:49;:::i;:::-;424:59;;196:293;;;;;:::o;494:203::-;80510:15960:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","srcMapRuntime":"80510:15960:0:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;85805:405;;;;;;;;;;-1:-1:-1;85805:405:0;;;;;:::i;:::-;;:::i;:::-;;;1653:14:1;;1646:22;1628:41;;1616:2;1601:18;85805:405:0;;;;;;;;87528:235;;;;;;;;;;-1:-1:-1;87528:235:0;;;;;:::i;:::-;;:::i;:::-;;;2347:25:1;;;2335:2;2320:18;87528:235:0;2201:177:1;87809:570:0;;;;;;;;;;-1:-1:-1;87809:570:0;;;;;:::i;:::-;;:::i;:::-;;;2559:42:1;2547:55;;;2529:74;;2517:2;2502:18;87809:570:0;2383:226:1;81616:163:0;;;;;;;;;;-1:-1:-1;81616:163:0;;;;;:::i;:::-;;:::i;:::-;;82510:507;;;;;;:::i;:::-;;:::i;:::-;;;;4724:13:1;;4706:32;;4785:4;4773:17;;;4767:24;4810:18;4866:21;;;4844:20;;;4837:51;;;;4936:17;;;4930:24;4926:33;;;4904:20;;;4897:63;4694:2;4679:18;82510:507:0;4480:486:1;83181:1676:0;;;;;;:::i;:::-;;:::i;82040:425::-;;;;;;:::i;:::-;;:::i;53859:101::-;;;;;;;;;;;;;:::i;81103:28::-;;;;;;;;;;-1:-1:-1;81103:28:0;;;;;;;;80827:41;;;;;;;;;;;;80867:1;80827:41;;;;;7345:6:1;7333:19;;;7315:38;;7303:2;7288:18;80827:41:0;7171:188:1;88680:283:0;;;;;;;;;;-1:-1:-1;88680:283:0;;;;;:::i;:::-;;:::i;:::-;;;;;;;:::i;53204:85::-;;;;;;;;;;-1:-1:-1;53250:7:0;53276:6;;;53204:85;;84903:523;;;;;;;;;;-1:-1:-1;84903:523:0;;;;;:::i;:::-;;:::i;:::-;;;;11222:18:1;11267:15;;;11249:34;;11319:15;;;;11314:2;11299:18;;11292:43;11185:18;84903:523:0;11042:299:1;86611:871:0;;;;;;;;;;-1:-1:-1;86611:871:0;;;;;:::i;:::-;;:::i;88459:149::-;;;;;;;;;;-1:-1:-1;88459:149:0;;;;;:::i;:::-;;:::i;:::-;;;;13165:13:1;;13147:32;;13235:4;13223:17;;;13217:24;13195:20;;;13188:54;;;;13120:18;88459:149:0;12947:301:1;80960:38:0;;;;;;;;;;;;;;;86436:130;;;;;;;;;;-1:-1:-1;86436:130:0;;;;;:::i;:::-;86507:7;86533:26;;;:11;:26;;;;;;;;;86436:130;54109:215;;;;;;;;;;-1:-1:-1;54109:215:0;;;;;:::i;:::-;;:::i;81824:171::-;;;;;;;;;;-1:-1:-1;81824:171:0;;;;;:::i;:::-;;:::i;86255:136::-;;;;;;;;;;-1:-1:-1;86255:136:0;;;;;:::i;:::-;;:::i;85805:405::-;85902:4;85918:33;85954:32;85976:9;;85954:21;:32::i;:::-;85918:68;;86043:30;:4;:12;;;:28;:30::i;:::-;;86083:21;86117:9;;86107:20;;;;;;;:::i;:::-;;;;;;;;86083:44;;86137:45;86155:4;86161:13;86176:5;;86137:17;:45::i;:::-;-1:-1:-1;86199:4:0;;85805:405;-1:-1:-1;;;;;;85805:405:0:o;87528:235::-;87592:7;87626:13;87615:7;:24;;;87611:107;;87662:45;;;;;14435:18:1;14423:31;;87662:45:0;;;14405:50:1;14378:18;;87662:45:0;;;;;;;;87611:107;-1:-1:-1;87734:22:0;;;;;;:13;:22;;;;;;;87528:235::o;87809:570::-;87876:23;87926:13;87915:7;:24;;;87911:107;;87962:45;;;;;14435:18:1;14423:31;;87962:45:0;;;14405:50:1;14378:18;;87962:45:0;14261:200:1;87911:107:0;-1:-1:-1;88050:22:0;;;88027:20;88050:22;;;:13;:22;;;;;;;8729;;;88234:59;;88230:143;;88316:46;;;;;;;;2347:25:1;;;2320:18;;88316:46:0;2201:177:1;88230:143:0;87901:478;87809:570;;;:::o;81616:163::-;53097:13;:11;:13::i;:::-;81695::::1;:30:::0;;;::::1;;::::0;::::1;::::0;;::::1;::::0;;;81740:32:::1;::::0;2529:74:1;;;81740:32:0::1;::::0;2517:2:1;2502:18;81740:32:0::1;;;;;;;81616:163:::0;:::o;82510:507::-;-1:-1:-1;;;;;;;;;;;;;;;;;;;;;;;;;8729:22:0;;;82915:95;82931:10;8729:22;82960:19;82981:10;;82993:7;;83002;;82915:15;:95::i;:::-;82908:102;82510:507;-1:-1:-1;;;;;;;;;;;82510:507:0:o;83181:1676::-;83357:33;83393:34;83415:11;;83393:21;:34::i;:::-;83357:70;;83437:21;83471:11;;83461:22;;;;;;;:::i;:::-;;;;;;;;83437:46;;83493:45;83511:4;83517:13;83532:5;;83493:17;:45::i;:::-;83548:26;;;;:11;:26;;;;;:39;;;;83577:10;83548:39;;;83632:12;;;;:30;;:28;:30::i;:::-;83598:64;;83689:14;:25;;;83676:9;:38;83672:151;;83786:25;;;;83737:75;;;;;83775:9;83737:75;;;14640:25:1;14681:18;;;14674:34;;;;14613:18;;83737:75:0;14466:248:1;83672:151:0;83984:23;;:34;-1:-1:-1;83980:74:0;;;84031:23;;;-1:-1:-1;83980:74:0;84176:8;84163:9;:21;84159:101;;84207:42;;;;;;;;;;;;;;84159:101;84425:16;;;;84383:71;;;84460:8;84477:9;84514:4;:15;;;84551:4;:14;;;84588:4;:12;;;84626:4;:15;;;84664:4;:12;;;84383:304;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;84774:4;:15;;;84702:148;;84760:4;:12;;;84702:148;;84745:13;84702:148;84791:4;:15;;;84808:4;:14;;;84824:4;:16;;;84702:148;;;;;;;15516:18:1;15504:31;;;;15486:50;;15567:2;15552:18;;15545:34;;;;15610:2;15595:18;;15588:34;15474:2;15459:18;;15286:342;84702:148:0;;;;;;;;83347:1510;;;83181:1676;;;;;:::o;82040:425::-;-1:-1:-1;;;;;;;;;;;;;;;;;;;;;;;;;82370:88:0;82386:10;82398:8;82408:19;82429:10;;82441:7;;82450;;82370:15;:88::i;:::-;82363:95;82040:425;-1:-1:-1;;;;;;;;;;82040:425:0:o;53859:101::-;53097:13;:11;:13::i;:::-;53923:30:::1;53950:1;53923:18;:30::i;:::-;53859:101::o:0;88680:283::-;88763:12;88794:162;80867:1;88897:48;88940:4;88897:42;:48::i;:::-;88794:42;:162::i;:::-;88787:169;88680:283;-1:-1:-1;;88680:283:0:o;84903:523::-;84973:14;85037:26;;;:11;:26;;;;;;84973:14;;85037:26;;;85073:108;;85122:48;;;;;;;;2347:25:1;;;2320:18;;85122:48:0;2201:177:1;85073:108:0;85190:18;85222:13;85237:8;85211:35;;;;;;;;15807:25:1;;;15880:42;15868:55;15863:2;15848:18;;15841:83;15795:2;15780:18;;15633:297;85211:35:0;;;;;;;-1:-1:-1;;85211:35:0;;;;;;;85320:16;;85211:35;85320:16;;;85280:57;;;;;;2347:25:1;85211:35:0;-1:-1:-1;85294:13:0;85280:39;;;;;2320:18:1;;85280:57:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;85352:67;;2559:42:1;2547:55;;2529:74;;85256:81:0;;-1:-1:-1;85256:81:0;-1:-1:-1;85352:67:0;;;;;;;;;85374:13;;85352:67;;2517:2:1;2502:18;85352:67:0;;;;;;;85008:418;;84903:523;;;:::o;86611:871::-;86853:11;86880:31;86900:10;86880:19;:31::i;:::-;;86989:25;:7;;:23;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;86989:23:0;;-1:-1:-1;;;86989:25:0:i;:::-;-1:-1:-1;87076:69:0;;;;;:45;87090:13;87076:45;;;;:69;;87122:10;;87134;;;;87076:69;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;87070:75;-1:-1:-1;87221:33:0;;;;87217:259;;87270:19;87292:64;87329:7;87345:10;87292:36;:64::i;:::-;87377:88;;;;;87270:86;;-1:-1:-1;87377:54:0;;;;;;:88;;87432:10;;87270:86;;87457:7;;;;87377:88;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;87370:95;;;;:::i;:::-;;;87256:220;87217:259;86611:871;;;;;;;;;:::o;88459:149::-;-1:-1:-1;;;;;;;;;;;;;;;;;88569:32:0;:14;:30;:32::i;54109:215::-;53097:13;:11;:13::i;:::-;54193:22:::1;::::0;::::1;54189:91;;54238:31;::::0;::::1;::::0;;54266:1:::1;54238:31;::::0;::::1;2529:74:1::0;2502:18;;54238:31:0::1;2383:226:1::0;54189:91:0::1;54289:28;54308:8;54289:18;:28::i;:::-;54109:215:::0;:::o;81824:171::-;53097:13;:11;:13::i;:::-;81910:22:::1;::::0;::::1;;::::0;;;:13:::1;:22;::::0;;;;;;;;:31;;;81956:32;;18682:50:1;;;18748:18;;18741:34;;;81956:32:0::1;::::0;18655:18:1;81956:32:0::1;;;;;;;81824:171:::0;;:::o;86255:136::-;86325:7;86351:11;:33;86373:9;;86363:20;;;;;;;:::i;:::-;;;;;;;;;;;86351:33;;;;;;;;;;-1:-1:-1;86351:33:0;;;;;86255:136;-1:-1:-1;;;86255:136:0:o;96054:414::-;-1:-1:-1;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;96226:24:0;:11;;:22;:24::i;:::-;96209:41;-1:-1:-1;96264:25:0;;;80867:1;96264:25;96260:117;;96312:54;;;;;7345:6:1;7333:19;;96312:54:0;;;7315:38:1;7288:18;;96312:54:0;7171:188:1;96260:117:0;96393:68;96436:24;:11;;:22;:24::i;:::-;96393:42;:68::i;:::-;96386:75;96054:414;-1:-1:-1;;;;96054:414:0:o;50706:599::-;-1:-1:-1;;;;;;;;;;;;;;;;;50801:14:0;50818:27;:4;:25;:27::i;:::-;50801:44;-1:-1:-1;50481:1:0;50859:20;;;;50855:95;;;50902:37;;;;;7345:6:1;7333:19;;50902:37:0;;;7315:38:1;7288:18;;50902:37:0;7171:188:1;50855:95:0;51257:27;:4;:25;:27::i;:::-;51246:52;;;;;;;;;;;;:::i;:::-;51239:59;50706:599;-1:-1:-1;;;50706:599:0:o;92722:1508::-;92907:20;92930:36;92950:4;:15;;;92930:19;:36::i;:::-;92907:59;;92999:13;92980:4;:15;;;:32;;;92976:126;;93075:15;;;;93035:56;;;;;14435:18:1;14423:31;;;93035:56:0;;;14405:50:1;14378:18;;93035:56:0;14261:200:1;92976:126:0;93153:1;93115:26;;;:11;:26;;;;;;:40;:26;:40;93111:130;;93178:52;;;;;;;;2347:25:1;;;2320:18;;93178:52:0;2201:177:1;93111:130:0;93314:30;93347:218;;;;;;;;93389:4;:15;;;93347:218;;;;;;93427:4;:12;;;93347:218;;;;;;93465:4;:15;;;93347:218;;;;;;93505:12;93347:218;;;;93541:13;93347:218;;;93314:251;;93576:29;93607:35;93673:44;93700:4;:16;;;8875:1;8765:121;93673:44;93658:79;;;:81;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;93658:81:0;;;;;;;;;;;;:::i;:::-;93575:164;;;;93749:28;93780:36;:16;:34;:36::i;:::-;93830:27;;93749:67;;-1:-1:-1;93830:27:0;:32;93826:113;;93885:43;;;;;;;;;;;;;;93826:113;93948:17;93968:91;93996:18;94016:7;94025:5;;94032:9;:26;;;93968:27;:91::i;:::-;94085:27;;93948:111;;-1:-1:-1;94073:39:0;;94069:155;;;94185:27;;94135:78;;;;;;;94174:9;;94135:78;;14640:25:1;;;14696:2;14681:18;;14674:34;14628:2;14613:18;;14466:248;94069:155:0;92897:1333;;;;;;92722:1508;;;;:::o;53362:162::-;53250:7;53276:6;53421:23;53276:6;13491:10;53421:23;53417:101;;53467:40;;;;;13491:10;53467:40;;;2529:74:1;2502:18;;53467:40:0;2383:226:1;89365:2978:0;-1:-1:-1;;;;;;;;;;;;;;;;;;;;;;;;;89673:31:0;89693:10;89673:19;:31::i;:::-;-1:-1:-1;89730:1:0;89718:13;;;89714:60;;89740:34;;;;;;;;;;;;;;89714:60;89852:25;:7;;:23;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;89852:23:0;;-1:-1:-1;;;89852:25:0:i;:::-;-1:-1:-1;89913:69:0;;;;;89887:23;;89913:45;89927:13;89913:45;;;;:69;;89959:10;;89971;;;;89913:69;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;89887:95;;90008:15;89996:9;:27;89992:128;;;90046:63;;;;;90082:9;90046:63;;;14640:25:1;14681:18;;;14674:34;;;14613:18;;90046:63:0;14466:248:1;89992:128:0;90177:13;90163:46;;;:48;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;90130:4;:12;;90144:4;:15;;90129:82;;;;;;;;;;;;;;;;;;90221:33;90257:304;90333:10;90404;90370:8;90437:4;:12;;;90475:4;:15;;;90513:7;;90257:304;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;90543:7;;90257:304;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;90257:50:0;;-1:-1:-1;;;90257:304:0:i;:::-;90221:340;;90602:23;90620:4;90602:17;:23::i;:::-;90592:34;;;;;;90571:4;:18;;:55;;;;;90756:14;90772:17;90807:13;90793:55;;;90873:15;90903:4;:15;;;90920:4;:18;;;90940:10;;90793:158;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;90755:196;;;;90983:4;:12;;;90972:23;;:7;:23;;;:56;;;;;91013:4;:15;;;90999:29;;:10;:29;;;90972:56;90965:64;;;;:::i;:::-;-1:-1:-1;;91118:9:0;:27;;;;91169:16;;91165:150;;91216:13;;91268:15;;;;91285:18;;91201:103;;;;;18712:18:1;18700:31;;;91201:103:0;;;18682:50:1;18748:18;;;18741:34;91216:13:0;;;;;91201:45;;91254:12;;18655:18:1;;91201:103:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;91165:150;91403:33;;;;91399:607;;91452:55;;;;91538:10;91581:68;91618:7;91634;91581:36;:68::i;:::-;91682:18;;91452:341;;;;;;;;;;;;;;91682:18;91732:12;;91771:7;;;;91452:341;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;91807:22;91850:19;91832:50;;;:52;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;91913:13;;91943:15;;;;91960:18;;91898:97;;;;;22748:18:1;22736:31;;;91898:97:0;;;22718:50:1;22784:18;;;22777:34;91913:13:0;22847:55:1;;;22827:18;;;22820:83;91807:77:0;;-1:-1:-1;91913:13:0;;;91898:44;;22691:18:1;;91898:97:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;91438:568;91399:607;92117:4;:15;;;92020:316;;92091:4;:12;;;92020:316;;92059:4;:18;;;92020:316;92146:4;:15;;;92175:4;:14;;;92203:4;:16;;;92233:15;92262:12;92288:4;:12;;;92314:4;:12;;;92020:316;;;;;;;;;;;;:::i;:::-;;;;;;;;89663:2680;;;89365:2978;;;;;;;;;;;:::o;54478:187::-;54551:16;54570:6;;;54586:17;;;;;;;;;;54618:40;;54570:6;;;;;;;54618:40;;54551:16;54618:40;54541:124;54478:187;:::o;60774:409::-;60866:12;60921:107;60936:11;:22;;;60960:11;:22;;;60984:11;:19;;;61005:11;:22;;;62401:26;62424:3;62401:26;;;;62432;62455:3;62432:26;;;;62400:59;62463:22;62483:2;62463:22;;;;62400:86;62489:19;;;62400:108;62156:369;;;;;;;60921:107;61042:11;:21;;;61077:11;:23;;;61114:11;:19;;;61147:11;:19;;;60897:279;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;60890:286;;60774:409;;;:::o;9450:165::-;9543:12;9591:7;9600;9574:34;;;;;;;;;:::i;:::-;;;;;;;;;;;;;9567:41;;9450:165;;;;:::o;94321:367::-;94389:20;94436:13;94425:7;:24;;;94421:107;;94472:45;;;;;14435:18:1;14423:31;;94472:45:0;;;14405:50:1;14378:18;;94472:45:0;14261:200:1;94421:107:0;-1:-1:-1;94552:22:0;;;;;;;:13;:22;;;;;;;94588:17;;;94584:98;;94628:43;;;;;14435:18:1;14423:31;;94628:43:0;;;14405:50:1;14378:18;;94628:43:0;14261:200:1;94584:98:0;94321:367;;;:::o;61606:544::-;61690:7;-1:-1:-1;;8551:2:0;8532:6;;8531:23;-1:-1:-1;;8551:2:0;8532:6;;8531:23;62082:32;;:3;:32;:::i;:::-;:61;;;;:::i;9787:425::-;9863:14;9164:1;9893:40;;9889:122;;;9983:16;;9956:44;;;;;;;;;;;;:::i;9889:122::-;-1:-1:-1;;10158:37:0;10153:3;10149:47;;9787:425::o;10440:280::-;10516:14;;9164:1;10546:40;;10542:122;;;10636:16;;10609:44;;;;;;;;;;;;:::i;10542:122::-;10680:33;:16;9164:1;10680:16;;:33;:::i;:::-;10673:40;;;;10440:280;;;;;;:::o;61189:411::-;-1:-1:-1;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;61424:69:0;;;;;;:::i;:::-;61396:12;;;61339:154;61382:12;;;61339:154;61364:16;;;61339:154;61348:14;;;61339:154;;-1:-1:-1;61571:22:0;61339:154;62757:3;62728:32;;;;62820:3;62791:32;;;;62880:2;62851:31;;;;62531:415;61571:22;61503:90;;;;61552:15;;;61503:90;;;;61538:12;;;61503:90;;;;61521:15;;;61503:90;;;;-1:-1:-1;61504:4:0;61189:411;-1:-1:-1;;61189:411:0:o;10888:496::-;10972:14;9164:1;11002:16;:23;:40;10998:122;;;11092:16;11065:44;;;;;;;;;;;:::i;10998:122::-;-1:-1:-1;11361:4:0;11339:27;11333:34;11328:3;11324:44;;10888:496::o;11698:1053::-;11782:20;9164:1;11818:16;:23;:40;11814:122;;;11908:16;11881:44;;;;;;;;;;;:::i;11814:122::-;12094:23;;:40;;;12164:17;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;12164:17:0;;12154:27;;12305:8;12641:6;12634:4;12625:7;12621:18;12613:6;12606:4;12588:16;12584:27;12578:4;12571:5;12560:88;12553:95;;12672:3;12667:78;;12698:36;;;;;;;;;;;;;;12667:78;11804:947;;11698:1053;;;:::o;48927:610::-;-1:-1:-1;;;;;;;;;;;;;;;;;49026:14:0;49043:27;:4;:25;:27::i;:::-;49026:44;-1:-1:-1;48692:1:0;49084:23;;;;49080:100;;;49130:39;;;;;7345:6:1;7333:19;;49130:39:0;;;7315:38:1;7288:18;;49130:39:0;7171:188:1;95201:730:0;95441:26;;95483:442;95507:15;:22;95503:1;:26;95483:442;;;95550:19;95586:13;95572:46;;;95619:15;95635:1;95619:18;;;;;;;;:::i;:::-;;;;;;;95639:7;95648:5;;95572:82;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;95550:104;-1:-1:-1;95792:16:0;;;;;:68;;-1:-1:-1;95845:15:0;95812:30;95826:16;95812:11;:30;:::i;:::-;:48;95792:68;95788:127;;;95880:20;;;:::i;:::-;;;95788:127;-1:-1:-1;95531:3:0;;;:::i;:::-;;;95483:442;;;;95201:730;;;;;;;:::o;60063:705::-;-1:-1:-1;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;60408:353:0;;;;;;;;60456:32;60474:13;60456:17;:32::i;:::-;60408:353;;;;;;60576:10;60408:353;;;;;;60647:7;60408:353;;;;;;60680:10;60408:353;;;;;;60513:37;60540:9;8729:22;;;8632:127;60513:37;60408:353;;;;60613:11;60408:353;;;;60713:7;60408:353;;;;60743:7;60408:353;;;60401:360;;60063:705;;;;;;;;;:::o;27018:213::-;27074:6;27104:16;27096:24;;27092:103;;;27174:2;27143:41;;;;;;;;28036:36:1;;;;28088:18;;;28081:34;;;28009:18;;27143:41:0;27855:266:1;27092:103:0;-1:-1:-1;27218:5:0;27018:213::o;14:347:1:-;65:8;75:6;129:3;122:4;114:6;110:17;106:27;96:55;;147:1;144;137:12;96:55;-1:-1:-1;170:20:1;;213:18;202:30;;199:50;;;245:1;242;235:12;199:50;282:4;274:6;270:17;258:29;;334:3;327:4;318:6;310;306:19;302:30;299:39;296:59;;;351:1;348;341:12;366:367;429:8;439:6;493:3;486:4;478:6;474:17;470:27;460:55;;511:1;508;501:12;460:55;-1:-1:-1;534:20:1;;577:18;566:30;;563:50;;;609:1;606;599:12;563:50;646:4;638:6;634:17;622:29;;706:3;699:4;689:6;686:1;682:14;674:6;670:27;666:38;663:47;660:67;;;723:1;720;713:12;738:745;844:6;852;860;868;921:2;909:9;900:7;896:23;892:32;889:52;;;937:1;934;927:12;889:52;977:9;964:23;1006:18;1047:2;1039:6;1036:14;1033:34;;;1063:1;1060;1053:12;1033:34;1102:58;1152:7;1143:6;1132:9;1128:22;1102:58;:::i;:::-;1179:8;;-1:-1:-1;1076:84:1;-1:-1:-1;1267:2:1;1252:18;;1239:32;;-1:-1:-1;1283:16:1;;;1280:36;;;1312:1;1309;1302:12;1280:36;;1351:72;1415:7;1404:8;1393:9;1389:24;1351:72;:::i;:::-;738:745;;;;-1:-1:-1;1442:8:1;-1:-1:-1;;;;738:745:1:o;1680:129::-;1765:18;1758:5;1754:30;1747:5;1744:41;1734:69;;1799:1;1796;1789:12;1814:132;1881:20;;1910:30;1881:20;1910:30;:::i;1951:245::-;2009:6;2062:2;2050:9;2041:7;2037:23;2033:32;2030:52;;;2078:1;2075;2068:12;2030:52;2117:9;2104:23;2136:30;2160:5;2136:30;:::i;2614:154::-;2700:42;2693:5;2689:54;2682:5;2679:65;2669:93;;2758:1;2755;2748:12;2773:247;2832:6;2885:2;2873:9;2864:7;2860:23;2856:32;2853:52;;;2901:1;2898;2891:12;2853:52;2940:9;2927:23;2959:31;2984:5;2959:31;:::i;3025:1450::-;3177:6;3185;3193;3201;3209;3217;3225;3233;3241;3294:3;3282:9;3273:7;3269:23;3265:33;3262:53;;;3311:1;3308;3301:12;3262:53;3350:9;3337:23;3369:30;3393:5;3369:30;:::i;:::-;3418:5;-1:-1:-1;3475:2:1;3460:18;;3447:32;3488:33;3447:32;3488:33;:::i;:::-;3540:7;-1:-1:-1;3599:2:1;3584:18;;3571:32;3612:33;3571:32;3612:33;:::i;:::-;3664:7;-1:-1:-1;3722:2:1;3707:18;;3694:32;3745:18;3775:14;;;3772:34;;;3802:1;3799;3792:12;3772:34;3841:70;3903:7;3894:6;3883:9;3879:22;3841:70;:::i;:::-;3930:8;;-1:-1:-1;3815:96:1;-1:-1:-1;4018:3:1;4003:19;;3990:33;;-1:-1:-1;4035:16:1;;;4032:36;;;4064:1;4061;4054:12;4032:36;4103:60;4155:7;4144:8;4133:9;4129:24;4103:60;:::i;:::-;4182:8;;-1:-1:-1;4077:86:1;-1:-1:-1;4270:3:1;4255:19;;4242:33;;-1:-1:-1;4287:16:1;;;4284:36;;;4316:1;4313;4306:12;4284:36;;4355:60;4407:7;4396:8;4385:9;4381:24;4355:60;:::i;:::-;4329:86;;4434:8;4424:18;;;4461:8;4451:18;;;3025:1450;;;;;;;;;;;:::o;4971:813::-;5086:6;5094;5102;5110;5118;5171:2;5159:9;5150:7;5146:23;5142:32;5139:52;;;5187:1;5184;5177:12;5139:52;5223:9;5210:23;5200:33;;5284:2;5273:9;5269:18;5256:32;5307:18;5348:2;5340:6;5337:14;5334:34;;;5364:1;5361;5354:12;5334:34;5403:58;5453:7;5444:6;5433:9;5429:22;5403:58;:::i;:::-;5480:8;;-1:-1:-1;5377:84:1;-1:-1:-1;5568:2:1;5553:18;;5540:32;;-1:-1:-1;5584:16:1;;;5581:36;;;5613:1;5610;5603:12;5581:36;;5652:72;5716:7;5705:8;5694:9;5690:24;5652:72;:::i;:::-;4971:813;;;;-1:-1:-1;4971:813:1;;-1:-1:-1;5743:8:1;;5626:98;4971:813;-1:-1:-1;;;4971:813:1:o;5789:1377::-;5941:6;5949;5957;5965;5973;5981;5989;5997;6005;6058:3;6046:9;6037:7;6033:23;6029:33;6026:53;;;6075:1;6072;6065:12;6026:53;6114:9;6101:23;6133:30;6157:5;6133:30;:::i;:::-;6182:5;-1:-1:-1;6234:2:1;6219:18;;6206:32;;-1:-1:-1;6290:2:1;6275:18;;6262:32;6303:33;6262:32;6303:33;:::i;7364:184::-;7416:77;7413:1;7406:88;7513:4;7510:1;7503:15;7537:4;7534:1;7527:15;7553:255;7625:2;7619:9;7667:6;7655:19;;7704:18;7689:34;;7725:22;;;7686:62;7683:88;;;7751:18;;:::i;:::-;7787:2;7780:22;7553:255;:::o;7813:334::-;7884:2;7878:9;7940:2;7930:13;;-1:-1:-1;;7926:86:1;7914:99;;8043:18;8028:34;;8064:22;;;8025:62;8022:88;;;8090:18;;:::i;:::-;8126:2;8119:22;7813:334;;-1:-1:-1;7813:334:1:o;8152:245::-;8200:4;8233:18;8225:6;8222:30;8219:56;;;8255:18;;:::i;:::-;-1:-1:-1;8312:2:1;8300:15;-1:-1:-1;;8296:88:1;8386:4;8292:99;;8152:245::o;8402:462::-;8444:5;8497:3;8490:4;8482:6;8478:17;8474:27;8464:55;;8515:1;8512;8505:12;8464:55;8551:6;8538:20;8582:48;8598:31;8626:2;8598:31;:::i;:::-;8582:48;:::i;:::-;8655:2;8646:7;8639:19;8701:3;8694:4;8689:2;8681:6;8677:15;8673:26;8670:35;8667:55;;;8718:1;8715;8708:12;8667:55;8783:2;8776:4;8768:6;8764:17;8757:4;8748:7;8744:18;8731:55;8831:1;8806:16;;;8824:4;8802:27;8795:38;;;;8810:7;8402:462;-1:-1:-1;;;8402:462:1:o;8869:1172::-;8967:6;9020:2;9008:9;8999:7;8995:23;8991:32;8988:52;;;9036:1;9033;9026:12;8988:52;9076:9;9063:23;9105:18;9146:2;9138:6;9135:14;9132:34;;;9162:1;9159;9152:12;9132:34;9185:22;;;;9241:6;9223:16;;;9219:29;9216:49;;;9261:1;9258;9251:12;9216:49;9287:22;;:::i;:::-;9332:21;9350:2;9332:21;:::i;:::-;9325:5;9318:36;9386:30;9412:2;9408;9404:11;9386:30;:::i;:::-;9381:2;9374:5;9370:14;9363:54;9449:30;9475:2;9471;9467:11;9449:30;:::i;:::-;9444:2;9437:5;9433:14;9426:54;9512:30;9538:2;9534;9530:11;9512:30;:::i;:::-;9507:2;9500:5;9496:14;9489:54;9597:3;9593:2;9589:12;9576:26;9570:3;9563:5;9559:15;9552:51;9657:3;9653:2;9649:12;9636:26;9630:3;9623:5;9619:15;9612:51;9709:3;9705:2;9701:12;9688:26;9739:2;9729:8;9726:16;9723:36;;;9755:1;9752;9745:12;9723:36;9792:44;9828:7;9817:8;9813:2;9809:17;9792:44;:::i;:::-;9786:3;9779:5;9775:15;9768:69;;9883:3;9879:2;9875:12;9862:26;9913:2;9903:8;9900:16;9897:36;;;9929:1;9926;9919:12;9897:36;9966:44;10002:7;9991:8;9987:2;9983:17;9966:44;:::i;:::-;9960:3;9949:15;;9942:69;-1:-1:-1;9953:5:1;8869:1172;-1:-1:-1;;;;;8869:1172:1:o;10046:250::-;10131:1;10141:113;10155:6;10152:1;10149:13;10141:113;;;10231:11;;;10225:18;10212:11;;;10205:39;10177:2;10170:10;10141:113;;;-1:-1:-1;;10288:1:1;10270:16;;10263:27;10046:250::o;10301:329::-;10342:3;10380:5;10374:12;10407:6;10402:3;10395:19;10423:76;10492:6;10485:4;10480:3;10476:14;10469:4;10462:5;10458:16;10423:76;:::i;:::-;10544:2;10532:15;-1:-1:-1;;10528:88:1;10519:98;;;;10619:4;10515:109;;10301:329;-1:-1:-1;;10301:329:1:o;10635:217::-;10782:2;10771:9;10764:21;10745:4;10802:44;10842:2;10831:9;10827:18;10819:6;10802:44;:::i;10857:180::-;10916:6;10969:2;10957:9;10948:7;10944:23;10940:32;10937:52;;;10985:1;10982;10975:12;10937:52;-1:-1:-1;11008:23:1;;10857:180;-1:-1:-1;10857:180:1:o;11346:1089::-;11478:6;11486;11494;11502;11510;11518;11526;11579:3;11567:9;11558:7;11554:23;11550:33;11547:53;;;11596:1;11593;11586:12;11547:53;11635:9;11622:23;11654:30;11678:5;11654:30;:::i;:::-;11703:5;-1:-1:-1;11760:2:1;11745:18;;11732:32;11773:33;11732:32;11773:33;:::i;:::-;11825:7;-1:-1:-1;11883:2:1;11868:18;;11855:32;11906:18;11936:14;;;11933:34;;;11963:1;11960;11953:12;11933:34;12002:70;12064:7;12055:6;12044:9;12040:22;12002:70;:::i;:::-;12091:8;;-1:-1:-1;11976:96:1;-1:-1:-1;12179:2:1;12164:18;;12151:32;;-1:-1:-1;12195:16:1;;;12192:36;;;12224:1;12221;12214:12;12192:36;;12263:60;12315:7;12304:8;12293:9;12289:24;12263:60;:::i;:::-;11346:1089;;;;-1:-1:-1;11346:1089:1;;;;;;12424:3;12409:19;;;12396:33;;11346:1089;-1:-1:-1;;;;11346:1089:1:o;12622:320::-;12690:6;12743:2;12731:9;12722:7;12718:23;12714:32;12711:52;;;12759:1;12756;12749:12;12711:52;12799:9;12786:23;12832:18;12824:6;12821:30;12818:50;;;12864:1;12861;12854:12;12818:50;12887:49;12928:7;12919:6;12908:9;12904:22;12887:49;:::i;13253:313::-;13320:6;13328;13381:2;13369:9;13360:7;13356:23;13352:32;13349:52;;;13397:1;13394;13387:12;13349:52;13436:9;13423:23;13455:30;13479:5;13455:30;:::i;:::-;13504:5;13556:2;13541:18;;;;13528:32;;-1:-1:-1;;;13253:313:1:o;13571:409::-;13641:6;13649;13702:2;13690:9;13681:7;13677:23;13673:32;13670:52;;;13718:1;13715;13708:12;13670:52;13758:9;13745:23;13791:18;13783:6;13780:30;13777:50;;;13823:1;13820;13813:12;13777:50;13862:58;13912:7;13903:6;13892:9;13888:22;13862:58;:::i;:::-;13939:8;;13836:84;;-1:-1:-1;13571:409:1;-1:-1:-1;;;;13571:409:1:o;13985:271::-;14168:6;14160;14155:3;14142:33;14124:3;14194:16;;14219:13;;;14194:16;13985:271;-1:-1:-1;13985:271:1:o;14719:562::-;14935:4;14964:18;15021:2;15013:6;15009:15;14998:9;14991:34;15061:6;15056:2;15045:9;15041:18;15034:34;15116:2;15108:6;15104:15;15099:2;15088:9;15084:18;15077:43;15168:2;15160:6;15156:15;15151:2;15140:9;15136:18;15129:43;;15209:3;15203;15192:9;15188:19;15181:32;15230:45;15270:3;15259:9;15255:19;15247:6;15230:45;:::i;15935:381::-;16012:6;16020;16073:2;16061:9;16052:7;16048:23;16044:32;16041:52;;;16089:1;16086;16079:12;16041:52;16121:9;16115:16;16140:30;16164:5;16140:30;:::i;:::-;16239:2;16224:18;;16218:25;16189:5;;-1:-1:-1;16252:32:1;16218:25;16252:32;:::i;:::-;16303:7;16293:17;;;15935:381;;;;;:::o;16321:545::-;16421:6;16416:3;16409:19;16391:3;16447:4;16476:2;16471:3;16467:12;16460:19;;16502:5;16525:1;16535:306;16549:6;16546:1;16543:13;16535:306;;;16626:6;16613:20;16646:33;16671:7;16646:33;:::i;:::-;16717:42;16704:56;16692:69;;16781:12;;;;16816:15;;;;16571:1;16564:9;16535:306;;;-1:-1:-1;16857:3:1;;16321:545;-1:-1:-1;;;;;16321:545:1:o;16871:382::-;17098:18;17090:6;17086:31;17075:9;17068:50;17154:2;17149;17138:9;17134:18;17127:30;17049:4;17174:73;17243:2;17232:9;17228:18;17220:6;17212;17174:73;:::i;:::-;17166:81;16871:382;-1:-1:-1;;;;;16871:382:1:o;17258:184::-;17328:6;17381:2;17369:9;17360:7;17356:23;17352:32;17349:52;;;17397:1;17394;17387:12;17349:52;-1:-1:-1;17420:16:1;;17258:184;-1:-1:-1;17258:184:1:o;17447:325::-;17535:6;17530:3;17523:19;17587:6;17580:5;17573:4;17568:3;17564:14;17551:43;;17639:1;17632:4;17623:6;17618:3;17614:16;17610:27;17603:38;17505:3;17761:4;-1:-1:-1;;17686:2:1;17678:6;17674:15;17670:88;17665:3;17661:98;17657:109;17650:116;;17447:325;;;;:::o;17777:409::-;18000:18;17992:6;17988:31;17977:9;17970:50;18056:6;18051:2;18040:9;18036:18;18029:34;18099:2;18094;18083:9;18079:18;18072:30;17951:4;18119:61;18176:2;18165:9;18161:18;18153:6;18145;18119:61;:::i;:::-;18111:69;17777:409;-1:-1:-1;;;;;;17777:409:1:o;18191:184::-;18243:77;18240:1;18233:88;18340:4;18337:1;18330:15;18364:4;18361:1;18354:15;18380:125;18445:9;;;18466:10;;;18463:36;;;18479:18;;:::i;18786:475::-;18853:5;18901:4;18889:9;18884:3;18880:19;18876:30;18873:50;;;18919:1;18916;18909:12;18873:50;18952:4;18946:11;18996:4;18988:6;18984:17;19067:6;19055:10;19052:22;19031:18;19019:10;19016:34;19013:62;19010:88;;;19078:18;;:::i;:::-;19114:4;19107:24;19179:16;;19164:32;;19250:2;19235:18;;;19229:25;19212:15;;;19205:50;;;;-1:-1:-1;19149:6:1;18786:475;-1:-1:-1;18786:475:1:o;19266:253::-;19363:6;19416:2;19404:9;19395:7;19391:23;19387:32;19384:52;;;19432:1;19429;19422:12;19384:52;19455:58;19505:7;19494:9;19455:58;:::i;19524:1527::-;19637:6;19645;19698:2;19686:9;19677:7;19673:23;19669:32;19666:52;;;19714:1;19711;19704:12;19666:52;19747:9;19741:16;19776:18;19817:2;19809:6;19806:14;19803:34;;;19833:1;19830;19823:12;19803:34;19871:6;19860:9;19856:22;19846:32;;19916:7;19909:4;19905:2;19901:13;19897:27;19887:55;;19938:1;19935;19928:12;19887:55;19967:2;19961:9;19989:4;20015:48;20031:31;20059:2;20031:31;:::i;20015:48::-;20086:2;20079:5;20072:17;20126:7;20121:2;20116;20112;20108:11;20104:20;20101:33;20098:53;;;20147:1;20144;20137:12;20098:53;20160:67;20224:2;20219;20212:5;20208:14;20203:2;20199;20195:11;20160:67;:::i;:::-;20282:18;;;20276:25;20246:5;;-1:-1:-1;20276:25:1;-1:-1:-1;20313:16:1;;;20310:36;;;20342:1;20339;20332:12;20310:36;20380:8;20369:9;20365:24;20355:34;;20427:7;20420:4;20416:2;20412:13;20408:27;20398:55;;20449:1;20446;20439:12;20398:55;20478:2;20472:9;20462:19;;20500:2;20496;20493:10;20490:36;;;20506:18;;:::i;:::-;20552:2;20549:1;20545:10;20535:20;;20575:28;20599:2;20595;20591:11;20575:28;:::i;:::-;20637:15;;;20707:11;;;20703:20;;;20668:12;;;;20735:19;;;20732:39;;;20767:1;20764;20757:12;20732:39;20791:11;;;;20811:210;20827:6;20822:3;20819:15;20811:210;;;20900:3;20894:10;20881:23;;20917:31;20942:5;20917:31;:::i;:::-;20961:18;;;20844:12;;;;20999;;;;20811:210;;;21040:5;21030:15;;;;;;;;19524:1527;;;;;:::o;21056:453::-;21311:18;21303:6;21299:31;21288:9;21281:50;21367:6;21362:2;21351:9;21347:18;21340:34;21410:2;21405;21394:9;21390:18;21383:30;21262:4;21430:73;21499:2;21488:9;21484:18;21476:6;21468;21430:73;:::i;21514:184::-;21566:77;21563:1;21556:88;21663:4;21660:1;21653:15;21687:4;21684:1;21677:15;21703:554;21982:18;21974:6;21970:31;21959:9;21952:50;22038:6;22033:2;22022:9;22018:18;22011:34;22081:6;22076:2;22065:9;22061:18;22054:34;22124:6;22119:2;22108:9;22104:18;22097:34;22168:3;22162;22151:9;22147:19;22140:32;21933:4;22189:62;22246:3;22235:9;22231:19;22223:6;22215;22189:62;:::i;:::-;22181:70;21703:554;-1:-1:-1;;;;;;;;21703:554:1:o;22262:251::-;22332:6;22385:2;22373:9;22364:7;22360:23;22356:32;22353:52;;;22401:1;22398;22391:12;22353:52;22433:9;22427:16;22452:31;22477:5;22452:31;:::i;22914:760::-;23257:18;23249:6;23245:31;23234:9;23227:50;23313:6;23308:2;23297:9;23293:18;23286:34;23356:6;23351:2;23340:9;23336:18;23329:34;23399:6;23394:2;23383:9;23379:18;23372:34;23443:6;23437:3;23426:9;23422:19;23415:35;23487:3;23481;23470:9;23466:19;23459:32;23208:4;23514:45;23554:3;23543:9;23539:19;23531:6;23514:45;:::i;:::-;23608:9;23600:6;23596:22;23590:3;23579:9;23575:19;23568:51;23636:32;23661:6;23653;23636:32;:::i;23679:624::-;23987:6;23976:9;23969:25;24030:6;24025:2;24014:9;24010:18;24003:34;24073:6;24068:2;24057:9;24053:18;24046:34;24116:3;24111:2;24100:9;24096:18;24089:31;23950:4;24143:45;24183:3;24172:9;24168:19;24160:6;24143:45;:::i;:::-;24237:9;24229:6;24225:22;24219:3;24208:9;24204:19;24197:51;24265:32;24290:6;24282;24265:32;:::i;24308:440::-;24515:66;24506:6;24501:3;24497:16;24493:89;24488:3;24481:102;24463:3;24612:6;24606:13;24628:74;24695:6;24691:1;24686:3;24682:11;24675:4;24667:6;24663:17;24628:74;:::i;:::-;24722:16;;;;24740:1;24718:24;;24308:440;-1:-1:-1;;;24308:440:1:o;24753:244::-;24910:2;24899:9;24892:21;24873:4;24930:61;24987:2;24976:9;24972:18;24964:6;24956;24930:61;:::i;25002:331::-;25107:9;25118;25160:8;25148:10;25145:24;25142:44;;;25182:1;25179;25172:12;25142:44;25211:6;25201:8;25198:20;25195:40;;;25231:1;25228;25221:12;25195:40;-1:-1:-1;;25257:23:1;;;25302:25;;;;;-1:-1:-1;25002:331:1:o;25338:776::-;25482:6;25490;25498;25506;25514;25567:3;25555:9;25546:7;25542:23;25538:33;25535:53;;;25584:1;25581;25574:12;25535:53;25620:9;25607:23;25597:33;;25677:2;25666:9;25662:18;25649:32;25639:42;;25728:2;25717:9;25713:18;25700:32;25690:42;;25783:2;25772:9;25768:18;25755:32;25806:18;25847:2;25839:6;25836:14;25833:34;;;25863:1;25860;25853:12;25833:34;25886:49;25927:7;25918:6;25907:9;25903:22;25886:49;:::i;:::-;25876:59;;25988:3;25977:9;25973:19;25960:33;25944:49;;26018:2;26008:8;26005:16;26002:36;;;26034:1;26031;26024:12;26002:36;;26057:51;26100:7;26089:8;26078:9;26074:24;26057:51;:::i;:::-;26047:61;;;25338:776;;;;;;;;:::o;26379:184::-;26431:77;26428:1;26421:88;26528:4;26525:1;26518:15;26552:4;26549:1;26542:15;26568:1082;26891:42;26883:6;26879:55;26868:9;26861:74;26842:4;26954:18;27027:2;27018:6;27012:13;27008:22;27003:2;26992:9;26988:18;26981:50;27095:2;27089;27081:6;27077:15;27071:22;27067:31;27062:2;27051:9;27047:18;27040:59;27163:2;27157;27149:6;27145:15;27139:22;27135:31;27130:2;27119:9;27115:18;27108:59;;27222:2;27214:6;27210:15;27204:22;27198:3;27187:9;27183:19;27176:51;27282:3;27274:6;27270:16;27264:23;27258:3;27247:9;27243:19;27236:52;27325:3;27319;27308:9;27304:19;27297:32;27366:6;27360:3;27349:9;27345:19;27338:35;27392:3;27418:66;27410:6;27407:78;27404:98;;;27498:1;27495;27488:12;27404:98;27532:6;27529:1;27525:14;27589:6;27581;27576:2;27565:9;27561:18;27548:48;27617:22;;;;27613:31;;;;26568:1082;-1:-1:-1;;;;;26568:1082:1:o;27655:195::-;27694:3;27725:66;27718:5;27715:77;27712:103;;27795:18;;:::i;:::-;-1:-1:-1;27842:1:1;27831:13;;27655:195::o","abiDefinition":[{"inputs":[{"internalType":"address","name":"interchainDB","type":"address"},{"internalType":"address","name":"owner_","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"inputs":[{"internalType":"uint16","name":"version","type":"uint16"}],"name":"AppConfigLib__IncorrectVersion","type":"error"},{"inputs":[{"internalType":"uint256","name":"actual","type":"uint256"},{"internalType":"uint256","name":"required","type":"uint256"}],"name":"InterchainClientV1__FeeAmountTooLow","type":"error"},{"inputs":[{"internalType":"uint64","name":"chainId","type":"uint64"}],"name":"InterchainClientV1__IncorrectDstChainId","type":"error"},{"inputs":[{"internalType":"uint256","name":"actual","type":"uint256"},{"internalType":"uint256","name":"required","type":"uint256"}],"name":"InterchainClientV1__IncorrectMsgValue","type":"error"},{"inputs":[{"internalType":"uint16","name":"version","type":"uint16"}],"name":"InterchainClientV1__InvalidTransactionVersion","type":"error"},{"inputs":[{"internalType":"uint64","name":"chainId","type":"uint64"}],"name":"InterchainClientV1__NoLinkedClient","type":"error"},{"inputs":[{"internalType":"bytes32","name":"client","type":"bytes32"}],"name":"InterchainClientV1__NotEVMClient","type":"error"},{"inputs":[],"name":"InterchainClientV1__NotEnoughGasSupplied","type":"error"},{"inputs":[{"internalType":"uint256","name":"actual","type":"uint256"},{"internalType":"uint256","name":"required","type":"uint256"}],"name":"InterchainClientV1__NotEnoughResponses","type":"error"},{"inputs":[{"internalType":"uint64","name":"chainId","type":"uint64"}],"name":"InterchainClientV1__NotRemoteChainId","type":"error"},{"inputs":[{"internalType":"bytes32","name":"transactionId","type":"bytes32"}],"name":"InterchainClientV1__TxAlreadyExecuted","type":"error"},{"inputs":[{"internalType":"bytes32","name":"transactionId","type":"bytes32"}],"name":"InterchainClientV1__TxNotExecuted","type":"error"},{"inputs":[],"name":"InterchainClientV1__ZeroReceiver","type":"error"},{"inputs":[],"name":"InterchainClientV1__ZeroRequiredResponses","type":"error"},{"inputs":[{"internalType":"uint16","name":"version","type":"uint16"}],"name":"OptionsLib__IncorrectVersion","type":"error"},{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"OwnableInvalidOwner","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"OwnableUnauthorizedAccount","type":"error"},{"inputs":[{"internalType":"uint8","name":"bits","type":"uint8"},{"internalType":"uint256","name":"value","type":"uint256"}],"name":"SafeCastOverflowedUintDowncast","type":"error"},{"inputs":[],"name":"VersionedPayload__PrecompileFailed","type":"error"},{"inputs":[{"internalType":"bytes","name":"versionedPayload","type":"bytes"}],"name":"VersionedPayload__TooShort","type":"error"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"executionFees","type":"address"}],"name":"ExecutionFeesSet","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"indexed":true,"internalType":"uint64","name":"dbNonce","type":"uint64"},{"indexed":true,"internalType":"uint64","name":"entryIndex","type":"uint64"},{"indexed":false,"internalType":"address","name":"executor","type":"address"}],"name":"ExecutionProofWritten","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"indexed":true,"internalType":"uint64","name":"dbNonce","type":"uint64"},{"indexed":true,"internalType":"uint64","name":"entryIndex","type":"uint64"},{"indexed":false,"internalType":"uint64","name":"srcChainId","type":"uint64"},{"indexed":false,"internalType":"bytes32","name":"srcSender","type":"bytes32"},{"indexed":false,"internalType":"bytes32","name":"dstReceiver","type":"bytes32"}],"name":"InterchainTransactionReceived","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"indexed":true,"internalType":"uint64","name":"dbNonce","type":"uint64"},{"indexed":true,"internalType":"uint64","name":"entryIndex","type":"uint64"},{"indexed":false,"internalType":"uint64","name":"dstChainId","type":"uint64"},{"indexed":false,"internalType":"bytes32","name":"srcSender","type":"bytes32"},{"indexed":false,"internalType":"bytes32","name":"dstReceiver","type":"bytes32"},{"indexed":false,"internalType":"uint256","name":"verificationFee","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"executionFee","type":"uint256"},{"indexed":false,"internalType":"bytes","name":"options","type":"bytes"},{"indexed":false,"internalType":"bytes","name":"message","type":"bytes"}],"name":"InterchainTransactionSent","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint64","name":"chainId","type":"uint64"},{"indexed":false,"internalType":"bytes32","name":"client","type":"bytes32"}],"name":"LinkedClientSet","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"inputs":[],"name":"CLIENT_VERSION","outputs":[{"internalType":"uint16","name":"","type":"uint16"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"INTERCHAIN_DB","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes","name":"encodedOptions","type":"bytes"}],"name":"decodeOptions","outputs":[{"components":[{"internalType":"uint256","name":"gasLimit","type":"uint256"},{"internalType":"uint256","name":"gasAirdrop","type":"uint256"}],"internalType":"struct OptionsV1","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[{"components":[{"internalType":"uint64","name":"srcChainId","type":"uint64"},{"internalType":"uint64","name":"dstChainId","type":"uint64"},{"internalType":"uint64","name":"dbNonce","type":"uint64"},{"internalType":"uint64","name":"entryIndex","type":"uint64"},{"internalType":"bytes32","name":"srcSender","type":"bytes32"},{"internalType":"bytes32","name":"dstReceiver","type":"bytes32"},{"internalType":"bytes","name":"options","type":"bytes"},{"internalType":"bytes","name":"message","type":"bytes"}],"internalType":"struct InterchainTransaction","name":"icTx","type":"tuple"}],"name":"encodeTransaction","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"executionFees","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes","name":"encodedTx","type":"bytes"}],"name":"getExecutor","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"transactionId","type":"bytes32"}],"name":"getExecutorById","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint64","name":"dstChainId","type":"uint64"},{"internalType":"address","name":"srcExecutionService","type":"address"},{"internalType":"address[]","name":"srcModules","type":"address[]"},{"internalType":"bytes","name":"options","type":"bytes"},{"internalType":"uint256","name":"messageLen","type":"uint256"}],"name":"getInterchainFee","outputs":[{"internalType":"uint256","name":"fee","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint64","name":"chainId","type":"uint64"}],"name":"getLinkedClient","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint64","name":"chainId","type":"uint64"}],"name":"getLinkedClientEVM","outputs":[{"internalType":"address","name":"linkedClientEVM","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"gasLimit","type":"uint256"},{"internalType":"bytes","name":"transaction","type":"bytes"},{"internalType":"bytes32[]","name":"proof","type":"bytes32[]"}],"name":"interchainExecute","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint64","name":"dstChainId","type":"uint64"},{"internalType":"bytes32","name":"receiver","type":"bytes32"},{"internalType":"address","name":"srcExecutionService","type":"address"},{"internalType":"address[]","name":"srcModules","type":"address[]"},{"internalType":"bytes","name":"options","type":"bytes"},{"internalType":"bytes","name":"message","type":"bytes"}],"name":"interchainSend","outputs":[{"components":[{"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"internalType":"uint64","name":"dbNonce","type":"uint64"},{"internalType":"uint64","name":"entryIndex","type":"uint64"}],"internalType":"struct InterchainTxDescriptor","name":"desc","type":"tuple"}],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint64","name":"dstChainId","type":"uint64"},{"internalType":"address","name":"receiver","type":"address"},{"internalType":"address","name":"srcExecutionService","type":"address"},{"internalType":"address[]","name":"srcModules","type":"address[]"},{"internalType":"bytes","name":"options","type":"bytes"},{"internalType":"bytes","name":"message","type":"bytes"}],"name":"interchainSendEVM","outputs":[{"components":[{"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"internalType":"uint64","name":"dbNonce","type":"uint64"},{"internalType":"uint64","name":"entryIndex","type":"uint64"}],"internalType":"struct InterchainTxDescriptor","name":"desc","type":"tuple"}],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"bytes","name":"encodedTx","type":"bytes"},{"internalType":"bytes32[]","name":"proof","type":"bytes32[]"}],"name":"isExecutable","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"executionFees_","type":"address"}],"name":"setExecutionFees","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint64","name":"chainId","type":"uint64"},{"internalType":"bytes32","name":"client","type":"bytes32"}],"name":"setLinkedClient","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"transactionId","type":"bytes32"}],"name":"writeExecutionProof","outputs":[{"internalType":"uint64","name":"dbNonce","type":"uint64"},{"internalType":"uint64","name":"entryIndex","type":"uint64"}],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{"CLIENT_VERSION()":{"notice":"Version of the InterchainClient contract. Sent and received transactions must have the same version."},"INTERCHAIN_DB()":{"notice":"Address of the InterchainDB contract, set at the time of deployment."},"decodeOptions(bytes)":{"notice":"Decodes the encoded options data into a OptionsV1 struct."},"encodeTransaction((uint64,uint64,uint64,uint64,bytes32,bytes32,bytes,bytes))":{"notice":"Encodes the transaction data into a bytes format."},"executionFees()":{"notice":"Address of the contract that handles execution fees. Can be updated by the owner."},"getExecutorById(bytes32)":{"notice":"Returns the address of the executor for a transaction that has been sent to the local chain."},"getInterchainFee(uint64,address,address[],bytes,uint256)":{"notice":"Returns the fee for sending an Interchain message."},"getLinkedClient(uint64)":{"notice":"Returns the address of the linked client (as bytes32) for a specific chain ID."},"getLinkedClientEVM(uint64)":{"notice":"Returns the EVM address of the linked client for a specific chain ID."},"interchainExecute(uint256,bytes,bytes32[])":{"notice":"Executes a transaction that has been sent via the Interchain."},"interchainSend(uint64,bytes32,address,address[],bytes,bytes)":{"notice":"Sends a message to another chain via the Interchain Communication Protocol."},"setExecutionFees(address)":{"notice":"Sets the address of the ExecutionFees contract."},"setLinkedClient(uint64,bytes32)":{"notice":"Sets the linked client for a specific chain ID."},"writeExecutionProof(bytes32)":{"notice":"Writes the proof of execution for a transaction into the InterchainDB."}},"version":1},"developerDoc":{"details":"Implements the operations of the Interchain Execution Layer.","errors":{"OwnableInvalidOwner(address)":[{"details":"The owner is not a valid owner account. (eg. `address(0)`)"}],"OwnableUnauthorizedAccount(address)":[{"details":"The caller account is not authorized to perform an operation."}],"SafeCastOverflowedUintDowncast(uint8,uint256)":[{"details":"Value doesn't fit in an uint of `bits` size."}]},"kind":"dev","methods":{"getInterchainFee(uint64,address,address[],bytes,uint256)":{"params":{"dstChainId":"The chain ID of the destination chain.","messageLen":"The length of the message being sent.","options":"Execution options for the message sent, currently gas limit + native gas drop.","srcExecutionService":"The address of the execution service to use for the message.","srcModules":"The source modules involved in the message sending."}},"getLinkedClient(uint64)":{"details":"Will return 0x0 if no client is linked for the chain ID."},"getLinkedClientEVM(uint64)":{"details":"Will return 0x0 if no client is linked for the chain ID. Will revert if the client is not an EVM client."},"interchainExecute(uint256,bytes,bytes32[])":{"details":"The transaction must have been previously sent and recorded. Transaction data includes the requested gas limit, but the executors could specify a different gas limit. If the specified gas limit is lower than requested, the requested gas limit will be used. Otherwise, the specified gas limit will be used. This allows to execute the transactions with requested gas limit set too low.","params":{"gasLimit":"The gas limit to use for the execution.","proof":"The Merkle proof for transaction execution, fetched from the source chain.","transaction":"The transaction data."}},"interchainSend(uint64,bytes32,address,address[],bytes,bytes)":{"details":"Charges a fee for the message, which is payable upon calling this function: - Verification fees: paid to every module that verifies the message. - Execution fee: paid to the executor that executes the message. Note: while a specific execution service is specified to request the execution of the message, any executor is able to execute the message on destination chain, earning the execution fee.","params":{"dstChainId":"The chain ID of the destination chain.","message":"The message being sent.","options":"Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.","receiver":"The address of the receiver on the destination chain.","srcExecutionService":"The address of the execution service to use for the message.","srcModules":"The source modules involved in the message sending."},"returns":{"desc":"The descriptor of the sent transaction: - transactionId: the ID of the transaction that was sent. - dbNonce: the database nonce of the batch containing the written entry for transaction. - entryIndex: the index of the written entry for transaction within the batch."}},"owner()":{"details":"Returns the address of the current owner."},"renounceOwnership()":{"details":"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."},"setExecutionFees(address)":{"details":"Only callable by the contract owner or an authorized account.","params":{"executionFees_":"The address of the ExecutionFees contract."}},"setLinkedClient(uint64,bytes32)":{"details":"Stores the address of the linked client in a mapping with the chain ID as the key.","params":{"chainId":"The chain ID for which the client is being set.","client":"The address of the client being linked."}},"transferOwnership(address)":{"details":"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."},"writeExecutionProof(bytes32)":{"details":"Will revert if the transaction has not been executed.","params":{"transactionId":"The ID of the transaction to write the proof for."},"returns":{"dbNonce":"        The database nonce of the batch containing the written proof for transaction.","entryIndex":"     The index of the written proof for transaction within the batch."}}},"stateVariables":{"_linkedClient":{"details":"Address of the InterchainClient contract on the remote chain"},"_txExecutor":{"details":"Executor address that completed the transaction. Address(0) if not executed yet."}},"title":"InterchainClientV1","version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"interchainDB\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"version\",\"type\":\"uint16\"}],\"name\":\"AppConfigLib__IncorrectVersion\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"required\",\"type\":\"uint256\"}],\"name\":\"InterchainClientV1__FeeAmountTooLow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"}],\"name\":\"InterchainClientV1__IncorrectDstChainId\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"required\",\"type\":\"uint256\"}],\"name\":\"InterchainClientV1__IncorrectMsgValue\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"version\",\"type\":\"uint16\"}],\"name\":\"InterchainClientV1__InvalidTransactionVersion\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"}],\"name\":\"InterchainClientV1__NoLinkedClient\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"client\",\"type\":\"bytes32\"}],\"name\":\"InterchainClientV1__NotEVMClient\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InterchainClientV1__NotEnoughGasSupplied\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"required\",\"type\":\"uint256\"}],\"name\":\"InterchainClientV1__NotEnoughResponses\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"}],\"name\":\"InterchainClientV1__NotRemoteChainId\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"}],\"name\":\"InterchainClientV1__TxAlreadyExecuted\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"}],\"name\":\"InterchainClientV1__TxNotExecuted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InterchainClientV1__ZeroReceiver\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InterchainClientV1__ZeroRequiredResponses\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"version\",\"type\":\"uint16\"}],\"name\":\"OptionsLib__IncorrectVersion\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"bits\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"SafeCastOverflowedUintDowncast\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VersionedPayload__PrecompileFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"versionedPayload\",\"type\":\"bytes\"}],\"name\":\"VersionedPayload__TooShort\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"executionFees\",\"type\":\"address\"}],\"name\":\"ExecutionFeesSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"}],\"name\":\"ExecutionProofWritten\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"srcChainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"srcSender\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"dstReceiver\",\"type\":\"bytes32\"}],\"name\":\"InterchainTransactionReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"dstChainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"srcSender\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"dstReceiver\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"verificationFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"executionFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"options\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"InterchainTransactionSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"client\",\"type\":\"bytes32\"}],\"name\":\"LinkedClientSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CLIENT_VERSION\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INTERCHAIN_DB\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedOptions\",\"type\":\"bytes\"}],\"name\":\"decodeOptions\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasAirdrop\",\"type\":\"uint256\"}],\"internalType\":\"struct OptionsV1\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"srcChainId\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"dstChainId\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"srcSender\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"dstReceiver\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"options\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"internalType\":\"struct InterchainTransaction\",\"name\":\"icTx\",\"type\":\"tuple\"}],\"name\":\"encodeTransaction\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"executionFees\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedTx\",\"type\":\"bytes\"}],\"name\":\"getExecutor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"}],\"name\":\"getExecutorById\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"dstChainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"srcExecutionService\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"},{\"internalType\":\"bytes\",\"name\":\"options\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"messageLen\",\"type\":\"uint256\"}],\"name\":\"getInterchainFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"}],\"name\":\"getLinkedClient\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"}],\"name\":\"getLinkedClientEVM\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"linkedClientEVM\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"transaction\",\"type\":\"bytes\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"interchainExecute\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"dstChainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"receiver\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"srcExecutionService\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"},{\"internalType\":\"bytes\",\"name\":\"options\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"interchainSend\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"}],\"internalType\":\"struct InterchainTxDescriptor\",\"name\":\"desc\",\"type\":\"tuple\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"dstChainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"srcExecutionService\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"},{\"internalType\":\"bytes\",\"name\":\"options\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"interchainSendEVM\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"}],\"internalType\":\"struct InterchainTxDescriptor\",\"name\":\"desc\",\"type\":\"tuple\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedTx\",\"type\":\"bytes\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"isExecutable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"executionFees_\",\"type\":\"address\"}],\"name\":\"setExecutionFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"client\",\"type\":\"bytes32\"}],\"name\":\"setLinkedClient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"}],\"name\":\"writeExecutionProof\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Implements the operations of the Interchain Execution Layer.\",\"errors\":{\"OwnableInvalidOwner(address)\":[{\"details\":\"The owner is not a valid owner account. (eg. `address(0)`)\"}],\"OwnableUnauthorizedAccount(address)\":[{\"details\":\"The caller account is not authorized to perform an operation.\"}],\"SafeCastOverflowedUintDowncast(uint8,uint256)\":[{\"details\":\"Value doesn't fit in an uint of `bits` size.\"}]},\"kind\":\"dev\",\"methods\":{\"getInterchainFee(uint64,address,address[],bytes,uint256)\":{\"params\":{\"dstChainId\":\"The chain ID of the destination chain.\",\"messageLen\":\"The length of the message being sent.\",\"options\":\"Execution options for the message sent, currently gas limit + native gas drop.\",\"srcExecutionService\":\"The address of the execution service to use for the message.\",\"srcModules\":\"The source modules involved in the message sending.\"}},\"getLinkedClient(uint64)\":{\"details\":\"Will return 0x0 if no client is linked for the chain ID.\"},\"getLinkedClientEVM(uint64)\":{\"details\":\"Will return 0x0 if no client is linked for the chain ID. Will revert if the client is not an EVM client.\"},\"interchainExecute(uint256,bytes,bytes32[])\":{\"details\":\"The transaction must have been previously sent and recorded. Transaction data includes the requested gas limit, but the executors could specify a different gas limit. If the specified gas limit is lower than requested, the requested gas limit will be used. Otherwise, the specified gas limit will be used. This allows to execute the transactions with requested gas limit set too low.\",\"params\":{\"gasLimit\":\"The gas limit to use for the execution.\",\"proof\":\"The Merkle proof for transaction execution, fetched from the source chain.\",\"transaction\":\"The transaction data.\"}},\"interchainSend(uint64,bytes32,address,address[],bytes,bytes)\":{\"details\":\"Charges a fee for the message, which is payable upon calling this function: - Verification fees: paid to every module that verifies the message. - Execution fee: paid to the executor that executes the message. Note: while a specific execution service is specified to request the execution of the message, any executor is able to execute the message on destination chain, earning the execution fee.\",\"params\":{\"dstChainId\":\"The chain ID of the destination chain.\",\"message\":\"The message being sent.\",\"options\":\"Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\",\"receiver\":\"The address of the receiver on the destination chain.\",\"srcExecutionService\":\"The address of the execution service to use for the message.\",\"srcModules\":\"The source modules involved in the message sending.\"},\"returns\":{\"desc\":\"The descriptor of the sent transaction: - transactionId: the ID of the transaction that was sent. - dbNonce: the database nonce of the batch containing the written entry for transaction. - entryIndex: the index of the written entry for transaction within the batch.\"}},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner.\"},\"setExecutionFees(address)\":{\"details\":\"Only callable by the contract owner or an authorized account.\",\"params\":{\"executionFees_\":\"The address of the ExecutionFees contract.\"}},\"setLinkedClient(uint64,bytes32)\":{\"details\":\"Stores the address of the linked client in a mapping with the chain ID as the key.\",\"params\":{\"chainId\":\"The chain ID for which the client is being set.\",\"client\":\"The address of the client being linked.\"}},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"},\"writeExecutionProof(bytes32)\":{\"details\":\"Will revert if the transaction has not been executed.\",\"params\":{\"transactionId\":\"The ID of the transaction to write the proof for.\"},\"returns\":{\"dbNonce\":\"        The database nonce of the batch containing the written proof for transaction.\",\"entryIndex\":\"     The index of the written proof for transaction within the batch.\"}}},\"stateVariables\":{\"_linkedClient\":{\"details\":\"Address of the InterchainClient contract on the remote chain\"},\"_txExecutor\":{\"details\":\"Executor address that completed the transaction. Address(0) if not executed yet.\"}},\"title\":\"InterchainClientV1\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"CLIENT_VERSION()\":{\"notice\":\"Version of the InterchainClient contract. Sent and received transactions must have the same version.\"},\"INTERCHAIN_DB()\":{\"notice\":\"Address of the InterchainDB contract, set at the time of deployment.\"},\"decodeOptions(bytes)\":{\"notice\":\"Decodes the encoded options data into a OptionsV1 struct.\"},\"encodeTransaction((uint64,uint64,uint64,uint64,bytes32,bytes32,bytes,bytes))\":{\"notice\":\"Encodes the transaction data into a bytes format.\"},\"executionFees()\":{\"notice\":\"Address of the contract that handles execution fees. Can be updated by the owner.\"},\"getExecutorById(bytes32)\":{\"notice\":\"Returns the address of the executor for a transaction that has been sent to the local chain.\"},\"getInterchainFee(uint64,address,address[],bytes,uint256)\":{\"notice\":\"Returns the fee for sending an Interchain message.\"},\"getLinkedClient(uint64)\":{\"notice\":\"Returns the address of the linked client (as bytes32) for a specific chain ID.\"},\"getLinkedClientEVM(uint64)\":{\"notice\":\"Returns the EVM address of the linked client for a specific chain ID.\"},\"interchainExecute(uint256,bytes,bytes32[])\":{\"notice\":\"Executes a transaction that has been sent via the Interchain.\"},\"interchainSend(uint64,bytes32,address,address[],bytes,bytes)\":{\"notice\":\"Sends a message to another chain via the Interchain Communication Protocol.\"},\"setExecutionFees(address)\":{\"notice\":\"Sets the address of the ExecutionFees contract.\"},\"setLinkedClient(uint64,bytes32)\":{\"notice\":\"Sets the linked client for a specific chain ID.\"},\"writeExecutionProof(bytes32)\":{\"notice\":\"Writes the proof of execution for a transaction into the InterchainDB.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainClientV1.sol\":\"InterchainClientV1\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainClientV1.sol\":{\"keccak256\":\"0xe270686a9bca05b4013610a4e8bb08040de32a0442edd218e1692edaca94e40e\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://727e84146369613e04e57a677f8bc6c709ee145df3eeb79f15ea5a922198d78f\",\"dweb:/ipfs/QmUXh2nDtHBnhYZSwCxcteN4be13S7dR9GbqqHT9mUxta3\"]}},\"version\":1}"},"hashes":{"CLIENT_VERSION()":"7813cd52","INTERCHAIN_DB()":"e4c61247","decodeOptions(bytes)":"d5e788a0","encodeTransaction((uint64,uint64,uint64,uint64,bytes32,bytes32,bytes,bytes))":"8654ddd4","executionFees()":"7341eaf9","getExecutor(bytes)":"f92a79ff","getExecutorById(bytes32)":"f1a61fac","getInterchainFee(uint64,address,address[],bytes,uint256)":"cbb3c631","getLinkedClient(uint64)":"2e568739","getLinkedClientEVM(uint64)":"35c4a191","interchainExecute(uint256,bytes,bytes32[])":"53b67d74","interchainSend(uint64,bytes32,address,address[],bytes,bytes)":"547efb84","interchainSendEVM(uint64,address,address,address[],bytes,bytes)":"3f34448e","isExecutable(bytes,bytes32[])":"1450c281","owner()":"8da5cb5b","renounceOwnership()":"715018a6","setExecutionFees(address)":"3dc68b87","setLinkedClient(uint64,bytes32)":"f3c66e2b","transferOwnership(address)":"f2fde38b","writeExecutionProof(bytes32)":"90e81077"}},"solidity/InterchainClientV1.sol:InterchainClientV1Events":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainClientV1Events.sol\n\nabstract contract InterchainClientV1Events {\n    event ExecutionFeesSet(address executionFees);\n    event LinkedClientSet(uint64 chainId, bytes32 client);\n\n    // TODO: figure out indexing\n\n    event InterchainTransactionSent(\n        bytes32 indexed transactionId,\n        uint64 indexed dbNonce,\n        uint64 indexed entryIndex,\n        uint64 dstChainId,\n        bytes32 srcSender,\n        bytes32 dstReceiver,\n        uint256 verificationFee,\n        uint256 executionFee,\n        bytes options,\n        bytes message\n    );\n\n    event InterchainTransactionReceived(\n        bytes32 indexed transactionId,\n        uint64 indexed dbNonce,\n        uint64 indexed entryIndex,\n        uint64 srcChainId,\n        bytes32 srcSender,\n        bytes32 dstReceiver\n    );\n\n    event ExecutionProofWritten(\n        bytes32 indexed transactionId, uint64 indexed dbNonce, uint64 indexed entryIndex, address executor\n    );\n}\n\n// contracts/interfaces/IExecutionFees.sol\n\ninterface IExecutionFees {\n    error ExecutionFees__AlreadyRecorded(uint64 dstChainId, bytes32 transactionId, address executor);\n    error ExecutionFees__ZeroAddress();\n    error ExecutionFees__ZeroAmount();\n\n    /// @notice Add the execution fee for a transaction. The attached value will be added to the\n    /// rewards for the executor completing the transaction.\n    /// Note: this could be used to store the execution fee for a new transaction, or to add more\n    /// funds to the execution fee of an existing transaction. Therefore this function is payable,\n    /// and does not implement any caller restrictions.\n    /// @dev Will revert if the executor is already recorded for the transaction.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to add the execution fee to.\n    function addExecutionFee(uint64 dstChainId, bytes32 transactionId) external payable;\n\n    /// @notice Record the executor (who completed the transaction) for a transaction,\n    /// and update the accumulated rewards for the executor.\n    /// @dev Could only be called by the Recorder.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to record the executor for.\n    /// @param executor             The address of the executor who completed the transaction.\n    function recordExecutor(uint64 dstChainId, bytes32 transactionId, address executor) external;\n\n    /// @notice Allows the executor to claim their unclaimed rewards.\n    /// @dev Will revert if the executor has no unclaimed rewards.\n    function claimExecutionFees(address executor) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the accumulated rewards for an executor.\n    /// @param executor             The address of the executor to get the rewards for.\n    function accumulatedRewards(address executor) external view returns (uint256 accumulated);\n\n    /// @notice Get the unclaimed rewards for an executor.\n    /// @param executor             The address of the executor to get the rewards for.\n    function unclaimedRewards(address executor) external view returns (uint256 unclaimed);\n\n    /// @notice Get the total execution fee for a transaction.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to get the execution fee for.\n    function executionFee(uint64 dstChainId, bytes32 transactionId) external view returns (uint256 fee);\n\n    /// @notice Get the address of the recorded executor for a transaction.\n    /// @dev Will return address(0) if the executor is not recorded.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to get the recorded executor for.\n    function recordedExecutor(uint64 dstChainId, bytes32 transactionId) external view returns (address executor);\n}\n\n// contracts/interfaces/IExecutionService.sol\n\ninterface IExecutionService {\n    /// @notice Request the execution of an Interchain Transaction on a remote chain.\n    /// Note: the off-chain actor needs to fetch the transaction payload from the InterchainClient\n    /// event with the same transactionId, then execute the transaction on the remote chain:\n    /// `dstInterchainClient.executeTransaction(transactionPayload)`\n    /// Once the execution is confirmed on the source chain, the off-chain actor will be able\n    /// to claim `executionFee` in the ExecutionFees contract.\n    /// @dev Could only be called by `InterchainClient` contracts.\n    /// Will revert if the execution fee is not big enough.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param txPayloadSize        The size of the transaction payload to use for the execution.\n    /// @param transactionId        The id of the transaction to execute.\n    /// @param executionFee         The fee paid for the execution.\n    /// @param options              The options to use for the execution.\n    function requestExecution(\n        uint64 dstChainId,\n        uint256 txPayloadSize,\n        bytes32 transactionId,\n        uint256 executionFee,\n        bytes memory options\n    )\n        external;\n\n    /// @notice Get the address of the EOA account that will be used to execute transactions on the\n    /// remote chains.\n    function executorEOA() external view returns (address);\n\n    /// @notice Get the execution fee for executing an Interchain Transaction on a remote chain.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param txPayloadSize        The size of the transaction payload to use for the execution.\n    /// @param options              The options to use for the execution.\n    function getExecutionFee(\n        uint64 dstChainId,\n        uint256 txPayloadSize,\n        bytes memory options\n    )\n        external\n        view\n        returns (uint256);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    /// @notice Allows the Interchain Client to pass the message to the Interchain App.\n    /// @dev App is responsible for keeping track of interchain clients, and must verify the message sender.\n    /// @param srcChainId   Chain ID of the source chain, where the message was sent from.\n    /// @param sender       Sender address on the source chain, as a bytes32 value.\n    /// @param dbNonce      The Interchain DB nonce of the batch containing the message entry.\n    /// @param entryIndex   The index of the message entry within the batch.\n    /// @param message      The message being sent.\n    function appReceive(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /// @notice Returns the verification configuration of the Interchain App.\n    /// @dev This configuration is used by the Interchain Client to verify that message has been confirmed\n    /// by the Interchain Modules on the destination chain.\n    /// Note: V1 version of AppConfig includes the required responses count, and optimistic period after which\n    /// the message is considered confirmed by the module. Following versions may include additional fields.\n    /// @return appConfig    The versioned configuration of the Interchain App, encoded as bytes.\n    /// @return modules      The list of Interchain Modules that app is trusting to confirm the messages.\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/Math.sol\n\nlibrary MathLib {\n    /// @notice Rounds up to the nearest multiple of 32.\n    /// Note: Returns zero on overflows instead of reverting. This is fine for practical\n    /// use cases, as this is used for determining the size of the payload in memory.\n    function roundUpToWord(uint256 x) internal pure returns (uint256) {\n        unchecked {\n            return (x + 31) \u0026 ~uint256(31);\n        }\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/VersionedPayload.sol\n\n// solhint-disable no-inline-assembly\n// solhint-disable ordering\nlibrary VersionedPayloadLib {\n    /// @notice Amount of bytes reserved for the version (uint16) in the versioned payload\n    uint256 internal constant VERSION_LENGTH = 2;\n\n    error VersionedPayload__TooShort(bytes versionedPayload);\n    error VersionedPayload__PrecompileFailed();\n\n    /// @notice Encodes the versioned payload into a single bytes array.\n    /// @param version  The payload's version.\n    /// @param payload  The payload to encode.\n    function encodeVersionedPayload(uint16 version, bytes memory payload) internal pure returns (bytes memory) {\n        return abi.encodePacked(version, payload);\n    }\n\n    /// @notice Extracts the version from the versioned payload (calldata reference).\n    /// @param versionedPayload     The versioned payload (calldata reference).\n    function getVersion(bytes calldata versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            version := shr(240, calldataload(versionedPayload.offset))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (calldata reference).\n    /// @dev The extracted payload is also returned as a calldata reference.\n    /// @param versionedPayload     The versioned payload.\n    function getPayload(bytes calldata versionedPayload) internal pure returns (bytes calldata) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        return versionedPayload[VERSION_LENGTH:];\n    }\n\n    /// @notice Extracts the version from the versioned payload (memory reference).\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getVersionFromMemory(bytes memory versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            // We add 0x20 to skip the length of the bytes array.\n            version := shr(240, mload(add(versionedPayload, 0x20)))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (memory reference).\n    /// @dev The extracted payload is copied into a new memory location. Use `getPayload` when possible\n    /// to avoid extra memory allocation.\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getPayloadFromMemory(bytes memory versionedPayload) internal view returns (bytes memory payload) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        // Figure how many bytes to copy and allocate the memory for the extracted payload.\n        uint256 toCopy;\n        unchecked {\n            toCopy = versionedPayload.length - VERSION_LENGTH;\n        }\n        payload = new bytes(toCopy);\n        // Use identity precompile (0x04) to copy the payload. Unlike MCOPY, this is available on all EVM chains.\n        bool res;\n        assembly {\n            // We add 0x20 to skip the length of the bytes array.\n            // We add 0x02 to skip the 2 bytes reserved for the version.\n            // Copy the payload to the previously allocated memory.\n            res := staticcall(gas(), 0x04, add(versionedPayload, 0x22), toCopy, add(payload, 0x20), toCopy)\n        }\n        if (!res) {\n            revert VersionedPayload__PrecompileFailed();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SafeCast.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value \u003e type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value \u003e type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value \u003e type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value \u003e type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value \u003e type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value \u003e type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value \u003e type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value \u003e type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value \u003e type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value \u003e type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value \u003e type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value \u003e type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value \u003e type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value \u003e type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value \u003e type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value \u003e type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value \u003e type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value \u003e type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value \u003e type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value \u003e type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value \u003e type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value \u003e type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value \u003e type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value \u003e type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value \u003e type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value \u003e type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value \u003e type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value \u003e type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value \u003e type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value \u003e type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value \u003e type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value \u003c 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value \u003e uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal view returns (AppConfigV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (AppConfigV1));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal view returns (OptionsV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (OptionsV1));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(OPTIONS_V1, abi.encode(options));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/libs/InterchainBatch.sol\n\ntype BatchKey is uint128;\n\n/// @notice Struct representing a batch of entries in the Interchain DataBase.\n/// Batched entries are put together in a Merkle tree, which root is saved.\n/// Batch has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: batchRoot\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch\n/// @param batchRoot    The root of the Merkle tree containing the batched entries\nstruct InterchainBatch {\n    uint64 srcChainId;\n    uint64 dbNonce;\n    bytes32 batchRoot;\n}\n\nlibrary InterchainBatchLib {\n    using VersionedPayloadLib for bytes;\n\n    /// @notice Constructs an InterchainBatch struct to be saved on the local chain.\n    /// @param dbNonce      The database nonce of the batch\n    /// @param batchRoot    The root of the Merkle tree containing the batched entries\n    /// @return batch       The constructed InterchainBatch struct\n    function constructLocalBatch(\n        uint64 dbNonce,\n        bytes32 batchRoot\n    )\n        internal\n        view\n        returns (InterchainBatch memory batch)\n    {\n        return InterchainBatch({srcChainId: SafeCast.toUint64(block.chainid), dbNonce: dbNonce, batchRoot: batchRoot});\n    }\n\n    /// @notice Encodes the InterchainBatch struct into a non-versioned batch payload.\n    function encodeBatch(InterchainBatch memory batch) internal pure returns (bytes memory) {\n        return abi.encode(encodeBatchKey(batch.srcChainId, batch.dbNonce), batch.batchRoot);\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in calldata.\n    function decodeBatch(bytes calldata data) internal pure returns (InterchainBatch memory batch) {\n        BatchKey key;\n        (key, batch.batchRoot) = abi.decode(data, (BatchKey, bytes32));\n        (batch.srcChainId, batch.dbNonce) = decodeBatchKey(key);\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in memory.\n    function decodeBatchFromMemory(bytes memory data) internal pure returns (InterchainBatch memory batch) {\n        BatchKey key;\n        (key, batch.batchRoot) = abi.decode(data, (BatchKey, bytes32));\n        (batch.srcChainId, batch.dbNonce) = decodeBatchKey(key);\n    }\n\n    /// @notice Encodes the uint128 key of the batch from uint64 srcChainId and uint64 dbNonce.\n    function encodeBatchKey(uint64 srcChainId, uint64 dbNonce) internal pure returns (BatchKey) {\n        return BatchKey.wrap((uint128(srcChainId) \u003c\u003c 64) | dbNonce);\n    }\n\n    /// @notice Decodes the uint128 key of the batch into uint64 srcChainId and uint64 dbNonce.\n    function decodeBatchKey(BatchKey key) internal pure returns (uint64 srcChainId, uint64 dbNonce) {\n        srcChainId = uint64(BatchKey.unwrap(key) \u003e\u003e 64);\n        dbNonce = uint64(BatchKey.unwrap(key));\n    }\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce + entryIndex\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch containing the entry\n/// @param entryIndex   The index of the entry in the batch\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint64 srcChainId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nusing InterchainEntryLib for InterchainEntry global;\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint64 dbNonce,\n        uint64 entryIndex,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: SafeCast.toUint64(block.chainid),\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n}\n\n// contracts/libs/InterchainTransaction.sol\n\ntype ICTxHeader is uint256;\n\nstruct InterchainTransaction {\n    uint64 srcChainId;\n    uint64 dstChainId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcSender;\n    bytes32 dstReceiver;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    using MathLib for uint256;\n    using VersionedPayloadLib for bytes;\n\n    function constructLocalTransaction(\n        address srcSender,\n        uint64 dstChainId,\n        bytes32 dstReceiver,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: SafeCast.toUint64(block.chainid),\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            encodeTxHeader(transaction.srcChainId, transaction.dstChainId, transaction.dbNonce, transaction.entryIndex),\n            transaction.srcSender,\n            transaction.dstReceiver,\n            transaction.options,\n            transaction.message\n        );\n    }\n\n    function decodeTransaction(bytes calldata transaction) internal pure returns (InterchainTransaction memory icTx) {\n        ICTxHeader header;\n        (header, icTx.srcSender, icTx.dstReceiver, icTx.options, icTx.message) =\n            abi.decode(transaction, (ICTxHeader, bytes32, bytes32, bytes, bytes));\n        (icTx.srcChainId, icTx.dstChainId, icTx.dbNonce, icTx.entryIndex) = decodeTxHeader(header);\n    }\n\n    function payloadSize(uint256 optionsLen, uint256 messageLen) internal pure returns (uint256) {\n        // 2 bytes are reserved for the transaction version\n        // + 5 fields * 32 bytes (3 values for static, 2 offsets for dynamic) + 2 * 32 bytes (lengths for dynamic) = 226\n        // (srcChainId, dstChainId, dbNonce, entryIndex) are merged into a single 32 bytes field\n        // Both options and message are dynamic fields, which are padded up to 32 bytes\n        return 226 + optionsLen.roundUpToWord() + messageLen.roundUpToWord();\n    }\n\n    function encodeTxHeader(\n        uint64 srcChainId,\n        uint64 dstChainId,\n        uint64 dbNonce,\n        uint64 entryIndex\n    )\n        internal\n        pure\n        returns (ICTxHeader)\n    {\n        return ICTxHeader.wrap(\n            (uint256(srcChainId) \u003c\u003c 192) | (uint256(dstChainId) \u003c\u003c 128) | (uint256(dbNonce) \u003c\u003c 64) | uint256(entryIndex)\n        );\n    }\n\n    function decodeTxHeader(ICTxHeader header)\n        internal\n        pure\n        returns (uint64 srcChainId, uint64 dstChainId, uint64 dbNonce, uint64 entryIndex)\n    {\n        srcChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 192);\n        dstChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 128);\n        dbNonce = uint64(ICTxHeader.unwrap(header) \u003e\u003e 64);\n        entryIndex = uint64(ICTxHeader.unwrap(header));\n    }\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint64 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__InvalidTransactionVersion(uint16 version);\n    error InterchainClientV1__NoLinkedClient(uint64 chainId);\n    error InterchainClientV1__NotEnoughGasSupplied();\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint64 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint64 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint64 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint64 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param messageLen           The length of the message being sent.\n    function getInterchainFee(\n        uint64 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        uint256 messageLen\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint64 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint64 chainId) external view returns (address);\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing a batch of entries from the remote Interchain DataBase,\n    /// verified by the Interchain Module.\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param batchRoot    The Merkle root of the batch\n    struct RemoteBatch {\n        uint256 verifiedAt;\n        bytes32 batchRoot;\n    }\n\n    error InterchainDB__BatchDoesNotExist(uint64 dbNonce);\n    error InterchainDB__BatchNotFinalized(uint64 dbNonce);\n    error InterchainDB__ConflictingBatches(address module, bytes32 existingBatchRoot, InterchainBatch newBatch);\n    error InterchainDB__EntryIndexOutOfRange(uint64 dbNonce, uint64 entryIndex, uint64 batchSize);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__InvalidBatchVersion(uint16 version);\n    error InterchainDB__InvalidEntryRange(uint64 dbNonce, uint64 start, uint64 end);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId(uint64 chainId);\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `requestBatchVerification` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntry(bytes32 dataHash) external returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Request the given Interchain Modules to verify an existing batch.\n    /// If the batch is not finalized, the module will verify it after finalization.\n    /// For the finalized batch the batch root is already available, and the module can verify it immediately.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any batch.\n    /// @dev Will revert if the batch with the given nonce does not exist.\n    /// @param dstChainId    The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the existing batch\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestBatchVerification(\n        uint64 dstChainId,\n        uint64 dbNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Then request the Interchain Modules to verify the batch containing the written entry on the destination chain.\n    /// See `writeEntry` and `requestBatchVerification` for more details.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntryWithVerification(\n        uint64 dstChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Allows the Interchain Module to verify the batch coming from the remote chain.\n    /// Note: The DB will only accept the batch of the same version as the DB itself.\n    /// @param versionedBatch   The versioned Interchain Batch to verify\n    function verifyRemoteBatch(bytes memory versionedBatch) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint64 dstChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce.\n    /// Note: the leafs are ordered by the index of the written entry in the current batch,\n    /// and the leafs value match the value of the written entry (srcWriter + dataHash hashed together).\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchLeafs(uint64 dbNonce) external view returns (bytes32[] memory);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce,\n    /// paginated by the given start and end indexes. The end index is exclusive.\n    /// Note: this is useful when the batch contains a large number of leafs, and calling `getBatchLeafs`\n    /// would result in a gas limit exceeded error.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the provided range is invalid.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param start        The start index of the paginated leafs, inclusive\n    /// @param end          The end index of the paginated leafs, exclusive\n    function getBatchLeafsPaginated(\n        uint64 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory);\n\n    /// @notice Returns the size of the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchSize(uint64 dbNonce) external view returns (uint64);\n\n    /// @notice Get the finalized Interchain Batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatch(uint64 dbNonce) external view returns (InterchainBatch memory);\n\n    /// @notice Get the Interchain Entry's value written on the local chain with the given batch nonce and entry index.\n    /// Entry value is calculated as the hash of the writer address and the written data hash.\n    /// Note: the batch does not have to be finalized to fetch the entry value.\n    /// @dev Will revert if the batch with the given nonce does not exist,\n    /// or the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the existing batch\n    /// @param entryIndex   The index of the written entry within the batch\n    function getEntryValue(uint64 dbNonce, uint64 entryIndex) external view returns (bytes32);\n\n    /// @notice Get the Merkle proof of inclusion for the entry with the given index\n    /// in the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param entryIndex   The index of the written entry within the batch\n    /// @return proof       The Merkle proof of inclusion for the entry\n    function getEntryProof(uint64 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof);\n\n    /// @notice Get the nonce of the database, which is incremented every time a new batch is finalized.\n    /// This is the nonce of the current non-finalized batch.\n    function getDBNonce() external view returns (uint64);\n\n    /// @notice Get the index of the next entry to be written to the database.\n    /// @return dbNonce      The database nonce of the batch including the next entry\n    /// @return entryIndex   The index of the next entry within that batch\n    function getNextEntryIndex() external view returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or ZERO if the module has not verified the entry.\n    function checkVerification(\n        address dstModule,\n        InterchainEntry memory entry,\n        bytes32[] memory proof\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n\n    /// @notice Get the version of the Interchain DataBase.\n    // solhint-disable-next-line func-name-mixedcase\n    function DB_VERSION() external pure returns (uint16);\n}\n\n// contracts/InterchainClientV1.sol\n\n/**\n * @title InterchainClientV1\n * @dev Implements the operations of the Interchain Execution Layer.\n */\ncontract InterchainClientV1 is Ownable, InterchainClientV1Events, IInterchainClientV1 {\n    using AppConfigLib for bytes;\n    using OptionsLib for bytes;\n    using VersionedPayloadLib for bytes;\n\n    /// @notice Version of the InterchainClient contract. Sent and received transactions must have the same version.\n    uint16 public constant CLIENT_VERSION = 1;\n\n    /// @notice Address of the InterchainDB contract, set at the time of deployment.\n    address public immutable INTERCHAIN_DB;\n\n    /// @notice Address of the contract that handles execution fees. Can be updated by the owner.\n    address public executionFees;\n\n    /// @dev Address of the InterchainClient contract on the remote chain\n    mapping(uint64 chainId =\u003e bytes32 remoteClient) internal _linkedClient;\n    /// @dev Executor address that completed the transaction. Address(0) if not executed yet.\n    mapping(bytes32 transactionId =\u003e address executor) internal _txExecutor;\n\n    constructor(address interchainDB, address owner_) Ownable(owner_) {\n        INTERCHAIN_DB = interchainDB;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function setExecutionFees(address executionFees_) external onlyOwner {\n        executionFees = executionFees_;\n        emit ExecutionFeesSet(executionFees_);\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function setLinkedClient(uint64 chainId, bytes32 client) external onlyOwner {\n        _linkedClient[chainId] = client;\n        emit LinkedClientSet(chainId, client);\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _interchainSend(dstChainId, receiver, srcExecutionService, srcModules, options, message);\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function interchainSendEVM(\n        uint64 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc)\n    {\n        bytes32 receiverBytes32 = TypeCasts.addressToBytes32(receiver);\n        return _interchainSend(dstChainId, receiverBytes32, srcExecutionService, srcModules, options, message);\n    }\n\n    // TODO: Handle the case where receiver does not implement the IInterchainApp interface (or does not exist at all)\n    // @inheritdoc IInterchainClientV1\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable\n    {\n        InterchainTransaction memory icTx = _assertCorrectVersion(transaction);\n        bytes32 transactionId = keccak256(transaction);\n        _assertExecutable(icTx, transactionId, proof);\n        _txExecutor[transactionId] = msg.sender;\n\n        OptionsV1 memory decodedOptions = icTx.options.decodeOptionsV1();\n        if (msg.value != decodedOptions.gasAirdrop) {\n            revert InterchainClientV1__IncorrectMsgValue(msg.value, decodedOptions.gasAirdrop);\n        }\n        // We should always use at least as much as the requested gas limit.\n        // The executor can specify a higher gas limit if they wanted.\n        if (decodedOptions.gasLimit \u003e gasLimit) gasLimit = decodedOptions.gasLimit;\n        // Check the the Executor has provided big enough gas limit for the whole transaction.\n        if (gasleft() \u003c= gasLimit) {\n            revert InterchainClientV1__NotEnoughGasSupplied();\n        }\n        // Pass the full msg.value to the app: we have already checked that it matches the requested gas airdrop.\n        IInterchainApp(TypeCasts.bytes32ToAddress(icTx.dstReceiver)).appReceive{gas: gasLimit, value: msg.value}({\n            srcChainId: icTx.srcChainId,\n            sender: icTx.srcSender,\n            dbNonce: icTx.dbNonce,\n            entryIndex: icTx.entryIndex,\n            message: icTx.message\n        });\n        emit InterchainTransactionReceived(\n            transactionId, icTx.dbNonce, icTx.entryIndex, icTx.srcChainId, icTx.srcSender, icTx.dstReceiver\n        );\n    }\n\n    /// @inheritdoc IInterchainClientV1\n    function writeExecutionProof(bytes32 transactionId) external returns (uint64 dbNonce, uint64 entryIndex) {\n        address executor = _txExecutor[transactionId];\n        if (executor == address(0)) {\n            revert InterchainClientV1__TxNotExecuted(transactionId);\n        }\n        bytes memory proof = abi.encode(transactionId, executor);\n        (dbNonce, entryIndex) = IInterchainDB(INTERCHAIN_DB).writeEntry(keccak256(proof));\n        emit ExecutionProofWritten(transactionId, dbNonce, entryIndex, executor);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // @inheritdoc IInterchainClientV1\n    function isExecutable(bytes calldata encodedTx, bytes32[] calldata proof) external view returns (bool) {\n        InterchainTransaction memory icTx = _assertCorrectVersion(encodedTx);\n        // Check that options could be decoded\n        icTx.options.decodeOptionsV1();\n        bytes32 transactionId = keccak256(encodedTx);\n        _assertExecutable(icTx, transactionId, proof);\n        return true;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function getExecutor(bytes calldata encodedTx) external view returns (address) {\n        return _txExecutor[keccak256(encodedTx)];\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function getExecutorById(bytes32 transactionId) external view returns (address) {\n        return _txExecutor[transactionId];\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function getInterchainFee(\n        uint64 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        uint256 messageLen\n    )\n        external\n        view\n        returns (uint256 fee)\n    {\n        _assertLinkedClient(dstChainId);\n        // Check that options could be decoded on destination chain\n        options.decodeOptionsV1();\n        // Verification fee from InterchainDB\n        fee = IInterchainDB(INTERCHAIN_DB).getInterchainFee(dstChainId, srcModules);\n        // Add execution fee, if ExecutionService is provided\n        if (srcExecutionService != address(0)) {\n            uint256 payloadSize = InterchainTransactionLib.payloadSize(options.length, messageLen);\n            fee += IExecutionService(srcExecutionService).getExecutionFee(dstChainId, payloadSize, options);\n        }\n    }\n\n    /// @inheritdoc IInterchainClientV1\n    function getLinkedClient(uint64 chainId) external view returns (bytes32) {\n        if (chainId == block.chainid) {\n            revert InterchainClientV1__NotRemoteChainId(chainId);\n        }\n        return _linkedClient[chainId];\n    }\n\n    /// @inheritdoc IInterchainClientV1\n    function getLinkedClientEVM(uint64 chainId) external view returns (address linkedClientEVM) {\n        if (chainId == block.chainid) {\n            revert InterchainClientV1__NotRemoteChainId(chainId);\n        }\n        bytes32 linkedClient = _linkedClient[chainId];\n        linkedClientEVM = TypeCasts.bytes32ToAddress(linkedClient);\n        // Check that the linked client address fits into the EVM address space\n        if (TypeCasts.addressToBytes32(linkedClientEVM) != linkedClient) {\n            revert InterchainClientV1__NotEVMClient(linkedClient);\n        }\n    }\n\n    /// @notice Decodes the encoded options data into a OptionsV1 struct.\n    function decodeOptions(bytes memory encodedOptions) external view returns (OptionsV1 memory) {\n        return encodedOptions.decodeOptionsV1();\n    }\n\n    /// @notice Encodes the transaction data into a bytes format.\n    function encodeTransaction(InterchainTransaction memory icTx) public pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload({\n            version: CLIENT_VERSION,\n            payload: InterchainTransactionLib.encodeTransaction(icTx)\n        });\n    }\n\n    // ═════════════════════════════════════════════════ INTERNAL ══════════════════════════════════════════════════════\n\n    /// @dev Internal logic for sending a message to another chain.\n    function _interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        _assertLinkedClient(dstChainId);\n        if (receiver == 0) revert InterchainClientV1__ZeroReceiver();\n        // Check that options could be decoded on destination chain\n        options.decodeOptionsV1();\n        uint256 verificationFee = IInterchainDB(INTERCHAIN_DB).getInterchainFee(dstChainId, srcModules);\n        if (msg.value \u003c verificationFee) {\n            revert InterchainClientV1__FeeAmountTooLow(msg.value, verificationFee);\n        }\n        (desc.dbNonce, desc.entryIndex) = IInterchainDB(INTERCHAIN_DB).getNextEntryIndex();\n        InterchainTransaction memory icTx = InterchainTransactionLib.constructLocalTransaction({\n            srcSender: msg.sender,\n            dstReceiver: receiver,\n            dstChainId: dstChainId,\n            dbNonce: desc.dbNonce,\n            entryIndex: desc.entryIndex,\n            options: options,\n            message: message\n        });\n        desc.transactionId = keccak256(encodeTransaction(icTx));\n        // Sanity check: nonce returned from DB should match the nonce used to construct the transaction\n        {\n            (uint64 dbNonce, uint64 entryIndex) = IInterchainDB(INTERCHAIN_DB).writeEntryWithVerification{\n                value: verificationFee\n            }(icTx.dstChainId, desc.transactionId, srcModules);\n            assert(dbNonce == desc.dbNonce \u0026\u0026 entryIndex == desc.entryIndex);\n        }\n        uint256 executionFee;\n        unchecked {\n            executionFee = msg.value - verificationFee;\n        }\n        if (executionFee \u003e 0) {\n            IExecutionFees(executionFees).addExecutionFee{value: executionFee}(icTx.dstChainId, desc.transactionId);\n        }\n        // TODO: consider disallowing the use of empty srcExecutionService\n        if (srcExecutionService != address(0)) {\n            IExecutionService(srcExecutionService).requestExecution({\n                dstChainId: dstChainId,\n                txPayloadSize: InterchainTransactionLib.payloadSize(options.length, message.length),\n                transactionId: desc.transactionId,\n                executionFee: executionFee,\n                options: options\n            });\n            address srcExecutorEOA = IExecutionService(srcExecutionService).executorEOA();\n            IExecutionFees(executionFees).recordExecutor(icTx.dstChainId, desc.transactionId, srcExecutorEOA);\n        }\n        emit InterchainTransactionSent(\n            desc.transactionId,\n            icTx.dbNonce,\n            icTx.entryIndex,\n            icTx.dstChainId,\n            icTx.srcSender,\n            icTx.dstReceiver,\n            verificationFee,\n            executionFee,\n            icTx.options,\n            icTx.message\n        );\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Asserts that the transaction is executable.\n    function _assertExecutable(\n        InterchainTransaction memory icTx,\n        bytes32 transactionId,\n        bytes32[] calldata proof\n    )\n        internal\n        view\n    {\n        bytes32 linkedClient = _assertLinkedClient(icTx.srcChainId);\n        if (icTx.dstChainId != block.chainid) {\n            revert InterchainClientV1__IncorrectDstChainId(icTx.dstChainId);\n        }\n        if (_txExecutor[transactionId] != address(0)) {\n            revert InterchainClientV1__TxAlreadyExecuted(transactionId);\n        }\n        // Construct expected entry based on icTransaction data\n        InterchainEntry memory icEntry = InterchainEntry({\n            srcChainId: icTx.srcChainId,\n            dbNonce: icTx.dbNonce,\n            entryIndex: icTx.entryIndex,\n            srcWriter: linkedClient,\n            dataHash: transactionId\n        });\n        (bytes memory encodedAppConfig, address[] memory approvedDstModules) =\n            IInterchainApp(TypeCasts.bytes32ToAddress(icTx.dstReceiver)).getReceivingConfig();\n        AppConfigV1 memory appConfig = encodedAppConfig.decodeAppConfigV1();\n        if (appConfig.requiredResponses == 0) {\n            revert InterchainClientV1__ZeroRequiredResponses();\n        }\n        uint256 responses = _getFinalizedResponsesCount(approvedDstModules, icEntry, proof, appConfig.optimisticPeriod);\n        if (responses \u003c appConfig.requiredResponses) {\n            revert InterchainClientV1__NotEnoughResponses(responses, appConfig.requiredResponses);\n        }\n    }\n\n    /// @dev Asserts that the chain is linked and returns the linked client address.\n    function _assertLinkedClient(uint64 chainId) internal view returns (bytes32 linkedClient) {\n        if (chainId == block.chainid) {\n            revert InterchainClientV1__NotRemoteChainId(chainId);\n        }\n        linkedClient = _linkedClient[chainId];\n        if (linkedClient == 0) {\n            revert InterchainClientV1__NoLinkedClient(chainId);\n        }\n    }\n\n    /**\n     * @dev Calculates the number of responses that are considered finalized within the optimistic time period.\n     * @param approvedModules       Approved modules that could have confirmed the entry.\n     * @param icEntry               The InterchainEntry to confirm.\n     * @param optimisticPeriod      The time period in seconds within which a response is considered valid.\n     * @return finalizedResponses   The count of responses that are finalized within the optimistic time period.\n     */\n    function _getFinalizedResponsesCount(\n        address[] memory approvedModules,\n        InterchainEntry memory icEntry,\n        bytes32[] calldata proof,\n        uint256 optimisticPeriod\n    )\n        internal\n        view\n        returns (uint256 finalizedResponses)\n    {\n        for (uint256 i = 0; i \u003c approvedModules.length; ++i) {\n            uint256 confirmedAt = IInterchainDB(INTERCHAIN_DB).checkVerification(approvedModules[i], icEntry, proof);\n            // checkVerification() returns 0 if entry hasn't been confirmed by the module, so we check for that as well\n            if (confirmedAt != 0 \u0026\u0026 confirmedAt + optimisticPeriod \u003c block.timestamp) {\n                ++finalizedResponses;\n            }\n        }\n    }\n\n    /// @dev Asserts that the transaction version is correct. Returns the decoded transaction for chaining purposes.\n    function _assertCorrectVersion(bytes calldata versionedTx)\n        internal\n        pure\n        returns (InterchainTransaction memory icTx)\n    {\n        uint16 version = versionedTx.getVersion();\n        if (version != CLIENT_VERSION) {\n            revert InterchainClientV1__InvalidTransactionVersion(version);\n        }\n        icTx = InterchainTransactionLib.decodeTransaction(versionedTx.getPayload());\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"executionFees","type":"address"}],"name":"ExecutionFeesSet","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"indexed":true,"internalType":"uint64","name":"dbNonce","type":"uint64"},{"indexed":true,"internalType":"uint64","name":"entryIndex","type":"uint64"},{"indexed":false,"internalType":"address","name":"executor","type":"address"}],"name":"ExecutionProofWritten","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"indexed":true,"internalType":"uint64","name":"dbNonce","type":"uint64"},{"indexed":true,"internalType":"uint64","name":"entryIndex","type":"uint64"},{"indexed":false,"internalType":"uint64","name":"srcChainId","type":"uint64"},{"indexed":false,"internalType":"bytes32","name":"srcSender","type":"bytes32"},{"indexed":false,"internalType":"bytes32","name":"dstReceiver","type":"bytes32"}],"name":"InterchainTransactionReceived","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"indexed":true,"internalType":"uint64","name":"dbNonce","type":"uint64"},{"indexed":true,"internalType":"uint64","name":"entryIndex","type":"uint64"},{"indexed":false,"internalType":"uint64","name":"dstChainId","type":"uint64"},{"indexed":false,"internalType":"bytes32","name":"srcSender","type":"bytes32"},{"indexed":false,"internalType":"bytes32","name":"dstReceiver","type":"bytes32"},{"indexed":false,"internalType":"uint256","name":"verificationFee","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"executionFee","type":"uint256"},{"indexed":false,"internalType":"bytes","name":"options","type":"bytes"},{"indexed":false,"internalType":"bytes","name":"message","type":"bytes"}],"name":"InterchainTransactionSent","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint64","name":"chainId","type":"uint64"},{"indexed":false,"internalType":"bytes32","name":"client","type":"bytes32"}],"name":"LinkedClientSet","type":"event"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"executionFees\",\"type\":\"address\"}],\"name\":\"ExecutionFeesSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"}],\"name\":\"ExecutionProofWritten\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"srcChainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"srcSender\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"dstReceiver\",\"type\":\"bytes32\"}],\"name\":\"InterchainTransactionReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"dstChainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"srcSender\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"dstReceiver\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"verificationFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"executionFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"options\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"InterchainTransactionSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"client\",\"type\":\"bytes32\"}],\"name\":\"LinkedClientSet\",\"type\":\"event\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainClientV1.sol\":\"InterchainClientV1Events\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainClientV1.sol\":{\"keccak256\":\"0xe270686a9bca05b4013610a4e8bb08040de32a0442edd218e1692edaca94e40e\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://727e84146369613e04e57a677f8bc6c709ee145df3eeb79f15ea5a922198d78f\",\"dweb:/ipfs/QmUXh2nDtHBnhYZSwCxcteN4be13S7dR9GbqqHT9mUxta3\"]}},\"version\":1}"},"hashes":{}},"solidity/InterchainClientV1.sol:InterchainEntryLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220d2e0a6fd6774c3c0a83b3c004b2ca706e0c10a5bed83a84d2fb06dbeac7e1c2a64736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220d2e0a6fd6774c3c0a83b3c004b2ca706e0c10a5bed83a84d2fb06dbeac7e1c2a64736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainClientV1Events.sol\n\nabstract contract InterchainClientV1Events {\n    event ExecutionFeesSet(address executionFees);\n    event LinkedClientSet(uint64 chainId, bytes32 client);\n\n    // TODO: figure out indexing\n\n    event InterchainTransactionSent(\n        bytes32 indexed transactionId,\n        uint64 indexed dbNonce,\n        uint64 indexed entryIndex,\n        uint64 dstChainId,\n        bytes32 srcSender,\n        bytes32 dstReceiver,\n        uint256 verificationFee,\n        uint256 executionFee,\n        bytes options,\n        bytes message\n    );\n\n    event InterchainTransactionReceived(\n        bytes32 indexed transactionId,\n        uint64 indexed dbNonce,\n        uint64 indexed entryIndex,\n        uint64 srcChainId,\n        bytes32 srcSender,\n        bytes32 dstReceiver\n    );\n\n    event ExecutionProofWritten(\n        bytes32 indexed transactionId, uint64 indexed dbNonce, uint64 indexed entryIndex, address executor\n    );\n}\n\n// contracts/interfaces/IExecutionFees.sol\n\ninterface IExecutionFees {\n    error ExecutionFees__AlreadyRecorded(uint64 dstChainId, bytes32 transactionId, address executor);\n    error ExecutionFees__ZeroAddress();\n    error ExecutionFees__ZeroAmount();\n\n    /// @notice Add the execution fee for a transaction. The attached value will be added to the\n    /// rewards for the executor completing the transaction.\n    /// Note: this could be used to store the execution fee for a new transaction, or to add more\n    /// funds to the execution fee of an existing transaction. Therefore this function is payable,\n    /// and does not implement any caller restrictions.\n    /// @dev Will revert if the executor is already recorded for the transaction.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to add the execution fee to.\n    function addExecutionFee(uint64 dstChainId, bytes32 transactionId) external payable;\n\n    /// @notice Record the executor (who completed the transaction) for a transaction,\n    /// and update the accumulated rewards for the executor.\n    /// @dev Could only be called by the Recorder.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to record the executor for.\n    /// @param executor             The address of the executor who completed the transaction.\n    function recordExecutor(uint64 dstChainId, bytes32 transactionId, address executor) external;\n\n    /// @notice Allows the executor to claim their unclaimed rewards.\n    /// @dev Will revert if the executor has no unclaimed rewards.\n    function claimExecutionFees(address executor) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the accumulated rewards for an executor.\n    /// @param executor             The address of the executor to get the rewards for.\n    function accumulatedRewards(address executor) external view returns (uint256 accumulated);\n\n    /// @notice Get the unclaimed rewards for an executor.\n    /// @param executor             The address of the executor to get the rewards for.\n    function unclaimedRewards(address executor) external view returns (uint256 unclaimed);\n\n    /// @notice Get the total execution fee for a transaction.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to get the execution fee for.\n    function executionFee(uint64 dstChainId, bytes32 transactionId) external view returns (uint256 fee);\n\n    /// @notice Get the address of the recorded executor for a transaction.\n    /// @dev Will return address(0) if the executor is not recorded.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to get the recorded executor for.\n    function recordedExecutor(uint64 dstChainId, bytes32 transactionId) external view returns (address executor);\n}\n\n// contracts/interfaces/IExecutionService.sol\n\ninterface IExecutionService {\n    /// @notice Request the execution of an Interchain Transaction on a remote chain.\n    /// Note: the off-chain actor needs to fetch the transaction payload from the InterchainClient\n    /// event with the same transactionId, then execute the transaction on the remote chain:\n    /// `dstInterchainClient.executeTransaction(transactionPayload)`\n    /// Once the execution is confirmed on the source chain, the off-chain actor will be able\n    /// to claim `executionFee` in the ExecutionFees contract.\n    /// @dev Could only be called by `InterchainClient` contracts.\n    /// Will revert if the execution fee is not big enough.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param txPayloadSize        The size of the transaction payload to use for the execution.\n    /// @param transactionId        The id of the transaction to execute.\n    /// @param executionFee         The fee paid for the execution.\n    /// @param options              The options to use for the execution.\n    function requestExecution(\n        uint64 dstChainId,\n        uint256 txPayloadSize,\n        bytes32 transactionId,\n        uint256 executionFee,\n        bytes memory options\n    )\n        external;\n\n    /// @notice Get the address of the EOA account that will be used to execute transactions on the\n    /// remote chains.\n    function executorEOA() external view returns (address);\n\n    /// @notice Get the execution fee for executing an Interchain Transaction on a remote chain.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param txPayloadSize        The size of the transaction payload to use for the execution.\n    /// @param options              The options to use for the execution.\n    function getExecutionFee(\n        uint64 dstChainId,\n        uint256 txPayloadSize,\n        bytes memory options\n    )\n        external\n        view\n        returns (uint256);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    /// @notice Allows the Interchain Client to pass the message to the Interchain App.\n    /// @dev App is responsible for keeping track of interchain clients, and must verify the message sender.\n    /// @param srcChainId   Chain ID of the source chain, where the message was sent from.\n    /// @param sender       Sender address on the source chain, as a bytes32 value.\n    /// @param dbNonce      The Interchain DB nonce of the batch containing the message entry.\n    /// @param entryIndex   The index of the message entry within the batch.\n    /// @param message      The message being sent.\n    function appReceive(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /// @notice Returns the verification configuration of the Interchain App.\n    /// @dev This configuration is used by the Interchain Client to verify that message has been confirmed\n    /// by the Interchain Modules on the destination chain.\n    /// Note: V1 version of AppConfig includes the required responses count, and optimistic period after which\n    /// the message is considered confirmed by the module. Following versions may include additional fields.\n    /// @return appConfig    The versioned configuration of the Interchain App, encoded as bytes.\n    /// @return modules      The list of Interchain Modules that app is trusting to confirm the messages.\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/Math.sol\n\nlibrary MathLib {\n    /// @notice Rounds up to the nearest multiple of 32.\n    /// Note: Returns zero on overflows instead of reverting. This is fine for practical\n    /// use cases, as this is used for determining the size of the payload in memory.\n    function roundUpToWord(uint256 x) internal pure returns (uint256) {\n        unchecked {\n            return (x + 31) \u0026 ~uint256(31);\n        }\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/VersionedPayload.sol\n\n// solhint-disable no-inline-assembly\n// solhint-disable ordering\nlibrary VersionedPayloadLib {\n    /// @notice Amount of bytes reserved for the version (uint16) in the versioned payload\n    uint256 internal constant VERSION_LENGTH = 2;\n\n    error VersionedPayload__TooShort(bytes versionedPayload);\n    error VersionedPayload__PrecompileFailed();\n\n    /// @notice Encodes the versioned payload into a single bytes array.\n    /// @param version  The payload's version.\n    /// @param payload  The payload to encode.\n    function encodeVersionedPayload(uint16 version, bytes memory payload) internal pure returns (bytes memory) {\n        return abi.encodePacked(version, payload);\n    }\n\n    /// @notice Extracts the version from the versioned payload (calldata reference).\n    /// @param versionedPayload     The versioned payload (calldata reference).\n    function getVersion(bytes calldata versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            version := shr(240, calldataload(versionedPayload.offset))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (calldata reference).\n    /// @dev The extracted payload is also returned as a calldata reference.\n    /// @param versionedPayload     The versioned payload.\n    function getPayload(bytes calldata versionedPayload) internal pure returns (bytes calldata) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        return versionedPayload[VERSION_LENGTH:];\n    }\n\n    /// @notice Extracts the version from the versioned payload (memory reference).\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getVersionFromMemory(bytes memory versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            // We add 0x20 to skip the length of the bytes array.\n            version := shr(240, mload(add(versionedPayload, 0x20)))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (memory reference).\n    /// @dev The extracted payload is copied into a new memory location. Use `getPayload` when possible\n    /// to avoid extra memory allocation.\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getPayloadFromMemory(bytes memory versionedPayload) internal view returns (bytes memory payload) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        // Figure how many bytes to copy and allocate the memory for the extracted payload.\n        uint256 toCopy;\n        unchecked {\n            toCopy = versionedPayload.length - VERSION_LENGTH;\n        }\n        payload = new bytes(toCopy);\n        // Use identity precompile (0x04) to copy the payload. Unlike MCOPY, this is available on all EVM chains.\n        bool res;\n        assembly {\n            // We add 0x20 to skip the length of the bytes array.\n            // We add 0x02 to skip the 2 bytes reserved for the version.\n            // Copy the payload to the previously allocated memory.\n            res := staticcall(gas(), 0x04, add(versionedPayload, 0x22), toCopy, add(payload, 0x20), toCopy)\n        }\n        if (!res) {\n            revert VersionedPayload__PrecompileFailed();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SafeCast.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value \u003e type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value \u003e type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value \u003e type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value \u003e type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value \u003e type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value \u003e type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value \u003e type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value \u003e type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value \u003e type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value \u003e type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value \u003e type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value \u003e type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value \u003e type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value \u003e type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value \u003e type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value \u003e type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value \u003e type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value \u003e type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value \u003e type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value \u003e type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value \u003e type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value \u003e type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value \u003e type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value \u003e type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value \u003e type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value \u003e type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value \u003e type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value \u003e type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value \u003e type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value \u003e type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value \u003e type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value \u003c 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value \u003e uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal view returns (AppConfigV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (AppConfigV1));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal view returns (OptionsV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (OptionsV1));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(OPTIONS_V1, abi.encode(options));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/libs/InterchainBatch.sol\n\ntype BatchKey is uint128;\n\n/// @notice Struct representing a batch of entries in the Interchain DataBase.\n/// Batched entries are put together in a Merkle tree, which root is saved.\n/// Batch has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: batchRoot\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch\n/// @param batchRoot    The root of the Merkle tree containing the batched entries\nstruct InterchainBatch {\n    uint64 srcChainId;\n    uint64 dbNonce;\n    bytes32 batchRoot;\n}\n\nlibrary InterchainBatchLib {\n    using VersionedPayloadLib for bytes;\n\n    /// @notice Constructs an InterchainBatch struct to be saved on the local chain.\n    /// @param dbNonce      The database nonce of the batch\n    /// @param batchRoot    The root of the Merkle tree containing the batched entries\n    /// @return batch       The constructed InterchainBatch struct\n    function constructLocalBatch(\n        uint64 dbNonce,\n        bytes32 batchRoot\n    )\n        internal\n        view\n        returns (InterchainBatch memory batch)\n    {\n        return InterchainBatch({srcChainId: SafeCast.toUint64(block.chainid), dbNonce: dbNonce, batchRoot: batchRoot});\n    }\n\n    /// @notice Encodes the InterchainBatch struct into a non-versioned batch payload.\n    function encodeBatch(InterchainBatch memory batch) internal pure returns (bytes memory) {\n        return abi.encode(encodeBatchKey(batch.srcChainId, batch.dbNonce), batch.batchRoot);\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in calldata.\n    function decodeBatch(bytes calldata data) internal pure returns (InterchainBatch memory batch) {\n        BatchKey key;\n        (key, batch.batchRoot) = abi.decode(data, (BatchKey, bytes32));\n        (batch.srcChainId, batch.dbNonce) = decodeBatchKey(key);\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in memory.\n    function decodeBatchFromMemory(bytes memory data) internal pure returns (InterchainBatch memory batch) {\n        BatchKey key;\n        (key, batch.batchRoot) = abi.decode(data, (BatchKey, bytes32));\n        (batch.srcChainId, batch.dbNonce) = decodeBatchKey(key);\n    }\n\n    /// @notice Encodes the uint128 key of the batch from uint64 srcChainId and uint64 dbNonce.\n    function encodeBatchKey(uint64 srcChainId, uint64 dbNonce) internal pure returns (BatchKey) {\n        return BatchKey.wrap((uint128(srcChainId) \u003c\u003c 64) | dbNonce);\n    }\n\n    /// @notice Decodes the uint128 key of the batch into uint64 srcChainId and uint64 dbNonce.\n    function decodeBatchKey(BatchKey key) internal pure returns (uint64 srcChainId, uint64 dbNonce) {\n        srcChainId = uint64(BatchKey.unwrap(key) \u003e\u003e 64);\n        dbNonce = uint64(BatchKey.unwrap(key));\n    }\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce + entryIndex\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch containing the entry\n/// @param entryIndex   The index of the entry in the batch\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint64 srcChainId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nusing InterchainEntryLib for InterchainEntry global;\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint64 dbNonce,\n        uint64 entryIndex,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: SafeCast.toUint64(block.chainid),\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n}\n\n// contracts/libs/InterchainTransaction.sol\n\ntype ICTxHeader is uint256;\n\nstruct InterchainTransaction {\n    uint64 srcChainId;\n    uint64 dstChainId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcSender;\n    bytes32 dstReceiver;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    using MathLib for uint256;\n    using VersionedPayloadLib for bytes;\n\n    function constructLocalTransaction(\n        address srcSender,\n        uint64 dstChainId,\n        bytes32 dstReceiver,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: SafeCast.toUint64(block.chainid),\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            encodeTxHeader(transaction.srcChainId, transaction.dstChainId, transaction.dbNonce, transaction.entryIndex),\n            transaction.srcSender,\n            transaction.dstReceiver,\n            transaction.options,\n            transaction.message\n        );\n    }\n\n    function decodeTransaction(bytes calldata transaction) internal pure returns (InterchainTransaction memory icTx) {\n        ICTxHeader header;\n        (header, icTx.srcSender, icTx.dstReceiver, icTx.options, icTx.message) =\n            abi.decode(transaction, (ICTxHeader, bytes32, bytes32, bytes, bytes));\n        (icTx.srcChainId, icTx.dstChainId, icTx.dbNonce, icTx.entryIndex) = decodeTxHeader(header);\n    }\n\n    function payloadSize(uint256 optionsLen, uint256 messageLen) internal pure returns (uint256) {\n        // 2 bytes are reserved for the transaction version\n        // + 5 fields * 32 bytes (3 values for static, 2 offsets for dynamic) + 2 * 32 bytes (lengths for dynamic) = 226\n        // (srcChainId, dstChainId, dbNonce, entryIndex) are merged into a single 32 bytes field\n        // Both options and message are dynamic fields, which are padded up to 32 bytes\n        return 226 + optionsLen.roundUpToWord() + messageLen.roundUpToWord();\n    }\n\n    function encodeTxHeader(\n        uint64 srcChainId,\n        uint64 dstChainId,\n        uint64 dbNonce,\n        uint64 entryIndex\n    )\n        internal\n        pure\n        returns (ICTxHeader)\n    {\n        return ICTxHeader.wrap(\n            (uint256(srcChainId) \u003c\u003c 192) | (uint256(dstChainId) \u003c\u003c 128) | (uint256(dbNonce) \u003c\u003c 64) | uint256(entryIndex)\n        );\n    }\n\n    function decodeTxHeader(ICTxHeader header)\n        internal\n        pure\n        returns (uint64 srcChainId, uint64 dstChainId, uint64 dbNonce, uint64 entryIndex)\n    {\n        srcChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 192);\n        dstChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 128);\n        dbNonce = uint64(ICTxHeader.unwrap(header) \u003e\u003e 64);\n        entryIndex = uint64(ICTxHeader.unwrap(header));\n    }\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint64 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__InvalidTransactionVersion(uint16 version);\n    error InterchainClientV1__NoLinkedClient(uint64 chainId);\n    error InterchainClientV1__NotEnoughGasSupplied();\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint64 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint64 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint64 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint64 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param messageLen           The length of the message being sent.\n    function getInterchainFee(\n        uint64 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        uint256 messageLen\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint64 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint64 chainId) external view returns (address);\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing a batch of entries from the remote Interchain DataBase,\n    /// verified by the Interchain Module.\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param batchRoot    The Merkle root of the batch\n    struct RemoteBatch {\n        uint256 verifiedAt;\n        bytes32 batchRoot;\n    }\n\n    error InterchainDB__BatchDoesNotExist(uint64 dbNonce);\n    error InterchainDB__BatchNotFinalized(uint64 dbNonce);\n    error InterchainDB__ConflictingBatches(address module, bytes32 existingBatchRoot, InterchainBatch newBatch);\n    error InterchainDB__EntryIndexOutOfRange(uint64 dbNonce, uint64 entryIndex, uint64 batchSize);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__InvalidBatchVersion(uint16 version);\n    error InterchainDB__InvalidEntryRange(uint64 dbNonce, uint64 start, uint64 end);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId(uint64 chainId);\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `requestBatchVerification` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntry(bytes32 dataHash) external returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Request the given Interchain Modules to verify an existing batch.\n    /// If the batch is not finalized, the module will verify it after finalization.\n    /// For the finalized batch the batch root is already available, and the module can verify it immediately.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any batch.\n    /// @dev Will revert if the batch with the given nonce does not exist.\n    /// @param dstChainId    The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the existing batch\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestBatchVerification(\n        uint64 dstChainId,\n        uint64 dbNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Then request the Interchain Modules to verify the batch containing the written entry on the destination chain.\n    /// See `writeEntry` and `requestBatchVerification` for more details.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntryWithVerification(\n        uint64 dstChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Allows the Interchain Module to verify the batch coming from the remote chain.\n    /// Note: The DB will only accept the batch of the same version as the DB itself.\n    /// @param versionedBatch   The versioned Interchain Batch to verify\n    function verifyRemoteBatch(bytes memory versionedBatch) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint64 dstChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce.\n    /// Note: the leafs are ordered by the index of the written entry in the current batch,\n    /// and the leafs value match the value of the written entry (srcWriter + dataHash hashed together).\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchLeafs(uint64 dbNonce) external view returns (bytes32[] memory);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce,\n    /// paginated by the given start and end indexes. The end index is exclusive.\n    /// Note: this is useful when the batch contains a large number of leafs, and calling `getBatchLeafs`\n    /// would result in a gas limit exceeded error.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the provided range is invalid.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param start        The start index of the paginated leafs, inclusive\n    /// @param end          The end index of the paginated leafs, exclusive\n    function getBatchLeafsPaginated(\n        uint64 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory);\n\n    /// @notice Returns the size of the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchSize(uint64 dbNonce) external view returns (uint64);\n\n    /// @notice Get the finalized Interchain Batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatch(uint64 dbNonce) external view returns (InterchainBatch memory);\n\n    /// @notice Get the Interchain Entry's value written on the local chain with the given batch nonce and entry index.\n    /// Entry value is calculated as the hash of the writer address and the written data hash.\n    /// Note: the batch does not have to be finalized to fetch the entry value.\n    /// @dev Will revert if the batch with the given nonce does not exist,\n    /// or the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the existing batch\n    /// @param entryIndex   The index of the written entry within the batch\n    function getEntryValue(uint64 dbNonce, uint64 entryIndex) external view returns (bytes32);\n\n    /// @notice Get the Merkle proof of inclusion for the entry with the given index\n    /// in the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param entryIndex   The index of the written entry within the batch\n    /// @return proof       The Merkle proof of inclusion for the entry\n    function getEntryProof(uint64 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof);\n\n    /// @notice Get the nonce of the database, which is incremented every time a new batch is finalized.\n    /// This is the nonce of the current non-finalized batch.\n    function getDBNonce() external view returns (uint64);\n\n    /// @notice Get the index of the next entry to be written to the database.\n    /// @return dbNonce      The database nonce of the batch including the next entry\n    /// @return entryIndex   The index of the next entry within that batch\n    function getNextEntryIndex() external view returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or ZERO if the module has not verified the entry.\n    function checkVerification(\n        address dstModule,\n        InterchainEntry memory entry,\n        bytes32[] memory proof\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n\n    /// @notice Get the version of the Interchain DataBase.\n    // solhint-disable-next-line func-name-mixedcase\n    function DB_VERSION() external pure returns (uint16);\n}\n\n// contracts/InterchainClientV1.sol\n\n/**\n * @title InterchainClientV1\n * @dev Implements the operations of the Interchain Execution Layer.\n */\ncontract InterchainClientV1 is Ownable, InterchainClientV1Events, IInterchainClientV1 {\n    using AppConfigLib for bytes;\n    using OptionsLib for bytes;\n    using VersionedPayloadLib for bytes;\n\n    /// @notice Version of the InterchainClient contract. Sent and received transactions must have the same version.\n    uint16 public constant CLIENT_VERSION = 1;\n\n    /// @notice Address of the InterchainDB contract, set at the time of deployment.\n    address public immutable INTERCHAIN_DB;\n\n    /// @notice Address of the contract that handles execution fees. Can be updated by the owner.\n    address public executionFees;\n\n    /// @dev Address of the InterchainClient contract on the remote chain\n    mapping(uint64 chainId =\u003e bytes32 remoteClient) internal _linkedClient;\n    /// @dev Executor address that completed the transaction. Address(0) if not executed yet.\n    mapping(bytes32 transactionId =\u003e address executor) internal _txExecutor;\n\n    constructor(address interchainDB, address owner_) Ownable(owner_) {\n        INTERCHAIN_DB = interchainDB;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function setExecutionFees(address executionFees_) external onlyOwner {\n        executionFees = executionFees_;\n        emit ExecutionFeesSet(executionFees_);\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function setLinkedClient(uint64 chainId, bytes32 client) external onlyOwner {\n        _linkedClient[chainId] = client;\n        emit LinkedClientSet(chainId, client);\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _interchainSend(dstChainId, receiver, srcExecutionService, srcModules, options, message);\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function interchainSendEVM(\n        uint64 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc)\n    {\n        bytes32 receiverBytes32 = TypeCasts.addressToBytes32(receiver);\n        return _interchainSend(dstChainId, receiverBytes32, srcExecutionService, srcModules, options, message);\n    }\n\n    // TODO: Handle the case where receiver does not implement the IInterchainApp interface (or does not exist at all)\n    // @inheritdoc IInterchainClientV1\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable\n    {\n        InterchainTransaction memory icTx = _assertCorrectVersion(transaction);\n        bytes32 transactionId = keccak256(transaction);\n        _assertExecutable(icTx, transactionId, proof);\n        _txExecutor[transactionId] = msg.sender;\n\n        OptionsV1 memory decodedOptions = icTx.options.decodeOptionsV1();\n        if (msg.value != decodedOptions.gasAirdrop) {\n            revert InterchainClientV1__IncorrectMsgValue(msg.value, decodedOptions.gasAirdrop);\n        }\n        // We should always use at least as much as the requested gas limit.\n        // The executor can specify a higher gas limit if they wanted.\n        if (decodedOptions.gasLimit \u003e gasLimit) gasLimit = decodedOptions.gasLimit;\n        // Check the the Executor has provided big enough gas limit for the whole transaction.\n        if (gasleft() \u003c= gasLimit) {\n            revert InterchainClientV1__NotEnoughGasSupplied();\n        }\n        // Pass the full msg.value to the app: we have already checked that it matches the requested gas airdrop.\n        IInterchainApp(TypeCasts.bytes32ToAddress(icTx.dstReceiver)).appReceive{gas: gasLimit, value: msg.value}({\n            srcChainId: icTx.srcChainId,\n            sender: icTx.srcSender,\n            dbNonce: icTx.dbNonce,\n            entryIndex: icTx.entryIndex,\n            message: icTx.message\n        });\n        emit InterchainTransactionReceived(\n            transactionId, icTx.dbNonce, icTx.entryIndex, icTx.srcChainId, icTx.srcSender, icTx.dstReceiver\n        );\n    }\n\n    /// @inheritdoc IInterchainClientV1\n    function writeExecutionProof(bytes32 transactionId) external returns (uint64 dbNonce, uint64 entryIndex) {\n        address executor = _txExecutor[transactionId];\n        if (executor == address(0)) {\n            revert InterchainClientV1__TxNotExecuted(transactionId);\n        }\n        bytes memory proof = abi.encode(transactionId, executor);\n        (dbNonce, entryIndex) = IInterchainDB(INTERCHAIN_DB).writeEntry(keccak256(proof));\n        emit ExecutionProofWritten(transactionId, dbNonce, entryIndex, executor);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // @inheritdoc IInterchainClientV1\n    function isExecutable(bytes calldata encodedTx, bytes32[] calldata proof) external view returns (bool) {\n        InterchainTransaction memory icTx = _assertCorrectVersion(encodedTx);\n        // Check that options could be decoded\n        icTx.options.decodeOptionsV1();\n        bytes32 transactionId = keccak256(encodedTx);\n        _assertExecutable(icTx, transactionId, proof);\n        return true;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function getExecutor(bytes calldata encodedTx) external view returns (address) {\n        return _txExecutor[keccak256(encodedTx)];\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function getExecutorById(bytes32 transactionId) external view returns (address) {\n        return _txExecutor[transactionId];\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function getInterchainFee(\n        uint64 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        uint256 messageLen\n    )\n        external\n        view\n        returns (uint256 fee)\n    {\n        _assertLinkedClient(dstChainId);\n        // Check that options could be decoded on destination chain\n        options.decodeOptionsV1();\n        // Verification fee from InterchainDB\n        fee = IInterchainDB(INTERCHAIN_DB).getInterchainFee(dstChainId, srcModules);\n        // Add execution fee, if ExecutionService is provided\n        if (srcExecutionService != address(0)) {\n            uint256 payloadSize = InterchainTransactionLib.payloadSize(options.length, messageLen);\n            fee += IExecutionService(srcExecutionService).getExecutionFee(dstChainId, payloadSize, options);\n        }\n    }\n\n    /// @inheritdoc IInterchainClientV1\n    function getLinkedClient(uint64 chainId) external view returns (bytes32) {\n        if (chainId == block.chainid) {\n            revert InterchainClientV1__NotRemoteChainId(chainId);\n        }\n        return _linkedClient[chainId];\n    }\n\n    /// @inheritdoc IInterchainClientV1\n    function getLinkedClientEVM(uint64 chainId) external view returns (address linkedClientEVM) {\n        if (chainId == block.chainid) {\n            revert InterchainClientV1__NotRemoteChainId(chainId);\n        }\n        bytes32 linkedClient = _linkedClient[chainId];\n        linkedClientEVM = TypeCasts.bytes32ToAddress(linkedClient);\n        // Check that the linked client address fits into the EVM address space\n        if (TypeCasts.addressToBytes32(linkedClientEVM) != linkedClient) {\n            revert InterchainClientV1__NotEVMClient(linkedClient);\n        }\n    }\n\n    /// @notice Decodes the encoded options data into a OptionsV1 struct.\n    function decodeOptions(bytes memory encodedOptions) external view returns (OptionsV1 memory) {\n        return encodedOptions.decodeOptionsV1();\n    }\n\n    /// @notice Encodes the transaction data into a bytes format.\n    function encodeTransaction(InterchainTransaction memory icTx) public pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload({\n            version: CLIENT_VERSION,\n            payload: InterchainTransactionLib.encodeTransaction(icTx)\n        });\n    }\n\n    // ═════════════════════════════════════════════════ INTERNAL ══════════════════════════════════════════════════════\n\n    /// @dev Internal logic for sending a message to another chain.\n    function _interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        _assertLinkedClient(dstChainId);\n        if (receiver == 0) revert InterchainClientV1__ZeroReceiver();\n        // Check that options could be decoded on destination chain\n        options.decodeOptionsV1();\n        uint256 verificationFee = IInterchainDB(INTERCHAIN_DB).getInterchainFee(dstChainId, srcModules);\n        if (msg.value \u003c verificationFee) {\n            revert InterchainClientV1__FeeAmountTooLow(msg.value, verificationFee);\n        }\n        (desc.dbNonce, desc.entryIndex) = IInterchainDB(INTERCHAIN_DB).getNextEntryIndex();\n        InterchainTransaction memory icTx = InterchainTransactionLib.constructLocalTransaction({\n            srcSender: msg.sender,\n            dstReceiver: receiver,\n            dstChainId: dstChainId,\n            dbNonce: desc.dbNonce,\n            entryIndex: desc.entryIndex,\n            options: options,\n            message: message\n        });\n        desc.transactionId = keccak256(encodeTransaction(icTx));\n        // Sanity check: nonce returned from DB should match the nonce used to construct the transaction\n        {\n            (uint64 dbNonce, uint64 entryIndex) = IInterchainDB(INTERCHAIN_DB).writeEntryWithVerification{\n                value: verificationFee\n            }(icTx.dstChainId, desc.transactionId, srcModules);\n            assert(dbNonce == desc.dbNonce \u0026\u0026 entryIndex == desc.entryIndex);\n        }\n        uint256 executionFee;\n        unchecked {\n            executionFee = msg.value - verificationFee;\n        }\n        if (executionFee \u003e 0) {\n            IExecutionFees(executionFees).addExecutionFee{value: executionFee}(icTx.dstChainId, desc.transactionId);\n        }\n        // TODO: consider disallowing the use of empty srcExecutionService\n        if (srcExecutionService != address(0)) {\n            IExecutionService(srcExecutionService).requestExecution({\n                dstChainId: dstChainId,\n                txPayloadSize: InterchainTransactionLib.payloadSize(options.length, message.length),\n                transactionId: desc.transactionId,\n                executionFee: executionFee,\n                options: options\n            });\n            address srcExecutorEOA = IExecutionService(srcExecutionService).executorEOA();\n            IExecutionFees(executionFees).recordExecutor(icTx.dstChainId, desc.transactionId, srcExecutorEOA);\n        }\n        emit InterchainTransactionSent(\n            desc.transactionId,\n            icTx.dbNonce,\n            icTx.entryIndex,\n            icTx.dstChainId,\n            icTx.srcSender,\n            icTx.dstReceiver,\n            verificationFee,\n            executionFee,\n            icTx.options,\n            icTx.message\n        );\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Asserts that the transaction is executable.\n    function _assertExecutable(\n        InterchainTransaction memory icTx,\n        bytes32 transactionId,\n        bytes32[] calldata proof\n    )\n        internal\n        view\n    {\n        bytes32 linkedClient = _assertLinkedClient(icTx.srcChainId);\n        if (icTx.dstChainId != block.chainid) {\n            revert InterchainClientV1__IncorrectDstChainId(icTx.dstChainId);\n        }\n        if (_txExecutor[transactionId] != address(0)) {\n            revert InterchainClientV1__TxAlreadyExecuted(transactionId);\n        }\n        // Construct expected entry based on icTransaction data\n        InterchainEntry memory icEntry = InterchainEntry({\n            srcChainId: icTx.srcChainId,\n            dbNonce: icTx.dbNonce,\n            entryIndex: icTx.entryIndex,\n            srcWriter: linkedClient,\n            dataHash: transactionId\n        });\n        (bytes memory encodedAppConfig, address[] memory approvedDstModules) =\n            IInterchainApp(TypeCasts.bytes32ToAddress(icTx.dstReceiver)).getReceivingConfig();\n        AppConfigV1 memory appConfig = encodedAppConfig.decodeAppConfigV1();\n        if (appConfig.requiredResponses == 0) {\n            revert InterchainClientV1__ZeroRequiredResponses();\n        }\n        uint256 responses = _getFinalizedResponsesCount(approvedDstModules, icEntry, proof, appConfig.optimisticPeriod);\n        if (responses \u003c appConfig.requiredResponses) {\n            revert InterchainClientV1__NotEnoughResponses(responses, appConfig.requiredResponses);\n        }\n    }\n\n    /// @dev Asserts that the chain is linked and returns the linked client address.\n    function _assertLinkedClient(uint64 chainId) internal view returns (bytes32 linkedClient) {\n        if (chainId == block.chainid) {\n            revert InterchainClientV1__NotRemoteChainId(chainId);\n        }\n        linkedClient = _linkedClient[chainId];\n        if (linkedClient == 0) {\n            revert InterchainClientV1__NoLinkedClient(chainId);\n        }\n    }\n\n    /**\n     * @dev Calculates the number of responses that are considered finalized within the optimistic time period.\n     * @param approvedModules       Approved modules that could have confirmed the entry.\n     * @param icEntry               The InterchainEntry to confirm.\n     * @param optimisticPeriod      The time period in seconds within which a response is considered valid.\n     * @return finalizedResponses   The count of responses that are finalized within the optimistic time period.\n     */\n    function _getFinalizedResponsesCount(\n        address[] memory approvedModules,\n        InterchainEntry memory icEntry,\n        bytes32[] calldata proof,\n        uint256 optimisticPeriod\n    )\n        internal\n        view\n        returns (uint256 finalizedResponses)\n    {\n        for (uint256 i = 0; i \u003c approvedModules.length; ++i) {\n            uint256 confirmedAt = IInterchainDB(INTERCHAIN_DB).checkVerification(approvedModules[i], icEntry, proof);\n            // checkVerification() returns 0 if entry hasn't been confirmed by the module, so we check for that as well\n            if (confirmedAt != 0 \u0026\u0026 confirmedAt + optimisticPeriod \u003c block.timestamp) {\n                ++finalizedResponses;\n            }\n        }\n    }\n\n    /// @dev Asserts that the transaction version is correct. Returns the decoded transaction for chaining purposes.\n    function _assertCorrectVersion(bytes calldata versionedTx)\n        internal\n        pure\n        returns (InterchainTransaction memory icTx)\n    {\n        uint16 version = versionedTx.getVersion();\n        if (version != CLIENT_VERSION) {\n            revert InterchainClientV1__InvalidTransactionVersion(version);\n        }\n        icTx = InterchainTransactionLib.decodeTransaction(versionedTx.getPayload());\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"58347:1148:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;58347:1148:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"58347:1148:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainClientV1.sol\":\"InterchainEntryLib\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainClientV1.sol\":{\"keccak256\":\"0xe270686a9bca05b4013610a4e8bb08040de32a0442edd218e1692edaca94e40e\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://727e84146369613e04e57a677f8bc6c709ee145df3eeb79f15ea5a922198d78f\",\"dweb:/ipfs/QmUXh2nDtHBnhYZSwCxcteN4be13S7dR9GbqqHT9mUxta3\"]}},\"version\":1}"},"hashes":{}},"solidity/InterchainClientV1.sol:InterchainTransactionLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220b2e4d3b9ce1c3ac21e3fe3ea137f7f94b8c3b39dc5e6e6025ef7e55fc115793164736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220b2e4d3b9ce1c3ac21e3fe3ea137f7f94b8c3b39dc5e6e6025ef7e55fc115793164736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainClientV1Events.sol\n\nabstract contract InterchainClientV1Events {\n    event ExecutionFeesSet(address executionFees);\n    event LinkedClientSet(uint64 chainId, bytes32 client);\n\n    // TODO: figure out indexing\n\n    event InterchainTransactionSent(\n        bytes32 indexed transactionId,\n        uint64 indexed dbNonce,\n        uint64 indexed entryIndex,\n        uint64 dstChainId,\n        bytes32 srcSender,\n        bytes32 dstReceiver,\n        uint256 verificationFee,\n        uint256 executionFee,\n        bytes options,\n        bytes message\n    );\n\n    event InterchainTransactionReceived(\n        bytes32 indexed transactionId,\n        uint64 indexed dbNonce,\n        uint64 indexed entryIndex,\n        uint64 srcChainId,\n        bytes32 srcSender,\n        bytes32 dstReceiver\n    );\n\n    event ExecutionProofWritten(\n        bytes32 indexed transactionId, uint64 indexed dbNonce, uint64 indexed entryIndex, address executor\n    );\n}\n\n// contracts/interfaces/IExecutionFees.sol\n\ninterface IExecutionFees {\n    error ExecutionFees__AlreadyRecorded(uint64 dstChainId, bytes32 transactionId, address executor);\n    error ExecutionFees__ZeroAddress();\n    error ExecutionFees__ZeroAmount();\n\n    /// @notice Add the execution fee for a transaction. The attached value will be added to the\n    /// rewards for the executor completing the transaction.\n    /// Note: this could be used to store the execution fee for a new transaction, or to add more\n    /// funds to the execution fee of an existing transaction. Therefore this function is payable,\n    /// and does not implement any caller restrictions.\n    /// @dev Will revert if the executor is already recorded for the transaction.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to add the execution fee to.\n    function addExecutionFee(uint64 dstChainId, bytes32 transactionId) external payable;\n\n    /// @notice Record the executor (who completed the transaction) for a transaction,\n    /// and update the accumulated rewards for the executor.\n    /// @dev Could only be called by the Recorder.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to record the executor for.\n    /// @param executor             The address of the executor who completed the transaction.\n    function recordExecutor(uint64 dstChainId, bytes32 transactionId, address executor) external;\n\n    /// @notice Allows the executor to claim their unclaimed rewards.\n    /// @dev Will revert if the executor has no unclaimed rewards.\n    function claimExecutionFees(address executor) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the accumulated rewards for an executor.\n    /// @param executor             The address of the executor to get the rewards for.\n    function accumulatedRewards(address executor) external view returns (uint256 accumulated);\n\n    /// @notice Get the unclaimed rewards for an executor.\n    /// @param executor             The address of the executor to get the rewards for.\n    function unclaimedRewards(address executor) external view returns (uint256 unclaimed);\n\n    /// @notice Get the total execution fee for a transaction.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to get the execution fee for.\n    function executionFee(uint64 dstChainId, bytes32 transactionId) external view returns (uint256 fee);\n\n    /// @notice Get the address of the recorded executor for a transaction.\n    /// @dev Will return address(0) if the executor is not recorded.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to get the recorded executor for.\n    function recordedExecutor(uint64 dstChainId, bytes32 transactionId) external view returns (address executor);\n}\n\n// contracts/interfaces/IExecutionService.sol\n\ninterface IExecutionService {\n    /// @notice Request the execution of an Interchain Transaction on a remote chain.\n    /// Note: the off-chain actor needs to fetch the transaction payload from the InterchainClient\n    /// event with the same transactionId, then execute the transaction on the remote chain:\n    /// `dstInterchainClient.executeTransaction(transactionPayload)`\n    /// Once the execution is confirmed on the source chain, the off-chain actor will be able\n    /// to claim `executionFee` in the ExecutionFees contract.\n    /// @dev Could only be called by `InterchainClient` contracts.\n    /// Will revert if the execution fee is not big enough.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param txPayloadSize        The size of the transaction payload to use for the execution.\n    /// @param transactionId        The id of the transaction to execute.\n    /// @param executionFee         The fee paid for the execution.\n    /// @param options              The options to use for the execution.\n    function requestExecution(\n        uint64 dstChainId,\n        uint256 txPayloadSize,\n        bytes32 transactionId,\n        uint256 executionFee,\n        bytes memory options\n    )\n        external;\n\n    /// @notice Get the address of the EOA account that will be used to execute transactions on the\n    /// remote chains.\n    function executorEOA() external view returns (address);\n\n    /// @notice Get the execution fee for executing an Interchain Transaction on a remote chain.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param txPayloadSize        The size of the transaction payload to use for the execution.\n    /// @param options              The options to use for the execution.\n    function getExecutionFee(\n        uint64 dstChainId,\n        uint256 txPayloadSize,\n        bytes memory options\n    )\n        external\n        view\n        returns (uint256);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    /// @notice Allows the Interchain Client to pass the message to the Interchain App.\n    /// @dev App is responsible for keeping track of interchain clients, and must verify the message sender.\n    /// @param srcChainId   Chain ID of the source chain, where the message was sent from.\n    /// @param sender       Sender address on the source chain, as a bytes32 value.\n    /// @param dbNonce      The Interchain DB nonce of the batch containing the message entry.\n    /// @param entryIndex   The index of the message entry within the batch.\n    /// @param message      The message being sent.\n    function appReceive(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /// @notice Returns the verification configuration of the Interchain App.\n    /// @dev This configuration is used by the Interchain Client to verify that message has been confirmed\n    /// by the Interchain Modules on the destination chain.\n    /// Note: V1 version of AppConfig includes the required responses count, and optimistic period after which\n    /// the message is considered confirmed by the module. Following versions may include additional fields.\n    /// @return appConfig    The versioned configuration of the Interchain App, encoded as bytes.\n    /// @return modules      The list of Interchain Modules that app is trusting to confirm the messages.\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/Math.sol\n\nlibrary MathLib {\n    /// @notice Rounds up to the nearest multiple of 32.\n    /// Note: Returns zero on overflows instead of reverting. This is fine for practical\n    /// use cases, as this is used for determining the size of the payload in memory.\n    function roundUpToWord(uint256 x) internal pure returns (uint256) {\n        unchecked {\n            return (x + 31) \u0026 ~uint256(31);\n        }\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/VersionedPayload.sol\n\n// solhint-disable no-inline-assembly\n// solhint-disable ordering\nlibrary VersionedPayloadLib {\n    /// @notice Amount of bytes reserved for the version (uint16) in the versioned payload\n    uint256 internal constant VERSION_LENGTH = 2;\n\n    error VersionedPayload__TooShort(bytes versionedPayload);\n    error VersionedPayload__PrecompileFailed();\n\n    /// @notice Encodes the versioned payload into a single bytes array.\n    /// @param version  The payload's version.\n    /// @param payload  The payload to encode.\n    function encodeVersionedPayload(uint16 version, bytes memory payload) internal pure returns (bytes memory) {\n        return abi.encodePacked(version, payload);\n    }\n\n    /// @notice Extracts the version from the versioned payload (calldata reference).\n    /// @param versionedPayload     The versioned payload (calldata reference).\n    function getVersion(bytes calldata versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            version := shr(240, calldataload(versionedPayload.offset))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (calldata reference).\n    /// @dev The extracted payload is also returned as a calldata reference.\n    /// @param versionedPayload     The versioned payload.\n    function getPayload(bytes calldata versionedPayload) internal pure returns (bytes calldata) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        return versionedPayload[VERSION_LENGTH:];\n    }\n\n    /// @notice Extracts the version from the versioned payload (memory reference).\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getVersionFromMemory(bytes memory versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            // We add 0x20 to skip the length of the bytes array.\n            version := shr(240, mload(add(versionedPayload, 0x20)))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (memory reference).\n    /// @dev The extracted payload is copied into a new memory location. Use `getPayload` when possible\n    /// to avoid extra memory allocation.\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getPayloadFromMemory(bytes memory versionedPayload) internal view returns (bytes memory payload) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        // Figure how many bytes to copy and allocate the memory for the extracted payload.\n        uint256 toCopy;\n        unchecked {\n            toCopy = versionedPayload.length - VERSION_LENGTH;\n        }\n        payload = new bytes(toCopy);\n        // Use identity precompile (0x04) to copy the payload. Unlike MCOPY, this is available on all EVM chains.\n        bool res;\n        assembly {\n            // We add 0x20 to skip the length of the bytes array.\n            // We add 0x02 to skip the 2 bytes reserved for the version.\n            // Copy the payload to the previously allocated memory.\n            res := staticcall(gas(), 0x04, add(versionedPayload, 0x22), toCopy, add(payload, 0x20), toCopy)\n        }\n        if (!res) {\n            revert VersionedPayload__PrecompileFailed();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SafeCast.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value \u003e type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value \u003e type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value \u003e type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value \u003e type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value \u003e type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value \u003e type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value \u003e type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value \u003e type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value \u003e type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value \u003e type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value \u003e type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value \u003e type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value \u003e type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value \u003e type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value \u003e type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value \u003e type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value \u003e type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value \u003e type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value \u003e type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value \u003e type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value \u003e type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value \u003e type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value \u003e type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value \u003e type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value \u003e type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value \u003e type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value \u003e type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value \u003e type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value \u003e type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value \u003e type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value \u003e type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value \u003c 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value \u003e uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal view returns (AppConfigV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (AppConfigV1));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal view returns (OptionsV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (OptionsV1));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(OPTIONS_V1, abi.encode(options));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/libs/InterchainBatch.sol\n\ntype BatchKey is uint128;\n\n/// @notice Struct representing a batch of entries in the Interchain DataBase.\n/// Batched entries are put together in a Merkle tree, which root is saved.\n/// Batch has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: batchRoot\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch\n/// @param batchRoot    The root of the Merkle tree containing the batched entries\nstruct InterchainBatch {\n    uint64 srcChainId;\n    uint64 dbNonce;\n    bytes32 batchRoot;\n}\n\nlibrary InterchainBatchLib {\n    using VersionedPayloadLib for bytes;\n\n    /// @notice Constructs an InterchainBatch struct to be saved on the local chain.\n    /// @param dbNonce      The database nonce of the batch\n    /// @param batchRoot    The root of the Merkle tree containing the batched entries\n    /// @return batch       The constructed InterchainBatch struct\n    function constructLocalBatch(\n        uint64 dbNonce,\n        bytes32 batchRoot\n    )\n        internal\n        view\n        returns (InterchainBatch memory batch)\n    {\n        return InterchainBatch({srcChainId: SafeCast.toUint64(block.chainid), dbNonce: dbNonce, batchRoot: batchRoot});\n    }\n\n    /// @notice Encodes the InterchainBatch struct into a non-versioned batch payload.\n    function encodeBatch(InterchainBatch memory batch) internal pure returns (bytes memory) {\n        return abi.encode(encodeBatchKey(batch.srcChainId, batch.dbNonce), batch.batchRoot);\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in calldata.\n    function decodeBatch(bytes calldata data) internal pure returns (InterchainBatch memory batch) {\n        BatchKey key;\n        (key, batch.batchRoot) = abi.decode(data, (BatchKey, bytes32));\n        (batch.srcChainId, batch.dbNonce) = decodeBatchKey(key);\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in memory.\n    function decodeBatchFromMemory(bytes memory data) internal pure returns (InterchainBatch memory batch) {\n        BatchKey key;\n        (key, batch.batchRoot) = abi.decode(data, (BatchKey, bytes32));\n        (batch.srcChainId, batch.dbNonce) = decodeBatchKey(key);\n    }\n\n    /// @notice Encodes the uint128 key of the batch from uint64 srcChainId and uint64 dbNonce.\n    function encodeBatchKey(uint64 srcChainId, uint64 dbNonce) internal pure returns (BatchKey) {\n        return BatchKey.wrap((uint128(srcChainId) \u003c\u003c 64) | dbNonce);\n    }\n\n    /// @notice Decodes the uint128 key of the batch into uint64 srcChainId and uint64 dbNonce.\n    function decodeBatchKey(BatchKey key) internal pure returns (uint64 srcChainId, uint64 dbNonce) {\n        srcChainId = uint64(BatchKey.unwrap(key) \u003e\u003e 64);\n        dbNonce = uint64(BatchKey.unwrap(key));\n    }\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce + entryIndex\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch containing the entry\n/// @param entryIndex   The index of the entry in the batch\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint64 srcChainId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nusing InterchainEntryLib for InterchainEntry global;\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint64 dbNonce,\n        uint64 entryIndex,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: SafeCast.toUint64(block.chainid),\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n}\n\n// contracts/libs/InterchainTransaction.sol\n\ntype ICTxHeader is uint256;\n\nstruct InterchainTransaction {\n    uint64 srcChainId;\n    uint64 dstChainId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcSender;\n    bytes32 dstReceiver;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    using MathLib for uint256;\n    using VersionedPayloadLib for bytes;\n\n    function constructLocalTransaction(\n        address srcSender,\n        uint64 dstChainId,\n        bytes32 dstReceiver,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: SafeCast.toUint64(block.chainid),\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            encodeTxHeader(transaction.srcChainId, transaction.dstChainId, transaction.dbNonce, transaction.entryIndex),\n            transaction.srcSender,\n            transaction.dstReceiver,\n            transaction.options,\n            transaction.message\n        );\n    }\n\n    function decodeTransaction(bytes calldata transaction) internal pure returns (InterchainTransaction memory icTx) {\n        ICTxHeader header;\n        (header, icTx.srcSender, icTx.dstReceiver, icTx.options, icTx.message) =\n            abi.decode(transaction, (ICTxHeader, bytes32, bytes32, bytes, bytes));\n        (icTx.srcChainId, icTx.dstChainId, icTx.dbNonce, icTx.entryIndex) = decodeTxHeader(header);\n    }\n\n    function payloadSize(uint256 optionsLen, uint256 messageLen) internal pure returns (uint256) {\n        // 2 bytes are reserved for the transaction version\n        // + 5 fields * 32 bytes (3 values for static, 2 offsets for dynamic) + 2 * 32 bytes (lengths for dynamic) = 226\n        // (srcChainId, dstChainId, dbNonce, entryIndex) are merged into a single 32 bytes field\n        // Both options and message are dynamic fields, which are padded up to 32 bytes\n        return 226 + optionsLen.roundUpToWord() + messageLen.roundUpToWord();\n    }\n\n    function encodeTxHeader(\n        uint64 srcChainId,\n        uint64 dstChainId,\n        uint64 dbNonce,\n        uint64 entryIndex\n    )\n        internal\n        pure\n        returns (ICTxHeader)\n    {\n        return ICTxHeader.wrap(\n            (uint256(srcChainId) \u003c\u003c 192) | (uint256(dstChainId) \u003c\u003c 128) | (uint256(dbNonce) \u003c\u003c 64) | uint256(entryIndex)\n        );\n    }\n\n    function decodeTxHeader(ICTxHeader header)\n        internal\n        pure\n        returns (uint64 srcChainId, uint64 dstChainId, uint64 dbNonce, uint64 entryIndex)\n    {\n        srcChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 192);\n        dstChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 128);\n        dbNonce = uint64(ICTxHeader.unwrap(header) \u003e\u003e 64);\n        entryIndex = uint64(ICTxHeader.unwrap(header));\n    }\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint64 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__InvalidTransactionVersion(uint16 version);\n    error InterchainClientV1__NoLinkedClient(uint64 chainId);\n    error InterchainClientV1__NotEnoughGasSupplied();\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint64 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint64 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint64 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint64 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param messageLen           The length of the message being sent.\n    function getInterchainFee(\n        uint64 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        uint256 messageLen\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint64 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint64 chainId) external view returns (address);\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing a batch of entries from the remote Interchain DataBase,\n    /// verified by the Interchain Module.\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param batchRoot    The Merkle root of the batch\n    struct RemoteBatch {\n        uint256 verifiedAt;\n        bytes32 batchRoot;\n    }\n\n    error InterchainDB__BatchDoesNotExist(uint64 dbNonce);\n    error InterchainDB__BatchNotFinalized(uint64 dbNonce);\n    error InterchainDB__ConflictingBatches(address module, bytes32 existingBatchRoot, InterchainBatch newBatch);\n    error InterchainDB__EntryIndexOutOfRange(uint64 dbNonce, uint64 entryIndex, uint64 batchSize);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__InvalidBatchVersion(uint16 version);\n    error InterchainDB__InvalidEntryRange(uint64 dbNonce, uint64 start, uint64 end);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId(uint64 chainId);\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `requestBatchVerification` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntry(bytes32 dataHash) external returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Request the given Interchain Modules to verify an existing batch.\n    /// If the batch is not finalized, the module will verify it after finalization.\n    /// For the finalized batch the batch root is already available, and the module can verify it immediately.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any batch.\n    /// @dev Will revert if the batch with the given nonce does not exist.\n    /// @param dstChainId    The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the existing batch\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestBatchVerification(\n        uint64 dstChainId,\n        uint64 dbNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Then request the Interchain Modules to verify the batch containing the written entry on the destination chain.\n    /// See `writeEntry` and `requestBatchVerification` for more details.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntryWithVerification(\n        uint64 dstChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Allows the Interchain Module to verify the batch coming from the remote chain.\n    /// Note: The DB will only accept the batch of the same version as the DB itself.\n    /// @param versionedBatch   The versioned Interchain Batch to verify\n    function verifyRemoteBatch(bytes memory versionedBatch) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint64 dstChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce.\n    /// Note: the leafs are ordered by the index of the written entry in the current batch,\n    /// and the leafs value match the value of the written entry (srcWriter + dataHash hashed together).\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchLeafs(uint64 dbNonce) external view returns (bytes32[] memory);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce,\n    /// paginated by the given start and end indexes. The end index is exclusive.\n    /// Note: this is useful when the batch contains a large number of leafs, and calling `getBatchLeafs`\n    /// would result in a gas limit exceeded error.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the provided range is invalid.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param start        The start index of the paginated leafs, inclusive\n    /// @param end          The end index of the paginated leafs, exclusive\n    function getBatchLeafsPaginated(\n        uint64 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory);\n\n    /// @notice Returns the size of the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchSize(uint64 dbNonce) external view returns (uint64);\n\n    /// @notice Get the finalized Interchain Batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatch(uint64 dbNonce) external view returns (InterchainBatch memory);\n\n    /// @notice Get the Interchain Entry's value written on the local chain with the given batch nonce and entry index.\n    /// Entry value is calculated as the hash of the writer address and the written data hash.\n    /// Note: the batch does not have to be finalized to fetch the entry value.\n    /// @dev Will revert if the batch with the given nonce does not exist,\n    /// or the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the existing batch\n    /// @param entryIndex   The index of the written entry within the batch\n    function getEntryValue(uint64 dbNonce, uint64 entryIndex) external view returns (bytes32);\n\n    /// @notice Get the Merkle proof of inclusion for the entry with the given index\n    /// in the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param entryIndex   The index of the written entry within the batch\n    /// @return proof       The Merkle proof of inclusion for the entry\n    function getEntryProof(uint64 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof);\n\n    /// @notice Get the nonce of the database, which is incremented every time a new batch is finalized.\n    /// This is the nonce of the current non-finalized batch.\n    function getDBNonce() external view returns (uint64);\n\n    /// @notice Get the index of the next entry to be written to the database.\n    /// @return dbNonce      The database nonce of the batch including the next entry\n    /// @return entryIndex   The index of the next entry within that batch\n    function getNextEntryIndex() external view returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or ZERO if the module has not verified the entry.\n    function checkVerification(\n        address dstModule,\n        InterchainEntry memory entry,\n        bytes32[] memory proof\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n\n    /// @notice Get the version of the Interchain DataBase.\n    // solhint-disable-next-line func-name-mixedcase\n    function DB_VERSION() external pure returns (uint16);\n}\n\n// contracts/InterchainClientV1.sol\n\n/**\n * @title InterchainClientV1\n * @dev Implements the operations of the Interchain Execution Layer.\n */\ncontract InterchainClientV1 is Ownable, InterchainClientV1Events, IInterchainClientV1 {\n    using AppConfigLib for bytes;\n    using OptionsLib for bytes;\n    using VersionedPayloadLib for bytes;\n\n    /// @notice Version of the InterchainClient contract. Sent and received transactions must have the same version.\n    uint16 public constant CLIENT_VERSION = 1;\n\n    /// @notice Address of the InterchainDB contract, set at the time of deployment.\n    address public immutable INTERCHAIN_DB;\n\n    /// @notice Address of the contract that handles execution fees. Can be updated by the owner.\n    address public executionFees;\n\n    /// @dev Address of the InterchainClient contract on the remote chain\n    mapping(uint64 chainId =\u003e bytes32 remoteClient) internal _linkedClient;\n    /// @dev Executor address that completed the transaction. Address(0) if not executed yet.\n    mapping(bytes32 transactionId =\u003e address executor) internal _txExecutor;\n\n    constructor(address interchainDB, address owner_) Ownable(owner_) {\n        INTERCHAIN_DB = interchainDB;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function setExecutionFees(address executionFees_) external onlyOwner {\n        executionFees = executionFees_;\n        emit ExecutionFeesSet(executionFees_);\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function setLinkedClient(uint64 chainId, bytes32 client) external onlyOwner {\n        _linkedClient[chainId] = client;\n        emit LinkedClientSet(chainId, client);\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _interchainSend(dstChainId, receiver, srcExecutionService, srcModules, options, message);\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function interchainSendEVM(\n        uint64 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc)\n    {\n        bytes32 receiverBytes32 = TypeCasts.addressToBytes32(receiver);\n        return _interchainSend(dstChainId, receiverBytes32, srcExecutionService, srcModules, options, message);\n    }\n\n    // TODO: Handle the case where receiver does not implement the IInterchainApp interface (or does not exist at all)\n    // @inheritdoc IInterchainClientV1\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable\n    {\n        InterchainTransaction memory icTx = _assertCorrectVersion(transaction);\n        bytes32 transactionId = keccak256(transaction);\n        _assertExecutable(icTx, transactionId, proof);\n        _txExecutor[transactionId] = msg.sender;\n\n        OptionsV1 memory decodedOptions = icTx.options.decodeOptionsV1();\n        if (msg.value != decodedOptions.gasAirdrop) {\n            revert InterchainClientV1__IncorrectMsgValue(msg.value, decodedOptions.gasAirdrop);\n        }\n        // We should always use at least as much as the requested gas limit.\n        // The executor can specify a higher gas limit if they wanted.\n        if (decodedOptions.gasLimit \u003e gasLimit) gasLimit = decodedOptions.gasLimit;\n        // Check the the Executor has provided big enough gas limit for the whole transaction.\n        if (gasleft() \u003c= gasLimit) {\n            revert InterchainClientV1__NotEnoughGasSupplied();\n        }\n        // Pass the full msg.value to the app: we have already checked that it matches the requested gas airdrop.\n        IInterchainApp(TypeCasts.bytes32ToAddress(icTx.dstReceiver)).appReceive{gas: gasLimit, value: msg.value}({\n            srcChainId: icTx.srcChainId,\n            sender: icTx.srcSender,\n            dbNonce: icTx.dbNonce,\n            entryIndex: icTx.entryIndex,\n            message: icTx.message\n        });\n        emit InterchainTransactionReceived(\n            transactionId, icTx.dbNonce, icTx.entryIndex, icTx.srcChainId, icTx.srcSender, icTx.dstReceiver\n        );\n    }\n\n    /// @inheritdoc IInterchainClientV1\n    function writeExecutionProof(bytes32 transactionId) external returns (uint64 dbNonce, uint64 entryIndex) {\n        address executor = _txExecutor[transactionId];\n        if (executor == address(0)) {\n            revert InterchainClientV1__TxNotExecuted(transactionId);\n        }\n        bytes memory proof = abi.encode(transactionId, executor);\n        (dbNonce, entryIndex) = IInterchainDB(INTERCHAIN_DB).writeEntry(keccak256(proof));\n        emit ExecutionProofWritten(transactionId, dbNonce, entryIndex, executor);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // @inheritdoc IInterchainClientV1\n    function isExecutable(bytes calldata encodedTx, bytes32[] calldata proof) external view returns (bool) {\n        InterchainTransaction memory icTx = _assertCorrectVersion(encodedTx);\n        // Check that options could be decoded\n        icTx.options.decodeOptionsV1();\n        bytes32 transactionId = keccak256(encodedTx);\n        _assertExecutable(icTx, transactionId, proof);\n        return true;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function getExecutor(bytes calldata encodedTx) external view returns (address) {\n        return _txExecutor[keccak256(encodedTx)];\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function getExecutorById(bytes32 transactionId) external view returns (address) {\n        return _txExecutor[transactionId];\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function getInterchainFee(\n        uint64 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        uint256 messageLen\n    )\n        external\n        view\n        returns (uint256 fee)\n    {\n        _assertLinkedClient(dstChainId);\n        // Check that options could be decoded on destination chain\n        options.decodeOptionsV1();\n        // Verification fee from InterchainDB\n        fee = IInterchainDB(INTERCHAIN_DB).getInterchainFee(dstChainId, srcModules);\n        // Add execution fee, if ExecutionService is provided\n        if (srcExecutionService != address(0)) {\n            uint256 payloadSize = InterchainTransactionLib.payloadSize(options.length, messageLen);\n            fee += IExecutionService(srcExecutionService).getExecutionFee(dstChainId, payloadSize, options);\n        }\n    }\n\n    /// @inheritdoc IInterchainClientV1\n    function getLinkedClient(uint64 chainId) external view returns (bytes32) {\n        if (chainId == block.chainid) {\n            revert InterchainClientV1__NotRemoteChainId(chainId);\n        }\n        return _linkedClient[chainId];\n    }\n\n    /// @inheritdoc IInterchainClientV1\n    function getLinkedClientEVM(uint64 chainId) external view returns (address linkedClientEVM) {\n        if (chainId == block.chainid) {\n            revert InterchainClientV1__NotRemoteChainId(chainId);\n        }\n        bytes32 linkedClient = _linkedClient[chainId];\n        linkedClientEVM = TypeCasts.bytes32ToAddress(linkedClient);\n        // Check that the linked client address fits into the EVM address space\n        if (TypeCasts.addressToBytes32(linkedClientEVM) != linkedClient) {\n            revert InterchainClientV1__NotEVMClient(linkedClient);\n        }\n    }\n\n    /// @notice Decodes the encoded options data into a OptionsV1 struct.\n    function decodeOptions(bytes memory encodedOptions) external view returns (OptionsV1 memory) {\n        return encodedOptions.decodeOptionsV1();\n    }\n\n    /// @notice Encodes the transaction data into a bytes format.\n    function encodeTransaction(InterchainTransaction memory icTx) public pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload({\n            version: CLIENT_VERSION,\n            payload: InterchainTransactionLib.encodeTransaction(icTx)\n        });\n    }\n\n    // ═════════════════════════════════════════════════ INTERNAL ══════════════════════════════════════════════════════\n\n    /// @dev Internal logic for sending a message to another chain.\n    function _interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        _assertLinkedClient(dstChainId);\n        if (receiver == 0) revert InterchainClientV1__ZeroReceiver();\n        // Check that options could be decoded on destination chain\n        options.decodeOptionsV1();\n        uint256 verificationFee = IInterchainDB(INTERCHAIN_DB).getInterchainFee(dstChainId, srcModules);\n        if (msg.value \u003c verificationFee) {\n            revert InterchainClientV1__FeeAmountTooLow(msg.value, verificationFee);\n        }\n        (desc.dbNonce, desc.entryIndex) = IInterchainDB(INTERCHAIN_DB).getNextEntryIndex();\n        InterchainTransaction memory icTx = InterchainTransactionLib.constructLocalTransaction({\n            srcSender: msg.sender,\n            dstReceiver: receiver,\n            dstChainId: dstChainId,\n            dbNonce: desc.dbNonce,\n            entryIndex: desc.entryIndex,\n            options: options,\n            message: message\n        });\n        desc.transactionId = keccak256(encodeTransaction(icTx));\n        // Sanity check: nonce returned from DB should match the nonce used to construct the transaction\n        {\n            (uint64 dbNonce, uint64 entryIndex) = IInterchainDB(INTERCHAIN_DB).writeEntryWithVerification{\n                value: verificationFee\n            }(icTx.dstChainId, desc.transactionId, srcModules);\n            assert(dbNonce == desc.dbNonce \u0026\u0026 entryIndex == desc.entryIndex);\n        }\n        uint256 executionFee;\n        unchecked {\n            executionFee = msg.value - verificationFee;\n        }\n        if (executionFee \u003e 0) {\n            IExecutionFees(executionFees).addExecutionFee{value: executionFee}(icTx.dstChainId, desc.transactionId);\n        }\n        // TODO: consider disallowing the use of empty srcExecutionService\n        if (srcExecutionService != address(0)) {\n            IExecutionService(srcExecutionService).requestExecution({\n                dstChainId: dstChainId,\n                txPayloadSize: InterchainTransactionLib.payloadSize(options.length, message.length),\n                transactionId: desc.transactionId,\n                executionFee: executionFee,\n                options: options\n            });\n            address srcExecutorEOA = IExecutionService(srcExecutionService).executorEOA();\n            IExecutionFees(executionFees).recordExecutor(icTx.dstChainId, desc.transactionId, srcExecutorEOA);\n        }\n        emit InterchainTransactionSent(\n            desc.transactionId,\n            icTx.dbNonce,\n            icTx.entryIndex,\n            icTx.dstChainId,\n            icTx.srcSender,\n            icTx.dstReceiver,\n            verificationFee,\n            executionFee,\n            icTx.options,\n            icTx.message\n        );\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Asserts that the transaction is executable.\n    function _assertExecutable(\n        InterchainTransaction memory icTx,\n        bytes32 transactionId,\n        bytes32[] calldata proof\n    )\n        internal\n        view\n    {\n        bytes32 linkedClient = _assertLinkedClient(icTx.srcChainId);\n        if (icTx.dstChainId != block.chainid) {\n            revert InterchainClientV1__IncorrectDstChainId(icTx.dstChainId);\n        }\n        if (_txExecutor[transactionId] != address(0)) {\n            revert InterchainClientV1__TxAlreadyExecuted(transactionId);\n        }\n        // Construct expected entry based on icTransaction data\n        InterchainEntry memory icEntry = InterchainEntry({\n            srcChainId: icTx.srcChainId,\n            dbNonce: icTx.dbNonce,\n            entryIndex: icTx.entryIndex,\n            srcWriter: linkedClient,\n            dataHash: transactionId\n        });\n        (bytes memory encodedAppConfig, address[] memory approvedDstModules) =\n            IInterchainApp(TypeCasts.bytes32ToAddress(icTx.dstReceiver)).getReceivingConfig();\n        AppConfigV1 memory appConfig = encodedAppConfig.decodeAppConfigV1();\n        if (appConfig.requiredResponses == 0) {\n            revert InterchainClientV1__ZeroRequiredResponses();\n        }\n        uint256 responses = _getFinalizedResponsesCount(approvedDstModules, icEntry, proof, appConfig.optimisticPeriod);\n        if (responses \u003c appConfig.requiredResponses) {\n            revert InterchainClientV1__NotEnoughResponses(responses, appConfig.requiredResponses);\n        }\n    }\n\n    /// @dev Asserts that the chain is linked and returns the linked client address.\n    function _assertLinkedClient(uint64 chainId) internal view returns (bytes32 linkedClient) {\n        if (chainId == block.chainid) {\n            revert InterchainClientV1__NotRemoteChainId(chainId);\n        }\n        linkedClient = _linkedClient[chainId];\n        if (linkedClient == 0) {\n            revert InterchainClientV1__NoLinkedClient(chainId);\n        }\n    }\n\n    /**\n     * @dev Calculates the number of responses that are considered finalized within the optimistic time period.\n     * @param approvedModules       Approved modules that could have confirmed the entry.\n     * @param icEntry               The InterchainEntry to confirm.\n     * @param optimisticPeriod      The time period in seconds within which a response is considered valid.\n     * @return finalizedResponses   The count of responses that are finalized within the optimistic time period.\n     */\n    function _getFinalizedResponsesCount(\n        address[] memory approvedModules,\n        InterchainEntry memory icEntry,\n        bytes32[] calldata proof,\n        uint256 optimisticPeriod\n    )\n        internal\n        view\n        returns (uint256 finalizedResponses)\n    {\n        for (uint256 i = 0; i \u003c approvedModules.length; ++i) {\n            uint256 confirmedAt = IInterchainDB(INTERCHAIN_DB).checkVerification(approvedModules[i], icEntry, proof);\n            // checkVerification() returns 0 if entry hasn't been confirmed by the module, so we check for that as well\n            if (confirmedAt != 0 \u0026\u0026 confirmedAt + optimisticPeriod \u003c block.timestamp) {\n                ++finalizedResponses;\n            }\n        }\n    }\n\n    /// @dev Asserts that the transaction version is correct. Returns the decoded transaction for chaining purposes.\n    function _assertCorrectVersion(bytes calldata versionedTx)\n        internal\n        pure\n        returns (InterchainTransaction memory icTx)\n    {\n        uint16 version = versionedTx.getVersion();\n        if (version != CLIENT_VERSION) {\n            revert InterchainClientV1__InvalidTransactionVersion(version);\n        }\n        icTx = InterchainTransactionLib.decodeTransaction(versionedTx.getPayload());\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"59951:2997:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;59951:2997:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"59951:2997:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainClientV1.sol\":\"InterchainTransactionLib\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainClientV1.sol\":{\"keccak256\":\"0xe270686a9bca05b4013610a4e8bb08040de32a0442edd218e1692edaca94e40e\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://727e84146369613e04e57a677f8bc6c709ee145df3eeb79f15ea5a922198d78f\",\"dweb:/ipfs/QmUXh2nDtHBnhYZSwCxcteN4be13S7dR9GbqqHT9mUxta3\"]}},\"version\":1}"},"hashes":{}},"solidity/InterchainClientV1.sol:MathLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122093ce42b7f93a41d9072c03671857c16fcc470ce032f39ba433fe73c34f3d843564736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122093ce42b7f93a41d9072c03671857c16fcc470ce032f39ba433fe73c34f3d843564736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainClientV1Events.sol\n\nabstract contract InterchainClientV1Events {\n    event ExecutionFeesSet(address executionFees);\n    event LinkedClientSet(uint64 chainId, bytes32 client);\n\n    // TODO: figure out indexing\n\n    event InterchainTransactionSent(\n        bytes32 indexed transactionId,\n        uint64 indexed dbNonce,\n        uint64 indexed entryIndex,\n        uint64 dstChainId,\n        bytes32 srcSender,\n        bytes32 dstReceiver,\n        uint256 verificationFee,\n        uint256 executionFee,\n        bytes options,\n        bytes message\n    );\n\n    event InterchainTransactionReceived(\n        bytes32 indexed transactionId,\n        uint64 indexed dbNonce,\n        uint64 indexed entryIndex,\n        uint64 srcChainId,\n        bytes32 srcSender,\n        bytes32 dstReceiver\n    );\n\n    event ExecutionProofWritten(\n        bytes32 indexed transactionId, uint64 indexed dbNonce, uint64 indexed entryIndex, address executor\n    );\n}\n\n// contracts/interfaces/IExecutionFees.sol\n\ninterface IExecutionFees {\n    error ExecutionFees__AlreadyRecorded(uint64 dstChainId, bytes32 transactionId, address executor);\n    error ExecutionFees__ZeroAddress();\n    error ExecutionFees__ZeroAmount();\n\n    /// @notice Add the execution fee for a transaction. The attached value will be added to the\n    /// rewards for the executor completing the transaction.\n    /// Note: this could be used to store the execution fee for a new transaction, or to add more\n    /// funds to the execution fee of an existing transaction. Therefore this function is payable,\n    /// and does not implement any caller restrictions.\n    /// @dev Will revert if the executor is already recorded for the transaction.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to add the execution fee to.\n    function addExecutionFee(uint64 dstChainId, bytes32 transactionId) external payable;\n\n    /// @notice Record the executor (who completed the transaction) for a transaction,\n    /// and update the accumulated rewards for the executor.\n    /// @dev Could only be called by the Recorder.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to record the executor for.\n    /// @param executor             The address of the executor who completed the transaction.\n    function recordExecutor(uint64 dstChainId, bytes32 transactionId, address executor) external;\n\n    /// @notice Allows the executor to claim their unclaimed rewards.\n    /// @dev Will revert if the executor has no unclaimed rewards.\n    function claimExecutionFees(address executor) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the accumulated rewards for an executor.\n    /// @param executor             The address of the executor to get the rewards for.\n    function accumulatedRewards(address executor) external view returns (uint256 accumulated);\n\n    /// @notice Get the unclaimed rewards for an executor.\n    /// @param executor             The address of the executor to get the rewards for.\n    function unclaimedRewards(address executor) external view returns (uint256 unclaimed);\n\n    /// @notice Get the total execution fee for a transaction.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to get the execution fee for.\n    function executionFee(uint64 dstChainId, bytes32 transactionId) external view returns (uint256 fee);\n\n    /// @notice Get the address of the recorded executor for a transaction.\n    /// @dev Will return address(0) if the executor is not recorded.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to get the recorded executor for.\n    function recordedExecutor(uint64 dstChainId, bytes32 transactionId) external view returns (address executor);\n}\n\n// contracts/interfaces/IExecutionService.sol\n\ninterface IExecutionService {\n    /// @notice Request the execution of an Interchain Transaction on a remote chain.\n    /// Note: the off-chain actor needs to fetch the transaction payload from the InterchainClient\n    /// event with the same transactionId, then execute the transaction on the remote chain:\n    /// `dstInterchainClient.executeTransaction(transactionPayload)`\n    /// Once the execution is confirmed on the source chain, the off-chain actor will be able\n    /// to claim `executionFee` in the ExecutionFees contract.\n    /// @dev Could only be called by `InterchainClient` contracts.\n    /// Will revert if the execution fee is not big enough.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param txPayloadSize        The size of the transaction payload to use for the execution.\n    /// @param transactionId        The id of the transaction to execute.\n    /// @param executionFee         The fee paid for the execution.\n    /// @param options              The options to use for the execution.\n    function requestExecution(\n        uint64 dstChainId,\n        uint256 txPayloadSize,\n        bytes32 transactionId,\n        uint256 executionFee,\n        bytes memory options\n    )\n        external;\n\n    /// @notice Get the address of the EOA account that will be used to execute transactions on the\n    /// remote chains.\n    function executorEOA() external view returns (address);\n\n    /// @notice Get the execution fee for executing an Interchain Transaction on a remote chain.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param txPayloadSize        The size of the transaction payload to use for the execution.\n    /// @param options              The options to use for the execution.\n    function getExecutionFee(\n        uint64 dstChainId,\n        uint256 txPayloadSize,\n        bytes memory options\n    )\n        external\n        view\n        returns (uint256);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    /// @notice Allows the Interchain Client to pass the message to the Interchain App.\n    /// @dev App is responsible for keeping track of interchain clients, and must verify the message sender.\n    /// @param srcChainId   Chain ID of the source chain, where the message was sent from.\n    /// @param sender       Sender address on the source chain, as a bytes32 value.\n    /// @param dbNonce      The Interchain DB nonce of the batch containing the message entry.\n    /// @param entryIndex   The index of the message entry within the batch.\n    /// @param message      The message being sent.\n    function appReceive(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /// @notice Returns the verification configuration of the Interchain App.\n    /// @dev This configuration is used by the Interchain Client to verify that message has been confirmed\n    /// by the Interchain Modules on the destination chain.\n    /// Note: V1 version of AppConfig includes the required responses count, and optimistic period after which\n    /// the message is considered confirmed by the module. Following versions may include additional fields.\n    /// @return appConfig    The versioned configuration of the Interchain App, encoded as bytes.\n    /// @return modules      The list of Interchain Modules that app is trusting to confirm the messages.\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/Math.sol\n\nlibrary MathLib {\n    /// @notice Rounds up to the nearest multiple of 32.\n    /// Note: Returns zero on overflows instead of reverting. This is fine for practical\n    /// use cases, as this is used for determining the size of the payload in memory.\n    function roundUpToWord(uint256 x) internal pure returns (uint256) {\n        unchecked {\n            return (x + 31) \u0026 ~uint256(31);\n        }\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/VersionedPayload.sol\n\n// solhint-disable no-inline-assembly\n// solhint-disable ordering\nlibrary VersionedPayloadLib {\n    /// @notice Amount of bytes reserved for the version (uint16) in the versioned payload\n    uint256 internal constant VERSION_LENGTH = 2;\n\n    error VersionedPayload__TooShort(bytes versionedPayload);\n    error VersionedPayload__PrecompileFailed();\n\n    /// @notice Encodes the versioned payload into a single bytes array.\n    /// @param version  The payload's version.\n    /// @param payload  The payload to encode.\n    function encodeVersionedPayload(uint16 version, bytes memory payload) internal pure returns (bytes memory) {\n        return abi.encodePacked(version, payload);\n    }\n\n    /// @notice Extracts the version from the versioned payload (calldata reference).\n    /// @param versionedPayload     The versioned payload (calldata reference).\n    function getVersion(bytes calldata versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            version := shr(240, calldataload(versionedPayload.offset))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (calldata reference).\n    /// @dev The extracted payload is also returned as a calldata reference.\n    /// @param versionedPayload     The versioned payload.\n    function getPayload(bytes calldata versionedPayload) internal pure returns (bytes calldata) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        return versionedPayload[VERSION_LENGTH:];\n    }\n\n    /// @notice Extracts the version from the versioned payload (memory reference).\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getVersionFromMemory(bytes memory versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            // We add 0x20 to skip the length of the bytes array.\n            version := shr(240, mload(add(versionedPayload, 0x20)))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (memory reference).\n    /// @dev The extracted payload is copied into a new memory location. Use `getPayload` when possible\n    /// to avoid extra memory allocation.\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getPayloadFromMemory(bytes memory versionedPayload) internal view returns (bytes memory payload) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        // Figure how many bytes to copy and allocate the memory for the extracted payload.\n        uint256 toCopy;\n        unchecked {\n            toCopy = versionedPayload.length - VERSION_LENGTH;\n        }\n        payload = new bytes(toCopy);\n        // Use identity precompile (0x04) to copy the payload. Unlike MCOPY, this is available on all EVM chains.\n        bool res;\n        assembly {\n            // We add 0x20 to skip the length of the bytes array.\n            // We add 0x02 to skip the 2 bytes reserved for the version.\n            // Copy the payload to the previously allocated memory.\n            res := staticcall(gas(), 0x04, add(versionedPayload, 0x22), toCopy, add(payload, 0x20), toCopy)\n        }\n        if (!res) {\n            revert VersionedPayload__PrecompileFailed();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SafeCast.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value \u003e type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value \u003e type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value \u003e type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value \u003e type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value \u003e type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value \u003e type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value \u003e type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value \u003e type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value \u003e type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value \u003e type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value \u003e type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value \u003e type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value \u003e type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value \u003e type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value \u003e type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value \u003e type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value \u003e type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value \u003e type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value \u003e type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value \u003e type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value \u003e type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value \u003e type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value \u003e type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value \u003e type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value \u003e type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value \u003e type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value \u003e type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value \u003e type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value \u003e type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value \u003e type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value \u003e type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value \u003c 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value \u003e uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal view returns (AppConfigV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (AppConfigV1));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal view returns (OptionsV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (OptionsV1));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(OPTIONS_V1, abi.encode(options));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/libs/InterchainBatch.sol\n\ntype BatchKey is uint128;\n\n/// @notice Struct representing a batch of entries in the Interchain DataBase.\n/// Batched entries are put together in a Merkle tree, which root is saved.\n/// Batch has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: batchRoot\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch\n/// @param batchRoot    The root of the Merkle tree containing the batched entries\nstruct InterchainBatch {\n    uint64 srcChainId;\n    uint64 dbNonce;\n    bytes32 batchRoot;\n}\n\nlibrary InterchainBatchLib {\n    using VersionedPayloadLib for bytes;\n\n    /// @notice Constructs an InterchainBatch struct to be saved on the local chain.\n    /// @param dbNonce      The database nonce of the batch\n    /// @param batchRoot    The root of the Merkle tree containing the batched entries\n    /// @return batch       The constructed InterchainBatch struct\n    function constructLocalBatch(\n        uint64 dbNonce,\n        bytes32 batchRoot\n    )\n        internal\n        view\n        returns (InterchainBatch memory batch)\n    {\n        return InterchainBatch({srcChainId: SafeCast.toUint64(block.chainid), dbNonce: dbNonce, batchRoot: batchRoot});\n    }\n\n    /// @notice Encodes the InterchainBatch struct into a non-versioned batch payload.\n    function encodeBatch(InterchainBatch memory batch) internal pure returns (bytes memory) {\n        return abi.encode(encodeBatchKey(batch.srcChainId, batch.dbNonce), batch.batchRoot);\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in calldata.\n    function decodeBatch(bytes calldata data) internal pure returns (InterchainBatch memory batch) {\n        BatchKey key;\n        (key, batch.batchRoot) = abi.decode(data, (BatchKey, bytes32));\n        (batch.srcChainId, batch.dbNonce) = decodeBatchKey(key);\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in memory.\n    function decodeBatchFromMemory(bytes memory data) internal pure returns (InterchainBatch memory batch) {\n        BatchKey key;\n        (key, batch.batchRoot) = abi.decode(data, (BatchKey, bytes32));\n        (batch.srcChainId, batch.dbNonce) = decodeBatchKey(key);\n    }\n\n    /// @notice Encodes the uint128 key of the batch from uint64 srcChainId and uint64 dbNonce.\n    function encodeBatchKey(uint64 srcChainId, uint64 dbNonce) internal pure returns (BatchKey) {\n        return BatchKey.wrap((uint128(srcChainId) \u003c\u003c 64) | dbNonce);\n    }\n\n    /// @notice Decodes the uint128 key of the batch into uint64 srcChainId and uint64 dbNonce.\n    function decodeBatchKey(BatchKey key) internal pure returns (uint64 srcChainId, uint64 dbNonce) {\n        srcChainId = uint64(BatchKey.unwrap(key) \u003e\u003e 64);\n        dbNonce = uint64(BatchKey.unwrap(key));\n    }\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce + entryIndex\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch containing the entry\n/// @param entryIndex   The index of the entry in the batch\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint64 srcChainId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nusing InterchainEntryLib for InterchainEntry global;\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint64 dbNonce,\n        uint64 entryIndex,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: SafeCast.toUint64(block.chainid),\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n}\n\n// contracts/libs/InterchainTransaction.sol\n\ntype ICTxHeader is uint256;\n\nstruct InterchainTransaction {\n    uint64 srcChainId;\n    uint64 dstChainId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcSender;\n    bytes32 dstReceiver;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    using MathLib for uint256;\n    using VersionedPayloadLib for bytes;\n\n    function constructLocalTransaction(\n        address srcSender,\n        uint64 dstChainId,\n        bytes32 dstReceiver,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: SafeCast.toUint64(block.chainid),\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            encodeTxHeader(transaction.srcChainId, transaction.dstChainId, transaction.dbNonce, transaction.entryIndex),\n            transaction.srcSender,\n            transaction.dstReceiver,\n            transaction.options,\n            transaction.message\n        );\n    }\n\n    function decodeTransaction(bytes calldata transaction) internal pure returns (InterchainTransaction memory icTx) {\n        ICTxHeader header;\n        (header, icTx.srcSender, icTx.dstReceiver, icTx.options, icTx.message) =\n            abi.decode(transaction, (ICTxHeader, bytes32, bytes32, bytes, bytes));\n        (icTx.srcChainId, icTx.dstChainId, icTx.dbNonce, icTx.entryIndex) = decodeTxHeader(header);\n    }\n\n    function payloadSize(uint256 optionsLen, uint256 messageLen) internal pure returns (uint256) {\n        // 2 bytes are reserved for the transaction version\n        // + 5 fields * 32 bytes (3 values for static, 2 offsets for dynamic) + 2 * 32 bytes (lengths for dynamic) = 226\n        // (srcChainId, dstChainId, dbNonce, entryIndex) are merged into a single 32 bytes field\n        // Both options and message are dynamic fields, which are padded up to 32 bytes\n        return 226 + optionsLen.roundUpToWord() + messageLen.roundUpToWord();\n    }\n\n    function encodeTxHeader(\n        uint64 srcChainId,\n        uint64 dstChainId,\n        uint64 dbNonce,\n        uint64 entryIndex\n    )\n        internal\n        pure\n        returns (ICTxHeader)\n    {\n        return ICTxHeader.wrap(\n            (uint256(srcChainId) \u003c\u003c 192) | (uint256(dstChainId) \u003c\u003c 128) | (uint256(dbNonce) \u003c\u003c 64) | uint256(entryIndex)\n        );\n    }\n\n    function decodeTxHeader(ICTxHeader header)\n        internal\n        pure\n        returns (uint64 srcChainId, uint64 dstChainId, uint64 dbNonce, uint64 entryIndex)\n    {\n        srcChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 192);\n        dstChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 128);\n        dbNonce = uint64(ICTxHeader.unwrap(header) \u003e\u003e 64);\n        entryIndex = uint64(ICTxHeader.unwrap(header));\n    }\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint64 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__InvalidTransactionVersion(uint16 version);\n    error InterchainClientV1__NoLinkedClient(uint64 chainId);\n    error InterchainClientV1__NotEnoughGasSupplied();\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint64 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint64 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint64 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint64 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param messageLen           The length of the message being sent.\n    function getInterchainFee(\n        uint64 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        uint256 messageLen\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint64 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint64 chainId) external view returns (address);\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing a batch of entries from the remote Interchain DataBase,\n    /// verified by the Interchain Module.\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param batchRoot    The Merkle root of the batch\n    struct RemoteBatch {\n        uint256 verifiedAt;\n        bytes32 batchRoot;\n    }\n\n    error InterchainDB__BatchDoesNotExist(uint64 dbNonce);\n    error InterchainDB__BatchNotFinalized(uint64 dbNonce);\n    error InterchainDB__ConflictingBatches(address module, bytes32 existingBatchRoot, InterchainBatch newBatch);\n    error InterchainDB__EntryIndexOutOfRange(uint64 dbNonce, uint64 entryIndex, uint64 batchSize);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__InvalidBatchVersion(uint16 version);\n    error InterchainDB__InvalidEntryRange(uint64 dbNonce, uint64 start, uint64 end);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId(uint64 chainId);\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `requestBatchVerification` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntry(bytes32 dataHash) external returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Request the given Interchain Modules to verify an existing batch.\n    /// If the batch is not finalized, the module will verify it after finalization.\n    /// For the finalized batch the batch root is already available, and the module can verify it immediately.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any batch.\n    /// @dev Will revert if the batch with the given nonce does not exist.\n    /// @param dstChainId    The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the existing batch\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestBatchVerification(\n        uint64 dstChainId,\n        uint64 dbNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Then request the Interchain Modules to verify the batch containing the written entry on the destination chain.\n    /// See `writeEntry` and `requestBatchVerification` for more details.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntryWithVerification(\n        uint64 dstChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Allows the Interchain Module to verify the batch coming from the remote chain.\n    /// Note: The DB will only accept the batch of the same version as the DB itself.\n    /// @param versionedBatch   The versioned Interchain Batch to verify\n    function verifyRemoteBatch(bytes memory versionedBatch) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint64 dstChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce.\n    /// Note: the leafs are ordered by the index of the written entry in the current batch,\n    /// and the leafs value match the value of the written entry (srcWriter + dataHash hashed together).\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchLeafs(uint64 dbNonce) external view returns (bytes32[] memory);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce,\n    /// paginated by the given start and end indexes. The end index is exclusive.\n    /// Note: this is useful when the batch contains a large number of leafs, and calling `getBatchLeafs`\n    /// would result in a gas limit exceeded error.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the provided range is invalid.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param start        The start index of the paginated leafs, inclusive\n    /// @param end          The end index of the paginated leafs, exclusive\n    function getBatchLeafsPaginated(\n        uint64 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory);\n\n    /// @notice Returns the size of the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchSize(uint64 dbNonce) external view returns (uint64);\n\n    /// @notice Get the finalized Interchain Batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatch(uint64 dbNonce) external view returns (InterchainBatch memory);\n\n    /// @notice Get the Interchain Entry's value written on the local chain with the given batch nonce and entry index.\n    /// Entry value is calculated as the hash of the writer address and the written data hash.\n    /// Note: the batch does not have to be finalized to fetch the entry value.\n    /// @dev Will revert if the batch with the given nonce does not exist,\n    /// or the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the existing batch\n    /// @param entryIndex   The index of the written entry within the batch\n    function getEntryValue(uint64 dbNonce, uint64 entryIndex) external view returns (bytes32);\n\n    /// @notice Get the Merkle proof of inclusion for the entry with the given index\n    /// in the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param entryIndex   The index of the written entry within the batch\n    /// @return proof       The Merkle proof of inclusion for the entry\n    function getEntryProof(uint64 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof);\n\n    /// @notice Get the nonce of the database, which is incremented every time a new batch is finalized.\n    /// This is the nonce of the current non-finalized batch.\n    function getDBNonce() external view returns (uint64);\n\n    /// @notice Get the index of the next entry to be written to the database.\n    /// @return dbNonce      The database nonce of the batch including the next entry\n    /// @return entryIndex   The index of the next entry within that batch\n    function getNextEntryIndex() external view returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or ZERO if the module has not verified the entry.\n    function checkVerification(\n        address dstModule,\n        InterchainEntry memory entry,\n        bytes32[] memory proof\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n\n    /// @notice Get the version of the Interchain DataBase.\n    // solhint-disable-next-line func-name-mixedcase\n    function DB_VERSION() external pure returns (uint16);\n}\n\n// contracts/InterchainClientV1.sol\n\n/**\n * @title InterchainClientV1\n * @dev Implements the operations of the Interchain Execution Layer.\n */\ncontract InterchainClientV1 is Ownable, InterchainClientV1Events, IInterchainClientV1 {\n    using AppConfigLib for bytes;\n    using OptionsLib for bytes;\n    using VersionedPayloadLib for bytes;\n\n    /// @notice Version of the InterchainClient contract. Sent and received transactions must have the same version.\n    uint16 public constant CLIENT_VERSION = 1;\n\n    /// @notice Address of the InterchainDB contract, set at the time of deployment.\n    address public immutable INTERCHAIN_DB;\n\n    /// @notice Address of the contract that handles execution fees. Can be updated by the owner.\n    address public executionFees;\n\n    /// @dev Address of the InterchainClient contract on the remote chain\n    mapping(uint64 chainId =\u003e bytes32 remoteClient) internal _linkedClient;\n    /// @dev Executor address that completed the transaction. Address(0) if not executed yet.\n    mapping(bytes32 transactionId =\u003e address executor) internal _txExecutor;\n\n    constructor(address interchainDB, address owner_) Ownable(owner_) {\n        INTERCHAIN_DB = interchainDB;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function setExecutionFees(address executionFees_) external onlyOwner {\n        executionFees = executionFees_;\n        emit ExecutionFeesSet(executionFees_);\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function setLinkedClient(uint64 chainId, bytes32 client) external onlyOwner {\n        _linkedClient[chainId] = client;\n        emit LinkedClientSet(chainId, client);\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _interchainSend(dstChainId, receiver, srcExecutionService, srcModules, options, message);\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function interchainSendEVM(\n        uint64 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc)\n    {\n        bytes32 receiverBytes32 = TypeCasts.addressToBytes32(receiver);\n        return _interchainSend(dstChainId, receiverBytes32, srcExecutionService, srcModules, options, message);\n    }\n\n    // TODO: Handle the case where receiver does not implement the IInterchainApp interface (or does not exist at all)\n    // @inheritdoc IInterchainClientV1\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable\n    {\n        InterchainTransaction memory icTx = _assertCorrectVersion(transaction);\n        bytes32 transactionId = keccak256(transaction);\n        _assertExecutable(icTx, transactionId, proof);\n        _txExecutor[transactionId] = msg.sender;\n\n        OptionsV1 memory decodedOptions = icTx.options.decodeOptionsV1();\n        if (msg.value != decodedOptions.gasAirdrop) {\n            revert InterchainClientV1__IncorrectMsgValue(msg.value, decodedOptions.gasAirdrop);\n        }\n        // We should always use at least as much as the requested gas limit.\n        // The executor can specify a higher gas limit if they wanted.\n        if (decodedOptions.gasLimit \u003e gasLimit) gasLimit = decodedOptions.gasLimit;\n        // Check the the Executor has provided big enough gas limit for the whole transaction.\n        if (gasleft() \u003c= gasLimit) {\n            revert InterchainClientV1__NotEnoughGasSupplied();\n        }\n        // Pass the full msg.value to the app: we have already checked that it matches the requested gas airdrop.\n        IInterchainApp(TypeCasts.bytes32ToAddress(icTx.dstReceiver)).appReceive{gas: gasLimit, value: msg.value}({\n            srcChainId: icTx.srcChainId,\n            sender: icTx.srcSender,\n            dbNonce: icTx.dbNonce,\n            entryIndex: icTx.entryIndex,\n            message: icTx.message\n        });\n        emit InterchainTransactionReceived(\n            transactionId, icTx.dbNonce, icTx.entryIndex, icTx.srcChainId, icTx.srcSender, icTx.dstReceiver\n        );\n    }\n\n    /// @inheritdoc IInterchainClientV1\n    function writeExecutionProof(bytes32 transactionId) external returns (uint64 dbNonce, uint64 entryIndex) {\n        address executor = _txExecutor[transactionId];\n        if (executor == address(0)) {\n            revert InterchainClientV1__TxNotExecuted(transactionId);\n        }\n        bytes memory proof = abi.encode(transactionId, executor);\n        (dbNonce, entryIndex) = IInterchainDB(INTERCHAIN_DB).writeEntry(keccak256(proof));\n        emit ExecutionProofWritten(transactionId, dbNonce, entryIndex, executor);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // @inheritdoc IInterchainClientV1\n    function isExecutable(bytes calldata encodedTx, bytes32[] calldata proof) external view returns (bool) {\n        InterchainTransaction memory icTx = _assertCorrectVersion(encodedTx);\n        // Check that options could be decoded\n        icTx.options.decodeOptionsV1();\n        bytes32 transactionId = keccak256(encodedTx);\n        _assertExecutable(icTx, transactionId, proof);\n        return true;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function getExecutor(bytes calldata encodedTx) external view returns (address) {\n        return _txExecutor[keccak256(encodedTx)];\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function getExecutorById(bytes32 transactionId) external view returns (address) {\n        return _txExecutor[transactionId];\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function getInterchainFee(\n        uint64 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        uint256 messageLen\n    )\n        external\n        view\n        returns (uint256 fee)\n    {\n        _assertLinkedClient(dstChainId);\n        // Check that options could be decoded on destination chain\n        options.decodeOptionsV1();\n        // Verification fee from InterchainDB\n        fee = IInterchainDB(INTERCHAIN_DB).getInterchainFee(dstChainId, srcModules);\n        // Add execution fee, if ExecutionService is provided\n        if (srcExecutionService != address(0)) {\n            uint256 payloadSize = InterchainTransactionLib.payloadSize(options.length, messageLen);\n            fee += IExecutionService(srcExecutionService).getExecutionFee(dstChainId, payloadSize, options);\n        }\n    }\n\n    /// @inheritdoc IInterchainClientV1\n    function getLinkedClient(uint64 chainId) external view returns (bytes32) {\n        if (chainId == block.chainid) {\n            revert InterchainClientV1__NotRemoteChainId(chainId);\n        }\n        return _linkedClient[chainId];\n    }\n\n    /// @inheritdoc IInterchainClientV1\n    function getLinkedClientEVM(uint64 chainId) external view returns (address linkedClientEVM) {\n        if (chainId == block.chainid) {\n            revert InterchainClientV1__NotRemoteChainId(chainId);\n        }\n        bytes32 linkedClient = _linkedClient[chainId];\n        linkedClientEVM = TypeCasts.bytes32ToAddress(linkedClient);\n        // Check that the linked client address fits into the EVM address space\n        if (TypeCasts.addressToBytes32(linkedClientEVM) != linkedClient) {\n            revert InterchainClientV1__NotEVMClient(linkedClient);\n        }\n    }\n\n    /// @notice Decodes the encoded options data into a OptionsV1 struct.\n    function decodeOptions(bytes memory encodedOptions) external view returns (OptionsV1 memory) {\n        return encodedOptions.decodeOptionsV1();\n    }\n\n    /// @notice Encodes the transaction data into a bytes format.\n    function encodeTransaction(InterchainTransaction memory icTx) public pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload({\n            version: CLIENT_VERSION,\n            payload: InterchainTransactionLib.encodeTransaction(icTx)\n        });\n    }\n\n    // ═════════════════════════════════════════════════ INTERNAL ══════════════════════════════════════════════════════\n\n    /// @dev Internal logic for sending a message to another chain.\n    function _interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        _assertLinkedClient(dstChainId);\n        if (receiver == 0) revert InterchainClientV1__ZeroReceiver();\n        // Check that options could be decoded on destination chain\n        options.decodeOptionsV1();\n        uint256 verificationFee = IInterchainDB(INTERCHAIN_DB).getInterchainFee(dstChainId, srcModules);\n        if (msg.value \u003c verificationFee) {\n            revert InterchainClientV1__FeeAmountTooLow(msg.value, verificationFee);\n        }\n        (desc.dbNonce, desc.entryIndex) = IInterchainDB(INTERCHAIN_DB).getNextEntryIndex();\n        InterchainTransaction memory icTx = InterchainTransactionLib.constructLocalTransaction({\n            srcSender: msg.sender,\n            dstReceiver: receiver,\n            dstChainId: dstChainId,\n            dbNonce: desc.dbNonce,\n            entryIndex: desc.entryIndex,\n            options: options,\n            message: message\n        });\n        desc.transactionId = keccak256(encodeTransaction(icTx));\n        // Sanity check: nonce returned from DB should match the nonce used to construct the transaction\n        {\n            (uint64 dbNonce, uint64 entryIndex) = IInterchainDB(INTERCHAIN_DB).writeEntryWithVerification{\n                value: verificationFee\n            }(icTx.dstChainId, desc.transactionId, srcModules);\n            assert(dbNonce == desc.dbNonce \u0026\u0026 entryIndex == desc.entryIndex);\n        }\n        uint256 executionFee;\n        unchecked {\n            executionFee = msg.value - verificationFee;\n        }\n        if (executionFee \u003e 0) {\n            IExecutionFees(executionFees).addExecutionFee{value: executionFee}(icTx.dstChainId, desc.transactionId);\n        }\n        // TODO: consider disallowing the use of empty srcExecutionService\n        if (srcExecutionService != address(0)) {\n            IExecutionService(srcExecutionService).requestExecution({\n                dstChainId: dstChainId,\n                txPayloadSize: InterchainTransactionLib.payloadSize(options.length, message.length),\n                transactionId: desc.transactionId,\n                executionFee: executionFee,\n                options: options\n            });\n            address srcExecutorEOA = IExecutionService(srcExecutionService).executorEOA();\n            IExecutionFees(executionFees).recordExecutor(icTx.dstChainId, desc.transactionId, srcExecutorEOA);\n        }\n        emit InterchainTransactionSent(\n            desc.transactionId,\n            icTx.dbNonce,\n            icTx.entryIndex,\n            icTx.dstChainId,\n            icTx.srcSender,\n            icTx.dstReceiver,\n            verificationFee,\n            executionFee,\n            icTx.options,\n            icTx.message\n        );\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Asserts that the transaction is executable.\n    function _assertExecutable(\n        InterchainTransaction memory icTx,\n        bytes32 transactionId,\n        bytes32[] calldata proof\n    )\n        internal\n        view\n    {\n        bytes32 linkedClient = _assertLinkedClient(icTx.srcChainId);\n        if (icTx.dstChainId != block.chainid) {\n            revert InterchainClientV1__IncorrectDstChainId(icTx.dstChainId);\n        }\n        if (_txExecutor[transactionId] != address(0)) {\n            revert InterchainClientV1__TxAlreadyExecuted(transactionId);\n        }\n        // Construct expected entry based on icTransaction data\n        InterchainEntry memory icEntry = InterchainEntry({\n            srcChainId: icTx.srcChainId,\n            dbNonce: icTx.dbNonce,\n            entryIndex: icTx.entryIndex,\n            srcWriter: linkedClient,\n            dataHash: transactionId\n        });\n        (bytes memory encodedAppConfig, address[] memory approvedDstModules) =\n            IInterchainApp(TypeCasts.bytes32ToAddress(icTx.dstReceiver)).getReceivingConfig();\n        AppConfigV1 memory appConfig = encodedAppConfig.decodeAppConfigV1();\n        if (appConfig.requiredResponses == 0) {\n            revert InterchainClientV1__ZeroRequiredResponses();\n        }\n        uint256 responses = _getFinalizedResponsesCount(approvedDstModules, icEntry, proof, appConfig.optimisticPeriod);\n        if (responses \u003c appConfig.requiredResponses) {\n            revert InterchainClientV1__NotEnoughResponses(responses, appConfig.requiredResponses);\n        }\n    }\n\n    /// @dev Asserts that the chain is linked and returns the linked client address.\n    function _assertLinkedClient(uint64 chainId) internal view returns (bytes32 linkedClient) {\n        if (chainId == block.chainid) {\n            revert InterchainClientV1__NotRemoteChainId(chainId);\n        }\n        linkedClient = _linkedClient[chainId];\n        if (linkedClient == 0) {\n            revert InterchainClientV1__NoLinkedClient(chainId);\n        }\n    }\n\n    /**\n     * @dev Calculates the number of responses that are considered finalized within the optimistic time period.\n     * @param approvedModules       Approved modules that could have confirmed the entry.\n     * @param icEntry               The InterchainEntry to confirm.\n     * @param optimisticPeriod      The time period in seconds within which a response is considered valid.\n     * @return finalizedResponses   The count of responses that are finalized within the optimistic time period.\n     */\n    function _getFinalizedResponsesCount(\n        address[] memory approvedModules,\n        InterchainEntry memory icEntry,\n        bytes32[] calldata proof,\n        uint256 optimisticPeriod\n    )\n        internal\n        view\n        returns (uint256 finalizedResponses)\n    {\n        for (uint256 i = 0; i \u003c approvedModules.length; ++i) {\n            uint256 confirmedAt = IInterchainDB(INTERCHAIN_DB).checkVerification(approvedModules[i], icEntry, proof);\n            // checkVerification() returns 0 if entry hasn't been confirmed by the module, so we check for that as well\n            if (confirmedAt != 0 \u0026\u0026 confirmedAt + optimisticPeriod \u003c block.timestamp) {\n                ++finalizedResponses;\n            }\n        }\n    }\n\n    /// @dev Asserts that the transaction version is correct. Returns the decoded transaction for chaining purposes.\n    function _assertCorrectVersion(bytes calldata versionedTx)\n        internal\n        pure\n        returns (InterchainTransaction memory icTx)\n    {\n        uint16 version = versionedTx.getVersion();\n        if (version != CLIENT_VERSION) {\n            revert InterchainClientV1__InvalidTransactionVersion(version);\n        }\n        icTx = InterchainTransactionLib.decodeTransaction(versionedTx.getPayload());\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"8170:403:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;8170:403:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"8170:403:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainClientV1.sol\":\"MathLib\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainClientV1.sol\":{\"keccak256\":\"0xe270686a9bca05b4013610a4e8bb08040de32a0442edd218e1692edaca94e40e\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://727e84146369613e04e57a677f8bc6c709ee145df3eeb79f15ea5a922198d78f\",\"dweb:/ipfs/QmUXh2nDtHBnhYZSwCxcteN4be13S7dR9GbqqHT9mUxta3\"]}},\"version\":1}"},"hashes":{}},"solidity/InterchainClientV1.sol:OptionsLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220c1bbe406d975444c80ff326a0e2e09f1d835cce1a07abfe4f29f63c5f0478bda64736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220c1bbe406d975444c80ff326a0e2e09f1d835cce1a07abfe4f29f63c5f0478bda64736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainClientV1Events.sol\n\nabstract contract InterchainClientV1Events {\n    event ExecutionFeesSet(address executionFees);\n    event LinkedClientSet(uint64 chainId, bytes32 client);\n\n    // TODO: figure out indexing\n\n    event InterchainTransactionSent(\n        bytes32 indexed transactionId,\n        uint64 indexed dbNonce,\n        uint64 indexed entryIndex,\n        uint64 dstChainId,\n        bytes32 srcSender,\n        bytes32 dstReceiver,\n        uint256 verificationFee,\n        uint256 executionFee,\n        bytes options,\n        bytes message\n    );\n\n    event InterchainTransactionReceived(\n        bytes32 indexed transactionId,\n        uint64 indexed dbNonce,\n        uint64 indexed entryIndex,\n        uint64 srcChainId,\n        bytes32 srcSender,\n        bytes32 dstReceiver\n    );\n\n    event ExecutionProofWritten(\n        bytes32 indexed transactionId, uint64 indexed dbNonce, uint64 indexed entryIndex, address executor\n    );\n}\n\n// contracts/interfaces/IExecutionFees.sol\n\ninterface IExecutionFees {\n    error ExecutionFees__AlreadyRecorded(uint64 dstChainId, bytes32 transactionId, address executor);\n    error ExecutionFees__ZeroAddress();\n    error ExecutionFees__ZeroAmount();\n\n    /// @notice Add the execution fee for a transaction. The attached value will be added to the\n    /// rewards for the executor completing the transaction.\n    /// Note: this could be used to store the execution fee for a new transaction, or to add more\n    /// funds to the execution fee of an existing transaction. Therefore this function is payable,\n    /// and does not implement any caller restrictions.\n    /// @dev Will revert if the executor is already recorded for the transaction.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to add the execution fee to.\n    function addExecutionFee(uint64 dstChainId, bytes32 transactionId) external payable;\n\n    /// @notice Record the executor (who completed the transaction) for a transaction,\n    /// and update the accumulated rewards for the executor.\n    /// @dev Could only be called by the Recorder.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to record the executor for.\n    /// @param executor             The address of the executor who completed the transaction.\n    function recordExecutor(uint64 dstChainId, bytes32 transactionId, address executor) external;\n\n    /// @notice Allows the executor to claim their unclaimed rewards.\n    /// @dev Will revert if the executor has no unclaimed rewards.\n    function claimExecutionFees(address executor) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the accumulated rewards for an executor.\n    /// @param executor             The address of the executor to get the rewards for.\n    function accumulatedRewards(address executor) external view returns (uint256 accumulated);\n\n    /// @notice Get the unclaimed rewards for an executor.\n    /// @param executor             The address of the executor to get the rewards for.\n    function unclaimedRewards(address executor) external view returns (uint256 unclaimed);\n\n    /// @notice Get the total execution fee for a transaction.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to get the execution fee for.\n    function executionFee(uint64 dstChainId, bytes32 transactionId) external view returns (uint256 fee);\n\n    /// @notice Get the address of the recorded executor for a transaction.\n    /// @dev Will return address(0) if the executor is not recorded.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to get the recorded executor for.\n    function recordedExecutor(uint64 dstChainId, bytes32 transactionId) external view returns (address executor);\n}\n\n// contracts/interfaces/IExecutionService.sol\n\ninterface IExecutionService {\n    /// @notice Request the execution of an Interchain Transaction on a remote chain.\n    /// Note: the off-chain actor needs to fetch the transaction payload from the InterchainClient\n    /// event with the same transactionId, then execute the transaction on the remote chain:\n    /// `dstInterchainClient.executeTransaction(transactionPayload)`\n    /// Once the execution is confirmed on the source chain, the off-chain actor will be able\n    /// to claim `executionFee` in the ExecutionFees contract.\n    /// @dev Could only be called by `InterchainClient` contracts.\n    /// Will revert if the execution fee is not big enough.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param txPayloadSize        The size of the transaction payload to use for the execution.\n    /// @param transactionId        The id of the transaction to execute.\n    /// @param executionFee         The fee paid for the execution.\n    /// @param options              The options to use for the execution.\n    function requestExecution(\n        uint64 dstChainId,\n        uint256 txPayloadSize,\n        bytes32 transactionId,\n        uint256 executionFee,\n        bytes memory options\n    )\n        external;\n\n    /// @notice Get the address of the EOA account that will be used to execute transactions on the\n    /// remote chains.\n    function executorEOA() external view returns (address);\n\n    /// @notice Get the execution fee for executing an Interchain Transaction on a remote chain.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param txPayloadSize        The size of the transaction payload to use for the execution.\n    /// @param options              The options to use for the execution.\n    function getExecutionFee(\n        uint64 dstChainId,\n        uint256 txPayloadSize,\n        bytes memory options\n    )\n        external\n        view\n        returns (uint256);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    /// @notice Allows the Interchain Client to pass the message to the Interchain App.\n    /// @dev App is responsible for keeping track of interchain clients, and must verify the message sender.\n    /// @param srcChainId   Chain ID of the source chain, where the message was sent from.\n    /// @param sender       Sender address on the source chain, as a bytes32 value.\n    /// @param dbNonce      The Interchain DB nonce of the batch containing the message entry.\n    /// @param entryIndex   The index of the message entry within the batch.\n    /// @param message      The message being sent.\n    function appReceive(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /// @notice Returns the verification configuration of the Interchain App.\n    /// @dev This configuration is used by the Interchain Client to verify that message has been confirmed\n    /// by the Interchain Modules on the destination chain.\n    /// Note: V1 version of AppConfig includes the required responses count, and optimistic period after which\n    /// the message is considered confirmed by the module. Following versions may include additional fields.\n    /// @return appConfig    The versioned configuration of the Interchain App, encoded as bytes.\n    /// @return modules      The list of Interchain Modules that app is trusting to confirm the messages.\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/Math.sol\n\nlibrary MathLib {\n    /// @notice Rounds up to the nearest multiple of 32.\n    /// Note: Returns zero on overflows instead of reverting. This is fine for practical\n    /// use cases, as this is used for determining the size of the payload in memory.\n    function roundUpToWord(uint256 x) internal pure returns (uint256) {\n        unchecked {\n            return (x + 31) \u0026 ~uint256(31);\n        }\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/VersionedPayload.sol\n\n// solhint-disable no-inline-assembly\n// solhint-disable ordering\nlibrary VersionedPayloadLib {\n    /// @notice Amount of bytes reserved for the version (uint16) in the versioned payload\n    uint256 internal constant VERSION_LENGTH = 2;\n\n    error VersionedPayload__TooShort(bytes versionedPayload);\n    error VersionedPayload__PrecompileFailed();\n\n    /// @notice Encodes the versioned payload into a single bytes array.\n    /// @param version  The payload's version.\n    /// @param payload  The payload to encode.\n    function encodeVersionedPayload(uint16 version, bytes memory payload) internal pure returns (bytes memory) {\n        return abi.encodePacked(version, payload);\n    }\n\n    /// @notice Extracts the version from the versioned payload (calldata reference).\n    /// @param versionedPayload     The versioned payload (calldata reference).\n    function getVersion(bytes calldata versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            version := shr(240, calldataload(versionedPayload.offset))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (calldata reference).\n    /// @dev The extracted payload is also returned as a calldata reference.\n    /// @param versionedPayload     The versioned payload.\n    function getPayload(bytes calldata versionedPayload) internal pure returns (bytes calldata) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        return versionedPayload[VERSION_LENGTH:];\n    }\n\n    /// @notice Extracts the version from the versioned payload (memory reference).\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getVersionFromMemory(bytes memory versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            // We add 0x20 to skip the length of the bytes array.\n            version := shr(240, mload(add(versionedPayload, 0x20)))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (memory reference).\n    /// @dev The extracted payload is copied into a new memory location. Use `getPayload` when possible\n    /// to avoid extra memory allocation.\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getPayloadFromMemory(bytes memory versionedPayload) internal view returns (bytes memory payload) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        // Figure how many bytes to copy and allocate the memory for the extracted payload.\n        uint256 toCopy;\n        unchecked {\n            toCopy = versionedPayload.length - VERSION_LENGTH;\n        }\n        payload = new bytes(toCopy);\n        // Use identity precompile (0x04) to copy the payload. Unlike MCOPY, this is available on all EVM chains.\n        bool res;\n        assembly {\n            // We add 0x20 to skip the length of the bytes array.\n            // We add 0x02 to skip the 2 bytes reserved for the version.\n            // Copy the payload to the previously allocated memory.\n            res := staticcall(gas(), 0x04, add(versionedPayload, 0x22), toCopy, add(payload, 0x20), toCopy)\n        }\n        if (!res) {\n            revert VersionedPayload__PrecompileFailed();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SafeCast.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value \u003e type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value \u003e type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value \u003e type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value \u003e type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value \u003e type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value \u003e type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value \u003e type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value \u003e type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value \u003e type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value \u003e type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value \u003e type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value \u003e type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value \u003e type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value \u003e type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value \u003e type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value \u003e type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value \u003e type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value \u003e type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value \u003e type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value \u003e type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value \u003e type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value \u003e type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value \u003e type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value \u003e type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value \u003e type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value \u003e type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value \u003e type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value \u003e type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value \u003e type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value \u003e type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value \u003e type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value \u003c 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value \u003e uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal view returns (AppConfigV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (AppConfigV1));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal view returns (OptionsV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (OptionsV1));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(OPTIONS_V1, abi.encode(options));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/libs/InterchainBatch.sol\n\ntype BatchKey is uint128;\n\n/// @notice Struct representing a batch of entries in the Interchain DataBase.\n/// Batched entries are put together in a Merkle tree, which root is saved.\n/// Batch has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: batchRoot\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch\n/// @param batchRoot    The root of the Merkle tree containing the batched entries\nstruct InterchainBatch {\n    uint64 srcChainId;\n    uint64 dbNonce;\n    bytes32 batchRoot;\n}\n\nlibrary InterchainBatchLib {\n    using VersionedPayloadLib for bytes;\n\n    /// @notice Constructs an InterchainBatch struct to be saved on the local chain.\n    /// @param dbNonce      The database nonce of the batch\n    /// @param batchRoot    The root of the Merkle tree containing the batched entries\n    /// @return batch       The constructed InterchainBatch struct\n    function constructLocalBatch(\n        uint64 dbNonce,\n        bytes32 batchRoot\n    )\n        internal\n        view\n        returns (InterchainBatch memory batch)\n    {\n        return InterchainBatch({srcChainId: SafeCast.toUint64(block.chainid), dbNonce: dbNonce, batchRoot: batchRoot});\n    }\n\n    /// @notice Encodes the InterchainBatch struct into a non-versioned batch payload.\n    function encodeBatch(InterchainBatch memory batch) internal pure returns (bytes memory) {\n        return abi.encode(encodeBatchKey(batch.srcChainId, batch.dbNonce), batch.batchRoot);\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in calldata.\n    function decodeBatch(bytes calldata data) internal pure returns (InterchainBatch memory batch) {\n        BatchKey key;\n        (key, batch.batchRoot) = abi.decode(data, (BatchKey, bytes32));\n        (batch.srcChainId, batch.dbNonce) = decodeBatchKey(key);\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in memory.\n    function decodeBatchFromMemory(bytes memory data) internal pure returns (InterchainBatch memory batch) {\n        BatchKey key;\n        (key, batch.batchRoot) = abi.decode(data, (BatchKey, bytes32));\n        (batch.srcChainId, batch.dbNonce) = decodeBatchKey(key);\n    }\n\n    /// @notice Encodes the uint128 key of the batch from uint64 srcChainId and uint64 dbNonce.\n    function encodeBatchKey(uint64 srcChainId, uint64 dbNonce) internal pure returns (BatchKey) {\n        return BatchKey.wrap((uint128(srcChainId) \u003c\u003c 64) | dbNonce);\n    }\n\n    /// @notice Decodes the uint128 key of the batch into uint64 srcChainId and uint64 dbNonce.\n    function decodeBatchKey(BatchKey key) internal pure returns (uint64 srcChainId, uint64 dbNonce) {\n        srcChainId = uint64(BatchKey.unwrap(key) \u003e\u003e 64);\n        dbNonce = uint64(BatchKey.unwrap(key));\n    }\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce + entryIndex\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch containing the entry\n/// @param entryIndex   The index of the entry in the batch\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint64 srcChainId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nusing InterchainEntryLib for InterchainEntry global;\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint64 dbNonce,\n        uint64 entryIndex,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: SafeCast.toUint64(block.chainid),\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n}\n\n// contracts/libs/InterchainTransaction.sol\n\ntype ICTxHeader is uint256;\n\nstruct InterchainTransaction {\n    uint64 srcChainId;\n    uint64 dstChainId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcSender;\n    bytes32 dstReceiver;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    using MathLib for uint256;\n    using VersionedPayloadLib for bytes;\n\n    function constructLocalTransaction(\n        address srcSender,\n        uint64 dstChainId,\n        bytes32 dstReceiver,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: SafeCast.toUint64(block.chainid),\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            encodeTxHeader(transaction.srcChainId, transaction.dstChainId, transaction.dbNonce, transaction.entryIndex),\n            transaction.srcSender,\n            transaction.dstReceiver,\n            transaction.options,\n            transaction.message\n        );\n    }\n\n    function decodeTransaction(bytes calldata transaction) internal pure returns (InterchainTransaction memory icTx) {\n        ICTxHeader header;\n        (header, icTx.srcSender, icTx.dstReceiver, icTx.options, icTx.message) =\n            abi.decode(transaction, (ICTxHeader, bytes32, bytes32, bytes, bytes));\n        (icTx.srcChainId, icTx.dstChainId, icTx.dbNonce, icTx.entryIndex) = decodeTxHeader(header);\n    }\n\n    function payloadSize(uint256 optionsLen, uint256 messageLen) internal pure returns (uint256) {\n        // 2 bytes are reserved for the transaction version\n        // + 5 fields * 32 bytes (3 values for static, 2 offsets for dynamic) + 2 * 32 bytes (lengths for dynamic) = 226\n        // (srcChainId, dstChainId, dbNonce, entryIndex) are merged into a single 32 bytes field\n        // Both options and message are dynamic fields, which are padded up to 32 bytes\n        return 226 + optionsLen.roundUpToWord() + messageLen.roundUpToWord();\n    }\n\n    function encodeTxHeader(\n        uint64 srcChainId,\n        uint64 dstChainId,\n        uint64 dbNonce,\n        uint64 entryIndex\n    )\n        internal\n        pure\n        returns (ICTxHeader)\n    {\n        return ICTxHeader.wrap(\n            (uint256(srcChainId) \u003c\u003c 192) | (uint256(dstChainId) \u003c\u003c 128) | (uint256(dbNonce) \u003c\u003c 64) | uint256(entryIndex)\n        );\n    }\n\n    function decodeTxHeader(ICTxHeader header)\n        internal\n        pure\n        returns (uint64 srcChainId, uint64 dstChainId, uint64 dbNonce, uint64 entryIndex)\n    {\n        srcChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 192);\n        dstChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 128);\n        dbNonce = uint64(ICTxHeader.unwrap(header) \u003e\u003e 64);\n        entryIndex = uint64(ICTxHeader.unwrap(header));\n    }\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint64 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__InvalidTransactionVersion(uint16 version);\n    error InterchainClientV1__NoLinkedClient(uint64 chainId);\n    error InterchainClientV1__NotEnoughGasSupplied();\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint64 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint64 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint64 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint64 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param messageLen           The length of the message being sent.\n    function getInterchainFee(\n        uint64 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        uint256 messageLen\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint64 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint64 chainId) external view returns (address);\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing a batch of entries from the remote Interchain DataBase,\n    /// verified by the Interchain Module.\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param batchRoot    The Merkle root of the batch\n    struct RemoteBatch {\n        uint256 verifiedAt;\n        bytes32 batchRoot;\n    }\n\n    error InterchainDB__BatchDoesNotExist(uint64 dbNonce);\n    error InterchainDB__BatchNotFinalized(uint64 dbNonce);\n    error InterchainDB__ConflictingBatches(address module, bytes32 existingBatchRoot, InterchainBatch newBatch);\n    error InterchainDB__EntryIndexOutOfRange(uint64 dbNonce, uint64 entryIndex, uint64 batchSize);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__InvalidBatchVersion(uint16 version);\n    error InterchainDB__InvalidEntryRange(uint64 dbNonce, uint64 start, uint64 end);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId(uint64 chainId);\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `requestBatchVerification` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntry(bytes32 dataHash) external returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Request the given Interchain Modules to verify an existing batch.\n    /// If the batch is not finalized, the module will verify it after finalization.\n    /// For the finalized batch the batch root is already available, and the module can verify it immediately.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any batch.\n    /// @dev Will revert if the batch with the given nonce does not exist.\n    /// @param dstChainId    The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the existing batch\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestBatchVerification(\n        uint64 dstChainId,\n        uint64 dbNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Then request the Interchain Modules to verify the batch containing the written entry on the destination chain.\n    /// See `writeEntry` and `requestBatchVerification` for more details.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntryWithVerification(\n        uint64 dstChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Allows the Interchain Module to verify the batch coming from the remote chain.\n    /// Note: The DB will only accept the batch of the same version as the DB itself.\n    /// @param versionedBatch   The versioned Interchain Batch to verify\n    function verifyRemoteBatch(bytes memory versionedBatch) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint64 dstChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce.\n    /// Note: the leafs are ordered by the index of the written entry in the current batch,\n    /// and the leafs value match the value of the written entry (srcWriter + dataHash hashed together).\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchLeafs(uint64 dbNonce) external view returns (bytes32[] memory);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce,\n    /// paginated by the given start and end indexes. The end index is exclusive.\n    /// Note: this is useful when the batch contains a large number of leafs, and calling `getBatchLeafs`\n    /// would result in a gas limit exceeded error.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the provided range is invalid.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param start        The start index of the paginated leafs, inclusive\n    /// @param end          The end index of the paginated leafs, exclusive\n    function getBatchLeafsPaginated(\n        uint64 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory);\n\n    /// @notice Returns the size of the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchSize(uint64 dbNonce) external view returns (uint64);\n\n    /// @notice Get the finalized Interchain Batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatch(uint64 dbNonce) external view returns (InterchainBatch memory);\n\n    /// @notice Get the Interchain Entry's value written on the local chain with the given batch nonce and entry index.\n    /// Entry value is calculated as the hash of the writer address and the written data hash.\n    /// Note: the batch does not have to be finalized to fetch the entry value.\n    /// @dev Will revert if the batch with the given nonce does not exist,\n    /// or the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the existing batch\n    /// @param entryIndex   The index of the written entry within the batch\n    function getEntryValue(uint64 dbNonce, uint64 entryIndex) external view returns (bytes32);\n\n    /// @notice Get the Merkle proof of inclusion for the entry with the given index\n    /// in the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param entryIndex   The index of the written entry within the batch\n    /// @return proof       The Merkle proof of inclusion for the entry\n    function getEntryProof(uint64 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof);\n\n    /// @notice Get the nonce of the database, which is incremented every time a new batch is finalized.\n    /// This is the nonce of the current non-finalized batch.\n    function getDBNonce() external view returns (uint64);\n\n    /// @notice Get the index of the next entry to be written to the database.\n    /// @return dbNonce      The database nonce of the batch including the next entry\n    /// @return entryIndex   The index of the next entry within that batch\n    function getNextEntryIndex() external view returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or ZERO if the module has not verified the entry.\n    function checkVerification(\n        address dstModule,\n        InterchainEntry memory entry,\n        bytes32[] memory proof\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n\n    /// @notice Get the version of the Interchain DataBase.\n    // solhint-disable-next-line func-name-mixedcase\n    function DB_VERSION() external pure returns (uint16);\n}\n\n// contracts/InterchainClientV1.sol\n\n/**\n * @title InterchainClientV1\n * @dev Implements the operations of the Interchain Execution Layer.\n */\ncontract InterchainClientV1 is Ownable, InterchainClientV1Events, IInterchainClientV1 {\n    using AppConfigLib for bytes;\n    using OptionsLib for bytes;\n    using VersionedPayloadLib for bytes;\n\n    /// @notice Version of the InterchainClient contract. Sent and received transactions must have the same version.\n    uint16 public constant CLIENT_VERSION = 1;\n\n    /// @notice Address of the InterchainDB contract, set at the time of deployment.\n    address public immutable INTERCHAIN_DB;\n\n    /// @notice Address of the contract that handles execution fees. Can be updated by the owner.\n    address public executionFees;\n\n    /// @dev Address of the InterchainClient contract on the remote chain\n    mapping(uint64 chainId =\u003e bytes32 remoteClient) internal _linkedClient;\n    /// @dev Executor address that completed the transaction. Address(0) if not executed yet.\n    mapping(bytes32 transactionId =\u003e address executor) internal _txExecutor;\n\n    constructor(address interchainDB, address owner_) Ownable(owner_) {\n        INTERCHAIN_DB = interchainDB;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function setExecutionFees(address executionFees_) external onlyOwner {\n        executionFees = executionFees_;\n        emit ExecutionFeesSet(executionFees_);\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function setLinkedClient(uint64 chainId, bytes32 client) external onlyOwner {\n        _linkedClient[chainId] = client;\n        emit LinkedClientSet(chainId, client);\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _interchainSend(dstChainId, receiver, srcExecutionService, srcModules, options, message);\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function interchainSendEVM(\n        uint64 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc)\n    {\n        bytes32 receiverBytes32 = TypeCasts.addressToBytes32(receiver);\n        return _interchainSend(dstChainId, receiverBytes32, srcExecutionService, srcModules, options, message);\n    }\n\n    // TODO: Handle the case where receiver does not implement the IInterchainApp interface (or does not exist at all)\n    // @inheritdoc IInterchainClientV1\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable\n    {\n        InterchainTransaction memory icTx = _assertCorrectVersion(transaction);\n        bytes32 transactionId = keccak256(transaction);\n        _assertExecutable(icTx, transactionId, proof);\n        _txExecutor[transactionId] = msg.sender;\n\n        OptionsV1 memory decodedOptions = icTx.options.decodeOptionsV1();\n        if (msg.value != decodedOptions.gasAirdrop) {\n            revert InterchainClientV1__IncorrectMsgValue(msg.value, decodedOptions.gasAirdrop);\n        }\n        // We should always use at least as much as the requested gas limit.\n        // The executor can specify a higher gas limit if they wanted.\n        if (decodedOptions.gasLimit \u003e gasLimit) gasLimit = decodedOptions.gasLimit;\n        // Check the the Executor has provided big enough gas limit for the whole transaction.\n        if (gasleft() \u003c= gasLimit) {\n            revert InterchainClientV1__NotEnoughGasSupplied();\n        }\n        // Pass the full msg.value to the app: we have already checked that it matches the requested gas airdrop.\n        IInterchainApp(TypeCasts.bytes32ToAddress(icTx.dstReceiver)).appReceive{gas: gasLimit, value: msg.value}({\n            srcChainId: icTx.srcChainId,\n            sender: icTx.srcSender,\n            dbNonce: icTx.dbNonce,\n            entryIndex: icTx.entryIndex,\n            message: icTx.message\n        });\n        emit InterchainTransactionReceived(\n            transactionId, icTx.dbNonce, icTx.entryIndex, icTx.srcChainId, icTx.srcSender, icTx.dstReceiver\n        );\n    }\n\n    /// @inheritdoc IInterchainClientV1\n    function writeExecutionProof(bytes32 transactionId) external returns (uint64 dbNonce, uint64 entryIndex) {\n        address executor = _txExecutor[transactionId];\n        if (executor == address(0)) {\n            revert InterchainClientV1__TxNotExecuted(transactionId);\n        }\n        bytes memory proof = abi.encode(transactionId, executor);\n        (dbNonce, entryIndex) = IInterchainDB(INTERCHAIN_DB).writeEntry(keccak256(proof));\n        emit ExecutionProofWritten(transactionId, dbNonce, entryIndex, executor);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // @inheritdoc IInterchainClientV1\n    function isExecutable(bytes calldata encodedTx, bytes32[] calldata proof) external view returns (bool) {\n        InterchainTransaction memory icTx = _assertCorrectVersion(encodedTx);\n        // Check that options could be decoded\n        icTx.options.decodeOptionsV1();\n        bytes32 transactionId = keccak256(encodedTx);\n        _assertExecutable(icTx, transactionId, proof);\n        return true;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function getExecutor(bytes calldata encodedTx) external view returns (address) {\n        return _txExecutor[keccak256(encodedTx)];\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function getExecutorById(bytes32 transactionId) external view returns (address) {\n        return _txExecutor[transactionId];\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function getInterchainFee(\n        uint64 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        uint256 messageLen\n    )\n        external\n        view\n        returns (uint256 fee)\n    {\n        _assertLinkedClient(dstChainId);\n        // Check that options could be decoded on destination chain\n        options.decodeOptionsV1();\n        // Verification fee from InterchainDB\n        fee = IInterchainDB(INTERCHAIN_DB).getInterchainFee(dstChainId, srcModules);\n        // Add execution fee, if ExecutionService is provided\n        if (srcExecutionService != address(0)) {\n            uint256 payloadSize = InterchainTransactionLib.payloadSize(options.length, messageLen);\n            fee += IExecutionService(srcExecutionService).getExecutionFee(dstChainId, payloadSize, options);\n        }\n    }\n\n    /// @inheritdoc IInterchainClientV1\n    function getLinkedClient(uint64 chainId) external view returns (bytes32) {\n        if (chainId == block.chainid) {\n            revert InterchainClientV1__NotRemoteChainId(chainId);\n        }\n        return _linkedClient[chainId];\n    }\n\n    /// @inheritdoc IInterchainClientV1\n    function getLinkedClientEVM(uint64 chainId) external view returns (address linkedClientEVM) {\n        if (chainId == block.chainid) {\n            revert InterchainClientV1__NotRemoteChainId(chainId);\n        }\n        bytes32 linkedClient = _linkedClient[chainId];\n        linkedClientEVM = TypeCasts.bytes32ToAddress(linkedClient);\n        // Check that the linked client address fits into the EVM address space\n        if (TypeCasts.addressToBytes32(linkedClientEVM) != linkedClient) {\n            revert InterchainClientV1__NotEVMClient(linkedClient);\n        }\n    }\n\n    /// @notice Decodes the encoded options data into a OptionsV1 struct.\n    function decodeOptions(bytes memory encodedOptions) external view returns (OptionsV1 memory) {\n        return encodedOptions.decodeOptionsV1();\n    }\n\n    /// @notice Encodes the transaction data into a bytes format.\n    function encodeTransaction(InterchainTransaction memory icTx) public pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload({\n            version: CLIENT_VERSION,\n            payload: InterchainTransactionLib.encodeTransaction(icTx)\n        });\n    }\n\n    // ═════════════════════════════════════════════════ INTERNAL ══════════════════════════════════════════════════════\n\n    /// @dev Internal logic for sending a message to another chain.\n    function _interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        _assertLinkedClient(dstChainId);\n        if (receiver == 0) revert InterchainClientV1__ZeroReceiver();\n        // Check that options could be decoded on destination chain\n        options.decodeOptionsV1();\n        uint256 verificationFee = IInterchainDB(INTERCHAIN_DB).getInterchainFee(dstChainId, srcModules);\n        if (msg.value \u003c verificationFee) {\n            revert InterchainClientV1__FeeAmountTooLow(msg.value, verificationFee);\n        }\n        (desc.dbNonce, desc.entryIndex) = IInterchainDB(INTERCHAIN_DB).getNextEntryIndex();\n        InterchainTransaction memory icTx = InterchainTransactionLib.constructLocalTransaction({\n            srcSender: msg.sender,\n            dstReceiver: receiver,\n            dstChainId: dstChainId,\n            dbNonce: desc.dbNonce,\n            entryIndex: desc.entryIndex,\n            options: options,\n            message: message\n        });\n        desc.transactionId = keccak256(encodeTransaction(icTx));\n        // Sanity check: nonce returned from DB should match the nonce used to construct the transaction\n        {\n            (uint64 dbNonce, uint64 entryIndex) = IInterchainDB(INTERCHAIN_DB).writeEntryWithVerification{\n                value: verificationFee\n            }(icTx.dstChainId, desc.transactionId, srcModules);\n            assert(dbNonce == desc.dbNonce \u0026\u0026 entryIndex == desc.entryIndex);\n        }\n        uint256 executionFee;\n        unchecked {\n            executionFee = msg.value - verificationFee;\n        }\n        if (executionFee \u003e 0) {\n            IExecutionFees(executionFees).addExecutionFee{value: executionFee}(icTx.dstChainId, desc.transactionId);\n        }\n        // TODO: consider disallowing the use of empty srcExecutionService\n        if (srcExecutionService != address(0)) {\n            IExecutionService(srcExecutionService).requestExecution({\n                dstChainId: dstChainId,\n                txPayloadSize: InterchainTransactionLib.payloadSize(options.length, message.length),\n                transactionId: desc.transactionId,\n                executionFee: executionFee,\n                options: options\n            });\n            address srcExecutorEOA = IExecutionService(srcExecutionService).executorEOA();\n            IExecutionFees(executionFees).recordExecutor(icTx.dstChainId, desc.transactionId, srcExecutorEOA);\n        }\n        emit InterchainTransactionSent(\n            desc.transactionId,\n            icTx.dbNonce,\n            icTx.entryIndex,\n            icTx.dstChainId,\n            icTx.srcSender,\n            icTx.dstReceiver,\n            verificationFee,\n            executionFee,\n            icTx.options,\n            icTx.message\n        );\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Asserts that the transaction is executable.\n    function _assertExecutable(\n        InterchainTransaction memory icTx,\n        bytes32 transactionId,\n        bytes32[] calldata proof\n    )\n        internal\n        view\n    {\n        bytes32 linkedClient = _assertLinkedClient(icTx.srcChainId);\n        if (icTx.dstChainId != block.chainid) {\n            revert InterchainClientV1__IncorrectDstChainId(icTx.dstChainId);\n        }\n        if (_txExecutor[transactionId] != address(0)) {\n            revert InterchainClientV1__TxAlreadyExecuted(transactionId);\n        }\n        // Construct expected entry based on icTransaction data\n        InterchainEntry memory icEntry = InterchainEntry({\n            srcChainId: icTx.srcChainId,\n            dbNonce: icTx.dbNonce,\n            entryIndex: icTx.entryIndex,\n            srcWriter: linkedClient,\n            dataHash: transactionId\n        });\n        (bytes memory encodedAppConfig, address[] memory approvedDstModules) =\n            IInterchainApp(TypeCasts.bytes32ToAddress(icTx.dstReceiver)).getReceivingConfig();\n        AppConfigV1 memory appConfig = encodedAppConfig.decodeAppConfigV1();\n        if (appConfig.requiredResponses == 0) {\n            revert InterchainClientV1__ZeroRequiredResponses();\n        }\n        uint256 responses = _getFinalizedResponsesCount(approvedDstModules, icEntry, proof, appConfig.optimisticPeriod);\n        if (responses \u003c appConfig.requiredResponses) {\n            revert InterchainClientV1__NotEnoughResponses(responses, appConfig.requiredResponses);\n        }\n    }\n\n    /// @dev Asserts that the chain is linked and returns the linked client address.\n    function _assertLinkedClient(uint64 chainId) internal view returns (bytes32 linkedClient) {\n        if (chainId == block.chainid) {\n            revert InterchainClientV1__NotRemoteChainId(chainId);\n        }\n        linkedClient = _linkedClient[chainId];\n        if (linkedClient == 0) {\n            revert InterchainClientV1__NoLinkedClient(chainId);\n        }\n    }\n\n    /**\n     * @dev Calculates the number of responses that are considered finalized within the optimistic time period.\n     * @param approvedModules       Approved modules that could have confirmed the entry.\n     * @param icEntry               The InterchainEntry to confirm.\n     * @param optimisticPeriod      The time period in seconds within which a response is considered valid.\n     * @return finalizedResponses   The count of responses that are finalized within the optimistic time period.\n     */\n    function _getFinalizedResponsesCount(\n        address[] memory approvedModules,\n        InterchainEntry memory icEntry,\n        bytes32[] calldata proof,\n        uint256 optimisticPeriod\n    )\n        internal\n        view\n        returns (uint256 finalizedResponses)\n    {\n        for (uint256 i = 0; i \u003c approvedModules.length; ++i) {\n            uint256 confirmedAt = IInterchainDB(INTERCHAIN_DB).checkVerification(approvedModules[i], icEntry, proof);\n            // checkVerification() returns 0 if entry hasn't been confirmed by the module, so we check for that as well\n            if (confirmedAt != 0 \u0026\u0026 confirmedAt + optimisticPeriod \u003c block.timestamp) {\n                ++finalizedResponses;\n            }\n        }\n    }\n\n    /// @dev Asserts that the transaction version is correct. Returns the decoded transaction for chaining purposes.\n    function _assertCorrectVersion(bytes calldata versionedTx)\n        internal\n        pure\n        returns (InterchainTransaction memory icTx)\n    {\n        uint16 version = versionedTx.getVersion();\n        if (version != CLIENT_VERSION) {\n            revert InterchainClientV1__InvalidTransactionVersion(version);\n        }\n        icTx = InterchainTransactionLib.decodeTransaction(versionedTx.getPayload());\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"50376:1233:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;50376:1233:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"50376:1233:0:-:0;;;;;;;;","abiDefinition":[{"inputs":[{"internalType":"uint16","name":"version","type":"uint16"}],"name":"OptionsLib__IncorrectVersion","type":"error"}],"userDoc":{"kind":"user","methods":{},"notice":"A library for encoding and decoding Interchain options related to interchain messages.","version":1},"developerDoc":{"kind":"dev","methods":{},"title":"OptionsLib","version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"version\",\"type\":\"uint16\"}],\"name\":\"OptionsLib__IncorrectVersion\",\"type\":\"error\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"title\":\"OptionsLib\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"A library for encoding and decoding Interchain options related to interchain messages.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainClientV1.sol\":\"OptionsLib\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainClientV1.sol\":{\"keccak256\":\"0xe270686a9bca05b4013610a4e8bb08040de32a0442edd218e1692edaca94e40e\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://727e84146369613e04e57a677f8bc6c709ee145df3eeb79f15ea5a922198d78f\",\"dweb:/ipfs/QmUXh2nDtHBnhYZSwCxcteN4be13S7dR9GbqqHT9mUxta3\"]}},\"version\":1}"},"hashes":{}},"solidity/InterchainClientV1.sol:Ownable":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainClientV1Events.sol\n\nabstract contract InterchainClientV1Events {\n    event ExecutionFeesSet(address executionFees);\n    event LinkedClientSet(uint64 chainId, bytes32 client);\n\n    // TODO: figure out indexing\n\n    event InterchainTransactionSent(\n        bytes32 indexed transactionId,\n        uint64 indexed dbNonce,\n        uint64 indexed entryIndex,\n        uint64 dstChainId,\n        bytes32 srcSender,\n        bytes32 dstReceiver,\n        uint256 verificationFee,\n        uint256 executionFee,\n        bytes options,\n        bytes message\n    );\n\n    event InterchainTransactionReceived(\n        bytes32 indexed transactionId,\n        uint64 indexed dbNonce,\n        uint64 indexed entryIndex,\n        uint64 srcChainId,\n        bytes32 srcSender,\n        bytes32 dstReceiver\n    );\n\n    event ExecutionProofWritten(\n        bytes32 indexed transactionId, uint64 indexed dbNonce, uint64 indexed entryIndex, address executor\n    );\n}\n\n// contracts/interfaces/IExecutionFees.sol\n\ninterface IExecutionFees {\n    error ExecutionFees__AlreadyRecorded(uint64 dstChainId, bytes32 transactionId, address executor);\n    error ExecutionFees__ZeroAddress();\n    error ExecutionFees__ZeroAmount();\n\n    /// @notice Add the execution fee for a transaction. The attached value will be added to the\n    /// rewards for the executor completing the transaction.\n    /// Note: this could be used to store the execution fee for a new transaction, or to add more\n    /// funds to the execution fee of an existing transaction. Therefore this function is payable,\n    /// and does not implement any caller restrictions.\n    /// @dev Will revert if the executor is already recorded for the transaction.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to add the execution fee to.\n    function addExecutionFee(uint64 dstChainId, bytes32 transactionId) external payable;\n\n    /// @notice Record the executor (who completed the transaction) for a transaction,\n    /// and update the accumulated rewards for the executor.\n    /// @dev Could only be called by the Recorder.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to record the executor for.\n    /// @param executor             The address of the executor who completed the transaction.\n    function recordExecutor(uint64 dstChainId, bytes32 transactionId, address executor) external;\n\n    /// @notice Allows the executor to claim their unclaimed rewards.\n    /// @dev Will revert if the executor has no unclaimed rewards.\n    function claimExecutionFees(address executor) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the accumulated rewards for an executor.\n    /// @param executor             The address of the executor to get the rewards for.\n    function accumulatedRewards(address executor) external view returns (uint256 accumulated);\n\n    /// @notice Get the unclaimed rewards for an executor.\n    /// @param executor             The address of the executor to get the rewards for.\n    function unclaimedRewards(address executor) external view returns (uint256 unclaimed);\n\n    /// @notice Get the total execution fee for a transaction.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to get the execution fee for.\n    function executionFee(uint64 dstChainId, bytes32 transactionId) external view returns (uint256 fee);\n\n    /// @notice Get the address of the recorded executor for a transaction.\n    /// @dev Will return address(0) if the executor is not recorded.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to get the recorded executor for.\n    function recordedExecutor(uint64 dstChainId, bytes32 transactionId) external view returns (address executor);\n}\n\n// contracts/interfaces/IExecutionService.sol\n\ninterface IExecutionService {\n    /// @notice Request the execution of an Interchain Transaction on a remote chain.\n    /// Note: the off-chain actor needs to fetch the transaction payload from the InterchainClient\n    /// event with the same transactionId, then execute the transaction on the remote chain:\n    /// `dstInterchainClient.executeTransaction(transactionPayload)`\n    /// Once the execution is confirmed on the source chain, the off-chain actor will be able\n    /// to claim `executionFee` in the ExecutionFees contract.\n    /// @dev Could only be called by `InterchainClient` contracts.\n    /// Will revert if the execution fee is not big enough.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param txPayloadSize        The size of the transaction payload to use for the execution.\n    /// @param transactionId        The id of the transaction to execute.\n    /// @param executionFee         The fee paid for the execution.\n    /// @param options              The options to use for the execution.\n    function requestExecution(\n        uint64 dstChainId,\n        uint256 txPayloadSize,\n        bytes32 transactionId,\n        uint256 executionFee,\n        bytes memory options\n    )\n        external;\n\n    /// @notice Get the address of the EOA account that will be used to execute transactions on the\n    /// remote chains.\n    function executorEOA() external view returns (address);\n\n    /// @notice Get the execution fee for executing an Interchain Transaction on a remote chain.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param txPayloadSize        The size of the transaction payload to use for the execution.\n    /// @param options              The options to use for the execution.\n    function getExecutionFee(\n        uint64 dstChainId,\n        uint256 txPayloadSize,\n        bytes memory options\n    )\n        external\n        view\n        returns (uint256);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    /// @notice Allows the Interchain Client to pass the message to the Interchain App.\n    /// @dev App is responsible for keeping track of interchain clients, and must verify the message sender.\n    /// @param srcChainId   Chain ID of the source chain, where the message was sent from.\n    /// @param sender       Sender address on the source chain, as a bytes32 value.\n    /// @param dbNonce      The Interchain DB nonce of the batch containing the message entry.\n    /// @param entryIndex   The index of the message entry within the batch.\n    /// @param message      The message being sent.\n    function appReceive(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /// @notice Returns the verification configuration of the Interchain App.\n    /// @dev This configuration is used by the Interchain Client to verify that message has been confirmed\n    /// by the Interchain Modules on the destination chain.\n    /// Note: V1 version of AppConfig includes the required responses count, and optimistic period after which\n    /// the message is considered confirmed by the module. Following versions may include additional fields.\n    /// @return appConfig    The versioned configuration of the Interchain App, encoded as bytes.\n    /// @return modules      The list of Interchain Modules that app is trusting to confirm the messages.\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/Math.sol\n\nlibrary MathLib {\n    /// @notice Rounds up to the nearest multiple of 32.\n    /// Note: Returns zero on overflows instead of reverting. This is fine for practical\n    /// use cases, as this is used for determining the size of the payload in memory.\n    function roundUpToWord(uint256 x) internal pure returns (uint256) {\n        unchecked {\n            return (x + 31) \u0026 ~uint256(31);\n        }\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/VersionedPayload.sol\n\n// solhint-disable no-inline-assembly\n// solhint-disable ordering\nlibrary VersionedPayloadLib {\n    /// @notice Amount of bytes reserved for the version (uint16) in the versioned payload\n    uint256 internal constant VERSION_LENGTH = 2;\n\n    error VersionedPayload__TooShort(bytes versionedPayload);\n    error VersionedPayload__PrecompileFailed();\n\n    /// @notice Encodes the versioned payload into a single bytes array.\n    /// @param version  The payload's version.\n    /// @param payload  The payload to encode.\n    function encodeVersionedPayload(uint16 version, bytes memory payload) internal pure returns (bytes memory) {\n        return abi.encodePacked(version, payload);\n    }\n\n    /// @notice Extracts the version from the versioned payload (calldata reference).\n    /// @param versionedPayload     The versioned payload (calldata reference).\n    function getVersion(bytes calldata versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            version := shr(240, calldataload(versionedPayload.offset))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (calldata reference).\n    /// @dev The extracted payload is also returned as a calldata reference.\n    /// @param versionedPayload     The versioned payload.\n    function getPayload(bytes calldata versionedPayload) internal pure returns (bytes calldata) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        return versionedPayload[VERSION_LENGTH:];\n    }\n\n    /// @notice Extracts the version from the versioned payload (memory reference).\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getVersionFromMemory(bytes memory versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            // We add 0x20 to skip the length of the bytes array.\n            version := shr(240, mload(add(versionedPayload, 0x20)))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (memory reference).\n    /// @dev The extracted payload is copied into a new memory location. Use `getPayload` when possible\n    /// to avoid extra memory allocation.\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getPayloadFromMemory(bytes memory versionedPayload) internal view returns (bytes memory payload) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        // Figure how many bytes to copy and allocate the memory for the extracted payload.\n        uint256 toCopy;\n        unchecked {\n            toCopy = versionedPayload.length - VERSION_LENGTH;\n        }\n        payload = new bytes(toCopy);\n        // Use identity precompile (0x04) to copy the payload. Unlike MCOPY, this is available on all EVM chains.\n        bool res;\n        assembly {\n            // We add 0x20 to skip the length of the bytes array.\n            // We add 0x02 to skip the 2 bytes reserved for the version.\n            // Copy the payload to the previously allocated memory.\n            res := staticcall(gas(), 0x04, add(versionedPayload, 0x22), toCopy, add(payload, 0x20), toCopy)\n        }\n        if (!res) {\n            revert VersionedPayload__PrecompileFailed();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SafeCast.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value \u003e type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value \u003e type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value \u003e type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value \u003e type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value \u003e type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value \u003e type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value \u003e type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value \u003e type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value \u003e type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value \u003e type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value \u003e type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value \u003e type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value \u003e type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value \u003e type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value \u003e type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value \u003e type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value \u003e type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value \u003e type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value \u003e type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value \u003e type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value \u003e type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value \u003e type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value \u003e type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value \u003e type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value \u003e type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value \u003e type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value \u003e type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value \u003e type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value \u003e type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value \u003e type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value \u003e type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value \u003c 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value \u003e uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal view returns (AppConfigV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (AppConfigV1));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal view returns (OptionsV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (OptionsV1));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(OPTIONS_V1, abi.encode(options));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/libs/InterchainBatch.sol\n\ntype BatchKey is uint128;\n\n/// @notice Struct representing a batch of entries in the Interchain DataBase.\n/// Batched entries are put together in a Merkle tree, which root is saved.\n/// Batch has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: batchRoot\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch\n/// @param batchRoot    The root of the Merkle tree containing the batched entries\nstruct InterchainBatch {\n    uint64 srcChainId;\n    uint64 dbNonce;\n    bytes32 batchRoot;\n}\n\nlibrary InterchainBatchLib {\n    using VersionedPayloadLib for bytes;\n\n    /// @notice Constructs an InterchainBatch struct to be saved on the local chain.\n    /// @param dbNonce      The database nonce of the batch\n    /// @param batchRoot    The root of the Merkle tree containing the batched entries\n    /// @return batch       The constructed InterchainBatch struct\n    function constructLocalBatch(\n        uint64 dbNonce,\n        bytes32 batchRoot\n    )\n        internal\n        view\n        returns (InterchainBatch memory batch)\n    {\n        return InterchainBatch({srcChainId: SafeCast.toUint64(block.chainid), dbNonce: dbNonce, batchRoot: batchRoot});\n    }\n\n    /// @notice Encodes the InterchainBatch struct into a non-versioned batch payload.\n    function encodeBatch(InterchainBatch memory batch) internal pure returns (bytes memory) {\n        return abi.encode(encodeBatchKey(batch.srcChainId, batch.dbNonce), batch.batchRoot);\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in calldata.\n    function decodeBatch(bytes calldata data) internal pure returns (InterchainBatch memory batch) {\n        BatchKey key;\n        (key, batch.batchRoot) = abi.decode(data, (BatchKey, bytes32));\n        (batch.srcChainId, batch.dbNonce) = decodeBatchKey(key);\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in memory.\n    function decodeBatchFromMemory(bytes memory data) internal pure returns (InterchainBatch memory batch) {\n        BatchKey key;\n        (key, batch.batchRoot) = abi.decode(data, (BatchKey, bytes32));\n        (batch.srcChainId, batch.dbNonce) = decodeBatchKey(key);\n    }\n\n    /// @notice Encodes the uint128 key of the batch from uint64 srcChainId and uint64 dbNonce.\n    function encodeBatchKey(uint64 srcChainId, uint64 dbNonce) internal pure returns (BatchKey) {\n        return BatchKey.wrap((uint128(srcChainId) \u003c\u003c 64) | dbNonce);\n    }\n\n    /// @notice Decodes the uint128 key of the batch into uint64 srcChainId and uint64 dbNonce.\n    function decodeBatchKey(BatchKey key) internal pure returns (uint64 srcChainId, uint64 dbNonce) {\n        srcChainId = uint64(BatchKey.unwrap(key) \u003e\u003e 64);\n        dbNonce = uint64(BatchKey.unwrap(key));\n    }\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce + entryIndex\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch containing the entry\n/// @param entryIndex   The index of the entry in the batch\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint64 srcChainId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nusing InterchainEntryLib for InterchainEntry global;\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint64 dbNonce,\n        uint64 entryIndex,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: SafeCast.toUint64(block.chainid),\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n}\n\n// contracts/libs/InterchainTransaction.sol\n\ntype ICTxHeader is uint256;\n\nstruct InterchainTransaction {\n    uint64 srcChainId;\n    uint64 dstChainId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcSender;\n    bytes32 dstReceiver;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    using MathLib for uint256;\n    using VersionedPayloadLib for bytes;\n\n    function constructLocalTransaction(\n        address srcSender,\n        uint64 dstChainId,\n        bytes32 dstReceiver,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: SafeCast.toUint64(block.chainid),\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            encodeTxHeader(transaction.srcChainId, transaction.dstChainId, transaction.dbNonce, transaction.entryIndex),\n            transaction.srcSender,\n            transaction.dstReceiver,\n            transaction.options,\n            transaction.message\n        );\n    }\n\n    function decodeTransaction(bytes calldata transaction) internal pure returns (InterchainTransaction memory icTx) {\n        ICTxHeader header;\n        (header, icTx.srcSender, icTx.dstReceiver, icTx.options, icTx.message) =\n            abi.decode(transaction, (ICTxHeader, bytes32, bytes32, bytes, bytes));\n        (icTx.srcChainId, icTx.dstChainId, icTx.dbNonce, icTx.entryIndex) = decodeTxHeader(header);\n    }\n\n    function payloadSize(uint256 optionsLen, uint256 messageLen) internal pure returns (uint256) {\n        // 2 bytes are reserved for the transaction version\n        // + 5 fields * 32 bytes (3 values for static, 2 offsets for dynamic) + 2 * 32 bytes (lengths for dynamic) = 226\n        // (srcChainId, dstChainId, dbNonce, entryIndex) are merged into a single 32 bytes field\n        // Both options and message are dynamic fields, which are padded up to 32 bytes\n        return 226 + optionsLen.roundUpToWord() + messageLen.roundUpToWord();\n    }\n\n    function encodeTxHeader(\n        uint64 srcChainId,\n        uint64 dstChainId,\n        uint64 dbNonce,\n        uint64 entryIndex\n    )\n        internal\n        pure\n        returns (ICTxHeader)\n    {\n        return ICTxHeader.wrap(\n            (uint256(srcChainId) \u003c\u003c 192) | (uint256(dstChainId) \u003c\u003c 128) | (uint256(dbNonce) \u003c\u003c 64) | uint256(entryIndex)\n        );\n    }\n\n    function decodeTxHeader(ICTxHeader header)\n        internal\n        pure\n        returns (uint64 srcChainId, uint64 dstChainId, uint64 dbNonce, uint64 entryIndex)\n    {\n        srcChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 192);\n        dstChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 128);\n        dbNonce = uint64(ICTxHeader.unwrap(header) \u003e\u003e 64);\n        entryIndex = uint64(ICTxHeader.unwrap(header));\n    }\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint64 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__InvalidTransactionVersion(uint16 version);\n    error InterchainClientV1__NoLinkedClient(uint64 chainId);\n    error InterchainClientV1__NotEnoughGasSupplied();\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint64 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint64 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint64 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint64 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param messageLen           The length of the message being sent.\n    function getInterchainFee(\n        uint64 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        uint256 messageLen\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint64 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint64 chainId) external view returns (address);\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing a batch of entries from the remote Interchain DataBase,\n    /// verified by the Interchain Module.\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param batchRoot    The Merkle root of the batch\n    struct RemoteBatch {\n        uint256 verifiedAt;\n        bytes32 batchRoot;\n    }\n\n    error InterchainDB__BatchDoesNotExist(uint64 dbNonce);\n    error InterchainDB__BatchNotFinalized(uint64 dbNonce);\n    error InterchainDB__ConflictingBatches(address module, bytes32 existingBatchRoot, InterchainBatch newBatch);\n    error InterchainDB__EntryIndexOutOfRange(uint64 dbNonce, uint64 entryIndex, uint64 batchSize);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__InvalidBatchVersion(uint16 version);\n    error InterchainDB__InvalidEntryRange(uint64 dbNonce, uint64 start, uint64 end);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId(uint64 chainId);\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `requestBatchVerification` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntry(bytes32 dataHash) external returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Request the given Interchain Modules to verify an existing batch.\n    /// If the batch is not finalized, the module will verify it after finalization.\n    /// For the finalized batch the batch root is already available, and the module can verify it immediately.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any batch.\n    /// @dev Will revert if the batch with the given nonce does not exist.\n    /// @param dstChainId    The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the existing batch\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestBatchVerification(\n        uint64 dstChainId,\n        uint64 dbNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Then request the Interchain Modules to verify the batch containing the written entry on the destination chain.\n    /// See `writeEntry` and `requestBatchVerification` for more details.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntryWithVerification(\n        uint64 dstChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Allows the Interchain Module to verify the batch coming from the remote chain.\n    /// Note: The DB will only accept the batch of the same version as the DB itself.\n    /// @param versionedBatch   The versioned Interchain Batch to verify\n    function verifyRemoteBatch(bytes memory versionedBatch) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint64 dstChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce.\n    /// Note: the leafs are ordered by the index of the written entry in the current batch,\n    /// and the leafs value match the value of the written entry (srcWriter + dataHash hashed together).\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchLeafs(uint64 dbNonce) external view returns (bytes32[] memory);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce,\n    /// paginated by the given start and end indexes. The end index is exclusive.\n    /// Note: this is useful when the batch contains a large number of leafs, and calling `getBatchLeafs`\n    /// would result in a gas limit exceeded error.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the provided range is invalid.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param start        The start index of the paginated leafs, inclusive\n    /// @param end          The end index of the paginated leafs, exclusive\n    function getBatchLeafsPaginated(\n        uint64 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory);\n\n    /// @notice Returns the size of the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchSize(uint64 dbNonce) external view returns (uint64);\n\n    /// @notice Get the finalized Interchain Batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatch(uint64 dbNonce) external view returns (InterchainBatch memory);\n\n    /// @notice Get the Interchain Entry's value written on the local chain with the given batch nonce and entry index.\n    /// Entry value is calculated as the hash of the writer address and the written data hash.\n    /// Note: the batch does not have to be finalized to fetch the entry value.\n    /// @dev Will revert if the batch with the given nonce does not exist,\n    /// or the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the existing batch\n    /// @param entryIndex   The index of the written entry within the batch\n    function getEntryValue(uint64 dbNonce, uint64 entryIndex) external view returns (bytes32);\n\n    /// @notice Get the Merkle proof of inclusion for the entry with the given index\n    /// in the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param entryIndex   The index of the written entry within the batch\n    /// @return proof       The Merkle proof of inclusion for the entry\n    function getEntryProof(uint64 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof);\n\n    /// @notice Get the nonce of the database, which is incremented every time a new batch is finalized.\n    /// This is the nonce of the current non-finalized batch.\n    function getDBNonce() external view returns (uint64);\n\n    /// @notice Get the index of the next entry to be written to the database.\n    /// @return dbNonce      The database nonce of the batch including the next entry\n    /// @return entryIndex   The index of the next entry within that batch\n    function getNextEntryIndex() external view returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or ZERO if the module has not verified the entry.\n    function checkVerification(\n        address dstModule,\n        InterchainEntry memory entry,\n        bytes32[] memory proof\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n\n    /// @notice Get the version of the Interchain DataBase.\n    // solhint-disable-next-line func-name-mixedcase\n    function DB_VERSION() external pure returns (uint16);\n}\n\n// contracts/InterchainClientV1.sol\n\n/**\n * @title InterchainClientV1\n * @dev Implements the operations of the Interchain Execution Layer.\n */\ncontract InterchainClientV1 is Ownable, InterchainClientV1Events, IInterchainClientV1 {\n    using AppConfigLib for bytes;\n    using OptionsLib for bytes;\n    using VersionedPayloadLib for bytes;\n\n    /// @notice Version of the InterchainClient contract. Sent and received transactions must have the same version.\n    uint16 public constant CLIENT_VERSION = 1;\n\n    /// @notice Address of the InterchainDB contract, set at the time of deployment.\n    address public immutable INTERCHAIN_DB;\n\n    /// @notice Address of the contract that handles execution fees. Can be updated by the owner.\n    address public executionFees;\n\n    /// @dev Address of the InterchainClient contract on the remote chain\n    mapping(uint64 chainId =\u003e bytes32 remoteClient) internal _linkedClient;\n    /// @dev Executor address that completed the transaction. Address(0) if not executed yet.\n    mapping(bytes32 transactionId =\u003e address executor) internal _txExecutor;\n\n    constructor(address interchainDB, address owner_) Ownable(owner_) {\n        INTERCHAIN_DB = interchainDB;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function setExecutionFees(address executionFees_) external onlyOwner {\n        executionFees = executionFees_;\n        emit ExecutionFeesSet(executionFees_);\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function setLinkedClient(uint64 chainId, bytes32 client) external onlyOwner {\n        _linkedClient[chainId] = client;\n        emit LinkedClientSet(chainId, client);\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _interchainSend(dstChainId, receiver, srcExecutionService, srcModules, options, message);\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function interchainSendEVM(\n        uint64 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc)\n    {\n        bytes32 receiverBytes32 = TypeCasts.addressToBytes32(receiver);\n        return _interchainSend(dstChainId, receiverBytes32, srcExecutionService, srcModules, options, message);\n    }\n\n    // TODO: Handle the case where receiver does not implement the IInterchainApp interface (or does not exist at all)\n    // @inheritdoc IInterchainClientV1\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable\n    {\n        InterchainTransaction memory icTx = _assertCorrectVersion(transaction);\n        bytes32 transactionId = keccak256(transaction);\n        _assertExecutable(icTx, transactionId, proof);\n        _txExecutor[transactionId] = msg.sender;\n\n        OptionsV1 memory decodedOptions = icTx.options.decodeOptionsV1();\n        if (msg.value != decodedOptions.gasAirdrop) {\n            revert InterchainClientV1__IncorrectMsgValue(msg.value, decodedOptions.gasAirdrop);\n        }\n        // We should always use at least as much as the requested gas limit.\n        // The executor can specify a higher gas limit if they wanted.\n        if (decodedOptions.gasLimit \u003e gasLimit) gasLimit = decodedOptions.gasLimit;\n        // Check the the Executor has provided big enough gas limit for the whole transaction.\n        if (gasleft() \u003c= gasLimit) {\n            revert InterchainClientV1__NotEnoughGasSupplied();\n        }\n        // Pass the full msg.value to the app: we have already checked that it matches the requested gas airdrop.\n        IInterchainApp(TypeCasts.bytes32ToAddress(icTx.dstReceiver)).appReceive{gas: gasLimit, value: msg.value}({\n            srcChainId: icTx.srcChainId,\n            sender: icTx.srcSender,\n            dbNonce: icTx.dbNonce,\n            entryIndex: icTx.entryIndex,\n            message: icTx.message\n        });\n        emit InterchainTransactionReceived(\n            transactionId, icTx.dbNonce, icTx.entryIndex, icTx.srcChainId, icTx.srcSender, icTx.dstReceiver\n        );\n    }\n\n    /// @inheritdoc IInterchainClientV1\n    function writeExecutionProof(bytes32 transactionId) external returns (uint64 dbNonce, uint64 entryIndex) {\n        address executor = _txExecutor[transactionId];\n        if (executor == address(0)) {\n            revert InterchainClientV1__TxNotExecuted(transactionId);\n        }\n        bytes memory proof = abi.encode(transactionId, executor);\n        (dbNonce, entryIndex) = IInterchainDB(INTERCHAIN_DB).writeEntry(keccak256(proof));\n        emit ExecutionProofWritten(transactionId, dbNonce, entryIndex, executor);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // @inheritdoc IInterchainClientV1\n    function isExecutable(bytes calldata encodedTx, bytes32[] calldata proof) external view returns (bool) {\n        InterchainTransaction memory icTx = _assertCorrectVersion(encodedTx);\n        // Check that options could be decoded\n        icTx.options.decodeOptionsV1();\n        bytes32 transactionId = keccak256(encodedTx);\n        _assertExecutable(icTx, transactionId, proof);\n        return true;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function getExecutor(bytes calldata encodedTx) external view returns (address) {\n        return _txExecutor[keccak256(encodedTx)];\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function getExecutorById(bytes32 transactionId) external view returns (address) {\n        return _txExecutor[transactionId];\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function getInterchainFee(\n        uint64 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        uint256 messageLen\n    )\n        external\n        view\n        returns (uint256 fee)\n    {\n        _assertLinkedClient(dstChainId);\n        // Check that options could be decoded on destination chain\n        options.decodeOptionsV1();\n        // Verification fee from InterchainDB\n        fee = IInterchainDB(INTERCHAIN_DB).getInterchainFee(dstChainId, srcModules);\n        // Add execution fee, if ExecutionService is provided\n        if (srcExecutionService != address(0)) {\n            uint256 payloadSize = InterchainTransactionLib.payloadSize(options.length, messageLen);\n            fee += IExecutionService(srcExecutionService).getExecutionFee(dstChainId, payloadSize, options);\n        }\n    }\n\n    /// @inheritdoc IInterchainClientV1\n    function getLinkedClient(uint64 chainId) external view returns (bytes32) {\n        if (chainId == block.chainid) {\n            revert InterchainClientV1__NotRemoteChainId(chainId);\n        }\n        return _linkedClient[chainId];\n    }\n\n    /// @inheritdoc IInterchainClientV1\n    function getLinkedClientEVM(uint64 chainId) external view returns (address linkedClientEVM) {\n        if (chainId == block.chainid) {\n            revert InterchainClientV1__NotRemoteChainId(chainId);\n        }\n        bytes32 linkedClient = _linkedClient[chainId];\n        linkedClientEVM = TypeCasts.bytes32ToAddress(linkedClient);\n        // Check that the linked client address fits into the EVM address space\n        if (TypeCasts.addressToBytes32(linkedClientEVM) != linkedClient) {\n            revert InterchainClientV1__NotEVMClient(linkedClient);\n        }\n    }\n\n    /// @notice Decodes the encoded options data into a OptionsV1 struct.\n    function decodeOptions(bytes memory encodedOptions) external view returns (OptionsV1 memory) {\n        return encodedOptions.decodeOptionsV1();\n    }\n\n    /// @notice Encodes the transaction data into a bytes format.\n    function encodeTransaction(InterchainTransaction memory icTx) public pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload({\n            version: CLIENT_VERSION,\n            payload: InterchainTransactionLib.encodeTransaction(icTx)\n        });\n    }\n\n    // ═════════════════════════════════════════════════ INTERNAL ══════════════════════════════════════════════════════\n\n    /// @dev Internal logic for sending a message to another chain.\n    function _interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        _assertLinkedClient(dstChainId);\n        if (receiver == 0) revert InterchainClientV1__ZeroReceiver();\n        // Check that options could be decoded on destination chain\n        options.decodeOptionsV1();\n        uint256 verificationFee = IInterchainDB(INTERCHAIN_DB).getInterchainFee(dstChainId, srcModules);\n        if (msg.value \u003c verificationFee) {\n            revert InterchainClientV1__FeeAmountTooLow(msg.value, verificationFee);\n        }\n        (desc.dbNonce, desc.entryIndex) = IInterchainDB(INTERCHAIN_DB).getNextEntryIndex();\n        InterchainTransaction memory icTx = InterchainTransactionLib.constructLocalTransaction({\n            srcSender: msg.sender,\n            dstReceiver: receiver,\n            dstChainId: dstChainId,\n            dbNonce: desc.dbNonce,\n            entryIndex: desc.entryIndex,\n            options: options,\n            message: message\n        });\n        desc.transactionId = keccak256(encodeTransaction(icTx));\n        // Sanity check: nonce returned from DB should match the nonce used to construct the transaction\n        {\n            (uint64 dbNonce, uint64 entryIndex) = IInterchainDB(INTERCHAIN_DB).writeEntryWithVerification{\n                value: verificationFee\n            }(icTx.dstChainId, desc.transactionId, srcModules);\n            assert(dbNonce == desc.dbNonce \u0026\u0026 entryIndex == desc.entryIndex);\n        }\n        uint256 executionFee;\n        unchecked {\n            executionFee = msg.value - verificationFee;\n        }\n        if (executionFee \u003e 0) {\n            IExecutionFees(executionFees).addExecutionFee{value: executionFee}(icTx.dstChainId, desc.transactionId);\n        }\n        // TODO: consider disallowing the use of empty srcExecutionService\n        if (srcExecutionService != address(0)) {\n            IExecutionService(srcExecutionService).requestExecution({\n                dstChainId: dstChainId,\n                txPayloadSize: InterchainTransactionLib.payloadSize(options.length, message.length),\n                transactionId: desc.transactionId,\n                executionFee: executionFee,\n                options: options\n            });\n            address srcExecutorEOA = IExecutionService(srcExecutionService).executorEOA();\n            IExecutionFees(executionFees).recordExecutor(icTx.dstChainId, desc.transactionId, srcExecutorEOA);\n        }\n        emit InterchainTransactionSent(\n            desc.transactionId,\n            icTx.dbNonce,\n            icTx.entryIndex,\n            icTx.dstChainId,\n            icTx.srcSender,\n            icTx.dstReceiver,\n            verificationFee,\n            executionFee,\n            icTx.options,\n            icTx.message\n        );\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Asserts that the transaction is executable.\n    function _assertExecutable(\n        InterchainTransaction memory icTx,\n        bytes32 transactionId,\n        bytes32[] calldata proof\n    )\n        internal\n        view\n    {\n        bytes32 linkedClient = _assertLinkedClient(icTx.srcChainId);\n        if (icTx.dstChainId != block.chainid) {\n            revert InterchainClientV1__IncorrectDstChainId(icTx.dstChainId);\n        }\n        if (_txExecutor[transactionId] != address(0)) {\n            revert InterchainClientV1__TxAlreadyExecuted(transactionId);\n        }\n        // Construct expected entry based on icTransaction data\n        InterchainEntry memory icEntry = InterchainEntry({\n            srcChainId: icTx.srcChainId,\n            dbNonce: icTx.dbNonce,\n            entryIndex: icTx.entryIndex,\n            srcWriter: linkedClient,\n            dataHash: transactionId\n        });\n        (bytes memory encodedAppConfig, address[] memory approvedDstModules) =\n            IInterchainApp(TypeCasts.bytes32ToAddress(icTx.dstReceiver)).getReceivingConfig();\n        AppConfigV1 memory appConfig = encodedAppConfig.decodeAppConfigV1();\n        if (appConfig.requiredResponses == 0) {\n            revert InterchainClientV1__ZeroRequiredResponses();\n        }\n        uint256 responses = _getFinalizedResponsesCount(approvedDstModules, icEntry, proof, appConfig.optimisticPeriod);\n        if (responses \u003c appConfig.requiredResponses) {\n            revert InterchainClientV1__NotEnoughResponses(responses, appConfig.requiredResponses);\n        }\n    }\n\n    /// @dev Asserts that the chain is linked and returns the linked client address.\n    function _assertLinkedClient(uint64 chainId) internal view returns (bytes32 linkedClient) {\n        if (chainId == block.chainid) {\n            revert InterchainClientV1__NotRemoteChainId(chainId);\n        }\n        linkedClient = _linkedClient[chainId];\n        if (linkedClient == 0) {\n            revert InterchainClientV1__NoLinkedClient(chainId);\n        }\n    }\n\n    /**\n     * @dev Calculates the number of responses that are considered finalized within the optimistic time period.\n     * @param approvedModules       Approved modules that could have confirmed the entry.\n     * @param icEntry               The InterchainEntry to confirm.\n     * @param optimisticPeriod      The time period in seconds within which a response is considered valid.\n     * @return finalizedResponses   The count of responses that are finalized within the optimistic time period.\n     */\n    function _getFinalizedResponsesCount(\n        address[] memory approvedModules,\n        InterchainEntry memory icEntry,\n        bytes32[] calldata proof,\n        uint256 optimisticPeriod\n    )\n        internal\n        view\n        returns (uint256 finalizedResponses)\n    {\n        for (uint256 i = 0; i \u003c approvedModules.length; ++i) {\n            uint256 confirmedAt = IInterchainDB(INTERCHAIN_DB).checkVerification(approvedModules[i], icEntry, proof);\n            // checkVerification() returns 0 if entry hasn't been confirmed by the module, so we check for that as well\n            if (confirmedAt != 0 \u0026\u0026 confirmedAt + optimisticPeriod \u003c block.timestamp) {\n                ++finalizedResponses;\n            }\n        }\n    }\n\n    /// @dev Asserts that the transaction version is correct. Returns the decoded transaction for chaining purposes.\n    function _assertCorrectVersion(bytes calldata versionedTx)\n        internal\n        pure\n        returns (InterchainTransaction memory icTx)\n    {\n        uint16 version = versionedTx.getVersion();\n        if (version != CLIENT_VERSION) {\n            revert InterchainClientV1__InvalidTransactionVersion(version);\n        }\n        icTx = InterchainTransactionLib.decodeTransaction(versionedTx.getPayload());\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"OwnableInvalidOwner","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"OwnableUnauthorizedAccount","type":"error"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"details":"Contract module which provides a basic access control mechanism, where there is an account (an owner) that can be granted exclusive access to specific functions. The initial owner is set to the address provided by the deployer. This can later be changed with {transferOwnership}. This module is used through inheritance. It will make available the modifier `onlyOwner`, which can be applied to your functions to restrict their use to the owner.","errors":{"OwnableInvalidOwner(address)":[{"details":"The owner is not a valid owner account. (eg. `address(0)`)"}],"OwnableUnauthorizedAccount(address)":[{"details":"The caller account is not authorized to perform an operation."}]},"kind":"dev","methods":{"constructor":{"details":"Initializes the contract setting the address provided by the deployer as the initial owner."},"owner()":{"details":"Returns the address of the current owner."},"renounceOwnership()":{"details":"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."},"transferOwnership(address)":{"details":"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Contract module which provides a basic access control mechanism, where there is an account (an owner) that can be granted exclusive access to specific functions. The initial owner is set to the address provided by the deployer. This can later be changed with {transferOwnership}. This module is used through inheritance. It will make available the modifier `onlyOwner`, which can be applied to your functions to restrict their use to the owner.\",\"errors\":{\"OwnableInvalidOwner(address)\":[{\"details\":\"The owner is not a valid owner account. (eg. `address(0)`)\"}],\"OwnableUnauthorizedAccount(address)\":[{\"details\":\"The caller account is not authorized to perform an operation.\"}]},\"kind\":\"dev\",\"methods\":{\"constructor\":{\"details\":\"Initializes the contract setting the address provided by the deployer as the initial owner.\"},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner.\"},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainClientV1.sol\":\"Ownable\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainClientV1.sol\":{\"keccak256\":\"0xe270686a9bca05b4013610a4e8bb08040de32a0442edd218e1692edaca94e40e\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://727e84146369613e04e57a677f8bc6c709ee145df3eeb79f15ea5a922198d78f\",\"dweb:/ipfs/QmUXh2nDtHBnhYZSwCxcteN4be13S7dR9GbqqHT9mUxta3\"]}},\"version\":1}"},"hashes":{"owner()":"8da5cb5b","renounceOwnership()":"715018a6","transferOwnership(address)":"f2fde38b"}},"solidity/InterchainClientV1.sol:SafeCast":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220200db16b26b1c69acc1776bbf0efd7bf256cda2d011052a55132365fa954a5ee64736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220200db16b26b1c69acc1776bbf0efd7bf256cda2d011052a55132365fa954a5ee64736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainClientV1Events.sol\n\nabstract contract InterchainClientV1Events {\n    event ExecutionFeesSet(address executionFees);\n    event LinkedClientSet(uint64 chainId, bytes32 client);\n\n    // TODO: figure out indexing\n\n    event InterchainTransactionSent(\n        bytes32 indexed transactionId,\n        uint64 indexed dbNonce,\n        uint64 indexed entryIndex,\n        uint64 dstChainId,\n        bytes32 srcSender,\n        bytes32 dstReceiver,\n        uint256 verificationFee,\n        uint256 executionFee,\n        bytes options,\n        bytes message\n    );\n\n    event InterchainTransactionReceived(\n        bytes32 indexed transactionId,\n        uint64 indexed dbNonce,\n        uint64 indexed entryIndex,\n        uint64 srcChainId,\n        bytes32 srcSender,\n        bytes32 dstReceiver\n    );\n\n    event ExecutionProofWritten(\n        bytes32 indexed transactionId, uint64 indexed dbNonce, uint64 indexed entryIndex, address executor\n    );\n}\n\n// contracts/interfaces/IExecutionFees.sol\n\ninterface IExecutionFees {\n    error ExecutionFees__AlreadyRecorded(uint64 dstChainId, bytes32 transactionId, address executor);\n    error ExecutionFees__ZeroAddress();\n    error ExecutionFees__ZeroAmount();\n\n    /// @notice Add the execution fee for a transaction. The attached value will be added to the\n    /// rewards for the executor completing the transaction.\n    /// Note: this could be used to store the execution fee for a new transaction, or to add more\n    /// funds to the execution fee of an existing transaction. Therefore this function is payable,\n    /// and does not implement any caller restrictions.\n    /// @dev Will revert if the executor is already recorded for the transaction.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to add the execution fee to.\n    function addExecutionFee(uint64 dstChainId, bytes32 transactionId) external payable;\n\n    /// @notice Record the executor (who completed the transaction) for a transaction,\n    /// and update the accumulated rewards for the executor.\n    /// @dev Could only be called by the Recorder.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to record the executor for.\n    /// @param executor             The address of the executor who completed the transaction.\n    function recordExecutor(uint64 dstChainId, bytes32 transactionId, address executor) external;\n\n    /// @notice Allows the executor to claim their unclaimed rewards.\n    /// @dev Will revert if the executor has no unclaimed rewards.\n    function claimExecutionFees(address executor) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the accumulated rewards for an executor.\n    /// @param executor             The address of the executor to get the rewards for.\n    function accumulatedRewards(address executor) external view returns (uint256 accumulated);\n\n    /// @notice Get the unclaimed rewards for an executor.\n    /// @param executor             The address of the executor to get the rewards for.\n    function unclaimedRewards(address executor) external view returns (uint256 unclaimed);\n\n    /// @notice Get the total execution fee for a transaction.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to get the execution fee for.\n    function executionFee(uint64 dstChainId, bytes32 transactionId) external view returns (uint256 fee);\n\n    /// @notice Get the address of the recorded executor for a transaction.\n    /// @dev Will return address(0) if the executor is not recorded.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to get the recorded executor for.\n    function recordedExecutor(uint64 dstChainId, bytes32 transactionId) external view returns (address executor);\n}\n\n// contracts/interfaces/IExecutionService.sol\n\ninterface IExecutionService {\n    /// @notice Request the execution of an Interchain Transaction on a remote chain.\n    /// Note: the off-chain actor needs to fetch the transaction payload from the InterchainClient\n    /// event with the same transactionId, then execute the transaction on the remote chain:\n    /// `dstInterchainClient.executeTransaction(transactionPayload)`\n    /// Once the execution is confirmed on the source chain, the off-chain actor will be able\n    /// to claim `executionFee` in the ExecutionFees contract.\n    /// @dev Could only be called by `InterchainClient` contracts.\n    /// Will revert if the execution fee is not big enough.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param txPayloadSize        The size of the transaction payload to use for the execution.\n    /// @param transactionId        The id of the transaction to execute.\n    /// @param executionFee         The fee paid for the execution.\n    /// @param options              The options to use for the execution.\n    function requestExecution(\n        uint64 dstChainId,\n        uint256 txPayloadSize,\n        bytes32 transactionId,\n        uint256 executionFee,\n        bytes memory options\n    )\n        external;\n\n    /// @notice Get the address of the EOA account that will be used to execute transactions on the\n    /// remote chains.\n    function executorEOA() external view returns (address);\n\n    /// @notice Get the execution fee for executing an Interchain Transaction on a remote chain.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param txPayloadSize        The size of the transaction payload to use for the execution.\n    /// @param options              The options to use for the execution.\n    function getExecutionFee(\n        uint64 dstChainId,\n        uint256 txPayloadSize,\n        bytes memory options\n    )\n        external\n        view\n        returns (uint256);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    /// @notice Allows the Interchain Client to pass the message to the Interchain App.\n    /// @dev App is responsible for keeping track of interchain clients, and must verify the message sender.\n    /// @param srcChainId   Chain ID of the source chain, where the message was sent from.\n    /// @param sender       Sender address on the source chain, as a bytes32 value.\n    /// @param dbNonce      The Interchain DB nonce of the batch containing the message entry.\n    /// @param entryIndex   The index of the message entry within the batch.\n    /// @param message      The message being sent.\n    function appReceive(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /// @notice Returns the verification configuration of the Interchain App.\n    /// @dev This configuration is used by the Interchain Client to verify that message has been confirmed\n    /// by the Interchain Modules on the destination chain.\n    /// Note: V1 version of AppConfig includes the required responses count, and optimistic period after which\n    /// the message is considered confirmed by the module. Following versions may include additional fields.\n    /// @return appConfig    The versioned configuration of the Interchain App, encoded as bytes.\n    /// @return modules      The list of Interchain Modules that app is trusting to confirm the messages.\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/Math.sol\n\nlibrary MathLib {\n    /// @notice Rounds up to the nearest multiple of 32.\n    /// Note: Returns zero on overflows instead of reverting. This is fine for practical\n    /// use cases, as this is used for determining the size of the payload in memory.\n    function roundUpToWord(uint256 x) internal pure returns (uint256) {\n        unchecked {\n            return (x + 31) \u0026 ~uint256(31);\n        }\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/VersionedPayload.sol\n\n// solhint-disable no-inline-assembly\n// solhint-disable ordering\nlibrary VersionedPayloadLib {\n    /// @notice Amount of bytes reserved for the version (uint16) in the versioned payload\n    uint256 internal constant VERSION_LENGTH = 2;\n\n    error VersionedPayload__TooShort(bytes versionedPayload);\n    error VersionedPayload__PrecompileFailed();\n\n    /// @notice Encodes the versioned payload into a single bytes array.\n    /// @param version  The payload's version.\n    /// @param payload  The payload to encode.\n    function encodeVersionedPayload(uint16 version, bytes memory payload) internal pure returns (bytes memory) {\n        return abi.encodePacked(version, payload);\n    }\n\n    /// @notice Extracts the version from the versioned payload (calldata reference).\n    /// @param versionedPayload     The versioned payload (calldata reference).\n    function getVersion(bytes calldata versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            version := shr(240, calldataload(versionedPayload.offset))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (calldata reference).\n    /// @dev The extracted payload is also returned as a calldata reference.\n    /// @param versionedPayload     The versioned payload.\n    function getPayload(bytes calldata versionedPayload) internal pure returns (bytes calldata) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        return versionedPayload[VERSION_LENGTH:];\n    }\n\n    /// @notice Extracts the version from the versioned payload (memory reference).\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getVersionFromMemory(bytes memory versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            // We add 0x20 to skip the length of the bytes array.\n            version := shr(240, mload(add(versionedPayload, 0x20)))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (memory reference).\n    /// @dev The extracted payload is copied into a new memory location. Use `getPayload` when possible\n    /// to avoid extra memory allocation.\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getPayloadFromMemory(bytes memory versionedPayload) internal view returns (bytes memory payload) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        // Figure how many bytes to copy and allocate the memory for the extracted payload.\n        uint256 toCopy;\n        unchecked {\n            toCopy = versionedPayload.length - VERSION_LENGTH;\n        }\n        payload = new bytes(toCopy);\n        // Use identity precompile (0x04) to copy the payload. Unlike MCOPY, this is available on all EVM chains.\n        bool res;\n        assembly {\n            // We add 0x20 to skip the length of the bytes array.\n            // We add 0x02 to skip the 2 bytes reserved for the version.\n            // Copy the payload to the previously allocated memory.\n            res := staticcall(gas(), 0x04, add(versionedPayload, 0x22), toCopy, add(payload, 0x20), toCopy)\n        }\n        if (!res) {\n            revert VersionedPayload__PrecompileFailed();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SafeCast.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value \u003e type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value \u003e type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value \u003e type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value \u003e type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value \u003e type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value \u003e type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value \u003e type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value \u003e type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value \u003e type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value \u003e type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value \u003e type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value \u003e type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value \u003e type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value \u003e type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value \u003e type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value \u003e type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value \u003e type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value \u003e type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value \u003e type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value \u003e type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value \u003e type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value \u003e type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value \u003e type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value \u003e type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value \u003e type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value \u003e type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value \u003e type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value \u003e type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value \u003e type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value \u003e type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value \u003e type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value \u003c 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value \u003e uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal view returns (AppConfigV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (AppConfigV1));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal view returns (OptionsV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (OptionsV1));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(OPTIONS_V1, abi.encode(options));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/libs/InterchainBatch.sol\n\ntype BatchKey is uint128;\n\n/// @notice Struct representing a batch of entries in the Interchain DataBase.\n/// Batched entries are put together in a Merkle tree, which root is saved.\n/// Batch has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: batchRoot\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch\n/// @param batchRoot    The root of the Merkle tree containing the batched entries\nstruct InterchainBatch {\n    uint64 srcChainId;\n    uint64 dbNonce;\n    bytes32 batchRoot;\n}\n\nlibrary InterchainBatchLib {\n    using VersionedPayloadLib for bytes;\n\n    /// @notice Constructs an InterchainBatch struct to be saved on the local chain.\n    /// @param dbNonce      The database nonce of the batch\n    /// @param batchRoot    The root of the Merkle tree containing the batched entries\n    /// @return batch       The constructed InterchainBatch struct\n    function constructLocalBatch(\n        uint64 dbNonce,\n        bytes32 batchRoot\n    )\n        internal\n        view\n        returns (InterchainBatch memory batch)\n    {\n        return InterchainBatch({srcChainId: SafeCast.toUint64(block.chainid), dbNonce: dbNonce, batchRoot: batchRoot});\n    }\n\n    /// @notice Encodes the InterchainBatch struct into a non-versioned batch payload.\n    function encodeBatch(InterchainBatch memory batch) internal pure returns (bytes memory) {\n        return abi.encode(encodeBatchKey(batch.srcChainId, batch.dbNonce), batch.batchRoot);\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in calldata.\n    function decodeBatch(bytes calldata data) internal pure returns (InterchainBatch memory batch) {\n        BatchKey key;\n        (key, batch.batchRoot) = abi.decode(data, (BatchKey, bytes32));\n        (batch.srcChainId, batch.dbNonce) = decodeBatchKey(key);\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in memory.\n    function decodeBatchFromMemory(bytes memory data) internal pure returns (InterchainBatch memory batch) {\n        BatchKey key;\n        (key, batch.batchRoot) = abi.decode(data, (BatchKey, bytes32));\n        (batch.srcChainId, batch.dbNonce) = decodeBatchKey(key);\n    }\n\n    /// @notice Encodes the uint128 key of the batch from uint64 srcChainId and uint64 dbNonce.\n    function encodeBatchKey(uint64 srcChainId, uint64 dbNonce) internal pure returns (BatchKey) {\n        return BatchKey.wrap((uint128(srcChainId) \u003c\u003c 64) | dbNonce);\n    }\n\n    /// @notice Decodes the uint128 key of the batch into uint64 srcChainId and uint64 dbNonce.\n    function decodeBatchKey(BatchKey key) internal pure returns (uint64 srcChainId, uint64 dbNonce) {\n        srcChainId = uint64(BatchKey.unwrap(key) \u003e\u003e 64);\n        dbNonce = uint64(BatchKey.unwrap(key));\n    }\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce + entryIndex\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch containing the entry\n/// @param entryIndex   The index of the entry in the batch\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint64 srcChainId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nusing InterchainEntryLib for InterchainEntry global;\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint64 dbNonce,\n        uint64 entryIndex,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: SafeCast.toUint64(block.chainid),\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n}\n\n// contracts/libs/InterchainTransaction.sol\n\ntype ICTxHeader is uint256;\n\nstruct InterchainTransaction {\n    uint64 srcChainId;\n    uint64 dstChainId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcSender;\n    bytes32 dstReceiver;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    using MathLib for uint256;\n    using VersionedPayloadLib for bytes;\n\n    function constructLocalTransaction(\n        address srcSender,\n        uint64 dstChainId,\n        bytes32 dstReceiver,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: SafeCast.toUint64(block.chainid),\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            encodeTxHeader(transaction.srcChainId, transaction.dstChainId, transaction.dbNonce, transaction.entryIndex),\n            transaction.srcSender,\n            transaction.dstReceiver,\n            transaction.options,\n            transaction.message\n        );\n    }\n\n    function decodeTransaction(bytes calldata transaction) internal pure returns (InterchainTransaction memory icTx) {\n        ICTxHeader header;\n        (header, icTx.srcSender, icTx.dstReceiver, icTx.options, icTx.message) =\n            abi.decode(transaction, (ICTxHeader, bytes32, bytes32, bytes, bytes));\n        (icTx.srcChainId, icTx.dstChainId, icTx.dbNonce, icTx.entryIndex) = decodeTxHeader(header);\n    }\n\n    function payloadSize(uint256 optionsLen, uint256 messageLen) internal pure returns (uint256) {\n        // 2 bytes are reserved for the transaction version\n        // + 5 fields * 32 bytes (3 values for static, 2 offsets for dynamic) + 2 * 32 bytes (lengths for dynamic) = 226\n        // (srcChainId, dstChainId, dbNonce, entryIndex) are merged into a single 32 bytes field\n        // Both options and message are dynamic fields, which are padded up to 32 bytes\n        return 226 + optionsLen.roundUpToWord() + messageLen.roundUpToWord();\n    }\n\n    function encodeTxHeader(\n        uint64 srcChainId,\n        uint64 dstChainId,\n        uint64 dbNonce,\n        uint64 entryIndex\n    )\n        internal\n        pure\n        returns (ICTxHeader)\n    {\n        return ICTxHeader.wrap(\n            (uint256(srcChainId) \u003c\u003c 192) | (uint256(dstChainId) \u003c\u003c 128) | (uint256(dbNonce) \u003c\u003c 64) | uint256(entryIndex)\n        );\n    }\n\n    function decodeTxHeader(ICTxHeader header)\n        internal\n        pure\n        returns (uint64 srcChainId, uint64 dstChainId, uint64 dbNonce, uint64 entryIndex)\n    {\n        srcChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 192);\n        dstChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 128);\n        dbNonce = uint64(ICTxHeader.unwrap(header) \u003e\u003e 64);\n        entryIndex = uint64(ICTxHeader.unwrap(header));\n    }\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint64 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__InvalidTransactionVersion(uint16 version);\n    error InterchainClientV1__NoLinkedClient(uint64 chainId);\n    error InterchainClientV1__NotEnoughGasSupplied();\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint64 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint64 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint64 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint64 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param messageLen           The length of the message being sent.\n    function getInterchainFee(\n        uint64 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        uint256 messageLen\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint64 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint64 chainId) external view returns (address);\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing a batch of entries from the remote Interchain DataBase,\n    /// verified by the Interchain Module.\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param batchRoot    The Merkle root of the batch\n    struct RemoteBatch {\n        uint256 verifiedAt;\n        bytes32 batchRoot;\n    }\n\n    error InterchainDB__BatchDoesNotExist(uint64 dbNonce);\n    error InterchainDB__BatchNotFinalized(uint64 dbNonce);\n    error InterchainDB__ConflictingBatches(address module, bytes32 existingBatchRoot, InterchainBatch newBatch);\n    error InterchainDB__EntryIndexOutOfRange(uint64 dbNonce, uint64 entryIndex, uint64 batchSize);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__InvalidBatchVersion(uint16 version);\n    error InterchainDB__InvalidEntryRange(uint64 dbNonce, uint64 start, uint64 end);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId(uint64 chainId);\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `requestBatchVerification` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntry(bytes32 dataHash) external returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Request the given Interchain Modules to verify an existing batch.\n    /// If the batch is not finalized, the module will verify it after finalization.\n    /// For the finalized batch the batch root is already available, and the module can verify it immediately.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any batch.\n    /// @dev Will revert if the batch with the given nonce does not exist.\n    /// @param dstChainId    The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the existing batch\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestBatchVerification(\n        uint64 dstChainId,\n        uint64 dbNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Then request the Interchain Modules to verify the batch containing the written entry on the destination chain.\n    /// See `writeEntry` and `requestBatchVerification` for more details.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntryWithVerification(\n        uint64 dstChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Allows the Interchain Module to verify the batch coming from the remote chain.\n    /// Note: The DB will only accept the batch of the same version as the DB itself.\n    /// @param versionedBatch   The versioned Interchain Batch to verify\n    function verifyRemoteBatch(bytes memory versionedBatch) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint64 dstChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce.\n    /// Note: the leafs are ordered by the index of the written entry in the current batch,\n    /// and the leafs value match the value of the written entry (srcWriter + dataHash hashed together).\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchLeafs(uint64 dbNonce) external view returns (bytes32[] memory);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce,\n    /// paginated by the given start and end indexes. The end index is exclusive.\n    /// Note: this is useful when the batch contains a large number of leafs, and calling `getBatchLeafs`\n    /// would result in a gas limit exceeded error.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the provided range is invalid.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param start        The start index of the paginated leafs, inclusive\n    /// @param end          The end index of the paginated leafs, exclusive\n    function getBatchLeafsPaginated(\n        uint64 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory);\n\n    /// @notice Returns the size of the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchSize(uint64 dbNonce) external view returns (uint64);\n\n    /// @notice Get the finalized Interchain Batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatch(uint64 dbNonce) external view returns (InterchainBatch memory);\n\n    /// @notice Get the Interchain Entry's value written on the local chain with the given batch nonce and entry index.\n    /// Entry value is calculated as the hash of the writer address and the written data hash.\n    /// Note: the batch does not have to be finalized to fetch the entry value.\n    /// @dev Will revert if the batch with the given nonce does not exist,\n    /// or the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the existing batch\n    /// @param entryIndex   The index of the written entry within the batch\n    function getEntryValue(uint64 dbNonce, uint64 entryIndex) external view returns (bytes32);\n\n    /// @notice Get the Merkle proof of inclusion for the entry with the given index\n    /// in the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param entryIndex   The index of the written entry within the batch\n    /// @return proof       The Merkle proof of inclusion for the entry\n    function getEntryProof(uint64 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof);\n\n    /// @notice Get the nonce of the database, which is incremented every time a new batch is finalized.\n    /// This is the nonce of the current non-finalized batch.\n    function getDBNonce() external view returns (uint64);\n\n    /// @notice Get the index of the next entry to be written to the database.\n    /// @return dbNonce      The database nonce of the batch including the next entry\n    /// @return entryIndex   The index of the next entry within that batch\n    function getNextEntryIndex() external view returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or ZERO if the module has not verified the entry.\n    function checkVerification(\n        address dstModule,\n        InterchainEntry memory entry,\n        bytes32[] memory proof\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n\n    /// @notice Get the version of the Interchain DataBase.\n    // solhint-disable-next-line func-name-mixedcase\n    function DB_VERSION() external pure returns (uint16);\n}\n\n// contracts/InterchainClientV1.sol\n\n/**\n * @title InterchainClientV1\n * @dev Implements the operations of the Interchain Execution Layer.\n */\ncontract InterchainClientV1 is Ownable, InterchainClientV1Events, IInterchainClientV1 {\n    using AppConfigLib for bytes;\n    using OptionsLib for bytes;\n    using VersionedPayloadLib for bytes;\n\n    /// @notice Version of the InterchainClient contract. Sent and received transactions must have the same version.\n    uint16 public constant CLIENT_VERSION = 1;\n\n    /// @notice Address of the InterchainDB contract, set at the time of deployment.\n    address public immutable INTERCHAIN_DB;\n\n    /// @notice Address of the contract that handles execution fees. Can be updated by the owner.\n    address public executionFees;\n\n    /// @dev Address of the InterchainClient contract on the remote chain\n    mapping(uint64 chainId =\u003e bytes32 remoteClient) internal _linkedClient;\n    /// @dev Executor address that completed the transaction. Address(0) if not executed yet.\n    mapping(bytes32 transactionId =\u003e address executor) internal _txExecutor;\n\n    constructor(address interchainDB, address owner_) Ownable(owner_) {\n        INTERCHAIN_DB = interchainDB;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function setExecutionFees(address executionFees_) external onlyOwner {\n        executionFees = executionFees_;\n        emit ExecutionFeesSet(executionFees_);\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function setLinkedClient(uint64 chainId, bytes32 client) external onlyOwner {\n        _linkedClient[chainId] = client;\n        emit LinkedClientSet(chainId, client);\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _interchainSend(dstChainId, receiver, srcExecutionService, srcModules, options, message);\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function interchainSendEVM(\n        uint64 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc)\n    {\n        bytes32 receiverBytes32 = TypeCasts.addressToBytes32(receiver);\n        return _interchainSend(dstChainId, receiverBytes32, srcExecutionService, srcModules, options, message);\n    }\n\n    // TODO: Handle the case where receiver does not implement the IInterchainApp interface (or does not exist at all)\n    // @inheritdoc IInterchainClientV1\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable\n    {\n        InterchainTransaction memory icTx = _assertCorrectVersion(transaction);\n        bytes32 transactionId = keccak256(transaction);\n        _assertExecutable(icTx, transactionId, proof);\n        _txExecutor[transactionId] = msg.sender;\n\n        OptionsV1 memory decodedOptions = icTx.options.decodeOptionsV1();\n        if (msg.value != decodedOptions.gasAirdrop) {\n            revert InterchainClientV1__IncorrectMsgValue(msg.value, decodedOptions.gasAirdrop);\n        }\n        // We should always use at least as much as the requested gas limit.\n        // The executor can specify a higher gas limit if they wanted.\n        if (decodedOptions.gasLimit \u003e gasLimit) gasLimit = decodedOptions.gasLimit;\n        // Check the the Executor has provided big enough gas limit for the whole transaction.\n        if (gasleft() \u003c= gasLimit) {\n            revert InterchainClientV1__NotEnoughGasSupplied();\n        }\n        // Pass the full msg.value to the app: we have already checked that it matches the requested gas airdrop.\n        IInterchainApp(TypeCasts.bytes32ToAddress(icTx.dstReceiver)).appReceive{gas: gasLimit, value: msg.value}({\n            srcChainId: icTx.srcChainId,\n            sender: icTx.srcSender,\n            dbNonce: icTx.dbNonce,\n            entryIndex: icTx.entryIndex,\n            message: icTx.message\n        });\n        emit InterchainTransactionReceived(\n            transactionId, icTx.dbNonce, icTx.entryIndex, icTx.srcChainId, icTx.srcSender, icTx.dstReceiver\n        );\n    }\n\n    /// @inheritdoc IInterchainClientV1\n    function writeExecutionProof(bytes32 transactionId) external returns (uint64 dbNonce, uint64 entryIndex) {\n        address executor = _txExecutor[transactionId];\n        if (executor == address(0)) {\n            revert InterchainClientV1__TxNotExecuted(transactionId);\n        }\n        bytes memory proof = abi.encode(transactionId, executor);\n        (dbNonce, entryIndex) = IInterchainDB(INTERCHAIN_DB).writeEntry(keccak256(proof));\n        emit ExecutionProofWritten(transactionId, dbNonce, entryIndex, executor);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // @inheritdoc IInterchainClientV1\n    function isExecutable(bytes calldata encodedTx, bytes32[] calldata proof) external view returns (bool) {\n        InterchainTransaction memory icTx = _assertCorrectVersion(encodedTx);\n        // Check that options could be decoded\n        icTx.options.decodeOptionsV1();\n        bytes32 transactionId = keccak256(encodedTx);\n        _assertExecutable(icTx, transactionId, proof);\n        return true;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function getExecutor(bytes calldata encodedTx) external view returns (address) {\n        return _txExecutor[keccak256(encodedTx)];\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function getExecutorById(bytes32 transactionId) external view returns (address) {\n        return _txExecutor[transactionId];\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function getInterchainFee(\n        uint64 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        uint256 messageLen\n    )\n        external\n        view\n        returns (uint256 fee)\n    {\n        _assertLinkedClient(dstChainId);\n        // Check that options could be decoded on destination chain\n        options.decodeOptionsV1();\n        // Verification fee from InterchainDB\n        fee = IInterchainDB(INTERCHAIN_DB).getInterchainFee(dstChainId, srcModules);\n        // Add execution fee, if ExecutionService is provided\n        if (srcExecutionService != address(0)) {\n            uint256 payloadSize = InterchainTransactionLib.payloadSize(options.length, messageLen);\n            fee += IExecutionService(srcExecutionService).getExecutionFee(dstChainId, payloadSize, options);\n        }\n    }\n\n    /// @inheritdoc IInterchainClientV1\n    function getLinkedClient(uint64 chainId) external view returns (bytes32) {\n        if (chainId == block.chainid) {\n            revert InterchainClientV1__NotRemoteChainId(chainId);\n        }\n        return _linkedClient[chainId];\n    }\n\n    /// @inheritdoc IInterchainClientV1\n    function getLinkedClientEVM(uint64 chainId) external view returns (address linkedClientEVM) {\n        if (chainId == block.chainid) {\n            revert InterchainClientV1__NotRemoteChainId(chainId);\n        }\n        bytes32 linkedClient = _linkedClient[chainId];\n        linkedClientEVM = TypeCasts.bytes32ToAddress(linkedClient);\n        // Check that the linked client address fits into the EVM address space\n        if (TypeCasts.addressToBytes32(linkedClientEVM) != linkedClient) {\n            revert InterchainClientV1__NotEVMClient(linkedClient);\n        }\n    }\n\n    /// @notice Decodes the encoded options data into a OptionsV1 struct.\n    function decodeOptions(bytes memory encodedOptions) external view returns (OptionsV1 memory) {\n        return encodedOptions.decodeOptionsV1();\n    }\n\n    /// @notice Encodes the transaction data into a bytes format.\n    function encodeTransaction(InterchainTransaction memory icTx) public pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload({\n            version: CLIENT_VERSION,\n            payload: InterchainTransactionLib.encodeTransaction(icTx)\n        });\n    }\n\n    // ═════════════════════════════════════════════════ INTERNAL ══════════════════════════════════════════════════════\n\n    /// @dev Internal logic for sending a message to another chain.\n    function _interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        _assertLinkedClient(dstChainId);\n        if (receiver == 0) revert InterchainClientV1__ZeroReceiver();\n        // Check that options could be decoded on destination chain\n        options.decodeOptionsV1();\n        uint256 verificationFee = IInterchainDB(INTERCHAIN_DB).getInterchainFee(dstChainId, srcModules);\n        if (msg.value \u003c verificationFee) {\n            revert InterchainClientV1__FeeAmountTooLow(msg.value, verificationFee);\n        }\n        (desc.dbNonce, desc.entryIndex) = IInterchainDB(INTERCHAIN_DB).getNextEntryIndex();\n        InterchainTransaction memory icTx = InterchainTransactionLib.constructLocalTransaction({\n            srcSender: msg.sender,\n            dstReceiver: receiver,\n            dstChainId: dstChainId,\n            dbNonce: desc.dbNonce,\n            entryIndex: desc.entryIndex,\n            options: options,\n            message: message\n        });\n        desc.transactionId = keccak256(encodeTransaction(icTx));\n        // Sanity check: nonce returned from DB should match the nonce used to construct the transaction\n        {\n            (uint64 dbNonce, uint64 entryIndex) = IInterchainDB(INTERCHAIN_DB).writeEntryWithVerification{\n                value: verificationFee\n            }(icTx.dstChainId, desc.transactionId, srcModules);\n            assert(dbNonce == desc.dbNonce \u0026\u0026 entryIndex == desc.entryIndex);\n        }\n        uint256 executionFee;\n        unchecked {\n            executionFee = msg.value - verificationFee;\n        }\n        if (executionFee \u003e 0) {\n            IExecutionFees(executionFees).addExecutionFee{value: executionFee}(icTx.dstChainId, desc.transactionId);\n        }\n        // TODO: consider disallowing the use of empty srcExecutionService\n        if (srcExecutionService != address(0)) {\n            IExecutionService(srcExecutionService).requestExecution({\n                dstChainId: dstChainId,\n                txPayloadSize: InterchainTransactionLib.payloadSize(options.length, message.length),\n                transactionId: desc.transactionId,\n                executionFee: executionFee,\n                options: options\n            });\n            address srcExecutorEOA = IExecutionService(srcExecutionService).executorEOA();\n            IExecutionFees(executionFees).recordExecutor(icTx.dstChainId, desc.transactionId, srcExecutorEOA);\n        }\n        emit InterchainTransactionSent(\n            desc.transactionId,\n            icTx.dbNonce,\n            icTx.entryIndex,\n            icTx.dstChainId,\n            icTx.srcSender,\n            icTx.dstReceiver,\n            verificationFee,\n            executionFee,\n            icTx.options,\n            icTx.message\n        );\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Asserts that the transaction is executable.\n    function _assertExecutable(\n        InterchainTransaction memory icTx,\n        bytes32 transactionId,\n        bytes32[] calldata proof\n    )\n        internal\n        view\n    {\n        bytes32 linkedClient = _assertLinkedClient(icTx.srcChainId);\n        if (icTx.dstChainId != block.chainid) {\n            revert InterchainClientV1__IncorrectDstChainId(icTx.dstChainId);\n        }\n        if (_txExecutor[transactionId] != address(0)) {\n            revert InterchainClientV1__TxAlreadyExecuted(transactionId);\n        }\n        // Construct expected entry based on icTransaction data\n        InterchainEntry memory icEntry = InterchainEntry({\n            srcChainId: icTx.srcChainId,\n            dbNonce: icTx.dbNonce,\n            entryIndex: icTx.entryIndex,\n            srcWriter: linkedClient,\n            dataHash: transactionId\n        });\n        (bytes memory encodedAppConfig, address[] memory approvedDstModules) =\n            IInterchainApp(TypeCasts.bytes32ToAddress(icTx.dstReceiver)).getReceivingConfig();\n        AppConfigV1 memory appConfig = encodedAppConfig.decodeAppConfigV1();\n        if (appConfig.requiredResponses == 0) {\n            revert InterchainClientV1__ZeroRequiredResponses();\n        }\n        uint256 responses = _getFinalizedResponsesCount(approvedDstModules, icEntry, proof, appConfig.optimisticPeriod);\n        if (responses \u003c appConfig.requiredResponses) {\n            revert InterchainClientV1__NotEnoughResponses(responses, appConfig.requiredResponses);\n        }\n    }\n\n    /// @dev Asserts that the chain is linked and returns the linked client address.\n    function _assertLinkedClient(uint64 chainId) internal view returns (bytes32 linkedClient) {\n        if (chainId == block.chainid) {\n            revert InterchainClientV1__NotRemoteChainId(chainId);\n        }\n        linkedClient = _linkedClient[chainId];\n        if (linkedClient == 0) {\n            revert InterchainClientV1__NoLinkedClient(chainId);\n        }\n    }\n\n    /**\n     * @dev Calculates the number of responses that are considered finalized within the optimistic time period.\n     * @param approvedModules       Approved modules that could have confirmed the entry.\n     * @param icEntry               The InterchainEntry to confirm.\n     * @param optimisticPeriod      The time period in seconds within which a response is considered valid.\n     * @return finalizedResponses   The count of responses that are finalized within the optimistic time period.\n     */\n    function _getFinalizedResponsesCount(\n        address[] memory approvedModules,\n        InterchainEntry memory icEntry,\n        bytes32[] calldata proof,\n        uint256 optimisticPeriod\n    )\n        internal\n        view\n        returns (uint256 finalizedResponses)\n    {\n        for (uint256 i = 0; i \u003c approvedModules.length; ++i) {\n            uint256 confirmedAt = IInterchainDB(INTERCHAIN_DB).checkVerification(approvedModules[i], icEntry, proof);\n            // checkVerification() returns 0 if entry hasn't been confirmed by the module, so we check for that as well\n            if (confirmedAt != 0 \u0026\u0026 confirmedAt + optimisticPeriod \u003c block.timestamp) {\n                ++finalizedResponses;\n            }\n        }\n    }\n\n    /// @dev Asserts that the transaction version is correct. Returns the decoded transaction for chaining purposes.\n    function _assertCorrectVersion(bytes calldata versionedTx)\n        internal\n        pure\n        returns (InterchainTransaction memory icTx)\n    {\n        uint16 version = versionedTx.getVersion();\n        if (version != CLIENT_VERSION) {\n            revert InterchainClientV1__InvalidTransactionVersion(version);\n        }\n        icTx = InterchainTransactionLib.decodeTransaction(versionedTx.getPayload());\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"14491:33927:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;14491:33927:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"14491:33927:0:-:0;;;;;;;;","abiDefinition":[{"inputs":[{"internalType":"uint8","name":"bits","type":"uint8"},{"internalType":"int256","name":"value","type":"int256"}],"name":"SafeCastOverflowedIntDowncast","type":"error"},{"inputs":[{"internalType":"int256","name":"value","type":"int256"}],"name":"SafeCastOverflowedIntToUint","type":"error"},{"inputs":[{"internalType":"uint8","name":"bits","type":"uint8"},{"internalType":"uint256","name":"value","type":"uint256"}],"name":"SafeCastOverflowedUintDowncast","type":"error"},{"inputs":[{"internalType":"uint256","name":"value","type":"uint256"}],"name":"SafeCastOverflowedUintToInt","type":"error"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"details":"Wrappers over Solidity's uintXX/intXX casting operators with added overflow checks. Downcasting from uint256/int256 in Solidity does not revert on overflow. This can easily result in undesired exploitation or bugs, since developers usually assume that overflows raise errors. `SafeCast` restores this intuition by reverting the transaction when such an operation overflows. Using this library instead of the unchecked operations eliminates an entire class of bugs, so it's recommended to use it always.","errors":{"SafeCastOverflowedIntDowncast(uint8,int256)":[{"details":"Value doesn't fit in an int of `bits` size."}],"SafeCastOverflowedIntToUint(int256)":[{"details":"An int value doesn't fit in an uint of `bits` size."}],"SafeCastOverflowedUintDowncast(uint8,uint256)":[{"details":"Value doesn't fit in an uint of `bits` size."}],"SafeCastOverflowedUintToInt(uint256)":[{"details":"An uint value doesn't fit in an int of `bits` size."}]},"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"bits\",\"type\":\"uint8\"},{\"internalType\":\"int256\",\"name\":\"value\",\"type\":\"int256\"}],\"name\":\"SafeCastOverflowedIntDowncast\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"value\",\"type\":\"int256\"}],\"name\":\"SafeCastOverflowedIntToUint\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"bits\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"SafeCastOverflowedUintDowncast\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"SafeCastOverflowedUintToInt\",\"type\":\"error\"}],\"devdoc\":{\"details\":\"Wrappers over Solidity's uintXX/intXX casting operators with added overflow checks. Downcasting from uint256/int256 in Solidity does not revert on overflow. This can easily result in undesired exploitation or bugs, since developers usually assume that overflows raise errors. `SafeCast` restores this intuition by reverting the transaction when such an operation overflows. Using this library instead of the unchecked operations eliminates an entire class of bugs, so it's recommended to use it always.\",\"errors\":{\"SafeCastOverflowedIntDowncast(uint8,int256)\":[{\"details\":\"Value doesn't fit in an int of `bits` size.\"}],\"SafeCastOverflowedIntToUint(int256)\":[{\"details\":\"An int value doesn't fit in an uint of `bits` size.\"}],\"SafeCastOverflowedUintDowncast(uint8,uint256)\":[{\"details\":\"Value doesn't fit in an uint of `bits` size.\"}],\"SafeCastOverflowedUintToInt(uint256)\":[{\"details\":\"An uint value doesn't fit in an int of `bits` size.\"}]},\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainClientV1.sol\":\"SafeCast\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainClientV1.sol\":{\"keccak256\":\"0xe270686a9bca05b4013610a4e8bb08040de32a0442edd218e1692edaca94e40e\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://727e84146369613e04e57a677f8bc6c709ee145df3eeb79f15ea5a922198d78f\",\"dweb:/ipfs/QmUXh2nDtHBnhYZSwCxcteN4be13S7dR9GbqqHT9mUxta3\"]}},\"version\":1}"},"hashes":{}},"solidity/InterchainClientV1.sol:TypeCasts":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220ce85fe1f62af9d3d8c6675891d7c7e75b37fe292c526bc66a91b03281ecb010764736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220ce85fe1f62af9d3d8c6675891d7c7e75b37fe292c526bc66a91b03281ecb010764736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainClientV1Events.sol\n\nabstract contract InterchainClientV1Events {\n    event ExecutionFeesSet(address executionFees);\n    event LinkedClientSet(uint64 chainId, bytes32 client);\n\n    // TODO: figure out indexing\n\n    event InterchainTransactionSent(\n        bytes32 indexed transactionId,\n        uint64 indexed dbNonce,\n        uint64 indexed entryIndex,\n        uint64 dstChainId,\n        bytes32 srcSender,\n        bytes32 dstReceiver,\n        uint256 verificationFee,\n        uint256 executionFee,\n        bytes options,\n        bytes message\n    );\n\n    event InterchainTransactionReceived(\n        bytes32 indexed transactionId,\n        uint64 indexed dbNonce,\n        uint64 indexed entryIndex,\n        uint64 srcChainId,\n        bytes32 srcSender,\n        bytes32 dstReceiver\n    );\n\n    event ExecutionProofWritten(\n        bytes32 indexed transactionId, uint64 indexed dbNonce, uint64 indexed entryIndex, address executor\n    );\n}\n\n// contracts/interfaces/IExecutionFees.sol\n\ninterface IExecutionFees {\n    error ExecutionFees__AlreadyRecorded(uint64 dstChainId, bytes32 transactionId, address executor);\n    error ExecutionFees__ZeroAddress();\n    error ExecutionFees__ZeroAmount();\n\n    /// @notice Add the execution fee for a transaction. The attached value will be added to the\n    /// rewards for the executor completing the transaction.\n    /// Note: this could be used to store the execution fee for a new transaction, or to add more\n    /// funds to the execution fee of an existing transaction. Therefore this function is payable,\n    /// and does not implement any caller restrictions.\n    /// @dev Will revert if the executor is already recorded for the transaction.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to add the execution fee to.\n    function addExecutionFee(uint64 dstChainId, bytes32 transactionId) external payable;\n\n    /// @notice Record the executor (who completed the transaction) for a transaction,\n    /// and update the accumulated rewards for the executor.\n    /// @dev Could only be called by the Recorder.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to record the executor for.\n    /// @param executor             The address of the executor who completed the transaction.\n    function recordExecutor(uint64 dstChainId, bytes32 transactionId, address executor) external;\n\n    /// @notice Allows the executor to claim their unclaimed rewards.\n    /// @dev Will revert if the executor has no unclaimed rewards.\n    function claimExecutionFees(address executor) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the accumulated rewards for an executor.\n    /// @param executor             The address of the executor to get the rewards for.\n    function accumulatedRewards(address executor) external view returns (uint256 accumulated);\n\n    /// @notice Get the unclaimed rewards for an executor.\n    /// @param executor             The address of the executor to get the rewards for.\n    function unclaimedRewards(address executor) external view returns (uint256 unclaimed);\n\n    /// @notice Get the total execution fee for a transaction.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to get the execution fee for.\n    function executionFee(uint64 dstChainId, bytes32 transactionId) external view returns (uint256 fee);\n\n    /// @notice Get the address of the recorded executor for a transaction.\n    /// @dev Will return address(0) if the executor is not recorded.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to get the recorded executor for.\n    function recordedExecutor(uint64 dstChainId, bytes32 transactionId) external view returns (address executor);\n}\n\n// contracts/interfaces/IExecutionService.sol\n\ninterface IExecutionService {\n    /// @notice Request the execution of an Interchain Transaction on a remote chain.\n    /// Note: the off-chain actor needs to fetch the transaction payload from the InterchainClient\n    /// event with the same transactionId, then execute the transaction on the remote chain:\n    /// `dstInterchainClient.executeTransaction(transactionPayload)`\n    /// Once the execution is confirmed on the source chain, the off-chain actor will be able\n    /// to claim `executionFee` in the ExecutionFees contract.\n    /// @dev Could only be called by `InterchainClient` contracts.\n    /// Will revert if the execution fee is not big enough.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param txPayloadSize        The size of the transaction payload to use for the execution.\n    /// @param transactionId        The id of the transaction to execute.\n    /// @param executionFee         The fee paid for the execution.\n    /// @param options              The options to use for the execution.\n    function requestExecution(\n        uint64 dstChainId,\n        uint256 txPayloadSize,\n        bytes32 transactionId,\n        uint256 executionFee,\n        bytes memory options\n    )\n        external;\n\n    /// @notice Get the address of the EOA account that will be used to execute transactions on the\n    /// remote chains.\n    function executorEOA() external view returns (address);\n\n    /// @notice Get the execution fee for executing an Interchain Transaction on a remote chain.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param txPayloadSize        The size of the transaction payload to use for the execution.\n    /// @param options              The options to use for the execution.\n    function getExecutionFee(\n        uint64 dstChainId,\n        uint256 txPayloadSize,\n        bytes memory options\n    )\n        external\n        view\n        returns (uint256);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    /// @notice Allows the Interchain Client to pass the message to the Interchain App.\n    /// @dev App is responsible for keeping track of interchain clients, and must verify the message sender.\n    /// @param srcChainId   Chain ID of the source chain, where the message was sent from.\n    /// @param sender       Sender address on the source chain, as a bytes32 value.\n    /// @param dbNonce      The Interchain DB nonce of the batch containing the message entry.\n    /// @param entryIndex   The index of the message entry within the batch.\n    /// @param message      The message being sent.\n    function appReceive(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /// @notice Returns the verification configuration of the Interchain App.\n    /// @dev This configuration is used by the Interchain Client to verify that message has been confirmed\n    /// by the Interchain Modules on the destination chain.\n    /// Note: V1 version of AppConfig includes the required responses count, and optimistic period after which\n    /// the message is considered confirmed by the module. Following versions may include additional fields.\n    /// @return appConfig    The versioned configuration of the Interchain App, encoded as bytes.\n    /// @return modules      The list of Interchain Modules that app is trusting to confirm the messages.\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/Math.sol\n\nlibrary MathLib {\n    /// @notice Rounds up to the nearest multiple of 32.\n    /// Note: Returns zero on overflows instead of reverting. This is fine for practical\n    /// use cases, as this is used for determining the size of the payload in memory.\n    function roundUpToWord(uint256 x) internal pure returns (uint256) {\n        unchecked {\n            return (x + 31) \u0026 ~uint256(31);\n        }\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/VersionedPayload.sol\n\n// solhint-disable no-inline-assembly\n// solhint-disable ordering\nlibrary VersionedPayloadLib {\n    /// @notice Amount of bytes reserved for the version (uint16) in the versioned payload\n    uint256 internal constant VERSION_LENGTH = 2;\n\n    error VersionedPayload__TooShort(bytes versionedPayload);\n    error VersionedPayload__PrecompileFailed();\n\n    /// @notice Encodes the versioned payload into a single bytes array.\n    /// @param version  The payload's version.\n    /// @param payload  The payload to encode.\n    function encodeVersionedPayload(uint16 version, bytes memory payload) internal pure returns (bytes memory) {\n        return abi.encodePacked(version, payload);\n    }\n\n    /// @notice Extracts the version from the versioned payload (calldata reference).\n    /// @param versionedPayload     The versioned payload (calldata reference).\n    function getVersion(bytes calldata versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            version := shr(240, calldataload(versionedPayload.offset))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (calldata reference).\n    /// @dev The extracted payload is also returned as a calldata reference.\n    /// @param versionedPayload     The versioned payload.\n    function getPayload(bytes calldata versionedPayload) internal pure returns (bytes calldata) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        return versionedPayload[VERSION_LENGTH:];\n    }\n\n    /// @notice Extracts the version from the versioned payload (memory reference).\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getVersionFromMemory(bytes memory versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            // We add 0x20 to skip the length of the bytes array.\n            version := shr(240, mload(add(versionedPayload, 0x20)))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (memory reference).\n    /// @dev The extracted payload is copied into a new memory location. Use `getPayload` when possible\n    /// to avoid extra memory allocation.\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getPayloadFromMemory(bytes memory versionedPayload) internal view returns (bytes memory payload) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        // Figure how many bytes to copy and allocate the memory for the extracted payload.\n        uint256 toCopy;\n        unchecked {\n            toCopy = versionedPayload.length - VERSION_LENGTH;\n        }\n        payload = new bytes(toCopy);\n        // Use identity precompile (0x04) to copy the payload. Unlike MCOPY, this is available on all EVM chains.\n        bool res;\n        assembly {\n            // We add 0x20 to skip the length of the bytes array.\n            // We add 0x02 to skip the 2 bytes reserved for the version.\n            // Copy the payload to the previously allocated memory.\n            res := staticcall(gas(), 0x04, add(versionedPayload, 0x22), toCopy, add(payload, 0x20), toCopy)\n        }\n        if (!res) {\n            revert VersionedPayload__PrecompileFailed();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SafeCast.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value \u003e type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value \u003e type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value \u003e type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value \u003e type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value \u003e type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value \u003e type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value \u003e type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value \u003e type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value \u003e type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value \u003e type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value \u003e type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value \u003e type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value \u003e type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value \u003e type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value \u003e type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value \u003e type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value \u003e type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value \u003e type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value \u003e type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value \u003e type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value \u003e type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value \u003e type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value \u003e type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value \u003e type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value \u003e type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value \u003e type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value \u003e type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value \u003e type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value \u003e type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value \u003e type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value \u003e type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value \u003c 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value \u003e uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal view returns (AppConfigV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (AppConfigV1));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal view returns (OptionsV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (OptionsV1));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(OPTIONS_V1, abi.encode(options));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/libs/InterchainBatch.sol\n\ntype BatchKey is uint128;\n\n/// @notice Struct representing a batch of entries in the Interchain DataBase.\n/// Batched entries are put together in a Merkle tree, which root is saved.\n/// Batch has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: batchRoot\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch\n/// @param batchRoot    The root of the Merkle tree containing the batched entries\nstruct InterchainBatch {\n    uint64 srcChainId;\n    uint64 dbNonce;\n    bytes32 batchRoot;\n}\n\nlibrary InterchainBatchLib {\n    using VersionedPayloadLib for bytes;\n\n    /// @notice Constructs an InterchainBatch struct to be saved on the local chain.\n    /// @param dbNonce      The database nonce of the batch\n    /// @param batchRoot    The root of the Merkle tree containing the batched entries\n    /// @return batch       The constructed InterchainBatch struct\n    function constructLocalBatch(\n        uint64 dbNonce,\n        bytes32 batchRoot\n    )\n        internal\n        view\n        returns (InterchainBatch memory batch)\n    {\n        return InterchainBatch({srcChainId: SafeCast.toUint64(block.chainid), dbNonce: dbNonce, batchRoot: batchRoot});\n    }\n\n    /// @notice Encodes the InterchainBatch struct into a non-versioned batch payload.\n    function encodeBatch(InterchainBatch memory batch) internal pure returns (bytes memory) {\n        return abi.encode(encodeBatchKey(batch.srcChainId, batch.dbNonce), batch.batchRoot);\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in calldata.\n    function decodeBatch(bytes calldata data) internal pure returns (InterchainBatch memory batch) {\n        BatchKey key;\n        (key, batch.batchRoot) = abi.decode(data, (BatchKey, bytes32));\n        (batch.srcChainId, batch.dbNonce) = decodeBatchKey(key);\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in memory.\n    function decodeBatchFromMemory(bytes memory data) internal pure returns (InterchainBatch memory batch) {\n        BatchKey key;\n        (key, batch.batchRoot) = abi.decode(data, (BatchKey, bytes32));\n        (batch.srcChainId, batch.dbNonce) = decodeBatchKey(key);\n    }\n\n    /// @notice Encodes the uint128 key of the batch from uint64 srcChainId and uint64 dbNonce.\n    function encodeBatchKey(uint64 srcChainId, uint64 dbNonce) internal pure returns (BatchKey) {\n        return BatchKey.wrap((uint128(srcChainId) \u003c\u003c 64) | dbNonce);\n    }\n\n    /// @notice Decodes the uint128 key of the batch into uint64 srcChainId and uint64 dbNonce.\n    function decodeBatchKey(BatchKey key) internal pure returns (uint64 srcChainId, uint64 dbNonce) {\n        srcChainId = uint64(BatchKey.unwrap(key) \u003e\u003e 64);\n        dbNonce = uint64(BatchKey.unwrap(key));\n    }\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce + entryIndex\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch containing the entry\n/// @param entryIndex   The index of the entry in the batch\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint64 srcChainId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nusing InterchainEntryLib for InterchainEntry global;\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint64 dbNonce,\n        uint64 entryIndex,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: SafeCast.toUint64(block.chainid),\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n}\n\n// contracts/libs/InterchainTransaction.sol\n\ntype ICTxHeader is uint256;\n\nstruct InterchainTransaction {\n    uint64 srcChainId;\n    uint64 dstChainId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcSender;\n    bytes32 dstReceiver;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    using MathLib for uint256;\n    using VersionedPayloadLib for bytes;\n\n    function constructLocalTransaction(\n        address srcSender,\n        uint64 dstChainId,\n        bytes32 dstReceiver,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: SafeCast.toUint64(block.chainid),\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            encodeTxHeader(transaction.srcChainId, transaction.dstChainId, transaction.dbNonce, transaction.entryIndex),\n            transaction.srcSender,\n            transaction.dstReceiver,\n            transaction.options,\n            transaction.message\n        );\n    }\n\n    function decodeTransaction(bytes calldata transaction) internal pure returns (InterchainTransaction memory icTx) {\n        ICTxHeader header;\n        (header, icTx.srcSender, icTx.dstReceiver, icTx.options, icTx.message) =\n            abi.decode(transaction, (ICTxHeader, bytes32, bytes32, bytes, bytes));\n        (icTx.srcChainId, icTx.dstChainId, icTx.dbNonce, icTx.entryIndex) = decodeTxHeader(header);\n    }\n\n    function payloadSize(uint256 optionsLen, uint256 messageLen) internal pure returns (uint256) {\n        // 2 bytes are reserved for the transaction version\n        // + 5 fields * 32 bytes (3 values for static, 2 offsets for dynamic) + 2 * 32 bytes (lengths for dynamic) = 226\n        // (srcChainId, dstChainId, dbNonce, entryIndex) are merged into a single 32 bytes field\n        // Both options and message are dynamic fields, which are padded up to 32 bytes\n        return 226 + optionsLen.roundUpToWord() + messageLen.roundUpToWord();\n    }\n\n    function encodeTxHeader(\n        uint64 srcChainId,\n        uint64 dstChainId,\n        uint64 dbNonce,\n        uint64 entryIndex\n    )\n        internal\n        pure\n        returns (ICTxHeader)\n    {\n        return ICTxHeader.wrap(\n            (uint256(srcChainId) \u003c\u003c 192) | (uint256(dstChainId) \u003c\u003c 128) | (uint256(dbNonce) \u003c\u003c 64) | uint256(entryIndex)\n        );\n    }\n\n    function decodeTxHeader(ICTxHeader header)\n        internal\n        pure\n        returns (uint64 srcChainId, uint64 dstChainId, uint64 dbNonce, uint64 entryIndex)\n    {\n        srcChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 192);\n        dstChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 128);\n        dbNonce = uint64(ICTxHeader.unwrap(header) \u003e\u003e 64);\n        entryIndex = uint64(ICTxHeader.unwrap(header));\n    }\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint64 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__InvalidTransactionVersion(uint16 version);\n    error InterchainClientV1__NoLinkedClient(uint64 chainId);\n    error InterchainClientV1__NotEnoughGasSupplied();\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint64 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint64 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint64 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint64 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param messageLen           The length of the message being sent.\n    function getInterchainFee(\n        uint64 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        uint256 messageLen\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint64 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint64 chainId) external view returns (address);\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing a batch of entries from the remote Interchain DataBase,\n    /// verified by the Interchain Module.\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param batchRoot    The Merkle root of the batch\n    struct RemoteBatch {\n        uint256 verifiedAt;\n        bytes32 batchRoot;\n    }\n\n    error InterchainDB__BatchDoesNotExist(uint64 dbNonce);\n    error InterchainDB__BatchNotFinalized(uint64 dbNonce);\n    error InterchainDB__ConflictingBatches(address module, bytes32 existingBatchRoot, InterchainBatch newBatch);\n    error InterchainDB__EntryIndexOutOfRange(uint64 dbNonce, uint64 entryIndex, uint64 batchSize);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__InvalidBatchVersion(uint16 version);\n    error InterchainDB__InvalidEntryRange(uint64 dbNonce, uint64 start, uint64 end);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId(uint64 chainId);\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `requestBatchVerification` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntry(bytes32 dataHash) external returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Request the given Interchain Modules to verify an existing batch.\n    /// If the batch is not finalized, the module will verify it after finalization.\n    /// For the finalized batch the batch root is already available, and the module can verify it immediately.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any batch.\n    /// @dev Will revert if the batch with the given nonce does not exist.\n    /// @param dstChainId    The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the existing batch\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestBatchVerification(\n        uint64 dstChainId,\n        uint64 dbNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Then request the Interchain Modules to verify the batch containing the written entry on the destination chain.\n    /// See `writeEntry` and `requestBatchVerification` for more details.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntryWithVerification(\n        uint64 dstChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Allows the Interchain Module to verify the batch coming from the remote chain.\n    /// Note: The DB will only accept the batch of the same version as the DB itself.\n    /// @param versionedBatch   The versioned Interchain Batch to verify\n    function verifyRemoteBatch(bytes memory versionedBatch) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint64 dstChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce.\n    /// Note: the leafs are ordered by the index of the written entry in the current batch,\n    /// and the leafs value match the value of the written entry (srcWriter + dataHash hashed together).\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchLeafs(uint64 dbNonce) external view returns (bytes32[] memory);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce,\n    /// paginated by the given start and end indexes. The end index is exclusive.\n    /// Note: this is useful when the batch contains a large number of leafs, and calling `getBatchLeafs`\n    /// would result in a gas limit exceeded error.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the provided range is invalid.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param start        The start index of the paginated leafs, inclusive\n    /// @param end          The end index of the paginated leafs, exclusive\n    function getBatchLeafsPaginated(\n        uint64 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory);\n\n    /// @notice Returns the size of the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchSize(uint64 dbNonce) external view returns (uint64);\n\n    /// @notice Get the finalized Interchain Batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatch(uint64 dbNonce) external view returns (InterchainBatch memory);\n\n    /// @notice Get the Interchain Entry's value written on the local chain with the given batch nonce and entry index.\n    /// Entry value is calculated as the hash of the writer address and the written data hash.\n    /// Note: the batch does not have to be finalized to fetch the entry value.\n    /// @dev Will revert if the batch with the given nonce does not exist,\n    /// or the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the existing batch\n    /// @param entryIndex   The index of the written entry within the batch\n    function getEntryValue(uint64 dbNonce, uint64 entryIndex) external view returns (bytes32);\n\n    /// @notice Get the Merkle proof of inclusion for the entry with the given index\n    /// in the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param entryIndex   The index of the written entry within the batch\n    /// @return proof       The Merkle proof of inclusion for the entry\n    function getEntryProof(uint64 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof);\n\n    /// @notice Get the nonce of the database, which is incremented every time a new batch is finalized.\n    /// This is the nonce of the current non-finalized batch.\n    function getDBNonce() external view returns (uint64);\n\n    /// @notice Get the index of the next entry to be written to the database.\n    /// @return dbNonce      The database nonce of the batch including the next entry\n    /// @return entryIndex   The index of the next entry within that batch\n    function getNextEntryIndex() external view returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or ZERO if the module has not verified the entry.\n    function checkVerification(\n        address dstModule,\n        InterchainEntry memory entry,\n        bytes32[] memory proof\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n\n    /// @notice Get the version of the Interchain DataBase.\n    // solhint-disable-next-line func-name-mixedcase\n    function DB_VERSION() external pure returns (uint16);\n}\n\n// contracts/InterchainClientV1.sol\n\n/**\n * @title InterchainClientV1\n * @dev Implements the operations of the Interchain Execution Layer.\n */\ncontract InterchainClientV1 is Ownable, InterchainClientV1Events, IInterchainClientV1 {\n    using AppConfigLib for bytes;\n    using OptionsLib for bytes;\n    using VersionedPayloadLib for bytes;\n\n    /// @notice Version of the InterchainClient contract. Sent and received transactions must have the same version.\n    uint16 public constant CLIENT_VERSION = 1;\n\n    /// @notice Address of the InterchainDB contract, set at the time of deployment.\n    address public immutable INTERCHAIN_DB;\n\n    /// @notice Address of the contract that handles execution fees. Can be updated by the owner.\n    address public executionFees;\n\n    /// @dev Address of the InterchainClient contract on the remote chain\n    mapping(uint64 chainId =\u003e bytes32 remoteClient) internal _linkedClient;\n    /// @dev Executor address that completed the transaction. Address(0) if not executed yet.\n    mapping(bytes32 transactionId =\u003e address executor) internal _txExecutor;\n\n    constructor(address interchainDB, address owner_) Ownable(owner_) {\n        INTERCHAIN_DB = interchainDB;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function setExecutionFees(address executionFees_) external onlyOwner {\n        executionFees = executionFees_;\n        emit ExecutionFeesSet(executionFees_);\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function setLinkedClient(uint64 chainId, bytes32 client) external onlyOwner {\n        _linkedClient[chainId] = client;\n        emit LinkedClientSet(chainId, client);\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _interchainSend(dstChainId, receiver, srcExecutionService, srcModules, options, message);\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function interchainSendEVM(\n        uint64 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc)\n    {\n        bytes32 receiverBytes32 = TypeCasts.addressToBytes32(receiver);\n        return _interchainSend(dstChainId, receiverBytes32, srcExecutionService, srcModules, options, message);\n    }\n\n    // TODO: Handle the case where receiver does not implement the IInterchainApp interface (or does not exist at all)\n    // @inheritdoc IInterchainClientV1\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable\n    {\n        InterchainTransaction memory icTx = _assertCorrectVersion(transaction);\n        bytes32 transactionId = keccak256(transaction);\n        _assertExecutable(icTx, transactionId, proof);\n        _txExecutor[transactionId] = msg.sender;\n\n        OptionsV1 memory decodedOptions = icTx.options.decodeOptionsV1();\n        if (msg.value != decodedOptions.gasAirdrop) {\n            revert InterchainClientV1__IncorrectMsgValue(msg.value, decodedOptions.gasAirdrop);\n        }\n        // We should always use at least as much as the requested gas limit.\n        // The executor can specify a higher gas limit if they wanted.\n        if (decodedOptions.gasLimit \u003e gasLimit) gasLimit = decodedOptions.gasLimit;\n        // Check the the Executor has provided big enough gas limit for the whole transaction.\n        if (gasleft() \u003c= gasLimit) {\n            revert InterchainClientV1__NotEnoughGasSupplied();\n        }\n        // Pass the full msg.value to the app: we have already checked that it matches the requested gas airdrop.\n        IInterchainApp(TypeCasts.bytes32ToAddress(icTx.dstReceiver)).appReceive{gas: gasLimit, value: msg.value}({\n            srcChainId: icTx.srcChainId,\n            sender: icTx.srcSender,\n            dbNonce: icTx.dbNonce,\n            entryIndex: icTx.entryIndex,\n            message: icTx.message\n        });\n        emit InterchainTransactionReceived(\n            transactionId, icTx.dbNonce, icTx.entryIndex, icTx.srcChainId, icTx.srcSender, icTx.dstReceiver\n        );\n    }\n\n    /// @inheritdoc IInterchainClientV1\n    function writeExecutionProof(bytes32 transactionId) external returns (uint64 dbNonce, uint64 entryIndex) {\n        address executor = _txExecutor[transactionId];\n        if (executor == address(0)) {\n            revert InterchainClientV1__TxNotExecuted(transactionId);\n        }\n        bytes memory proof = abi.encode(transactionId, executor);\n        (dbNonce, entryIndex) = IInterchainDB(INTERCHAIN_DB).writeEntry(keccak256(proof));\n        emit ExecutionProofWritten(transactionId, dbNonce, entryIndex, executor);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // @inheritdoc IInterchainClientV1\n    function isExecutable(bytes calldata encodedTx, bytes32[] calldata proof) external view returns (bool) {\n        InterchainTransaction memory icTx = _assertCorrectVersion(encodedTx);\n        // Check that options could be decoded\n        icTx.options.decodeOptionsV1();\n        bytes32 transactionId = keccak256(encodedTx);\n        _assertExecutable(icTx, transactionId, proof);\n        return true;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function getExecutor(bytes calldata encodedTx) external view returns (address) {\n        return _txExecutor[keccak256(encodedTx)];\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function getExecutorById(bytes32 transactionId) external view returns (address) {\n        return _txExecutor[transactionId];\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function getInterchainFee(\n        uint64 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        uint256 messageLen\n    )\n        external\n        view\n        returns (uint256 fee)\n    {\n        _assertLinkedClient(dstChainId);\n        // Check that options could be decoded on destination chain\n        options.decodeOptionsV1();\n        // Verification fee from InterchainDB\n        fee = IInterchainDB(INTERCHAIN_DB).getInterchainFee(dstChainId, srcModules);\n        // Add execution fee, if ExecutionService is provided\n        if (srcExecutionService != address(0)) {\n            uint256 payloadSize = InterchainTransactionLib.payloadSize(options.length, messageLen);\n            fee += IExecutionService(srcExecutionService).getExecutionFee(dstChainId, payloadSize, options);\n        }\n    }\n\n    /// @inheritdoc IInterchainClientV1\n    function getLinkedClient(uint64 chainId) external view returns (bytes32) {\n        if (chainId == block.chainid) {\n            revert InterchainClientV1__NotRemoteChainId(chainId);\n        }\n        return _linkedClient[chainId];\n    }\n\n    /// @inheritdoc IInterchainClientV1\n    function getLinkedClientEVM(uint64 chainId) external view returns (address linkedClientEVM) {\n        if (chainId == block.chainid) {\n            revert InterchainClientV1__NotRemoteChainId(chainId);\n        }\n        bytes32 linkedClient = _linkedClient[chainId];\n        linkedClientEVM = TypeCasts.bytes32ToAddress(linkedClient);\n        // Check that the linked client address fits into the EVM address space\n        if (TypeCasts.addressToBytes32(linkedClientEVM) != linkedClient) {\n            revert InterchainClientV1__NotEVMClient(linkedClient);\n        }\n    }\n\n    /// @notice Decodes the encoded options data into a OptionsV1 struct.\n    function decodeOptions(bytes memory encodedOptions) external view returns (OptionsV1 memory) {\n        return encodedOptions.decodeOptionsV1();\n    }\n\n    /// @notice Encodes the transaction data into a bytes format.\n    function encodeTransaction(InterchainTransaction memory icTx) public pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload({\n            version: CLIENT_VERSION,\n            payload: InterchainTransactionLib.encodeTransaction(icTx)\n        });\n    }\n\n    // ═════════════════════════════════════════════════ INTERNAL ══════════════════════════════════════════════════════\n\n    /// @dev Internal logic for sending a message to another chain.\n    function _interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        _assertLinkedClient(dstChainId);\n        if (receiver == 0) revert InterchainClientV1__ZeroReceiver();\n        // Check that options could be decoded on destination chain\n        options.decodeOptionsV1();\n        uint256 verificationFee = IInterchainDB(INTERCHAIN_DB).getInterchainFee(dstChainId, srcModules);\n        if (msg.value \u003c verificationFee) {\n            revert InterchainClientV1__FeeAmountTooLow(msg.value, verificationFee);\n        }\n        (desc.dbNonce, desc.entryIndex) = IInterchainDB(INTERCHAIN_DB).getNextEntryIndex();\n        InterchainTransaction memory icTx = InterchainTransactionLib.constructLocalTransaction({\n            srcSender: msg.sender,\n            dstReceiver: receiver,\n            dstChainId: dstChainId,\n            dbNonce: desc.dbNonce,\n            entryIndex: desc.entryIndex,\n            options: options,\n            message: message\n        });\n        desc.transactionId = keccak256(encodeTransaction(icTx));\n        // Sanity check: nonce returned from DB should match the nonce used to construct the transaction\n        {\n            (uint64 dbNonce, uint64 entryIndex) = IInterchainDB(INTERCHAIN_DB).writeEntryWithVerification{\n                value: verificationFee\n            }(icTx.dstChainId, desc.transactionId, srcModules);\n            assert(dbNonce == desc.dbNonce \u0026\u0026 entryIndex == desc.entryIndex);\n        }\n        uint256 executionFee;\n        unchecked {\n            executionFee = msg.value - verificationFee;\n        }\n        if (executionFee \u003e 0) {\n            IExecutionFees(executionFees).addExecutionFee{value: executionFee}(icTx.dstChainId, desc.transactionId);\n        }\n        // TODO: consider disallowing the use of empty srcExecutionService\n        if (srcExecutionService != address(0)) {\n            IExecutionService(srcExecutionService).requestExecution({\n                dstChainId: dstChainId,\n                txPayloadSize: InterchainTransactionLib.payloadSize(options.length, message.length),\n                transactionId: desc.transactionId,\n                executionFee: executionFee,\n                options: options\n            });\n            address srcExecutorEOA = IExecutionService(srcExecutionService).executorEOA();\n            IExecutionFees(executionFees).recordExecutor(icTx.dstChainId, desc.transactionId, srcExecutorEOA);\n        }\n        emit InterchainTransactionSent(\n            desc.transactionId,\n            icTx.dbNonce,\n            icTx.entryIndex,\n            icTx.dstChainId,\n            icTx.srcSender,\n            icTx.dstReceiver,\n            verificationFee,\n            executionFee,\n            icTx.options,\n            icTx.message\n        );\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Asserts that the transaction is executable.\n    function _assertExecutable(\n        InterchainTransaction memory icTx,\n        bytes32 transactionId,\n        bytes32[] calldata proof\n    )\n        internal\n        view\n    {\n        bytes32 linkedClient = _assertLinkedClient(icTx.srcChainId);\n        if (icTx.dstChainId != block.chainid) {\n            revert InterchainClientV1__IncorrectDstChainId(icTx.dstChainId);\n        }\n        if (_txExecutor[transactionId] != address(0)) {\n            revert InterchainClientV1__TxAlreadyExecuted(transactionId);\n        }\n        // Construct expected entry based on icTransaction data\n        InterchainEntry memory icEntry = InterchainEntry({\n            srcChainId: icTx.srcChainId,\n            dbNonce: icTx.dbNonce,\n            entryIndex: icTx.entryIndex,\n            srcWriter: linkedClient,\n            dataHash: transactionId\n        });\n        (bytes memory encodedAppConfig, address[] memory approvedDstModules) =\n            IInterchainApp(TypeCasts.bytes32ToAddress(icTx.dstReceiver)).getReceivingConfig();\n        AppConfigV1 memory appConfig = encodedAppConfig.decodeAppConfigV1();\n        if (appConfig.requiredResponses == 0) {\n            revert InterchainClientV1__ZeroRequiredResponses();\n        }\n        uint256 responses = _getFinalizedResponsesCount(approvedDstModules, icEntry, proof, appConfig.optimisticPeriod);\n        if (responses \u003c appConfig.requiredResponses) {\n            revert InterchainClientV1__NotEnoughResponses(responses, appConfig.requiredResponses);\n        }\n    }\n\n    /// @dev Asserts that the chain is linked and returns the linked client address.\n    function _assertLinkedClient(uint64 chainId) internal view returns (bytes32 linkedClient) {\n        if (chainId == block.chainid) {\n            revert InterchainClientV1__NotRemoteChainId(chainId);\n        }\n        linkedClient = _linkedClient[chainId];\n        if (linkedClient == 0) {\n            revert InterchainClientV1__NoLinkedClient(chainId);\n        }\n    }\n\n    /**\n     * @dev Calculates the number of responses that are considered finalized within the optimistic time period.\n     * @param approvedModules       Approved modules that could have confirmed the entry.\n     * @param icEntry               The InterchainEntry to confirm.\n     * @param optimisticPeriod      The time period in seconds within which a response is considered valid.\n     * @return finalizedResponses   The count of responses that are finalized within the optimistic time period.\n     */\n    function _getFinalizedResponsesCount(\n        address[] memory approvedModules,\n        InterchainEntry memory icEntry,\n        bytes32[] calldata proof,\n        uint256 optimisticPeriod\n    )\n        internal\n        view\n        returns (uint256 finalizedResponses)\n    {\n        for (uint256 i = 0; i \u003c approvedModules.length; ++i) {\n            uint256 confirmedAt = IInterchainDB(INTERCHAIN_DB).checkVerification(approvedModules[i], icEntry, proof);\n            // checkVerification() returns 0 if entry hasn't been confirmed by the module, so we check for that as well\n            if (confirmedAt != 0 \u0026\u0026 confirmedAt + optimisticPeriod \u003c block.timestamp) {\n                ++finalizedResponses;\n            }\n        }\n    }\n\n    /// @dev Asserts that the transaction version is correct. Returns the decoded transaction for chaining purposes.\n    function _assertCorrectVersion(bytes calldata versionedTx)\n        internal\n        pure\n        returns (InterchainTransaction memory icTx)\n    {\n        uint16 version = versionedTx.getVersion();\n        if (version != CLIENT_VERSION) {\n            revert InterchainClientV1__InvalidTransactionVersion(version);\n        }\n        icTx = InterchainTransactionLib.decodeTransaction(versionedTx.getPayload());\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"8608:280:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;8608:280:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"8608:280:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainClientV1.sol\":\"TypeCasts\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainClientV1.sol\":{\"keccak256\":\"0xe270686a9bca05b4013610a4e8bb08040de32a0442edd218e1692edaca94e40e\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://727e84146369613e04e57a677f8bc6c709ee145df3eeb79f15ea5a922198d78f\",\"dweb:/ipfs/QmUXh2nDtHBnhYZSwCxcteN4be13S7dR9GbqqHT9mUxta3\"]}},\"version\":1}"},"hashes":{}},"solidity/InterchainClientV1.sol:VersionedPayloadLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220405a8f4b3ddfdcdb0ee2efbfed4c90c244f3b94adcfd837c9f8b65e0c626c72264736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220405a8f4b3ddfdcdb0ee2efbfed4c90c244f3b94adcfd837c9f8b65e0c626c72264736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainClientV1Events.sol\n\nabstract contract InterchainClientV1Events {\n    event ExecutionFeesSet(address executionFees);\n    event LinkedClientSet(uint64 chainId, bytes32 client);\n\n    // TODO: figure out indexing\n\n    event InterchainTransactionSent(\n        bytes32 indexed transactionId,\n        uint64 indexed dbNonce,\n        uint64 indexed entryIndex,\n        uint64 dstChainId,\n        bytes32 srcSender,\n        bytes32 dstReceiver,\n        uint256 verificationFee,\n        uint256 executionFee,\n        bytes options,\n        bytes message\n    );\n\n    event InterchainTransactionReceived(\n        bytes32 indexed transactionId,\n        uint64 indexed dbNonce,\n        uint64 indexed entryIndex,\n        uint64 srcChainId,\n        bytes32 srcSender,\n        bytes32 dstReceiver\n    );\n\n    event ExecutionProofWritten(\n        bytes32 indexed transactionId, uint64 indexed dbNonce, uint64 indexed entryIndex, address executor\n    );\n}\n\n// contracts/interfaces/IExecutionFees.sol\n\ninterface IExecutionFees {\n    error ExecutionFees__AlreadyRecorded(uint64 dstChainId, bytes32 transactionId, address executor);\n    error ExecutionFees__ZeroAddress();\n    error ExecutionFees__ZeroAmount();\n\n    /// @notice Add the execution fee for a transaction. The attached value will be added to the\n    /// rewards for the executor completing the transaction.\n    /// Note: this could be used to store the execution fee for a new transaction, or to add more\n    /// funds to the execution fee of an existing transaction. Therefore this function is payable,\n    /// and does not implement any caller restrictions.\n    /// @dev Will revert if the executor is already recorded for the transaction.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to add the execution fee to.\n    function addExecutionFee(uint64 dstChainId, bytes32 transactionId) external payable;\n\n    /// @notice Record the executor (who completed the transaction) for a transaction,\n    /// and update the accumulated rewards for the executor.\n    /// @dev Could only be called by the Recorder.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to record the executor for.\n    /// @param executor             The address of the executor who completed the transaction.\n    function recordExecutor(uint64 dstChainId, bytes32 transactionId, address executor) external;\n\n    /// @notice Allows the executor to claim their unclaimed rewards.\n    /// @dev Will revert if the executor has no unclaimed rewards.\n    function claimExecutionFees(address executor) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the accumulated rewards for an executor.\n    /// @param executor             The address of the executor to get the rewards for.\n    function accumulatedRewards(address executor) external view returns (uint256 accumulated);\n\n    /// @notice Get the unclaimed rewards for an executor.\n    /// @param executor             The address of the executor to get the rewards for.\n    function unclaimedRewards(address executor) external view returns (uint256 unclaimed);\n\n    /// @notice Get the total execution fee for a transaction.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to get the execution fee for.\n    function executionFee(uint64 dstChainId, bytes32 transactionId) external view returns (uint256 fee);\n\n    /// @notice Get the address of the recorded executor for a transaction.\n    /// @dev Will return address(0) if the executor is not recorded.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param transactionId        The id of the transaction to get the recorded executor for.\n    function recordedExecutor(uint64 dstChainId, bytes32 transactionId) external view returns (address executor);\n}\n\n// contracts/interfaces/IExecutionService.sol\n\ninterface IExecutionService {\n    /// @notice Request the execution of an Interchain Transaction on a remote chain.\n    /// Note: the off-chain actor needs to fetch the transaction payload from the InterchainClient\n    /// event with the same transactionId, then execute the transaction on the remote chain:\n    /// `dstInterchainClient.executeTransaction(transactionPayload)`\n    /// Once the execution is confirmed on the source chain, the off-chain actor will be able\n    /// to claim `executionFee` in the ExecutionFees contract.\n    /// @dev Could only be called by `InterchainClient` contracts.\n    /// Will revert if the execution fee is not big enough.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param txPayloadSize        The size of the transaction payload to use for the execution.\n    /// @param transactionId        The id of the transaction to execute.\n    /// @param executionFee         The fee paid for the execution.\n    /// @param options              The options to use for the execution.\n    function requestExecution(\n        uint64 dstChainId,\n        uint256 txPayloadSize,\n        bytes32 transactionId,\n        uint256 executionFee,\n        bytes memory options\n    )\n        external;\n\n    /// @notice Get the address of the EOA account that will be used to execute transactions on the\n    /// remote chains.\n    function executorEOA() external view returns (address);\n\n    /// @notice Get the execution fee for executing an Interchain Transaction on a remote chain.\n    /// @param dstChainId           The chain id of the destination chain.\n    /// @param txPayloadSize        The size of the transaction payload to use for the execution.\n    /// @param options              The options to use for the execution.\n    function getExecutionFee(\n        uint64 dstChainId,\n        uint256 txPayloadSize,\n        bytes memory options\n    )\n        external\n        view\n        returns (uint256);\n}\n\n// contracts/interfaces/IInterchainApp.sol\n\n/// @notice Minimal interface for the Interchain App to work with the Interchain Client.\ninterface IInterchainApp {\n    /// @notice Allows the Interchain Client to pass the message to the Interchain App.\n    /// @dev App is responsible for keeping track of interchain clients, and must verify the message sender.\n    /// @param srcChainId   Chain ID of the source chain, where the message was sent from.\n    /// @param sender       Sender address on the source chain, as a bytes32 value.\n    /// @param dbNonce      The Interchain DB nonce of the batch containing the message entry.\n    /// @param entryIndex   The index of the message entry within the batch.\n    /// @param message      The message being sent.\n    function appReceive(\n        uint64 srcChainId,\n        bytes32 sender,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes calldata message\n    )\n        external\n        payable;\n\n    /// @notice Returns the verification configuration of the Interchain App.\n    /// @dev This configuration is used by the Interchain Client to verify that message has been confirmed\n    /// by the Interchain Modules on the destination chain.\n    /// Note: V1 version of AppConfig includes the required responses count, and optimistic period after which\n    /// the message is considered confirmed by the module. Following versions may include additional fields.\n    /// @return appConfig    The versioned configuration of the Interchain App, encoded as bytes.\n    /// @return modules      The list of Interchain Modules that app is trusting to confirm the messages.\n    function getReceivingConfig() external view returns (bytes memory appConfig, address[] memory modules);\n}\n\n// contracts/libs/Math.sol\n\nlibrary MathLib {\n    /// @notice Rounds up to the nearest multiple of 32.\n    /// Note: Returns zero on overflows instead of reverting. This is fine for practical\n    /// use cases, as this is used for determining the size of the payload in memory.\n    function roundUpToWord(uint256 x) internal pure returns (uint256) {\n        unchecked {\n            return (x + 31) \u0026 ~uint256(31);\n        }\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/VersionedPayload.sol\n\n// solhint-disable no-inline-assembly\n// solhint-disable ordering\nlibrary VersionedPayloadLib {\n    /// @notice Amount of bytes reserved for the version (uint16) in the versioned payload\n    uint256 internal constant VERSION_LENGTH = 2;\n\n    error VersionedPayload__TooShort(bytes versionedPayload);\n    error VersionedPayload__PrecompileFailed();\n\n    /// @notice Encodes the versioned payload into a single bytes array.\n    /// @param version  The payload's version.\n    /// @param payload  The payload to encode.\n    function encodeVersionedPayload(uint16 version, bytes memory payload) internal pure returns (bytes memory) {\n        return abi.encodePacked(version, payload);\n    }\n\n    /// @notice Extracts the version from the versioned payload (calldata reference).\n    /// @param versionedPayload     The versioned payload (calldata reference).\n    function getVersion(bytes calldata versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            version := shr(240, calldataload(versionedPayload.offset))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (calldata reference).\n    /// @dev The extracted payload is also returned as a calldata reference.\n    /// @param versionedPayload     The versioned payload.\n    function getPayload(bytes calldata versionedPayload) internal pure returns (bytes calldata) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        return versionedPayload[VERSION_LENGTH:];\n    }\n\n    /// @notice Extracts the version from the versioned payload (memory reference).\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getVersionFromMemory(bytes memory versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            // We add 0x20 to skip the length of the bytes array.\n            version := shr(240, mload(add(versionedPayload, 0x20)))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (memory reference).\n    /// @dev The extracted payload is copied into a new memory location. Use `getPayload` when possible\n    /// to avoid extra memory allocation.\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getPayloadFromMemory(bytes memory versionedPayload) internal view returns (bytes memory payload) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        // Figure how many bytes to copy and allocate the memory for the extracted payload.\n        uint256 toCopy;\n        unchecked {\n            toCopy = versionedPayload.length - VERSION_LENGTH;\n        }\n        payload = new bytes(toCopy);\n        // Use identity precompile (0x04) to copy the payload. Unlike MCOPY, this is available on all EVM chains.\n        bool res;\n        assembly {\n            // We add 0x20 to skip the length of the bytes array.\n            // We add 0x02 to skip the 2 bytes reserved for the version.\n            // Copy the payload to the previously allocated memory.\n            res := staticcall(gas(), 0x04, add(versionedPayload, 0x22), toCopy, add(payload, 0x20), toCopy)\n        }\n        if (!res) {\n            revert VersionedPayload__PrecompileFailed();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SafeCast.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value \u003e type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value \u003e type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value \u003e type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value \u003e type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value \u003e type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value \u003e type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value \u003e type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value \u003e type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value \u003e type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value \u003e type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value \u003e type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value \u003e type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value \u003e type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value \u003e type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value \u003e type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value \u003e type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value \u003e type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value \u003e type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value \u003e type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value \u003e type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value \u003e type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value \u003e type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value \u003e type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value \u003e type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value \u003e type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value \u003e type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value \u003e type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value \u003e type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value \u003e type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value \u003e type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value \u003e type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value \u003c 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value \u003e uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n}\n\n// contracts/libs/AppConfig.sol\n\nstruct AppConfigV1 {\n    uint256 requiredResponses;\n    uint256 optimisticPeriod;\n}\n\nusing AppConfigLib for AppConfigV1 global;\n\nlibrary AppConfigLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant APP_CONFIG_V1 = 1;\n\n    error AppConfigLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes app config (V1 or higher) from a bytes format back into an AppConfigV1 struct.\n    /// @param data         The app config data in bytes format.\n    function decodeAppConfigV1(bytes memory data) internal view returns (AppConfigV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c APP_CONFIG_V1) {\n            revert AppConfigLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (AppConfigV1));\n    }\n\n    /// @notice Encodes V1 app config into a bytes format.\n    /// @param appConfig    The AppConfigV1 to encode.\n    function encodeAppConfigV1(AppConfigV1 memory appConfig) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(APP_CONFIG_V1, abi.encode(appConfig));\n    }\n}\n\n// contracts/libs/Options.sol\n\n/// @notice Struct to hold V1 of options data.\n/// @dev Next versions have to use the fields from the previous version and add new fields at the end.\n/// @param gasLimit The gas limit for the transaction.\n/// @param gasAirdrop The amount of gas to airdrop.\nstruct OptionsV1 {\n    uint256 gasLimit;\n    uint256 gasAirdrop;\n}\n\nusing OptionsLib for OptionsV1 global;\n\n/// @title OptionsLib\n/// @notice A library for encoding and decoding Interchain options related to interchain messages.\nlibrary OptionsLib {\n    using VersionedPayloadLib for bytes;\n\n    uint16 internal constant OPTIONS_V1 = 1;\n\n    error OptionsLib__IncorrectVersion(uint16 version);\n\n    /// @notice Decodes options (V1 or higher) from a bytes format back into an OptionsV1 struct.\n    /// @param data         The options data in bytes format.\n    function decodeOptionsV1(bytes memory data) internal view returns (OptionsV1 memory) {\n        uint16 version = data.getVersionFromMemory();\n        if (version \u003c OPTIONS_V1) {\n            revert OptionsLib__IncorrectVersion(version);\n        }\n        // Structs of the same version will always be decoded correctly.\n        // Following versions will be decoded correctly if they have the same fields as the previous version,\n        // and new fields at the end: abi.decode ignores the extra bytes in the decoded payload.\n        return abi.decode(data.getPayloadFromMemory(), (OptionsV1));\n    }\n\n    /// @notice Encodes V1 options into a bytes format.\n    /// @param options      The OptionsV1 to encode.\n    function encodeOptionsV1(OptionsV1 memory options) internal pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload(OPTIONS_V1, abi.encode(options));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/libs/InterchainBatch.sol\n\ntype BatchKey is uint128;\n\n/// @notice Struct representing a batch of entries in the Interchain DataBase.\n/// Batched entries are put together in a Merkle tree, which root is saved.\n/// Batch has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: batchRoot\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch\n/// @param batchRoot    The root of the Merkle tree containing the batched entries\nstruct InterchainBatch {\n    uint64 srcChainId;\n    uint64 dbNonce;\n    bytes32 batchRoot;\n}\n\nlibrary InterchainBatchLib {\n    using VersionedPayloadLib for bytes;\n\n    /// @notice Constructs an InterchainBatch struct to be saved on the local chain.\n    /// @param dbNonce      The database nonce of the batch\n    /// @param batchRoot    The root of the Merkle tree containing the batched entries\n    /// @return batch       The constructed InterchainBatch struct\n    function constructLocalBatch(\n        uint64 dbNonce,\n        bytes32 batchRoot\n    )\n        internal\n        view\n        returns (InterchainBatch memory batch)\n    {\n        return InterchainBatch({srcChainId: SafeCast.toUint64(block.chainid), dbNonce: dbNonce, batchRoot: batchRoot});\n    }\n\n    /// @notice Encodes the InterchainBatch struct into a non-versioned batch payload.\n    function encodeBatch(InterchainBatch memory batch) internal pure returns (bytes memory) {\n        return abi.encode(encodeBatchKey(batch.srcChainId, batch.dbNonce), batch.batchRoot);\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in calldata.\n    function decodeBatch(bytes calldata data) internal pure returns (InterchainBatch memory batch) {\n        BatchKey key;\n        (key, batch.batchRoot) = abi.decode(data, (BatchKey, bytes32));\n        (batch.srcChainId, batch.dbNonce) = decodeBatchKey(key);\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in memory.\n    function decodeBatchFromMemory(bytes memory data) internal pure returns (InterchainBatch memory batch) {\n        BatchKey key;\n        (key, batch.batchRoot) = abi.decode(data, (BatchKey, bytes32));\n        (batch.srcChainId, batch.dbNonce) = decodeBatchKey(key);\n    }\n\n    /// @notice Encodes the uint128 key of the batch from uint64 srcChainId and uint64 dbNonce.\n    function encodeBatchKey(uint64 srcChainId, uint64 dbNonce) internal pure returns (BatchKey) {\n        return BatchKey.wrap((uint128(srcChainId) \u003c\u003c 64) | dbNonce);\n    }\n\n    /// @notice Decodes the uint128 key of the batch into uint64 srcChainId and uint64 dbNonce.\n    function decodeBatchKey(BatchKey key) internal pure returns (uint64 srcChainId, uint64 dbNonce) {\n        srcChainId = uint64(BatchKey.unwrap(key) \u003e\u003e 64);\n        dbNonce = uint64(BatchKey.unwrap(key));\n    }\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce + entryIndex\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch containing the entry\n/// @param entryIndex   The index of the entry in the batch\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint64 srcChainId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nusing InterchainEntryLib for InterchainEntry global;\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint64 dbNonce,\n        uint64 entryIndex,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: SafeCast.toUint64(block.chainid),\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n}\n\n// contracts/libs/InterchainTransaction.sol\n\ntype ICTxHeader is uint256;\n\nstruct InterchainTransaction {\n    uint64 srcChainId;\n    uint64 dstChainId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcSender;\n    bytes32 dstReceiver;\n    bytes options;\n    bytes message;\n}\n\nstruct InterchainTxDescriptor {\n    bytes32 transactionId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n}\n\nusing InterchainTransactionLib for InterchainTransaction global;\n\nlibrary InterchainTransactionLib {\n    using MathLib for uint256;\n    using VersionedPayloadLib for bytes;\n\n    function constructLocalTransaction(\n        address srcSender,\n        uint64 dstChainId,\n        bytes32 dstReceiver,\n        uint64 dbNonce,\n        uint64 entryIndex,\n        bytes memory options,\n        bytes memory message\n    )\n        internal\n        view\n        returns (InterchainTransaction memory transaction)\n    {\n        return InterchainTransaction({\n            srcChainId: SafeCast.toUint64(block.chainid),\n            srcSender: TypeCasts.addressToBytes32(srcSender),\n            dstChainId: dstChainId,\n            dstReceiver: dstReceiver,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            options: options,\n            message: message\n        });\n    }\n\n    function encodeTransaction(InterchainTransaction memory transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            encodeTxHeader(transaction.srcChainId, transaction.dstChainId, transaction.dbNonce, transaction.entryIndex),\n            transaction.srcSender,\n            transaction.dstReceiver,\n            transaction.options,\n            transaction.message\n        );\n    }\n\n    function decodeTransaction(bytes calldata transaction) internal pure returns (InterchainTransaction memory icTx) {\n        ICTxHeader header;\n        (header, icTx.srcSender, icTx.dstReceiver, icTx.options, icTx.message) =\n            abi.decode(transaction, (ICTxHeader, bytes32, bytes32, bytes, bytes));\n        (icTx.srcChainId, icTx.dstChainId, icTx.dbNonce, icTx.entryIndex) = decodeTxHeader(header);\n    }\n\n    function payloadSize(uint256 optionsLen, uint256 messageLen) internal pure returns (uint256) {\n        // 2 bytes are reserved for the transaction version\n        // + 5 fields * 32 bytes (3 values for static, 2 offsets for dynamic) + 2 * 32 bytes (lengths for dynamic) = 226\n        // (srcChainId, dstChainId, dbNonce, entryIndex) are merged into a single 32 bytes field\n        // Both options and message are dynamic fields, which are padded up to 32 bytes\n        return 226 + optionsLen.roundUpToWord() + messageLen.roundUpToWord();\n    }\n\n    function encodeTxHeader(\n        uint64 srcChainId,\n        uint64 dstChainId,\n        uint64 dbNonce,\n        uint64 entryIndex\n    )\n        internal\n        pure\n        returns (ICTxHeader)\n    {\n        return ICTxHeader.wrap(\n            (uint256(srcChainId) \u003c\u003c 192) | (uint256(dstChainId) \u003c\u003c 128) | (uint256(dbNonce) \u003c\u003c 64) | uint256(entryIndex)\n        );\n    }\n\n    function decodeTxHeader(ICTxHeader header)\n        internal\n        pure\n        returns (uint64 srcChainId, uint64 dstChainId, uint64 dbNonce, uint64 entryIndex)\n    {\n        srcChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 192);\n        dstChainId = uint64(ICTxHeader.unwrap(header) \u003e\u003e 128);\n        dbNonce = uint64(ICTxHeader.unwrap(header) \u003e\u003e 64);\n        entryIndex = uint64(ICTxHeader.unwrap(header));\n    }\n}\n\n// contracts/interfaces/IInterchainClientV1.sol\n\ninterface IInterchainClientV1 {\n    error InterchainClientV1__FeeAmountTooLow(uint256 actual, uint256 required);\n    error InterchainClientV1__IncorrectDstChainId(uint64 chainId);\n    error InterchainClientV1__IncorrectMsgValue(uint256 actual, uint256 required);\n    error InterchainClientV1__InvalidTransactionVersion(uint16 version);\n    error InterchainClientV1__NoLinkedClient(uint64 chainId);\n    error InterchainClientV1__NotEnoughGasSupplied();\n    error InterchainClientV1__NotEnoughResponses(uint256 actual, uint256 required);\n    error InterchainClientV1__NotEVMClient(bytes32 client);\n    error InterchainClientV1__NotRemoteChainId(uint64 chainId);\n    error InterchainClientV1__TxAlreadyExecuted(bytes32 transactionId);\n    error InterchainClientV1__TxNotExecuted(bytes32 transactionId);\n    error InterchainClientV1__ZeroReceiver();\n    error InterchainClientV1__ZeroRequiredResponses();\n\n    /**\n     * @notice Sets the address of the ExecutionFees contract.\n     * @dev Only callable by the contract owner or an authorized account.\n     * @param executionFees_ The address of the ExecutionFees contract.\n     */\n    function setExecutionFees(address executionFees_) external;\n\n    /**\n     * @notice Sets the linked client for a specific chain ID.\n     * @dev Stores the address of the linked client in a mapping with the chain ID as the key.\n     * @param chainId The chain ID for which the client is being set.\n     * @param client The address of the client being linked.\n     */\n    function setLinkedClient(uint64 chainId, bytes32 client) external;\n\n    /**\n     * @notice Sends a message to another chain via the Interchain Communication Protocol.\n     * @dev Charges a fee for the message, which is payable upon calling this function:\n     * - Verification fees: paid to every module that verifies the message.\n     * - Execution fee: paid to the executor that executes the message.\n     * Note: while a specific execution service is specified to request the execution of the message,\n     * any executor is able to execute the message on destination chain, earning the execution fee.\n     * @param dstChainId The chain ID of the destination chain.\n     * @param receiver The address of the receiver on the destination chain.\n     * @param srcExecutionService The address of the execution service to use for the message.\n     * @param srcModules The source modules involved in the message sending.\n     * @param options Execution options for the message sent, encoded as bytes, currently gas limit + native gas drop.\n     * @param message The message being sent.\n     * @return desc The descriptor of the sent transaction:\n     * - transactionId: the ID of the transaction that was sent.\n     * - dbNonce: the database nonce of the batch containing the written entry for transaction.\n     * - entryIndex: the index of the written entry for transaction within the batch.\n     */\n    function interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    function interchainSendEVM(\n        uint64 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc);\n\n    /**\n     * @notice Executes a transaction that has been sent via the Interchain.\n     * @dev The transaction must have been previously sent and recorded.\n     * Transaction data includes the requested gas limit, but the executors could specify a different gas limit.\n     * If the specified gas limit is lower than requested, the requested gas limit will be used.\n     * Otherwise, the specified gas limit will be used.\n     * This allows to execute the transactions with requested gas limit set too low.\n     * @param gasLimit          The gas limit to use for the execution.\n     * @param transaction       The transaction data.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     */\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable;\n\n    /// @notice Writes the proof of execution for a transaction into the InterchainDB.\n    /// @dev Will revert if the transaction has not been executed.\n    /// @param transactionId    The ID of the transaction to write the proof for.\n    /// @return dbNonce         The database nonce of the batch containing the written proof for transaction.\n    /// @return entryIndex      The index of the written proof for transaction within the batch.\n    function writeExecutionProof(bytes32 transactionId) external returns (uint64 dbNonce, uint64 entryIndex);\n\n    /**\n     * @notice Checks if a transaction is executable.\n     * @dev Determines if a transaction meets the criteria to be executed based on:\n     * - If approved modules have written to the InterchainDB\n     * - If the threshold of approved modules have been met\n     * - If the optimistic window has passed for all modules\n     * @param transaction       The InterchainTransaction struct to be checked.\n     * @param proof             The Merkle proof for transaction execution, fetched from the source chain.\n     * @return bool Returns true if the transaction is executable, false otherwise.\n     */\n    function isExecutable(bytes calldata transaction, bytes32[] calldata proof) external view returns (bool);\n\n    /// @notice Returns the fee for sending an Interchain message.\n    /// @param dstChainId           The chain ID of the destination chain.\n    /// @param srcExecutionService  The address of the execution service to use for the message.\n    /// @param srcModules           The source modules involved in the message sending.\n    /// @param options              Execution options for the message sent, currently gas limit + native gas drop.\n    /// @param messageLen           The length of the message being sent.\n    function getInterchainFee(\n        uint64 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        uint256 messageLen\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutor(bytes calldata transaction) external view returns (address);\n\n    /// @notice Returns the address of the executor for a transaction that has been sent to the local chain.\n    function getExecutorById(bytes32 transactionId) external view returns (address);\n\n    /// @notice Returns the address of the linked client (as bytes32) for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    function getLinkedClient(uint64 chainId) external view returns (bytes32);\n\n    /// @notice Returns the EVM address of the linked client for a specific chain ID.\n    /// @dev Will return 0x0 if no client is linked for the chain ID.\n    /// Will revert if the client is not an EVM client.\n    function getLinkedClientEVM(uint64 chainId) external view returns (address);\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing a batch of entries from the remote Interchain DataBase,\n    /// verified by the Interchain Module.\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param batchRoot    The Merkle root of the batch\n    struct RemoteBatch {\n        uint256 verifiedAt;\n        bytes32 batchRoot;\n    }\n\n    error InterchainDB__BatchDoesNotExist(uint64 dbNonce);\n    error InterchainDB__BatchNotFinalized(uint64 dbNonce);\n    error InterchainDB__ConflictingBatches(address module, bytes32 existingBatchRoot, InterchainBatch newBatch);\n    error InterchainDB__EntryIndexOutOfRange(uint64 dbNonce, uint64 entryIndex, uint64 batchSize);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__InvalidBatchVersion(uint16 version);\n    error InterchainDB__InvalidEntryRange(uint64 dbNonce, uint64 start, uint64 end);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId(uint64 chainId);\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `requestBatchVerification` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntry(bytes32 dataHash) external returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Request the given Interchain Modules to verify an existing batch.\n    /// If the batch is not finalized, the module will verify it after finalization.\n    /// For the finalized batch the batch root is already available, and the module can verify it immediately.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any batch.\n    /// @dev Will revert if the batch with the given nonce does not exist.\n    /// @param dstChainId    The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the existing batch\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestBatchVerification(\n        uint64 dstChainId,\n        uint64 dbNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Then request the Interchain Modules to verify the batch containing the written entry on the destination chain.\n    /// See `writeEntry` and `requestBatchVerification` for more details.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntryWithVerification(\n        uint64 dstChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Allows the Interchain Module to verify the batch coming from the remote chain.\n    /// Note: The DB will only accept the batch of the same version as the DB itself.\n    /// @param versionedBatch   The versioned Interchain Batch to verify\n    function verifyRemoteBatch(bytes memory versionedBatch) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint64 dstChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce.\n    /// Note: the leafs are ordered by the index of the written entry in the current batch,\n    /// and the leafs value match the value of the written entry (srcWriter + dataHash hashed together).\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchLeafs(uint64 dbNonce) external view returns (bytes32[] memory);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce,\n    /// paginated by the given start and end indexes. The end index is exclusive.\n    /// Note: this is useful when the batch contains a large number of leafs, and calling `getBatchLeafs`\n    /// would result in a gas limit exceeded error.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the provided range is invalid.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param start        The start index of the paginated leafs, inclusive\n    /// @param end          The end index of the paginated leafs, exclusive\n    function getBatchLeafsPaginated(\n        uint64 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory);\n\n    /// @notice Returns the size of the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchSize(uint64 dbNonce) external view returns (uint64);\n\n    /// @notice Get the finalized Interchain Batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatch(uint64 dbNonce) external view returns (InterchainBatch memory);\n\n    /// @notice Get the Interchain Entry's value written on the local chain with the given batch nonce and entry index.\n    /// Entry value is calculated as the hash of the writer address and the written data hash.\n    /// Note: the batch does not have to be finalized to fetch the entry value.\n    /// @dev Will revert if the batch with the given nonce does not exist,\n    /// or the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the existing batch\n    /// @param entryIndex   The index of the written entry within the batch\n    function getEntryValue(uint64 dbNonce, uint64 entryIndex) external view returns (bytes32);\n\n    /// @notice Get the Merkle proof of inclusion for the entry with the given index\n    /// in the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param entryIndex   The index of the written entry within the batch\n    /// @return proof       The Merkle proof of inclusion for the entry\n    function getEntryProof(uint64 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof);\n\n    /// @notice Get the nonce of the database, which is incremented every time a new batch is finalized.\n    /// This is the nonce of the current non-finalized batch.\n    function getDBNonce() external view returns (uint64);\n\n    /// @notice Get the index of the next entry to be written to the database.\n    /// @return dbNonce      The database nonce of the batch including the next entry\n    /// @return entryIndex   The index of the next entry within that batch\n    function getNextEntryIndex() external view returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or ZERO if the module has not verified the entry.\n    function checkVerification(\n        address dstModule,\n        InterchainEntry memory entry,\n        bytes32[] memory proof\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n\n    /// @notice Get the version of the Interchain DataBase.\n    // solhint-disable-next-line func-name-mixedcase\n    function DB_VERSION() external pure returns (uint16);\n}\n\n// contracts/InterchainClientV1.sol\n\n/**\n * @title InterchainClientV1\n * @dev Implements the operations of the Interchain Execution Layer.\n */\ncontract InterchainClientV1 is Ownable, InterchainClientV1Events, IInterchainClientV1 {\n    using AppConfigLib for bytes;\n    using OptionsLib for bytes;\n    using VersionedPayloadLib for bytes;\n\n    /// @notice Version of the InterchainClient contract. Sent and received transactions must have the same version.\n    uint16 public constant CLIENT_VERSION = 1;\n\n    /// @notice Address of the InterchainDB contract, set at the time of deployment.\n    address public immutable INTERCHAIN_DB;\n\n    /// @notice Address of the contract that handles execution fees. Can be updated by the owner.\n    address public executionFees;\n\n    /// @dev Address of the InterchainClient contract on the remote chain\n    mapping(uint64 chainId =\u003e bytes32 remoteClient) internal _linkedClient;\n    /// @dev Executor address that completed the transaction. Address(0) if not executed yet.\n    mapping(bytes32 transactionId =\u003e address executor) internal _txExecutor;\n\n    constructor(address interchainDB, address owner_) Ownable(owner_) {\n        INTERCHAIN_DB = interchainDB;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function setExecutionFees(address executionFees_) external onlyOwner {\n        executionFees = executionFees_;\n        emit ExecutionFeesSet(executionFees_);\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function setLinkedClient(uint64 chainId, bytes32 client) external onlyOwner {\n        _linkedClient[chainId] = client;\n        emit LinkedClientSet(chainId, client);\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc)\n    {\n        return _interchainSend(dstChainId, receiver, srcExecutionService, srcModules, options, message);\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function interchainSendEVM(\n        uint64 dstChainId,\n        address receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        external\n        payable\n        returns (InterchainTxDescriptor memory desc)\n    {\n        bytes32 receiverBytes32 = TypeCasts.addressToBytes32(receiver);\n        return _interchainSend(dstChainId, receiverBytes32, srcExecutionService, srcModules, options, message);\n    }\n\n    // TODO: Handle the case where receiver does not implement the IInterchainApp interface (or does not exist at all)\n    // @inheritdoc IInterchainClientV1\n    function interchainExecute(\n        uint256 gasLimit,\n        bytes calldata transaction,\n        bytes32[] calldata proof\n    )\n        external\n        payable\n    {\n        InterchainTransaction memory icTx = _assertCorrectVersion(transaction);\n        bytes32 transactionId = keccak256(transaction);\n        _assertExecutable(icTx, transactionId, proof);\n        _txExecutor[transactionId] = msg.sender;\n\n        OptionsV1 memory decodedOptions = icTx.options.decodeOptionsV1();\n        if (msg.value != decodedOptions.gasAirdrop) {\n            revert InterchainClientV1__IncorrectMsgValue(msg.value, decodedOptions.gasAirdrop);\n        }\n        // We should always use at least as much as the requested gas limit.\n        // The executor can specify a higher gas limit if they wanted.\n        if (decodedOptions.gasLimit \u003e gasLimit) gasLimit = decodedOptions.gasLimit;\n        // Check the the Executor has provided big enough gas limit for the whole transaction.\n        if (gasleft() \u003c= gasLimit) {\n            revert InterchainClientV1__NotEnoughGasSupplied();\n        }\n        // Pass the full msg.value to the app: we have already checked that it matches the requested gas airdrop.\n        IInterchainApp(TypeCasts.bytes32ToAddress(icTx.dstReceiver)).appReceive{gas: gasLimit, value: msg.value}({\n            srcChainId: icTx.srcChainId,\n            sender: icTx.srcSender,\n            dbNonce: icTx.dbNonce,\n            entryIndex: icTx.entryIndex,\n            message: icTx.message\n        });\n        emit InterchainTransactionReceived(\n            transactionId, icTx.dbNonce, icTx.entryIndex, icTx.srcChainId, icTx.srcSender, icTx.dstReceiver\n        );\n    }\n\n    /// @inheritdoc IInterchainClientV1\n    function writeExecutionProof(bytes32 transactionId) external returns (uint64 dbNonce, uint64 entryIndex) {\n        address executor = _txExecutor[transactionId];\n        if (executor == address(0)) {\n            revert InterchainClientV1__TxNotExecuted(transactionId);\n        }\n        bytes memory proof = abi.encode(transactionId, executor);\n        (dbNonce, entryIndex) = IInterchainDB(INTERCHAIN_DB).writeEntry(keccak256(proof));\n        emit ExecutionProofWritten(transactionId, dbNonce, entryIndex, executor);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // @inheritdoc IInterchainClientV1\n    function isExecutable(bytes calldata encodedTx, bytes32[] calldata proof) external view returns (bool) {\n        InterchainTransaction memory icTx = _assertCorrectVersion(encodedTx);\n        // Check that options could be decoded\n        icTx.options.decodeOptionsV1();\n        bytes32 transactionId = keccak256(encodedTx);\n        _assertExecutable(icTx, transactionId, proof);\n        return true;\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function getExecutor(bytes calldata encodedTx) external view returns (address) {\n        return _txExecutor[keccak256(encodedTx)];\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function getExecutorById(bytes32 transactionId) external view returns (address) {\n        return _txExecutor[transactionId];\n    }\n\n    // @inheritdoc IInterchainClientV1\n    function getInterchainFee(\n        uint64 dstChainId,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        uint256 messageLen\n    )\n        external\n        view\n        returns (uint256 fee)\n    {\n        _assertLinkedClient(dstChainId);\n        // Check that options could be decoded on destination chain\n        options.decodeOptionsV1();\n        // Verification fee from InterchainDB\n        fee = IInterchainDB(INTERCHAIN_DB).getInterchainFee(dstChainId, srcModules);\n        // Add execution fee, if ExecutionService is provided\n        if (srcExecutionService != address(0)) {\n            uint256 payloadSize = InterchainTransactionLib.payloadSize(options.length, messageLen);\n            fee += IExecutionService(srcExecutionService).getExecutionFee(dstChainId, payloadSize, options);\n        }\n    }\n\n    /// @inheritdoc IInterchainClientV1\n    function getLinkedClient(uint64 chainId) external view returns (bytes32) {\n        if (chainId == block.chainid) {\n            revert InterchainClientV1__NotRemoteChainId(chainId);\n        }\n        return _linkedClient[chainId];\n    }\n\n    /// @inheritdoc IInterchainClientV1\n    function getLinkedClientEVM(uint64 chainId) external view returns (address linkedClientEVM) {\n        if (chainId == block.chainid) {\n            revert InterchainClientV1__NotRemoteChainId(chainId);\n        }\n        bytes32 linkedClient = _linkedClient[chainId];\n        linkedClientEVM = TypeCasts.bytes32ToAddress(linkedClient);\n        // Check that the linked client address fits into the EVM address space\n        if (TypeCasts.addressToBytes32(linkedClientEVM) != linkedClient) {\n            revert InterchainClientV1__NotEVMClient(linkedClient);\n        }\n    }\n\n    /// @notice Decodes the encoded options data into a OptionsV1 struct.\n    function decodeOptions(bytes memory encodedOptions) external view returns (OptionsV1 memory) {\n        return encodedOptions.decodeOptionsV1();\n    }\n\n    /// @notice Encodes the transaction data into a bytes format.\n    function encodeTransaction(InterchainTransaction memory icTx) public pure returns (bytes memory) {\n        return VersionedPayloadLib.encodeVersionedPayload({\n            version: CLIENT_VERSION,\n            payload: InterchainTransactionLib.encodeTransaction(icTx)\n        });\n    }\n\n    // ═════════════════════════════════════════════════ INTERNAL ══════════════════════════════════════════════════════\n\n    /// @dev Internal logic for sending a message to another chain.\n    function _interchainSend(\n        uint64 dstChainId,\n        bytes32 receiver,\n        address srcExecutionService,\n        address[] calldata srcModules,\n        bytes calldata options,\n        bytes calldata message\n    )\n        internal\n        returns (InterchainTxDescriptor memory desc)\n    {\n        _assertLinkedClient(dstChainId);\n        if (receiver == 0) revert InterchainClientV1__ZeroReceiver();\n        // Check that options could be decoded on destination chain\n        options.decodeOptionsV1();\n        uint256 verificationFee = IInterchainDB(INTERCHAIN_DB).getInterchainFee(dstChainId, srcModules);\n        if (msg.value \u003c verificationFee) {\n            revert InterchainClientV1__FeeAmountTooLow(msg.value, verificationFee);\n        }\n        (desc.dbNonce, desc.entryIndex) = IInterchainDB(INTERCHAIN_DB).getNextEntryIndex();\n        InterchainTransaction memory icTx = InterchainTransactionLib.constructLocalTransaction({\n            srcSender: msg.sender,\n            dstReceiver: receiver,\n            dstChainId: dstChainId,\n            dbNonce: desc.dbNonce,\n            entryIndex: desc.entryIndex,\n            options: options,\n            message: message\n        });\n        desc.transactionId = keccak256(encodeTransaction(icTx));\n        // Sanity check: nonce returned from DB should match the nonce used to construct the transaction\n        {\n            (uint64 dbNonce, uint64 entryIndex) = IInterchainDB(INTERCHAIN_DB).writeEntryWithVerification{\n                value: verificationFee\n            }(icTx.dstChainId, desc.transactionId, srcModules);\n            assert(dbNonce == desc.dbNonce \u0026\u0026 entryIndex == desc.entryIndex);\n        }\n        uint256 executionFee;\n        unchecked {\n            executionFee = msg.value - verificationFee;\n        }\n        if (executionFee \u003e 0) {\n            IExecutionFees(executionFees).addExecutionFee{value: executionFee}(icTx.dstChainId, desc.transactionId);\n        }\n        // TODO: consider disallowing the use of empty srcExecutionService\n        if (srcExecutionService != address(0)) {\n            IExecutionService(srcExecutionService).requestExecution({\n                dstChainId: dstChainId,\n                txPayloadSize: InterchainTransactionLib.payloadSize(options.length, message.length),\n                transactionId: desc.transactionId,\n                executionFee: executionFee,\n                options: options\n            });\n            address srcExecutorEOA = IExecutionService(srcExecutionService).executorEOA();\n            IExecutionFees(executionFees).recordExecutor(icTx.dstChainId, desc.transactionId, srcExecutorEOA);\n        }\n        emit InterchainTransactionSent(\n            desc.transactionId,\n            icTx.dbNonce,\n            icTx.entryIndex,\n            icTx.dstChainId,\n            icTx.srcSender,\n            icTx.dstReceiver,\n            verificationFee,\n            executionFee,\n            icTx.options,\n            icTx.message\n        );\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Asserts that the transaction is executable.\n    function _assertExecutable(\n        InterchainTransaction memory icTx,\n        bytes32 transactionId,\n        bytes32[] calldata proof\n    )\n        internal\n        view\n    {\n        bytes32 linkedClient = _assertLinkedClient(icTx.srcChainId);\n        if (icTx.dstChainId != block.chainid) {\n            revert InterchainClientV1__IncorrectDstChainId(icTx.dstChainId);\n        }\n        if (_txExecutor[transactionId] != address(0)) {\n            revert InterchainClientV1__TxAlreadyExecuted(transactionId);\n        }\n        // Construct expected entry based on icTransaction data\n        InterchainEntry memory icEntry = InterchainEntry({\n            srcChainId: icTx.srcChainId,\n            dbNonce: icTx.dbNonce,\n            entryIndex: icTx.entryIndex,\n            srcWriter: linkedClient,\n            dataHash: transactionId\n        });\n        (bytes memory encodedAppConfig, address[] memory approvedDstModules) =\n            IInterchainApp(TypeCasts.bytes32ToAddress(icTx.dstReceiver)).getReceivingConfig();\n        AppConfigV1 memory appConfig = encodedAppConfig.decodeAppConfigV1();\n        if (appConfig.requiredResponses == 0) {\n            revert InterchainClientV1__ZeroRequiredResponses();\n        }\n        uint256 responses = _getFinalizedResponsesCount(approvedDstModules, icEntry, proof, appConfig.optimisticPeriod);\n        if (responses \u003c appConfig.requiredResponses) {\n            revert InterchainClientV1__NotEnoughResponses(responses, appConfig.requiredResponses);\n        }\n    }\n\n    /// @dev Asserts that the chain is linked and returns the linked client address.\n    function _assertLinkedClient(uint64 chainId) internal view returns (bytes32 linkedClient) {\n        if (chainId == block.chainid) {\n            revert InterchainClientV1__NotRemoteChainId(chainId);\n        }\n        linkedClient = _linkedClient[chainId];\n        if (linkedClient == 0) {\n            revert InterchainClientV1__NoLinkedClient(chainId);\n        }\n    }\n\n    /**\n     * @dev Calculates the number of responses that are considered finalized within the optimistic time period.\n     * @param approvedModules       Approved modules that could have confirmed the entry.\n     * @param icEntry               The InterchainEntry to confirm.\n     * @param optimisticPeriod      The time period in seconds within which a response is considered valid.\n     * @return finalizedResponses   The count of responses that are finalized within the optimistic time period.\n     */\n    function _getFinalizedResponsesCount(\n        address[] memory approvedModules,\n        InterchainEntry memory icEntry,\n        bytes32[] calldata proof,\n        uint256 optimisticPeriod\n    )\n        internal\n        view\n        returns (uint256 finalizedResponses)\n    {\n        for (uint256 i = 0; i \u003c approvedModules.length; ++i) {\n            uint256 confirmedAt = IInterchainDB(INTERCHAIN_DB).checkVerification(approvedModules[i], icEntry, proof);\n            // checkVerification() returns 0 if entry hasn't been confirmed by the module, so we check for that as well\n            if (confirmedAt != 0 \u0026\u0026 confirmedAt + optimisticPeriod \u003c block.timestamp) {\n                ++finalizedResponses;\n            }\n        }\n    }\n\n    /// @dev Asserts that the transaction version is correct. Returns the decoded transaction for chaining purposes.\n    function _assertCorrectVersion(bytes calldata versionedTx)\n        internal\n        pure\n        returns (InterchainTransaction memory icTx)\n    {\n        uint16 version = versionedTx.getVersion();\n        if (version != CLIENT_VERSION) {\n            revert InterchainClientV1__InvalidTransactionVersion(version);\n        }\n        icTx = InterchainTransactionLib.decodeTransaction(versionedTx.getPayload());\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"8996:3757:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;8996:3757:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"8996:3757:0:-:0;;;;;;;;","abiDefinition":[{"inputs":[],"name":"VersionedPayload__PrecompileFailed","type":"error"},{"inputs":[{"internalType":"bytes","name":"versionedPayload","type":"bytes"}],"name":"VersionedPayload__TooShort","type":"error"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"VersionedPayload__PrecompileFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"versionedPayload\",\"type\":\"bytes\"}],\"name\":\"VersionedPayload__TooShort\",\"type\":\"error\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainClientV1.sol\":\"VersionedPayloadLib\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainClientV1.sol\":{\"keccak256\":\"0xe270686a9bca05b4013610a4e8bb08040de32a0442edd218e1692edaca94e40e\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://727e84146369613e04e57a677f8bc6c709ee145df3eeb79f15ea5a922198d78f\",\"dweb:/ipfs/QmUXh2nDtHBnhYZSwCxcteN4be13S7dR9GbqqHT9mUxta3\"]}},\"version\":1}"},"hashes":{}}}