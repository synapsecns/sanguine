{"solidity/InterchainDB.sol:BatchingV1Lib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220c409a4d0c26822834e653f1f2cef492c9e745f04a504c0e66c09b305e4b342af64736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220c409a4d0c26822834e653f1f2cef492c9e745f04a504c0e66c09b305e4b342af64736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainDBEvents.sol\n\nabstract contract InterchainDBEvents {\n    /// @notice Emitted when a local entry is written to the database.\n    /// @param dbNonce      The nonce of the batch containing the entry.\n    /// @param entryIndex   The index of the entry within the batch.\n    /// @param srcWriter    The address of the writer.\n    /// @param dataHash     The written data hash.\n    event InterchainEntryWritten(\n        uint64 indexed dbNonce, uint64 entryIndex, bytes32 indexed srcWriter, bytes32 dataHash\n    );\n\n    /// @notice Emitted when a local batch is finalized.\n    /// @param dbNonce      The nonce of the finalized batch.\n    /// @param batchRoot    The Merkle root hash of the finalized batch.\n    event InterchainBatchFinalized(uint64 indexed dbNonce, bytes32 batchRoot);\n\n    /// @notice Emitted when a remote batch is verified by the Interchain Module.\n    /// @param module       The address of the Interchain Module that verified the batch.\n    /// @param srcChainId   The ID of the source chain.\n    /// @param dbNonce      The nonce of the verified batch.\n    /// @param batchRoot    The Merkle root hash of the verified batch.\n    event InterchainBatchVerified(\n        address indexed module, uint64 indexed srcChainId, uint64 indexed dbNonce, bytes32 batchRoot\n    );\n\n    /// @notice Emitted when a local batch is requested to be verified on a remote chain\n    /// using the set of Interchain Modules.\n    /// @param dstChainId   The ID of the destination chain.\n    /// @param dbNonce      The nonce of the batch to be verified.\n    /// @param batchRoot    The Merkle root hash of the batch to be verified.\n    /// @param srcModules   The addresses of the Interchain Modules that will verify the batch.\n    event InterchainBatchVerificationRequested(\n        uint64 indexed dstChainId, uint64 indexed dbNonce, bytes32 batchRoot, address[] srcModules\n    );\n}\n\n// contracts/interfaces/IInterchainModule.sol\n\n/// @notice Every Module may opt a different method to confirm the verified entries on destination chain,\n/// therefore this is not a part of a common interface.\ninterface IInterchainModule {\n    error InterchainModule__CallerNotInterchainDB(address caller);\n    error InterchainModule__ChainIdNotRemote(uint64 chainId);\n    error InterchainModule__FeeAmountBelowMin(uint256 feeAmount, uint256 minRequired);\n\n    /// @notice Request the verification of a batch from the Interchain DataBase by the module.\n    /// If the batch is not yet finalized, the verification on destination chain will be delayed until\n    /// the finalization is done and batch root is saved on the source chain.\n    /// Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`.\n    /// Note: this will eventually trigger `InterchainDB.verifyRemoteBatch(batch)` function on destination chain,\n    /// with no guarantee of ordering.\n    /// @dev Could be only called by the Interchain DataBase contract.\n    /// @param dstChainId       The chain id of the destination chain\n    /// @param batchNonce       The nonce of the batch on the source chain\n    /// @param versionedBatch   The versioned batch to verify\n    function requestBatchVerification(\n        uint64 dstChainId,\n        uint64 batchNonce,\n        bytes memory versionedBatch\n    )\n        external\n        payable;\n\n    /// @notice Get the Module fee for verifying a batch on the specified destination chain.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dbNonce      The database nonce of the batch on the source chain\n    function getModuleFee(uint64 dstChainId, uint64 dbNonce) external view returns (uint256);\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/VersionedPayload.sol\n\n// solhint-disable no-inline-assembly\n// solhint-disable ordering\nlibrary VersionedPayloadLib {\n    /// @notice Amount of bytes reserved for the version (uint16) in the versioned payload\n    uint256 internal constant VERSION_LENGTH = 2;\n\n    error VersionedPayload__PayloadTooShort(bytes versionedPayload);\n    error VersionedPayload__PrecompileFailed();\n\n    /// @notice Encodes the versioned payload into a single bytes array.\n    /// @param version  The payload's version.\n    /// @param payload  The payload to encode.\n    function encodeVersionedPayload(uint16 version, bytes memory payload) internal pure returns (bytes memory) {\n        return abi.encodePacked(version, payload);\n    }\n\n    /// @notice Extracts the version from the versioned payload (calldata reference).\n    /// @param versionedPayload     The versioned payload (calldata reference).\n    function getVersion(bytes calldata versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__PayloadTooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            version := shr(240, calldataload(versionedPayload.offset))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (calldata reference).\n    /// @dev The extracted payload is also returned as a calldata reference.\n    /// @param versionedPayload     The versioned payload.\n    function getPayload(bytes calldata versionedPayload) internal pure returns (bytes calldata) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__PayloadTooShort(versionedPayload);\n        }\n        return versionedPayload[VERSION_LENGTH:];\n    }\n\n    /// @notice Extracts the version from the versioned payload (memory reference).\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getVersionFromMemory(bytes memory versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__PayloadTooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            // We add 0x20 to skip the length of the bytes array.\n            version := shr(240, mload(add(versionedPayload, 0x20)))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (memory reference).\n    /// @dev The extracted payload is copied into a new memory location. Use `getPayload` when possible\n    /// to avoid extra memory allocation.\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getPayloadFromMemory(bytes memory versionedPayload) internal view returns (bytes memory payload) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__PayloadTooShort(versionedPayload);\n        }\n        // Figure how many bytes to copy and allocate the memory for the extracted payload.\n        uint256 toCopy;\n        unchecked {\n            toCopy = versionedPayload.length - VERSION_LENGTH;\n        }\n        payload = new bytes(toCopy);\n        // Use identity precompile (0x04) to copy the payload. Unlike MCOPY, this is available on all EVM chains.\n        bool res;\n        assembly {\n            // We add 0x20 to skip the length of the bytes array.\n            // We add 0x02 to skip the 2 bytes reserved for the version.\n            // Copy the payload to the previously allocated memory.\n            res := staticcall(gas(), 0x04, add(versionedPayload, 0x22), toCopy, add(payload, 0x20), toCopy)\n        }\n        if (!res) {\n            revert VersionedPayload__PrecompileFailed();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SafeCast.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value \u003e type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value \u003e type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value \u003e type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value \u003e type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value \u003e type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value \u003e type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value \u003e type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value \u003e type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value \u003e type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value \u003e type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value \u003e type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value \u003e type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value \u003e type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value \u003e type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value \u003e type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value \u003e type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value \u003e type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value \u003e type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value \u003e type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value \u003e type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value \u003e type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value \u003e type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value \u003e type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value \u003e type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value \u003e type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value \u003e type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value \u003e type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value \u003e type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value \u003e type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value \u003e type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value \u003e type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value \u003c 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value \u003e uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n}\n\n// contracts/libs/InterchainBatch.sol\n\ntype BatchKey is uint128;\n\n/// @notice Struct representing a batch of entries in the Interchain DataBase.\n/// Batched entries are put together in a Merkle tree, which root is saved.\n/// Batch has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: batchRoot\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch\n/// @param batchRoot    The root of the Merkle tree containing the batched entries\nstruct InterchainBatch {\n    uint64 srcChainId;\n    uint64 dbNonce;\n    bytes32 batchRoot;\n}\n\n/// @dev Signals that the module has not verified any batch with the given key.\nuint256 constant BATCH_UNVERIFIED = 0;\n/// @dev Signals that the module has verified a conflicting batch with the given key.\nuint256 constant BATCH_CONFLICT = type(uint256).max;\n\nlibrary InterchainBatchLib {\n    using VersionedPayloadLib for bytes;\n\n    /// @notice Constructs an InterchainBatch struct to be saved on the local chain.\n    /// @param dbNonce      The database nonce of the batch\n    /// @param batchRoot    The root of the Merkle tree containing the batched entries\n    /// @return batch       The constructed InterchainBatch struct\n    function constructLocalBatch(\n        uint64 dbNonce,\n        bytes32 batchRoot\n    )\n        internal\n        view\n        returns (InterchainBatch memory batch)\n    {\n        return InterchainBatch({srcChainId: SafeCast.toUint64(block.chainid), dbNonce: dbNonce, batchRoot: batchRoot});\n    }\n\n    /// @notice Encodes the InterchainBatch struct into a non-versioned batch payload.\n    function encodeBatch(InterchainBatch memory batch) internal pure returns (bytes memory) {\n        return abi.encode(encodeBatchKey(batch.srcChainId, batch.dbNonce), batch.batchRoot);\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in calldata.\n    function decodeBatch(bytes calldata data) internal pure returns (InterchainBatch memory batch) {\n        BatchKey key;\n        (key, batch.batchRoot) = abi.decode(data, (BatchKey, bytes32));\n        (batch.srcChainId, batch.dbNonce) = decodeBatchKey(key);\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in memory.\n    function decodeBatchFromMemory(bytes memory data) internal pure returns (InterchainBatch memory batch) {\n        BatchKey key;\n        (key, batch.batchRoot) = abi.decode(data, (BatchKey, bytes32));\n        (batch.srcChainId, batch.dbNonce) = decodeBatchKey(key);\n    }\n\n    /// @notice Encodes the uint128 key of the batch from uint64 srcChainId and uint64 dbNonce.\n    function encodeBatchKey(uint64 srcChainId, uint64 dbNonce) internal pure returns (BatchKey) {\n        return BatchKey.wrap((uint128(srcChainId) \u003c\u003c 64) | dbNonce);\n    }\n\n    /// @notice Decodes the uint128 key of the batch into uint64 srcChainId and uint64 dbNonce.\n    function decodeBatchKey(BatchKey key) internal pure returns (uint64 srcChainId, uint64 dbNonce) {\n        srcChainId = uint64(BatchKey.unwrap(key) \u003e\u003e 64);\n        dbNonce = uint64(BatchKey.unwrap(key));\n    }\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce + entryIndex\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch containing the entry\n/// @param entryIndex   The index of the entry in the batch\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint64 srcChainId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nusing InterchainEntryLib for InterchainEntry global;\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint64 dbNonce,\n        uint64 entryIndex,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: SafeCast.toUint64(block.chainid),\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return getEntryValue(entry.srcWriter, entry.dataHash);\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function getEntryValue(bytes32 srcWriter, bytes32 dataHash) internal pure returns (bytes32) {\n        return keccak256(abi.encode(srcWriter, dataHash));\n    }\n}\n\n// contracts/libs/BatchingV1.sol\n\nlibrary BatchingV1Lib {\n    error BatchingV1__EntryIndexNotZero(uint64 entryIndex);\n    error BatchingV1__ProofNotEmpty();\n\n    /// @notice Get the batch root containing the Interchain Entry with the given index.\n    /// @param srcWriter    The entry writer of the source chain\n    /// @param dataHash     The hash of the data of the entry\n    /// @param entryIndex   The index of the entry in the batch\n    /// @param proof        The Merkle proof of inclusion for the entry in the batch\n    /// @return batchRoot   The root of the batch containing the entry\n    function getBatchRoot(\n        bytes32 srcWriter,\n        bytes32 dataHash,\n        uint64 entryIndex,\n        bytes32[] calldata proof\n    )\n        internal\n        pure\n        returns (bytes32 batchRoot)\n    {\n        // In \"no batching\" mode: entry index is 0, proof is empty\n        if (entryIndex != 0) {\n            revert BatchingV1__EntryIndexNotZero(entryIndex);\n        }\n        if (proof.length != 0) {\n            revert BatchingV1__ProofNotEmpty();\n        }\n        // In \"no batching\" mode: the batch root is the same as the entry value\n        return InterchainEntryLib.getEntryValue({srcWriter: srcWriter, dataHash: dataHash});\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    error InterchainDB__BatchConflict(address module, bytes32 existingBatchRoot, InterchainBatch newBatch);\n    error InterchainDB__BatchVersionMismatch(uint16 version, uint16 required);\n    error InterchainDB__ChainIdNotRemote(uint64 chainId);\n    error InterchainDB__EntryIndexOutOfRange(uint64 dbNonce, uint64 entryIndex, uint64 batchSize);\n    error InterchainDB__EntryRangeInvalid(uint64 dbNonce, uint64 start, uint64 end);\n    error InterchainDB__FeeAmountBelowMin(uint256 feeAmount, uint256 minRequired);\n    error InterchainDB__ModulesNotProvided();\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `requestBatchVerification` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntry(bytes32 dataHash) external returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Request the given Interchain Modules to verify an existing batch.\n    /// If the batch is not finalized, the module will verify it after finalization.\n    /// For the finalized batch the batch root is already available, and the module can verify it immediately.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any batch.\n    /// @dev Will revert if the batch with the given nonce does not exist.\n    /// @param dstChainId    The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the existing batch\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestBatchVerification(\n        uint64 dstChainId,\n        uint64 dbNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Then request the Interchain Modules to verify the batch containing the written entry on the destination chain.\n    /// See `writeEntry` and `requestBatchVerification` for more details.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntryWithVerification(\n        uint64 dstChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Allows the Interchain Module to verify the batch coming from the remote chain.\n    /// The module SHOULD verify the exact finalized batch from the remote chain. If the batch with a given nonce\n    /// is not finalized or does not exist, module CAN verify it with an empty root value. Once the batch is\n    /// finalized, the module SHOULD re-verify the batch with the correct root value.\n    /// Note: The DB will only accept the batch of the same version as the DB itself.\n    /// @dev Will revert if the batch with the same nonce but a different non-empty root is already verified.\n    /// @param versionedBatch   The versioned Interchain Batch to verify\n    function verifyRemoteBatch(bytes memory versionedBatch) external;\n\n    //  VIEWS \n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint64 dstChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce.\n    /// Note: the leafs are ordered by the index of the written entry in the current batch,\n    /// and the leafs value match the value of the written entry (srcWriter + dataHash hashed together).\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchLeafs(uint64 dbNonce) external view returns (bytes32[] memory);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce,\n    /// paginated by the given start and end indexes. The end index is exclusive.\n    /// Note: this is useful when the batch contains a large number of leafs, and calling `getBatchLeafs`\n    /// would result in a gas limit exceeded error.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the provided range is invalid.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param start        The start index of the paginated leafs, inclusive\n    /// @param end          The end index of the paginated leafs, exclusive\n    function getBatchLeafsPaginated(\n        uint64 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory);\n\n    /// @notice Returns the size of the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchSize(uint64 dbNonce) external view returns (uint64);\n\n    /// @notice Get the finalized Interchain Batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatch(uint64 dbNonce) external view returns (InterchainBatch memory);\n\n    /// @notice Get the versioned Interchain Batch with the given nonce.\n    /// Note: will return a batch with an empty root if the batch does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the batch\n    function getVersionedBatch(uint64 dbNonce) external view returns (bytes memory);\n\n    /// @notice Get the Interchain Entry's value written on the local chain with the given batch nonce and entry index.\n    /// Entry value is calculated as the hash of the writer address and the written data hash.\n    /// Note: the batch does not have to be finalized to fetch the entry value.\n    /// @dev Will revert if the batch with the given nonce does not exist,\n    /// or the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the existing batch\n    /// @param entryIndex   The index of the written entry within the batch\n    function getEntryValue(uint64 dbNonce, uint64 entryIndex) external view returns (bytes32);\n\n    /// @notice Get the Merkle proof of inclusion for the entry with the given index\n    /// in the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param entryIndex   The index of the written entry within the batch\n    /// @return proof       The Merkle proof of inclusion for the entry\n    function getEntryProof(uint64 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof);\n\n    /// @notice Get the nonce of the database, which is incremented every time a new batch is finalized.\n    /// This is the nonce of the current non-finalized batch.\n    function getDBNonce() external view returns (uint64);\n\n    /// @notice Get the index of the next entry to be written to the database.\n    /// @return dbNonce      The database nonce of the batch including the next entry\n    /// @return entryIndex   The index of the next entry within that batch\n    function getNextEntryIndex() external view returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Check if the batch is verified by the Interchain Module on the destination chain.\n    /// Note: returned zero value indicates that the module has not verified the batch.\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @param batch        The Interchain Batch to check\n    /// @return moduleVerifiedAt    The block timestamp at which the batch was verified by the module,\n    ///                             or ZERO if the module has not verified the batch.\n    function checkBatchVerification(\n        address dstModule,\n        InterchainBatch memory batch\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n\n    /// @notice Get the batch root containing the Interchain Entry with the given index.\n    /// @param entry         The Interchain Entry to get the batch root for\n    /// @param proof         The Merkle proof of inclusion for the entry in the batch\n    function getBatchRoot(InterchainEntry memory entry, bytes32[] memory proof) external pure returns (bytes32);\n\n    /// @notice Get the version of the Interchain DataBase.\n    // solhint-disable-next-line func-name-mixedcase\n    function DB_VERSION() external pure returns (uint16);\n}\n\n// contracts/InterchainDB.sol\n\ncontract InterchainDB is InterchainDBEvents, IInterchainDB {\n    using VersionedPayloadLib for bytes;\n\n    /// @notice Struct representing a batch of entries from the remote Interchain DataBase,\n    /// verified by the Interchain Module.\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param batchRoot    The Merkle root of the batch\n    struct RemoteBatch {\n        uint256 verifiedAt;\n        bytes32 batchRoot;\n    }\n\n    uint16 public constant DB_VERSION = 1;\n\n    bytes32[] internal _entryValues;\n    mapping(address module =\u003e mapping(BatchKey batchKey =\u003e RemoteBatch batch)) internal _remoteBatches;\n\n    modifier onlyRemoteChainId(uint64 chainId) {\n        if (chainId == block.chainid) {\n            revert InterchainDB__ChainIdNotRemote(chainId);\n        }\n        _;\n    }\n\n    //  WRITER-FACING \n\n    /// @inheritdoc IInterchainDB\n    function writeEntry(bytes32 dataHash) external returns (uint64 dbNonce, uint64 entryIndex) {\n        InterchainEntry memory entry = _writeEntry(dataHash);\n        (dbNonce, entryIndex) = (entry.dbNonce, entry.entryIndex);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function requestBatchVerification(\n        uint64 dstChainId,\n        uint64 dbNonce,\n        address[] calldata srcModules\n    )\n        external\n        payable\n        onlyRemoteChainId(dstChainId)\n    {\n        InterchainBatch memory batch = getBatch(dbNonce);\n        _requestVerification(dstChainId, batch, srcModules);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function writeEntryWithVerification(\n        uint64 dstChainId,\n        bytes32 dataHash,\n        address[] calldata srcModules\n    )\n        external\n        payable\n        onlyRemoteChainId(dstChainId)\n        returns (uint64 dbNonce, uint64 entryIndex)\n    {\n        InterchainEntry memory entry = _writeEntry(dataHash);\n        (dbNonce, entryIndex) = (entry.dbNonce, entry.entryIndex);\n        // In \"no batching\" mode: the batch root is the same as the entry value\n        InterchainBatch memory batch = InterchainBatchLib.constructLocalBatch(dbNonce, entry.entryValue());\n        _requestVerification(dstChainId, batch, srcModules);\n    }\n\n    //  MODULE-FACING \n\n    /// @inheritdoc IInterchainDB\n    function verifyRemoteBatch(bytes calldata versionedBatch) external {\n        InterchainBatch memory batch = _assertCorrectBatch(versionedBatch);\n        BatchKey batchKey = InterchainBatchLib.encodeBatchKey({srcChainId: batch.srcChainId, dbNonce: batch.dbNonce});\n        RemoteBatch memory existingBatch = _remoteBatches[msg.sender][batchKey];\n        // Check if that's the first time module verifies the batch\n        if (existingBatch.verifiedAt == 0) {\n            _saveVerifiedBatch(msg.sender, batchKey, batch);\n            return;\n        }\n        // No-op if the batch root is the same\n        if (existingBatch.batchRoot == batch.batchRoot) {\n            return;\n        }\n        // Overwriting an empty (non-existent) batch with a different one is allowed\n        if (existingBatch.batchRoot == 0) {\n            _saveVerifiedBatch(msg.sender, batchKey, batch);\n            return;\n        }\n        // Overwriting an existing batch with a different one is not allowed\n        revert InterchainDB__BatchConflict(msg.sender, existingBatch.batchRoot, batch);\n    }\n\n    //  VIEWS \n\n    /// @inheritdoc IInterchainDB\n    function getBatchLeafs(uint64 dbNonce) external view returns (bytes32[] memory leafs) {\n        uint256 batchSize = getBatchSize(dbNonce);\n        leafs = new bytes32[](batchSize);\n        for (uint64 i = 0; i \u003c batchSize; ++i) {\n            leafs[i] = getEntryValue(dbNonce, i);\n        }\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getBatchLeafsPaginated(\n        uint64 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory leafs)\n    {\n        uint256 size = getBatchSize(dbNonce);\n        if (start \u003e end || end \u003e size) {\n            revert InterchainDB__EntryRangeInvalid(dbNonce, start, end);\n        }\n        leafs = new bytes32[](end - start);\n        for (uint64 i = start; i \u003c end; ++i) {\n            leafs[i - start] = getEntryValue(dbNonce, i);\n        }\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getEntryProof(uint64 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof) {\n        // In \"no batching\" mode: the batch root is the same as the entry value, hence the proof is empty\n        _assertEntryExists(dbNonce, entryIndex);\n        return new bytes32[](0);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getInterchainFee(uint64 dstChainId, address[] calldata srcModules) external view returns (uint256 fee) {\n        (, fee) = _getModuleFees(dstChainId, getDBNonce(), srcModules);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getNextEntryIndex() external view returns (uint64 dbNonce, uint64 entryIndex) {\n        // In \"no batching\" mode: entry index is 0, batch size is 1\n        dbNonce = getDBNonce();\n        entryIndex = 0;\n    }\n\n    /// @inheritdoc IInterchainDB\n    function checkBatchVerification(\n        address dstModule,\n        InterchainBatch memory batch\n    )\n        external\n        view\n        onlyRemoteChainId(batch.srcChainId)\n        returns (uint256 moduleVerifiedAt)\n    {\n        BatchKey batchKey = InterchainBatchLib.encodeBatchKey({srcChainId: batch.srcChainId, dbNonce: batch.dbNonce});\n        RemoteBatch memory remoteBatch = _remoteBatches[dstModule][batchKey];\n        // Check if module verified anything for this batch key first\n        if (remoteBatch.verifiedAt == 0) {\n            return BATCH_UNVERIFIED;\n        }\n        // Check if the batch root matches the one verified by the module\n        return remoteBatch.batchRoot == batch.batchRoot ? remoteBatch.verifiedAt : BATCH_CONFLICT;\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getVersionedBatch(uint64 dbNonce) external view returns (bytes memory versionedBatch) {\n        InterchainBatch memory batch = getBatch(dbNonce);\n        return VersionedPayloadLib.encodeVersionedPayload({\n            version: DB_VERSION,\n            payload: InterchainBatchLib.encodeBatch(batch)\n        });\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getBatchRoot(InterchainEntry memory entry, bytes32[] calldata proof) external pure returns (bytes32) {\n        return BatchingV1Lib.getBatchRoot({\n            srcWriter: entry.srcWriter,\n            dataHash: entry.dataHash,\n            entryIndex: entry.entryIndex,\n            proof: proof\n        });\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getBatchSize(uint64 dbNonce) public view returns (uint64) {\n        // In \"no batching\" mode: the finalized batch size is 1, the pending batch size is 0\n        // We also return 0 for non-existent batches\n        return dbNonce \u003c getDBNonce() ? 1 : 0;\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getBatch(uint64 dbNonce) public view returns (InterchainBatch memory) {\n        // In \"no batching\" mode: the batch root is the same as the entry hash.\n        // For non-finalized or non-existent batches, the batch root is 0.\n        bytes32 batchRoot = dbNonce \u003c getDBNonce() ? getEntryValue(dbNonce, 0) : bytes32(0);\n        return InterchainBatchLib.constructLocalBatch(dbNonce, batchRoot);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getEntryValue(uint64 dbNonce, uint64 entryIndex) public view returns (bytes32) {\n        _assertEntryExists(dbNonce, entryIndex);\n        return _entryValues[dbNonce];\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getDBNonce() public view returns (uint64) {\n        // We can do the unsafe cast here as writing more than 2^64 entries is practically impossible\n        return uint64(_entryValues.length);\n    }\n\n    //  INTERNAL LOGIC \n\n    /// @dev Write the entry to the database and emit the event.\n    function _writeEntry(bytes32 dataHash) internal returns (InterchainEntry memory entry) {\n        uint64 dbNonce = getDBNonce();\n        entry = InterchainEntryLib.constructLocalEntry({\n            dbNonce: dbNonce,\n            entryIndex: 0,\n            writer: msg.sender,\n            dataHash: dataHash\n        });\n        bytes32 entryValue = entry.entryValue();\n        _entryValues.push(entryValue);\n        emit InterchainEntryWritten({\n            dbNonce: dbNonce,\n            entryIndex: 0,\n            srcWriter: TypeCasts.addressToBytes32(msg.sender),\n            dataHash: dataHash\n        });\n        // In the InterchainDB V1 the batch is finalized immediately after the entry is written\n        emit InterchainBatchFinalized({dbNonce: dbNonce, batchRoot: entryValue});\n    }\n\n    /// @dev Request the verification of the entry by the modules, and emit the event.\n    /// Note: the validity of the passed entry and chain id being remote is enforced in the calling function.\n    function _requestVerification(\n        uint64 dstChainId,\n        InterchainBatch memory batch,\n        address[] calldata srcModules\n    )\n        internal\n    {\n        (uint256[] memory fees, uint256 totalFee) = _getModuleFees(dstChainId, batch.dbNonce, srcModules);\n        if (msg.value \u003c totalFee) {\n            revert InterchainDB__FeeAmountBelowMin(msg.value, totalFee);\n        } else if (msg.value \u003e totalFee) {\n            // The exceeding amount goes to the first module\n            fees[0] += msg.value - totalFee;\n        }\n        uint256 len = srcModules.length;\n        bytes memory versionedBatch = VersionedPayloadLib.encodeVersionedPayload({\n            version: DB_VERSION,\n            payload: InterchainBatchLib.encodeBatch(batch)\n        });\n        for (uint256 i = 0; i \u003c len; ++i) {\n            IInterchainModule(srcModules[i]).requestBatchVerification{value: fees[i]}(\n                dstChainId, batch.dbNonce, versionedBatch\n            );\n        }\n        emit InterchainBatchVerificationRequested(dstChainId, batch.dbNonce, batch.batchRoot, srcModules);\n    }\n\n    /// @dev Save the verified batch to the database and emit the event.\n    function _saveVerifiedBatch(address module, BatchKey batchKey, InterchainBatch memory batch) internal {\n        _remoteBatches[module][batchKey] = RemoteBatch({verifiedAt: block.timestamp, batchRoot: batch.batchRoot});\n        emit InterchainBatchVerified(module, batch.srcChainId, batch.dbNonce, batch.batchRoot);\n    }\n\n    //  INTERNAL VIEWS \n\n    /// @dev Asserts that the batch version is correct and that batch originates from a remote chain.\n    /// Note: returns the decoded batch for chaining purposes.\n    function _assertCorrectBatch(bytes calldata versionedBatch) internal view returns (InterchainBatch memory batch) {\n        uint16 dbVersion = versionedBatch.getVersion();\n        if (dbVersion != DB_VERSION) {\n            revert InterchainDB__BatchVersionMismatch(dbVersion, DB_VERSION);\n        }\n        batch = InterchainBatchLib.decodeBatch(versionedBatch.getPayload());\n        if (batch.srcChainId == block.chainid) {\n            revert InterchainDB__ChainIdNotRemote(batch.srcChainId);\n        }\n    }\n\n    /// @dev Check that the entry index is within the batch size. Also checks that the batch exists.\n    function _assertEntryExists(uint64 dbNonce, uint64 entryIndex) internal view {\n        // This will revert if the batch does not exist\n        uint64 batchSize = getBatchSize(dbNonce);\n        if (entryIndex \u003e= batchSize) {\n            revert InterchainDB__EntryIndexOutOfRange(dbNonce, entryIndex, batchSize);\n        }\n    }\n\n    /// @dev Get the verification fees for the modules\n    function _getModuleFees(\n        uint64 dstChainId,\n        uint64 dbNonce,\n        address[] calldata srcModules\n    )\n        internal\n        view\n        returns (uint256[] memory fees, uint256 totalFee)\n    {\n        uint256 len = srcModules.length;\n        if (len == 0) {\n            revert InterchainDB__ModulesNotProvided();\n        }\n        fees = new uint256[](len);\n        for (uint256 i = 0; i \u003c len; ++i) {\n            fees[i] = IInterchainModule(srcModules[i]).getModuleFee(dstChainId, dbNonce);\n            totalFee += fees[i];\n        }\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"48042:1219:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;48042:1219:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"48042:1219:0:-:0;;;;;;;;","abiDefinition":[{"inputs":[{"internalType":"uint64","name":"entryIndex","type":"uint64"}],"name":"BatchingV1__EntryIndexNotZero","type":"error"},{"inputs":[],"name":"BatchingV1__ProofNotEmpty","type":"error"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"}],\"name\":\"BatchingV1__EntryIndexNotZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BatchingV1__ProofNotEmpty\",\"type\":\"error\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainDB.sol\":\"BatchingV1Lib\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainDB.sol\":{\"keccak256\":\"0x4dd7dd2bde0a2d89cb06f57f8772f18d4b0547c65abb43503e5fc2dedf60ac3e\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://e22ed31c26dd9174d0f333bf9d8d5916d407c0c99aa908c56a6c4156756a5e1e\",\"dweb:/ipfs/QmTi96nhB9Vr3SRq9qa24zbPvctFSNubneRuohgndhAqHK\"]}},\"version\":1}"},"hashes":{}},"solidity/InterchainDB.sol:IInterchainDB":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainDBEvents.sol\n\nabstract contract InterchainDBEvents {\n    /// @notice Emitted when a local entry is written to the database.\n    /// @param dbNonce      The nonce of the batch containing the entry.\n    /// @param entryIndex   The index of the entry within the batch.\n    /// @param srcWriter    The address of the writer.\n    /// @param dataHash     The written data hash.\n    event InterchainEntryWritten(\n        uint64 indexed dbNonce, uint64 entryIndex, bytes32 indexed srcWriter, bytes32 dataHash\n    );\n\n    /// @notice Emitted when a local batch is finalized.\n    /// @param dbNonce      The nonce of the finalized batch.\n    /// @param batchRoot    The Merkle root hash of the finalized batch.\n    event InterchainBatchFinalized(uint64 indexed dbNonce, bytes32 batchRoot);\n\n    /// @notice Emitted when a remote batch is verified by the Interchain Module.\n    /// @param module       The address of the Interchain Module that verified the batch.\n    /// @param srcChainId   The ID of the source chain.\n    /// @param dbNonce      The nonce of the verified batch.\n    /// @param batchRoot    The Merkle root hash of the verified batch.\n    event InterchainBatchVerified(\n        address indexed module, uint64 indexed srcChainId, uint64 indexed dbNonce, bytes32 batchRoot\n    );\n\n    /// @notice Emitted when a local batch is requested to be verified on a remote chain\n    /// using the set of Interchain Modules.\n    /// @param dstChainId   The ID of the destination chain.\n    /// @param dbNonce      The nonce of the batch to be verified.\n    /// @param batchRoot    The Merkle root hash of the batch to be verified.\n    /// @param srcModules   The addresses of the Interchain Modules that will verify the batch.\n    event InterchainBatchVerificationRequested(\n        uint64 indexed dstChainId, uint64 indexed dbNonce, bytes32 batchRoot, address[] srcModules\n    );\n}\n\n// contracts/interfaces/IInterchainModule.sol\n\n/// @notice Every Module may opt a different method to confirm the verified entries on destination chain,\n/// therefore this is not a part of a common interface.\ninterface IInterchainModule {\n    error InterchainModule__CallerNotInterchainDB(address caller);\n    error InterchainModule__ChainIdNotRemote(uint64 chainId);\n    error InterchainModule__FeeAmountBelowMin(uint256 feeAmount, uint256 minRequired);\n\n    /// @notice Request the verification of a batch from the Interchain DataBase by the module.\n    /// If the batch is not yet finalized, the verification on destination chain will be delayed until\n    /// the finalization is done and batch root is saved on the source chain.\n    /// Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`.\n    /// Note: this will eventually trigger `InterchainDB.verifyRemoteBatch(batch)` function on destination chain,\n    /// with no guarantee of ordering.\n    /// @dev Could be only called by the Interchain DataBase contract.\n    /// @param dstChainId       The chain id of the destination chain\n    /// @param batchNonce       The nonce of the batch on the source chain\n    /// @param versionedBatch   The versioned batch to verify\n    function requestBatchVerification(\n        uint64 dstChainId,\n        uint64 batchNonce,\n        bytes memory versionedBatch\n    )\n        external\n        payable;\n\n    /// @notice Get the Module fee for verifying a batch on the specified destination chain.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dbNonce      The database nonce of the batch on the source chain\n    function getModuleFee(uint64 dstChainId, uint64 dbNonce) external view returns (uint256);\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/VersionedPayload.sol\n\n// solhint-disable no-inline-assembly\n// solhint-disable ordering\nlibrary VersionedPayloadLib {\n    /// @notice Amount of bytes reserved for the version (uint16) in the versioned payload\n    uint256 internal constant VERSION_LENGTH = 2;\n\n    error VersionedPayload__PayloadTooShort(bytes versionedPayload);\n    error VersionedPayload__PrecompileFailed();\n\n    /// @notice Encodes the versioned payload into a single bytes array.\n    /// @param version  The payload's version.\n    /// @param payload  The payload to encode.\n    function encodeVersionedPayload(uint16 version, bytes memory payload) internal pure returns (bytes memory) {\n        return abi.encodePacked(version, payload);\n    }\n\n    /// @notice Extracts the version from the versioned payload (calldata reference).\n    /// @param versionedPayload     The versioned payload (calldata reference).\n    function getVersion(bytes calldata versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__PayloadTooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            version := shr(240, calldataload(versionedPayload.offset))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (calldata reference).\n    /// @dev The extracted payload is also returned as a calldata reference.\n    /// @param versionedPayload     The versioned payload.\n    function getPayload(bytes calldata versionedPayload) internal pure returns (bytes calldata) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__PayloadTooShort(versionedPayload);\n        }\n        return versionedPayload[VERSION_LENGTH:];\n    }\n\n    /// @notice Extracts the version from the versioned payload (memory reference).\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getVersionFromMemory(bytes memory versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__PayloadTooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            // We add 0x20 to skip the length of the bytes array.\n            version := shr(240, mload(add(versionedPayload, 0x20)))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (memory reference).\n    /// @dev The extracted payload is copied into a new memory location. Use `getPayload` when possible\n    /// to avoid extra memory allocation.\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getPayloadFromMemory(bytes memory versionedPayload) internal view returns (bytes memory payload) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__PayloadTooShort(versionedPayload);\n        }\n        // Figure how many bytes to copy and allocate the memory for the extracted payload.\n        uint256 toCopy;\n        unchecked {\n            toCopy = versionedPayload.length - VERSION_LENGTH;\n        }\n        payload = new bytes(toCopy);\n        // Use identity precompile (0x04) to copy the payload. Unlike MCOPY, this is available on all EVM chains.\n        bool res;\n        assembly {\n            // We add 0x20 to skip the length of the bytes array.\n            // We add 0x02 to skip the 2 bytes reserved for the version.\n            // Copy the payload to the previously allocated memory.\n            res := staticcall(gas(), 0x04, add(versionedPayload, 0x22), toCopy, add(payload, 0x20), toCopy)\n        }\n        if (!res) {\n            revert VersionedPayload__PrecompileFailed();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SafeCast.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value \u003e type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value \u003e type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value \u003e type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value \u003e type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value \u003e type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value \u003e type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value \u003e type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value \u003e type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value \u003e type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value \u003e type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value \u003e type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value \u003e type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value \u003e type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value \u003e type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value \u003e type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value \u003e type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value \u003e type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value \u003e type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value \u003e type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value \u003e type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value \u003e type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value \u003e type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value \u003e type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value \u003e type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value \u003e type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value \u003e type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value \u003e type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value \u003e type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value \u003e type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value \u003e type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value \u003e type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value \u003c 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value \u003e uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n}\n\n// contracts/libs/InterchainBatch.sol\n\ntype BatchKey is uint128;\n\n/// @notice Struct representing a batch of entries in the Interchain DataBase.\n/// Batched entries are put together in a Merkle tree, which root is saved.\n/// Batch has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: batchRoot\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch\n/// @param batchRoot    The root of the Merkle tree containing the batched entries\nstruct InterchainBatch {\n    uint64 srcChainId;\n    uint64 dbNonce;\n    bytes32 batchRoot;\n}\n\n/// @dev Signals that the module has not verified any batch with the given key.\nuint256 constant BATCH_UNVERIFIED = 0;\n/// @dev Signals that the module has verified a conflicting batch with the given key.\nuint256 constant BATCH_CONFLICT = type(uint256).max;\n\nlibrary InterchainBatchLib {\n    using VersionedPayloadLib for bytes;\n\n    /// @notice Constructs an InterchainBatch struct to be saved on the local chain.\n    /// @param dbNonce      The database nonce of the batch\n    /// @param batchRoot    The root of the Merkle tree containing the batched entries\n    /// @return batch       The constructed InterchainBatch struct\n    function constructLocalBatch(\n        uint64 dbNonce,\n        bytes32 batchRoot\n    )\n        internal\n        view\n        returns (InterchainBatch memory batch)\n    {\n        return InterchainBatch({srcChainId: SafeCast.toUint64(block.chainid), dbNonce: dbNonce, batchRoot: batchRoot});\n    }\n\n    /// @notice Encodes the InterchainBatch struct into a non-versioned batch payload.\n    function encodeBatch(InterchainBatch memory batch) internal pure returns (bytes memory) {\n        return abi.encode(encodeBatchKey(batch.srcChainId, batch.dbNonce), batch.batchRoot);\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in calldata.\n    function decodeBatch(bytes calldata data) internal pure returns (InterchainBatch memory batch) {\n        BatchKey key;\n        (key, batch.batchRoot) = abi.decode(data, (BatchKey, bytes32));\n        (batch.srcChainId, batch.dbNonce) = decodeBatchKey(key);\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in memory.\n    function decodeBatchFromMemory(bytes memory data) internal pure returns (InterchainBatch memory batch) {\n        BatchKey key;\n        (key, batch.batchRoot) = abi.decode(data, (BatchKey, bytes32));\n        (batch.srcChainId, batch.dbNonce) = decodeBatchKey(key);\n    }\n\n    /// @notice Encodes the uint128 key of the batch from uint64 srcChainId and uint64 dbNonce.\n    function encodeBatchKey(uint64 srcChainId, uint64 dbNonce) internal pure returns (BatchKey) {\n        return BatchKey.wrap((uint128(srcChainId) \u003c\u003c 64) | dbNonce);\n    }\n\n    /// @notice Decodes the uint128 key of the batch into uint64 srcChainId and uint64 dbNonce.\n    function decodeBatchKey(BatchKey key) internal pure returns (uint64 srcChainId, uint64 dbNonce) {\n        srcChainId = uint64(BatchKey.unwrap(key) \u003e\u003e 64);\n        dbNonce = uint64(BatchKey.unwrap(key));\n    }\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce + entryIndex\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch containing the entry\n/// @param entryIndex   The index of the entry in the batch\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint64 srcChainId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nusing InterchainEntryLib for InterchainEntry global;\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint64 dbNonce,\n        uint64 entryIndex,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: SafeCast.toUint64(block.chainid),\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return getEntryValue(entry.srcWriter, entry.dataHash);\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function getEntryValue(bytes32 srcWriter, bytes32 dataHash) internal pure returns (bytes32) {\n        return keccak256(abi.encode(srcWriter, dataHash));\n    }\n}\n\n// contracts/libs/BatchingV1.sol\n\nlibrary BatchingV1Lib {\n    error BatchingV1__EntryIndexNotZero(uint64 entryIndex);\n    error BatchingV1__ProofNotEmpty();\n\n    /// @notice Get the batch root containing the Interchain Entry with the given index.\n    /// @param srcWriter    The entry writer of the source chain\n    /// @param dataHash     The hash of the data of the entry\n    /// @param entryIndex   The index of the entry in the batch\n    /// @param proof        The Merkle proof of inclusion for the entry in the batch\n    /// @return batchRoot   The root of the batch containing the entry\n    function getBatchRoot(\n        bytes32 srcWriter,\n        bytes32 dataHash,\n        uint64 entryIndex,\n        bytes32[] calldata proof\n    )\n        internal\n        pure\n        returns (bytes32 batchRoot)\n    {\n        // In \"no batching\" mode: entry index is 0, proof is empty\n        if (entryIndex != 0) {\n            revert BatchingV1__EntryIndexNotZero(entryIndex);\n        }\n        if (proof.length != 0) {\n            revert BatchingV1__ProofNotEmpty();\n        }\n        // In \"no batching\" mode: the batch root is the same as the entry value\n        return InterchainEntryLib.getEntryValue({srcWriter: srcWriter, dataHash: dataHash});\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    error InterchainDB__BatchConflict(address module, bytes32 existingBatchRoot, InterchainBatch newBatch);\n    error InterchainDB__BatchVersionMismatch(uint16 version, uint16 required);\n    error InterchainDB__ChainIdNotRemote(uint64 chainId);\n    error InterchainDB__EntryIndexOutOfRange(uint64 dbNonce, uint64 entryIndex, uint64 batchSize);\n    error InterchainDB__EntryRangeInvalid(uint64 dbNonce, uint64 start, uint64 end);\n    error InterchainDB__FeeAmountBelowMin(uint256 feeAmount, uint256 minRequired);\n    error InterchainDB__ModulesNotProvided();\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `requestBatchVerification` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntry(bytes32 dataHash) external returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Request the given Interchain Modules to verify an existing batch.\n    /// If the batch is not finalized, the module will verify it after finalization.\n    /// For the finalized batch the batch root is already available, and the module can verify it immediately.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any batch.\n    /// @dev Will revert if the batch with the given nonce does not exist.\n    /// @param dstChainId    The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the existing batch\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestBatchVerification(\n        uint64 dstChainId,\n        uint64 dbNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Then request the Interchain Modules to verify the batch containing the written entry on the destination chain.\n    /// See `writeEntry` and `requestBatchVerification` for more details.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntryWithVerification(\n        uint64 dstChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Allows the Interchain Module to verify the batch coming from the remote chain.\n    /// The module SHOULD verify the exact finalized batch from the remote chain. If the batch with a given nonce\n    /// is not finalized or does not exist, module CAN verify it with an empty root value. Once the batch is\n    /// finalized, the module SHOULD re-verify the batch with the correct root value.\n    /// Note: The DB will only accept the batch of the same version as the DB itself.\n    /// @dev Will revert if the batch with the same nonce but a different non-empty root is already verified.\n    /// @param versionedBatch   The versioned Interchain Batch to verify\n    function verifyRemoteBatch(bytes memory versionedBatch) external;\n\n    //  VIEWS \n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint64 dstChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce.\n    /// Note: the leafs are ordered by the index of the written entry in the current batch,\n    /// and the leafs value match the value of the written entry (srcWriter + dataHash hashed together).\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchLeafs(uint64 dbNonce) external view returns (bytes32[] memory);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce,\n    /// paginated by the given start and end indexes. The end index is exclusive.\n    /// Note: this is useful when the batch contains a large number of leafs, and calling `getBatchLeafs`\n    /// would result in a gas limit exceeded error.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the provided range is invalid.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param start        The start index of the paginated leafs, inclusive\n    /// @param end          The end index of the paginated leafs, exclusive\n    function getBatchLeafsPaginated(\n        uint64 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory);\n\n    /// @notice Returns the size of the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchSize(uint64 dbNonce) external view returns (uint64);\n\n    /// @notice Get the finalized Interchain Batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatch(uint64 dbNonce) external view returns (InterchainBatch memory);\n\n    /// @notice Get the versioned Interchain Batch with the given nonce.\n    /// Note: will return a batch with an empty root if the batch does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the batch\n    function getVersionedBatch(uint64 dbNonce) external view returns (bytes memory);\n\n    /// @notice Get the Interchain Entry's value written on the local chain with the given batch nonce and entry index.\n    /// Entry value is calculated as the hash of the writer address and the written data hash.\n    /// Note: the batch does not have to be finalized to fetch the entry value.\n    /// @dev Will revert if the batch with the given nonce does not exist,\n    /// or the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the existing batch\n    /// @param entryIndex   The index of the written entry within the batch\n    function getEntryValue(uint64 dbNonce, uint64 entryIndex) external view returns (bytes32);\n\n    /// @notice Get the Merkle proof of inclusion for the entry with the given index\n    /// in the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param entryIndex   The index of the written entry within the batch\n    /// @return proof       The Merkle proof of inclusion for the entry\n    function getEntryProof(uint64 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof);\n\n    /// @notice Get the nonce of the database, which is incremented every time a new batch is finalized.\n    /// This is the nonce of the current non-finalized batch.\n    function getDBNonce() external view returns (uint64);\n\n    /// @notice Get the index of the next entry to be written to the database.\n    /// @return dbNonce      The database nonce of the batch including the next entry\n    /// @return entryIndex   The index of the next entry within that batch\n    function getNextEntryIndex() external view returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Check if the batch is verified by the Interchain Module on the destination chain.\n    /// Note: returned zero value indicates that the module has not verified the batch.\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @param batch        The Interchain Batch to check\n    /// @return moduleVerifiedAt    The block timestamp at which the batch was verified by the module,\n    ///                             or ZERO if the module has not verified the batch.\n    function checkBatchVerification(\n        address dstModule,\n        InterchainBatch memory batch\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n\n    /// @notice Get the batch root containing the Interchain Entry with the given index.\n    /// @param entry         The Interchain Entry to get the batch root for\n    /// @param proof         The Merkle proof of inclusion for the entry in the batch\n    function getBatchRoot(InterchainEntry memory entry, bytes32[] memory proof) external pure returns (bytes32);\n\n    /// @notice Get the version of the Interchain DataBase.\n    // solhint-disable-next-line func-name-mixedcase\n    function DB_VERSION() external pure returns (uint16);\n}\n\n// contracts/InterchainDB.sol\n\ncontract InterchainDB is InterchainDBEvents, IInterchainDB {\n    using VersionedPayloadLib for bytes;\n\n    /// @notice Struct representing a batch of entries from the remote Interchain DataBase,\n    /// verified by the Interchain Module.\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param batchRoot    The Merkle root of the batch\n    struct RemoteBatch {\n        uint256 verifiedAt;\n        bytes32 batchRoot;\n    }\n\n    uint16 public constant DB_VERSION = 1;\n\n    bytes32[] internal _entryValues;\n    mapping(address module =\u003e mapping(BatchKey batchKey =\u003e RemoteBatch batch)) internal _remoteBatches;\n\n    modifier onlyRemoteChainId(uint64 chainId) {\n        if (chainId == block.chainid) {\n            revert InterchainDB__ChainIdNotRemote(chainId);\n        }\n        _;\n    }\n\n    //  WRITER-FACING \n\n    /// @inheritdoc IInterchainDB\n    function writeEntry(bytes32 dataHash) external returns (uint64 dbNonce, uint64 entryIndex) {\n        InterchainEntry memory entry = _writeEntry(dataHash);\n        (dbNonce, entryIndex) = (entry.dbNonce, entry.entryIndex);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function requestBatchVerification(\n        uint64 dstChainId,\n        uint64 dbNonce,\n        address[] calldata srcModules\n    )\n        external\n        payable\n        onlyRemoteChainId(dstChainId)\n    {\n        InterchainBatch memory batch = getBatch(dbNonce);\n        _requestVerification(dstChainId, batch, srcModules);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function writeEntryWithVerification(\n        uint64 dstChainId,\n        bytes32 dataHash,\n        address[] calldata srcModules\n    )\n        external\n        payable\n        onlyRemoteChainId(dstChainId)\n        returns (uint64 dbNonce, uint64 entryIndex)\n    {\n        InterchainEntry memory entry = _writeEntry(dataHash);\n        (dbNonce, entryIndex) = (entry.dbNonce, entry.entryIndex);\n        // In \"no batching\" mode: the batch root is the same as the entry value\n        InterchainBatch memory batch = InterchainBatchLib.constructLocalBatch(dbNonce, entry.entryValue());\n        _requestVerification(dstChainId, batch, srcModules);\n    }\n\n    //  MODULE-FACING \n\n    /// @inheritdoc IInterchainDB\n    function verifyRemoteBatch(bytes calldata versionedBatch) external {\n        InterchainBatch memory batch = _assertCorrectBatch(versionedBatch);\n        BatchKey batchKey = InterchainBatchLib.encodeBatchKey({srcChainId: batch.srcChainId, dbNonce: batch.dbNonce});\n        RemoteBatch memory existingBatch = _remoteBatches[msg.sender][batchKey];\n        // Check if that's the first time module verifies the batch\n        if (existingBatch.verifiedAt == 0) {\n            _saveVerifiedBatch(msg.sender, batchKey, batch);\n            return;\n        }\n        // No-op if the batch root is the same\n        if (existingBatch.batchRoot == batch.batchRoot) {\n            return;\n        }\n        // Overwriting an empty (non-existent) batch with a different one is allowed\n        if (existingBatch.batchRoot == 0) {\n            _saveVerifiedBatch(msg.sender, batchKey, batch);\n            return;\n        }\n        // Overwriting an existing batch with a different one is not allowed\n        revert InterchainDB__BatchConflict(msg.sender, existingBatch.batchRoot, batch);\n    }\n\n    //  VIEWS \n\n    /// @inheritdoc IInterchainDB\n    function getBatchLeafs(uint64 dbNonce) external view returns (bytes32[] memory leafs) {\n        uint256 batchSize = getBatchSize(dbNonce);\n        leafs = new bytes32[](batchSize);\n        for (uint64 i = 0; i \u003c batchSize; ++i) {\n            leafs[i] = getEntryValue(dbNonce, i);\n        }\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getBatchLeafsPaginated(\n        uint64 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory leafs)\n    {\n        uint256 size = getBatchSize(dbNonce);\n        if (start \u003e end || end \u003e size) {\n            revert InterchainDB__EntryRangeInvalid(dbNonce, start, end);\n        }\n        leafs = new bytes32[](end - start);\n        for (uint64 i = start; i \u003c end; ++i) {\n            leafs[i - start] = getEntryValue(dbNonce, i);\n        }\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getEntryProof(uint64 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof) {\n        // In \"no batching\" mode: the batch root is the same as the entry value, hence the proof is empty\n        _assertEntryExists(dbNonce, entryIndex);\n        return new bytes32[](0);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getInterchainFee(uint64 dstChainId, address[] calldata srcModules) external view returns (uint256 fee) {\n        (, fee) = _getModuleFees(dstChainId, getDBNonce(), srcModules);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getNextEntryIndex() external view returns (uint64 dbNonce, uint64 entryIndex) {\n        // In \"no batching\" mode: entry index is 0, batch size is 1\n        dbNonce = getDBNonce();\n        entryIndex = 0;\n    }\n\n    /// @inheritdoc IInterchainDB\n    function checkBatchVerification(\n        address dstModule,\n        InterchainBatch memory batch\n    )\n        external\n        view\n        onlyRemoteChainId(batch.srcChainId)\n        returns (uint256 moduleVerifiedAt)\n    {\n        BatchKey batchKey = InterchainBatchLib.encodeBatchKey({srcChainId: batch.srcChainId, dbNonce: batch.dbNonce});\n        RemoteBatch memory remoteBatch = _remoteBatches[dstModule][batchKey];\n        // Check if module verified anything for this batch key first\n        if (remoteBatch.verifiedAt == 0) {\n            return BATCH_UNVERIFIED;\n        }\n        // Check if the batch root matches the one verified by the module\n        return remoteBatch.batchRoot == batch.batchRoot ? remoteBatch.verifiedAt : BATCH_CONFLICT;\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getVersionedBatch(uint64 dbNonce) external view returns (bytes memory versionedBatch) {\n        InterchainBatch memory batch = getBatch(dbNonce);\n        return VersionedPayloadLib.encodeVersionedPayload({\n            version: DB_VERSION,\n            payload: InterchainBatchLib.encodeBatch(batch)\n        });\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getBatchRoot(InterchainEntry memory entry, bytes32[] calldata proof) external pure returns (bytes32) {\n        return BatchingV1Lib.getBatchRoot({\n            srcWriter: entry.srcWriter,\n            dataHash: entry.dataHash,\n            entryIndex: entry.entryIndex,\n            proof: proof\n        });\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getBatchSize(uint64 dbNonce) public view returns (uint64) {\n        // In \"no batching\" mode: the finalized batch size is 1, the pending batch size is 0\n        // We also return 0 for non-existent batches\n        return dbNonce \u003c getDBNonce() ? 1 : 0;\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getBatch(uint64 dbNonce) public view returns (InterchainBatch memory) {\n        // In \"no batching\" mode: the batch root is the same as the entry hash.\n        // For non-finalized or non-existent batches, the batch root is 0.\n        bytes32 batchRoot = dbNonce \u003c getDBNonce() ? getEntryValue(dbNonce, 0) : bytes32(0);\n        return InterchainBatchLib.constructLocalBatch(dbNonce, batchRoot);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getEntryValue(uint64 dbNonce, uint64 entryIndex) public view returns (bytes32) {\n        _assertEntryExists(dbNonce, entryIndex);\n        return _entryValues[dbNonce];\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getDBNonce() public view returns (uint64) {\n        // We can do the unsafe cast here as writing more than 2^64 entries is practically impossible\n        return uint64(_entryValues.length);\n    }\n\n    //  INTERNAL LOGIC \n\n    /// @dev Write the entry to the database and emit the event.\n    function _writeEntry(bytes32 dataHash) internal returns (InterchainEntry memory entry) {\n        uint64 dbNonce = getDBNonce();\n        entry = InterchainEntryLib.constructLocalEntry({\n            dbNonce: dbNonce,\n            entryIndex: 0,\n            writer: msg.sender,\n            dataHash: dataHash\n        });\n        bytes32 entryValue = entry.entryValue();\n        _entryValues.push(entryValue);\n        emit InterchainEntryWritten({\n            dbNonce: dbNonce,\n            entryIndex: 0,\n            srcWriter: TypeCasts.addressToBytes32(msg.sender),\n            dataHash: dataHash\n        });\n        // In the InterchainDB V1 the batch is finalized immediately after the entry is written\n        emit InterchainBatchFinalized({dbNonce: dbNonce, batchRoot: entryValue});\n    }\n\n    /// @dev Request the verification of the entry by the modules, and emit the event.\n    /// Note: the validity of the passed entry and chain id being remote is enforced in the calling function.\n    function _requestVerification(\n        uint64 dstChainId,\n        InterchainBatch memory batch,\n        address[] calldata srcModules\n    )\n        internal\n    {\n        (uint256[] memory fees, uint256 totalFee) = _getModuleFees(dstChainId, batch.dbNonce, srcModules);\n        if (msg.value \u003c totalFee) {\n            revert InterchainDB__FeeAmountBelowMin(msg.value, totalFee);\n        } else if (msg.value \u003e totalFee) {\n            // The exceeding amount goes to the first module\n            fees[0] += msg.value - totalFee;\n        }\n        uint256 len = srcModules.length;\n        bytes memory versionedBatch = VersionedPayloadLib.encodeVersionedPayload({\n            version: DB_VERSION,\n            payload: InterchainBatchLib.encodeBatch(batch)\n        });\n        for (uint256 i = 0; i \u003c len; ++i) {\n            IInterchainModule(srcModules[i]).requestBatchVerification{value: fees[i]}(\n                dstChainId, batch.dbNonce, versionedBatch\n            );\n        }\n        emit InterchainBatchVerificationRequested(dstChainId, batch.dbNonce, batch.batchRoot, srcModules);\n    }\n\n    /// @dev Save the verified batch to the database and emit the event.\n    function _saveVerifiedBatch(address module, BatchKey batchKey, InterchainBatch memory batch) internal {\n        _remoteBatches[module][batchKey] = RemoteBatch({verifiedAt: block.timestamp, batchRoot: batch.batchRoot});\n        emit InterchainBatchVerified(module, batch.srcChainId, batch.dbNonce, batch.batchRoot);\n    }\n\n    //  INTERNAL VIEWS \n\n    /// @dev Asserts that the batch version is correct and that batch originates from a remote chain.\n    /// Note: returns the decoded batch for chaining purposes.\n    function _assertCorrectBatch(bytes calldata versionedBatch) internal view returns (InterchainBatch memory batch) {\n        uint16 dbVersion = versionedBatch.getVersion();\n        if (dbVersion != DB_VERSION) {\n            revert InterchainDB__BatchVersionMismatch(dbVersion, DB_VERSION);\n        }\n        batch = InterchainBatchLib.decodeBatch(versionedBatch.getPayload());\n        if (batch.srcChainId == block.chainid) {\n            revert InterchainDB__ChainIdNotRemote(batch.srcChainId);\n        }\n    }\n\n    /// @dev Check that the entry index is within the batch size. Also checks that the batch exists.\n    function _assertEntryExists(uint64 dbNonce, uint64 entryIndex) internal view {\n        // This will revert if the batch does not exist\n        uint64 batchSize = getBatchSize(dbNonce);\n        if (entryIndex \u003e= batchSize) {\n            revert InterchainDB__EntryIndexOutOfRange(dbNonce, entryIndex, batchSize);\n        }\n    }\n\n    /// @dev Get the verification fees for the modules\n    function _getModuleFees(\n        uint64 dstChainId,\n        uint64 dbNonce,\n        address[] calldata srcModules\n    )\n        internal\n        view\n        returns (uint256[] memory fees, uint256 totalFee)\n    {\n        uint256 len = srcModules.length;\n        if (len == 0) {\n            revert InterchainDB__ModulesNotProvided();\n        }\n        fees = new uint256[](len);\n        for (uint256 i = 0; i \u003c len; ++i) {\n            fees[i] = IInterchainModule(srcModules[i]).getModuleFee(dstChainId, dbNonce);\n            totalFee += fees[i];\n        }\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"address","name":"module","type":"address"},{"internalType":"bytes32","name":"existingBatchRoot","type":"bytes32"},{"components":[{"internalType":"uint64","name":"srcChainId","type":"uint64"},{"internalType":"uint64","name":"dbNonce","type":"uint64"},{"internalType":"bytes32","name":"batchRoot","type":"bytes32"}],"internalType":"struct InterchainBatch","name":"newBatch","type":"tuple"}],"name":"InterchainDB__BatchConflict","type":"error"},{"inputs":[{"internalType":"uint16","name":"version","type":"uint16"},{"internalType":"uint16","name":"required","type":"uint16"}],"name":"InterchainDB__BatchVersionMismatch","type":"error"},{"inputs":[{"internalType":"uint64","name":"chainId","type":"uint64"}],"name":"InterchainDB__ChainIdNotRemote","type":"error"},{"inputs":[{"internalType":"uint64","name":"dbNonce","type":"uint64"},{"internalType":"uint64","name":"entryIndex","type":"uint64"},{"internalType":"uint64","name":"batchSize","type":"uint64"}],"name":"InterchainDB__EntryIndexOutOfRange","type":"error"},{"inputs":[{"internalType":"uint64","name":"dbNonce","type":"uint64"},{"internalType":"uint64","name":"start","type":"uint64"},{"internalType":"uint64","name":"end","type":"uint64"}],"name":"InterchainDB__EntryRangeInvalid","type":"error"},{"inputs":[{"internalType":"uint256","name":"feeAmount","type":"uint256"},{"internalType":"uint256","name":"minRequired","type":"uint256"}],"name":"InterchainDB__FeeAmountBelowMin","type":"error"},{"inputs":[],"name":"InterchainDB__ModulesNotProvided","type":"error"},{"inputs":[],"name":"DB_VERSION","outputs":[{"internalType":"uint16","name":"","type":"uint16"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"address","name":"dstModule","type":"address"},{"components":[{"internalType":"uint64","name":"srcChainId","type":"uint64"},{"internalType":"uint64","name":"dbNonce","type":"uint64"},{"internalType":"bytes32","name":"batchRoot","type":"bytes32"}],"internalType":"struct InterchainBatch","name":"batch","type":"tuple"}],"name":"checkBatchVerification","outputs":[{"internalType":"uint256","name":"moduleVerifiedAt","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint64","name":"dbNonce","type":"uint64"}],"name":"getBatch","outputs":[{"components":[{"internalType":"uint64","name":"srcChainId","type":"uint64"},{"internalType":"uint64","name":"dbNonce","type":"uint64"},{"internalType":"bytes32","name":"batchRoot","type":"bytes32"}],"internalType":"struct InterchainBatch","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint64","name":"dbNonce","type":"uint64"}],"name":"getBatchLeafs","outputs":[{"internalType":"bytes32[]","name":"","type":"bytes32[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint64","name":"dbNonce","type":"uint64"},{"internalType":"uint64","name":"start","type":"uint64"},{"internalType":"uint64","name":"end","type":"uint64"}],"name":"getBatchLeafsPaginated","outputs":[{"internalType":"bytes32[]","name":"","type":"bytes32[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"components":[{"internalType":"uint64","name":"srcChainId","type":"uint64"},{"internalType":"uint64","name":"dbNonce","type":"uint64"},{"internalType":"uint64","name":"entryIndex","type":"uint64"},{"internalType":"bytes32","name":"srcWriter","type":"bytes32"},{"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"internalType":"struct InterchainEntry","name":"entry","type":"tuple"},{"internalType":"bytes32[]","name":"proof","type":"bytes32[]"}],"name":"getBatchRoot","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint64","name":"dbNonce","type":"uint64"}],"name":"getBatchSize","outputs":[{"internalType":"uint64","name":"","type":"uint64"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getDBNonce","outputs":[{"internalType":"uint64","name":"","type":"uint64"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint64","name":"dbNonce","type":"uint64"},{"internalType":"uint64","name":"entryIndex","type":"uint64"}],"name":"getEntryProof","outputs":[{"internalType":"bytes32[]","name":"proof","type":"bytes32[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint64","name":"dbNonce","type":"uint64"},{"internalType":"uint64","name":"entryIndex","type":"uint64"}],"name":"getEntryValue","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint64","name":"dstChainId","type":"uint64"},{"internalType":"address[]","name":"srcModules","type":"address[]"}],"name":"getInterchainFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getNextEntryIndex","outputs":[{"internalType":"uint64","name":"dbNonce","type":"uint64"},{"internalType":"uint64","name":"entryIndex","type":"uint64"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint64","name":"dbNonce","type":"uint64"}],"name":"getVersionedBatch","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint64","name":"dstChainId","type":"uint64"},{"internalType":"uint64","name":"dbNonce","type":"uint64"},{"internalType":"address[]","name":"srcModules","type":"address[]"}],"name":"requestBatchVerification","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"bytes","name":"versionedBatch","type":"bytes"}],"name":"verifyRemoteBatch","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"name":"writeEntry","outputs":[{"internalType":"uint64","name":"dbNonce","type":"uint64"},{"internalType":"uint64","name":"entryIndex","type":"uint64"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint64","name":"dstChainId","type":"uint64"},{"internalType":"bytes32","name":"dataHash","type":"bytes32"},{"internalType":"address[]","name":"srcModules","type":"address[]"}],"name":"writeEntryWithVerification","outputs":[{"internalType":"uint64","name":"dbNonce","type":"uint64"},{"internalType":"uint64","name":"entryIndex","type":"uint64"}],"stateMutability":"payable","type":"function"}],"userDoc":{"kind":"user","methods":{"DB_VERSION()":{"notice":"Get the version of the Interchain DataBase."},"checkBatchVerification(address,(uint64,uint64,bytes32))":{"notice":"Check if the batch is verified by the Interchain Module on the destination chain. Note: returned zero value indicates that the module has not verified the batch."},"getBatch(uint64)":{"notice":"Get the finalized Interchain Batch with the given nonce."},"getBatchLeafs(uint64)":{"notice":"Returns the list of leafs of the finalized batch with the given nonce. Note: the leafs are ordered by the index of the written entry in the current batch, and the leafs value match the value of the written entry (srcWriter + dataHash hashed together)."},"getBatchLeafsPaginated(uint64,uint64,uint64)":{"notice":"Returns the list of leafs of the finalized batch with the given nonce, paginated by the given start and end indexes. The end index is exclusive. Note: this is useful when the batch contains a large number of leafs, and calling `getBatchLeafs` would result in a gas limit exceeded error."},"getBatchRoot((uint64,uint64,uint64,bytes32,bytes32),bytes32[])":{"notice":"Get the batch root containing the Interchain Entry with the given index."},"getBatchSize(uint64)":{"notice":"Returns the size of the finalized batch with the given nonce."},"getDBNonce()":{"notice":"Get the nonce of the database, which is incremented every time a new batch is finalized. This is the nonce of the current non-finalized batch."},"getEntryProof(uint64,uint64)":{"notice":"Get the Merkle proof of inclusion for the entry with the given index in the finalized batch with the given nonce."},"getEntryValue(uint64,uint64)":{"notice":"Get the Interchain Entry's value written on the local chain with the given batch nonce and entry index. Entry value is calculated as the hash of the writer address and the written data hash. Note: the batch does not have to be finalized to fetch the entry value."},"getInterchainFee(uint64,address[])":{"notice":"Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain using the provided Interchain Modules."},"getNextEntryIndex()":{"notice":"Get the index of the next entry to be written to the database."},"getVersionedBatch(uint64)":{"notice":"Get the versioned Interchain Batch with the given nonce. Note: will return a batch with an empty root if the batch does not exist, or is not finalized."},"requestBatchVerification(uint64,uint64,address[])":{"notice":"Request the given Interchain Modules to verify an existing batch. If the batch is not finalized, the module will verify it after finalization. For the finalized batch the batch root is already available, and the module can verify it immediately. Note: every module has a separate fee paid in the native gas token of the source chain, and `msg.value` must be equal to the sum of all fees. Note: this method is permissionless, and anyone can request verification for any batch."},"verifyRemoteBatch(bytes)":{"notice":"Allows the Interchain Module to verify the batch coming from the remote chain. The module SHOULD verify the exact finalized batch from the remote chain. If the batch with a given nonce is not finalized or does not exist, module CAN verify it with an empty root value. Once the batch is finalized, the module SHOULD re-verify the batch with the correct root value. Note: The DB will only accept the batch of the same version as the DB itself."},"writeEntry(bytes32)":{"notice":"Write data to the Interchain DataBase as a new entry in the current batch. Note: there are no guarantees that this entry will be available for reading on any of the remote chains. Use `requestBatchVerification` to ensure that the entry is available for reading on the destination chain."},"writeEntryWithVerification(uint64,bytes32,address[])":{"notice":"Write data to the Interchain DataBase as a new entry in the current batch. Then request the Interchain Modules to verify the batch containing the written entry on the destination chain. See `writeEntry` and `requestBatchVerification` for more details."}},"version":1},"developerDoc":{"kind":"dev","methods":{"checkBatchVerification(address,(uint64,uint64,bytes32))":{"params":{"batch":"The Interchain Batch to check","dstModule":"The destination chain addresses of the Interchain Modules to use for verification"},"returns":{"moduleVerifiedAt":"   The block timestamp at which the batch was verified by the module,                             or ZERO if the module has not verified the batch."}},"getBatch(uint64)":{"details":"Will revert if the batch with the given nonce does not exist, or is not finalized.","params":{"dbNonce":"The database nonce of the finalized batch"}},"getBatchLeafs(uint64)":{"details":"Will revert if the batch with the given nonce does not exist, or is not finalized.","params":{"dbNonce":"The database nonce of the finalized batch"}},"getBatchLeafsPaginated(uint64,uint64,uint64)":{"details":"Will revert if the batch with the given nonce does not exist, or is not finalized. Will revert if the provided range is invalid.","params":{"dbNonce":"The database nonce of the finalized batch","end":"The end index of the paginated leafs, exclusive","start":"The start index of the paginated leafs, inclusive"}},"getBatchRoot((uint64,uint64,uint64,bytes32,bytes32),bytes32[])":{"params":{"entry":"The Interchain Entry to get the batch root for","proof":"The Merkle proof of inclusion for the entry in the batch"}},"getBatchSize(uint64)":{"details":"Will revert if the batch with the given nonce does not exist, or is not finalized.","params":{"dbNonce":"The database nonce of the finalized batch"}},"getEntryProof(uint64,uint64)":{"details":"Will revert if the batch with the given nonce does not exist, or is not finalized. Will revert if the entry with the given index does not exist within the batch.","params":{"dbNonce":"The database nonce of the finalized batch","entryIndex":"The index of the written entry within the batch"},"returns":{"proof":"      The Merkle proof of inclusion for the entry"}},"getEntryValue(uint64,uint64)":{"details":"Will revert if the batch with the given nonce does not exist, or the entry with the given index does not exist within the batch.","params":{"dbNonce":"The database nonce of the existing batch","entryIndex":"The index of the written entry within the batch"}},"getInterchainFee(uint64,address[])":{"details":"Will revert if the empty array of modules is provided.","params":{"dstChainId":"The chain id of the destination chain","srcModules":"The source chain addresses of the Interchain Modules to use for verification"}},"getNextEntryIndex()":{"returns":{"dbNonce":"     The database nonce of the batch including the next entry","entryIndex":"  The index of the next entry within that batch"}},"getVersionedBatch(uint64)":{"params":{"dbNonce":"The database nonce of the batch"}},"requestBatchVerification(uint64,uint64,address[])":{"details":"Will revert if the batch with the given nonce does not exist.","params":{"dbNonce":"The database nonce of the existing batch","dstChainId":"The chain id of the destination chain","srcModules":"The source chain addresses of the Interchain Modules to use for verification"}},"verifyRemoteBatch(bytes)":{"details":"Will revert if the batch with the same nonce but a different non-empty root is already verified.","params":{"versionedBatch":"The versioned Interchain Batch to verify"}},"writeEntry(bytes32)":{"params":{"dataHash":"The hash of the data to be written to the Interchain DataBase as a new entry"},"returns":{"dbNonce":"    The database nonce of the batch containing the written entry","entryIndex":" The index of the written entry within the batch"}},"writeEntryWithVerification(uint64,bytes32,address[])":{"details":"Will revert if the empty array of modules is provided.","params":{"dataHash":"The hash of the data to be written to the Interchain DataBase as a new entry","dstChainId":"The chain id of the destination chain","srcModules":"The source chain addresses of the Interchain Modules to use for verification"},"returns":{"dbNonce":"    The database nonce of the batch containing the written entry","entryIndex":" The index of the written entry within the batch"}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"existingBatchRoot\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"srcChainId\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"batchRoot\",\"type\":\"bytes32\"}],\"internalType\":\"struct InterchainBatch\",\"name\":\"newBatch\",\"type\":\"tuple\"}],\"name\":\"InterchainDB__BatchConflict\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"version\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"required\",\"type\":\"uint16\"}],\"name\":\"InterchainDB__BatchVersionMismatch\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"}],\"name\":\"InterchainDB__ChainIdNotRemote\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"batchSize\",\"type\":\"uint64\"}],\"name\":\"InterchainDB__EntryIndexOutOfRange\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"start\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"end\",\"type\":\"uint64\"}],\"name\":\"InterchainDB__EntryRangeInvalid\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minRequired\",\"type\":\"uint256\"}],\"name\":\"InterchainDB__FeeAmountBelowMin\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InterchainDB__ModulesNotProvided\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DB_VERSION\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dstModule\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"srcChainId\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"batchRoot\",\"type\":\"bytes32\"}],\"internalType\":\"struct InterchainBatch\",\"name\":\"batch\",\"type\":\"tuple\"}],\"name\":\"checkBatchVerification\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"moduleVerifiedAt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"}],\"name\":\"getBatch\",\"outputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"srcChainId\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"batchRoot\",\"type\":\"bytes32\"}],\"internalType\":\"struct InterchainBatch\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"}],\"name\":\"getBatchLeafs\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"start\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"end\",\"type\":\"uint64\"}],\"name\":\"getBatchLeafsPaginated\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"srcChainId\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"srcWriter\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"internalType\":\"struct InterchainEntry\",\"name\":\"entry\",\"type\":\"tuple\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"getBatchRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"}],\"name\":\"getBatchSize\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDBNonce\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"}],\"name\":\"getEntryProof\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"}],\"name\":\"getEntryValue\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"dstChainId\",\"type\":\"uint64\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"}],\"name\":\"getInterchainFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNextEntryIndex\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"}],\"name\":\"getVersionedBatch\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"dstChainId\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"}],\"name\":\"requestBatchVerification\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"versionedBatch\",\"type\":\"bytes\"}],\"name\":\"verifyRemoteBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"name\":\"writeEntry\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"dstChainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"}],\"name\":\"writeEntryWithVerification\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"}],\"stateMutability\":\"payable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"checkBatchVerification(address,(uint64,uint64,bytes32))\":{\"params\":{\"batch\":\"The Interchain Batch to check\",\"dstModule\":\"The destination chain addresses of the Interchain Modules to use for verification\"},\"returns\":{\"moduleVerifiedAt\":\"   The block timestamp at which the batch was verified by the module,                             or ZERO if the module has not verified the batch.\"}},\"getBatch(uint64)\":{\"details\":\"Will revert if the batch with the given nonce does not exist, or is not finalized.\",\"params\":{\"dbNonce\":\"The database nonce of the finalized batch\"}},\"getBatchLeafs(uint64)\":{\"details\":\"Will revert if the batch with the given nonce does not exist, or is not finalized.\",\"params\":{\"dbNonce\":\"The database nonce of the finalized batch\"}},\"getBatchLeafsPaginated(uint64,uint64,uint64)\":{\"details\":\"Will revert if the batch with the given nonce does not exist, or is not finalized. Will revert if the provided range is invalid.\",\"params\":{\"dbNonce\":\"The database nonce of the finalized batch\",\"end\":\"The end index of the paginated leafs, exclusive\",\"start\":\"The start index of the paginated leafs, inclusive\"}},\"getBatchRoot((uint64,uint64,uint64,bytes32,bytes32),bytes32[])\":{\"params\":{\"entry\":\"The Interchain Entry to get the batch root for\",\"proof\":\"The Merkle proof of inclusion for the entry in the batch\"}},\"getBatchSize(uint64)\":{\"details\":\"Will revert if the batch with the given nonce does not exist, or is not finalized.\",\"params\":{\"dbNonce\":\"The database nonce of the finalized batch\"}},\"getEntryProof(uint64,uint64)\":{\"details\":\"Will revert if the batch with the given nonce does not exist, or is not finalized. Will revert if the entry with the given index does not exist within the batch.\",\"params\":{\"dbNonce\":\"The database nonce of the finalized batch\",\"entryIndex\":\"The index of the written entry within the batch\"},\"returns\":{\"proof\":\"      The Merkle proof of inclusion for the entry\"}},\"getEntryValue(uint64,uint64)\":{\"details\":\"Will revert if the batch with the given nonce does not exist, or the entry with the given index does not exist within the batch.\",\"params\":{\"dbNonce\":\"The database nonce of the existing batch\",\"entryIndex\":\"The index of the written entry within the batch\"}},\"getInterchainFee(uint64,address[])\":{\"details\":\"Will revert if the empty array of modules is provided.\",\"params\":{\"dstChainId\":\"The chain id of the destination chain\",\"srcModules\":\"The source chain addresses of the Interchain Modules to use for verification\"}},\"getNextEntryIndex()\":{\"returns\":{\"dbNonce\":\"     The database nonce of the batch including the next entry\",\"entryIndex\":\"  The index of the next entry within that batch\"}},\"getVersionedBatch(uint64)\":{\"params\":{\"dbNonce\":\"The database nonce of the batch\"}},\"requestBatchVerification(uint64,uint64,address[])\":{\"details\":\"Will revert if the batch with the given nonce does not exist.\",\"params\":{\"dbNonce\":\"The database nonce of the existing batch\",\"dstChainId\":\"The chain id of the destination chain\",\"srcModules\":\"The source chain addresses of the Interchain Modules to use for verification\"}},\"verifyRemoteBatch(bytes)\":{\"details\":\"Will revert if the batch with the same nonce but a different non-empty root is already verified.\",\"params\":{\"versionedBatch\":\"The versioned Interchain Batch to verify\"}},\"writeEntry(bytes32)\":{\"params\":{\"dataHash\":\"The hash of the data to be written to the Interchain DataBase as a new entry\"},\"returns\":{\"dbNonce\":\"    The database nonce of the batch containing the written entry\",\"entryIndex\":\" The index of the written entry within the batch\"}},\"writeEntryWithVerification(uint64,bytes32,address[])\":{\"details\":\"Will revert if the empty array of modules is provided.\",\"params\":{\"dataHash\":\"The hash of the data to be written to the Interchain DataBase as a new entry\",\"dstChainId\":\"The chain id of the destination chain\",\"srcModules\":\"The source chain addresses of the Interchain Modules to use for verification\"},\"returns\":{\"dbNonce\":\"    The database nonce of the batch containing the written entry\",\"entryIndex\":\" The index of the written entry within the batch\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"DB_VERSION()\":{\"notice\":\"Get the version of the Interchain DataBase.\"},\"checkBatchVerification(address,(uint64,uint64,bytes32))\":{\"notice\":\"Check if the batch is verified by the Interchain Module on the destination chain. Note: returned zero value indicates that the module has not verified the batch.\"},\"getBatch(uint64)\":{\"notice\":\"Get the finalized Interchain Batch with the given nonce.\"},\"getBatchLeafs(uint64)\":{\"notice\":\"Returns the list of leafs of the finalized batch with the given nonce. Note: the leafs are ordered by the index of the written entry in the current batch, and the leafs value match the value of the written entry (srcWriter + dataHash hashed together).\"},\"getBatchLeafsPaginated(uint64,uint64,uint64)\":{\"notice\":\"Returns the list of leafs of the finalized batch with the given nonce, paginated by the given start and end indexes. The end index is exclusive. Note: this is useful when the batch contains a large number of leafs, and calling `getBatchLeafs` would result in a gas limit exceeded error.\"},\"getBatchRoot((uint64,uint64,uint64,bytes32,bytes32),bytes32[])\":{\"notice\":\"Get the batch root containing the Interchain Entry with the given index.\"},\"getBatchSize(uint64)\":{\"notice\":\"Returns the size of the finalized batch with the given nonce.\"},\"getDBNonce()\":{\"notice\":\"Get the nonce of the database, which is incremented every time a new batch is finalized. This is the nonce of the current non-finalized batch.\"},\"getEntryProof(uint64,uint64)\":{\"notice\":\"Get the Merkle proof of inclusion for the entry with the given index in the finalized batch with the given nonce.\"},\"getEntryValue(uint64,uint64)\":{\"notice\":\"Get the Interchain Entry's value written on the local chain with the given batch nonce and entry index. Entry value is calculated as the hash of the writer address and the written data hash. Note: the batch does not have to be finalized to fetch the entry value.\"},\"getInterchainFee(uint64,address[])\":{\"notice\":\"Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain using the provided Interchain Modules.\"},\"getNextEntryIndex()\":{\"notice\":\"Get the index of the next entry to be written to the database.\"},\"getVersionedBatch(uint64)\":{\"notice\":\"Get the versioned Interchain Batch with the given nonce. Note: will return a batch with an empty root if the batch does not exist, or is not finalized.\"},\"requestBatchVerification(uint64,uint64,address[])\":{\"notice\":\"Request the given Interchain Modules to verify an existing batch. If the batch is not finalized, the module will verify it after finalization. For the finalized batch the batch root is already available, and the module can verify it immediately. Note: every module has a separate fee paid in the native gas token of the source chain, and `msg.value` must be equal to the sum of all fees. Note: this method is permissionless, and anyone can request verification for any batch.\"},\"verifyRemoteBatch(bytes)\":{\"notice\":\"Allows the Interchain Module to verify the batch coming from the remote chain. The module SHOULD verify the exact finalized batch from the remote chain. If the batch with a given nonce is not finalized or does not exist, module CAN verify it with an empty root value. Once the batch is finalized, the module SHOULD re-verify the batch with the correct root value. Note: The DB will only accept the batch of the same version as the DB itself.\"},\"writeEntry(bytes32)\":{\"notice\":\"Write data to the Interchain DataBase as a new entry in the current batch. Note: there are no guarantees that this entry will be available for reading on any of the remote chains. Use `requestBatchVerification` to ensure that the entry is available for reading on the destination chain.\"},\"writeEntryWithVerification(uint64,bytes32,address[])\":{\"notice\":\"Write data to the Interchain DataBase as a new entry in the current batch. Then request the Interchain Modules to verify the batch containing the written entry on the destination chain. See `writeEntry` and `requestBatchVerification` for more details.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainDB.sol\":\"IInterchainDB\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainDB.sol\":{\"keccak256\":\"0x4dd7dd2bde0a2d89cb06f57f8772f18d4b0547c65abb43503e5fc2dedf60ac3e\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://e22ed31c26dd9174d0f333bf9d8d5916d407c0c99aa908c56a6c4156756a5e1e\",\"dweb:/ipfs/QmTi96nhB9Vr3SRq9qa24zbPvctFSNubneRuohgndhAqHK\"]}},\"version\":1}"},"hashes":{"DB_VERSION()":"15f53956","checkBatchVerification(address,(uint64,uint64,bytes32))":"e39682c1","getBatch(uint64)":"888775d9","getBatchLeafs(uint64)":"fc1ebc91","getBatchLeafsPaginated(uint64,uint64,uint64)":"1c679ac1","getBatchRoot((uint64,uint64,uint64,bytes32,bytes32),bytes32[])":"0166204f","getBatchSize(uint64)":"727a5f91","getDBNonce()":"f338140e","getEntryProof(uint64,uint64)":"fec8dfb9","getEntryValue(uint64,uint64)":"d180db6f","getInterchainFee(uint64,address[])":"b8ba4ba1","getNextEntryIndex()":"aa2f06ae","getVersionedBatch(uint64)":"c7265781","requestBatchVerification(uint64,uint64,address[])":"6c49312c","verifyRemoteBatch(bytes)":"d961a48e","writeEntry(bytes32)":"2ad8c706","writeEntryWithVerification(uint64,bytes32,address[])":"eb20fbfd"}},"solidity/InterchainDB.sol:IInterchainModule":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainDBEvents.sol\n\nabstract contract InterchainDBEvents {\n    /// @notice Emitted when a local entry is written to the database.\n    /// @param dbNonce      The nonce of the batch containing the entry.\n    /// @param entryIndex   The index of the entry within the batch.\n    /// @param srcWriter    The address of the writer.\n    /// @param dataHash     The written data hash.\n    event InterchainEntryWritten(\n        uint64 indexed dbNonce, uint64 entryIndex, bytes32 indexed srcWriter, bytes32 dataHash\n    );\n\n    /// @notice Emitted when a local batch is finalized.\n    /// @param dbNonce      The nonce of the finalized batch.\n    /// @param batchRoot    The Merkle root hash of the finalized batch.\n    event InterchainBatchFinalized(uint64 indexed dbNonce, bytes32 batchRoot);\n\n    /// @notice Emitted when a remote batch is verified by the Interchain Module.\n    /// @param module       The address of the Interchain Module that verified the batch.\n    /// @param srcChainId   The ID of the source chain.\n    /// @param dbNonce      The nonce of the verified batch.\n    /// @param batchRoot    The Merkle root hash of the verified batch.\n    event InterchainBatchVerified(\n        address indexed module, uint64 indexed srcChainId, uint64 indexed dbNonce, bytes32 batchRoot\n    );\n\n    /// @notice Emitted when a local batch is requested to be verified on a remote chain\n    /// using the set of Interchain Modules.\n    /// @param dstChainId   The ID of the destination chain.\n    /// @param dbNonce      The nonce of the batch to be verified.\n    /// @param batchRoot    The Merkle root hash of the batch to be verified.\n    /// @param srcModules   The addresses of the Interchain Modules that will verify the batch.\n    event InterchainBatchVerificationRequested(\n        uint64 indexed dstChainId, uint64 indexed dbNonce, bytes32 batchRoot, address[] srcModules\n    );\n}\n\n// contracts/interfaces/IInterchainModule.sol\n\n/// @notice Every Module may opt a different method to confirm the verified entries on destination chain,\n/// therefore this is not a part of a common interface.\ninterface IInterchainModule {\n    error InterchainModule__CallerNotInterchainDB(address caller);\n    error InterchainModule__ChainIdNotRemote(uint64 chainId);\n    error InterchainModule__FeeAmountBelowMin(uint256 feeAmount, uint256 minRequired);\n\n    /// @notice Request the verification of a batch from the Interchain DataBase by the module.\n    /// If the batch is not yet finalized, the verification on destination chain will be delayed until\n    /// the finalization is done and batch root is saved on the source chain.\n    /// Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`.\n    /// Note: this will eventually trigger `InterchainDB.verifyRemoteBatch(batch)` function on destination chain,\n    /// with no guarantee of ordering.\n    /// @dev Could be only called by the Interchain DataBase contract.\n    /// @param dstChainId       The chain id of the destination chain\n    /// @param batchNonce       The nonce of the batch on the source chain\n    /// @param versionedBatch   The versioned batch to verify\n    function requestBatchVerification(\n        uint64 dstChainId,\n        uint64 batchNonce,\n        bytes memory versionedBatch\n    )\n        external\n        payable;\n\n    /// @notice Get the Module fee for verifying a batch on the specified destination chain.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dbNonce      The database nonce of the batch on the source chain\n    function getModuleFee(uint64 dstChainId, uint64 dbNonce) external view returns (uint256);\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/VersionedPayload.sol\n\n// solhint-disable no-inline-assembly\n// solhint-disable ordering\nlibrary VersionedPayloadLib {\n    /// @notice Amount of bytes reserved for the version (uint16) in the versioned payload\n    uint256 internal constant VERSION_LENGTH = 2;\n\n    error VersionedPayload__PayloadTooShort(bytes versionedPayload);\n    error VersionedPayload__PrecompileFailed();\n\n    /// @notice Encodes the versioned payload into a single bytes array.\n    /// @param version  The payload's version.\n    /// @param payload  The payload to encode.\n    function encodeVersionedPayload(uint16 version, bytes memory payload) internal pure returns (bytes memory) {\n        return abi.encodePacked(version, payload);\n    }\n\n    /// @notice Extracts the version from the versioned payload (calldata reference).\n    /// @param versionedPayload     The versioned payload (calldata reference).\n    function getVersion(bytes calldata versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__PayloadTooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            version := shr(240, calldataload(versionedPayload.offset))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (calldata reference).\n    /// @dev The extracted payload is also returned as a calldata reference.\n    /// @param versionedPayload     The versioned payload.\n    function getPayload(bytes calldata versionedPayload) internal pure returns (bytes calldata) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__PayloadTooShort(versionedPayload);\n        }\n        return versionedPayload[VERSION_LENGTH:];\n    }\n\n    /// @notice Extracts the version from the versioned payload (memory reference).\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getVersionFromMemory(bytes memory versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__PayloadTooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            // We add 0x20 to skip the length of the bytes array.\n            version := shr(240, mload(add(versionedPayload, 0x20)))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (memory reference).\n    /// @dev The extracted payload is copied into a new memory location. Use `getPayload` when possible\n    /// to avoid extra memory allocation.\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getPayloadFromMemory(bytes memory versionedPayload) internal view returns (bytes memory payload) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__PayloadTooShort(versionedPayload);\n        }\n        // Figure how many bytes to copy and allocate the memory for the extracted payload.\n        uint256 toCopy;\n        unchecked {\n            toCopy = versionedPayload.length - VERSION_LENGTH;\n        }\n        payload = new bytes(toCopy);\n        // Use identity precompile (0x04) to copy the payload. Unlike MCOPY, this is available on all EVM chains.\n        bool res;\n        assembly {\n            // We add 0x20 to skip the length of the bytes array.\n            // We add 0x02 to skip the 2 bytes reserved for the version.\n            // Copy the payload to the previously allocated memory.\n            res := staticcall(gas(), 0x04, add(versionedPayload, 0x22), toCopy, add(payload, 0x20), toCopy)\n        }\n        if (!res) {\n            revert VersionedPayload__PrecompileFailed();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SafeCast.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value \u003e type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value \u003e type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value \u003e type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value \u003e type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value \u003e type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value \u003e type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value \u003e type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value \u003e type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value \u003e type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value \u003e type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value \u003e type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value \u003e type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value \u003e type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value \u003e type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value \u003e type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value \u003e type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value \u003e type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value \u003e type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value \u003e type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value \u003e type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value \u003e type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value \u003e type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value \u003e type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value \u003e type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value \u003e type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value \u003e type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value \u003e type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value \u003e type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value \u003e type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value \u003e type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value \u003e type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value \u003c 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value \u003e uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n}\n\n// contracts/libs/InterchainBatch.sol\n\ntype BatchKey is uint128;\n\n/// @notice Struct representing a batch of entries in the Interchain DataBase.\n/// Batched entries are put together in a Merkle tree, which root is saved.\n/// Batch has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: batchRoot\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch\n/// @param batchRoot    The root of the Merkle tree containing the batched entries\nstruct InterchainBatch {\n    uint64 srcChainId;\n    uint64 dbNonce;\n    bytes32 batchRoot;\n}\n\n/// @dev Signals that the module has not verified any batch with the given key.\nuint256 constant BATCH_UNVERIFIED = 0;\n/// @dev Signals that the module has verified a conflicting batch with the given key.\nuint256 constant BATCH_CONFLICT = type(uint256).max;\n\nlibrary InterchainBatchLib {\n    using VersionedPayloadLib for bytes;\n\n    /// @notice Constructs an InterchainBatch struct to be saved on the local chain.\n    /// @param dbNonce      The database nonce of the batch\n    /// @param batchRoot    The root of the Merkle tree containing the batched entries\n    /// @return batch       The constructed InterchainBatch struct\n    function constructLocalBatch(\n        uint64 dbNonce,\n        bytes32 batchRoot\n    )\n        internal\n        view\n        returns (InterchainBatch memory batch)\n    {\n        return InterchainBatch({srcChainId: SafeCast.toUint64(block.chainid), dbNonce: dbNonce, batchRoot: batchRoot});\n    }\n\n    /// @notice Encodes the InterchainBatch struct into a non-versioned batch payload.\n    function encodeBatch(InterchainBatch memory batch) internal pure returns (bytes memory) {\n        return abi.encode(encodeBatchKey(batch.srcChainId, batch.dbNonce), batch.batchRoot);\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in calldata.\n    function decodeBatch(bytes calldata data) internal pure returns (InterchainBatch memory batch) {\n        BatchKey key;\n        (key, batch.batchRoot) = abi.decode(data, (BatchKey, bytes32));\n        (batch.srcChainId, batch.dbNonce) = decodeBatchKey(key);\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in memory.\n    function decodeBatchFromMemory(bytes memory data) internal pure returns (InterchainBatch memory batch) {\n        BatchKey key;\n        (key, batch.batchRoot) = abi.decode(data, (BatchKey, bytes32));\n        (batch.srcChainId, batch.dbNonce) = decodeBatchKey(key);\n    }\n\n    /// @notice Encodes the uint128 key of the batch from uint64 srcChainId and uint64 dbNonce.\n    function encodeBatchKey(uint64 srcChainId, uint64 dbNonce) internal pure returns (BatchKey) {\n        return BatchKey.wrap((uint128(srcChainId) \u003c\u003c 64) | dbNonce);\n    }\n\n    /// @notice Decodes the uint128 key of the batch into uint64 srcChainId and uint64 dbNonce.\n    function decodeBatchKey(BatchKey key) internal pure returns (uint64 srcChainId, uint64 dbNonce) {\n        srcChainId = uint64(BatchKey.unwrap(key) \u003e\u003e 64);\n        dbNonce = uint64(BatchKey.unwrap(key));\n    }\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce + entryIndex\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch containing the entry\n/// @param entryIndex   The index of the entry in the batch\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint64 srcChainId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nusing InterchainEntryLib for InterchainEntry global;\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint64 dbNonce,\n        uint64 entryIndex,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: SafeCast.toUint64(block.chainid),\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return getEntryValue(entry.srcWriter, entry.dataHash);\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function getEntryValue(bytes32 srcWriter, bytes32 dataHash) internal pure returns (bytes32) {\n        return keccak256(abi.encode(srcWriter, dataHash));\n    }\n}\n\n// contracts/libs/BatchingV1.sol\n\nlibrary BatchingV1Lib {\n    error BatchingV1__EntryIndexNotZero(uint64 entryIndex);\n    error BatchingV1__ProofNotEmpty();\n\n    /// @notice Get the batch root containing the Interchain Entry with the given index.\n    /// @param srcWriter    The entry writer of the source chain\n    /// @param dataHash     The hash of the data of the entry\n    /// @param entryIndex   The index of the entry in the batch\n    /// @param proof        The Merkle proof of inclusion for the entry in the batch\n    /// @return batchRoot   The root of the batch containing the entry\n    function getBatchRoot(\n        bytes32 srcWriter,\n        bytes32 dataHash,\n        uint64 entryIndex,\n        bytes32[] calldata proof\n    )\n        internal\n        pure\n        returns (bytes32 batchRoot)\n    {\n        // In \"no batching\" mode: entry index is 0, proof is empty\n        if (entryIndex != 0) {\n            revert BatchingV1__EntryIndexNotZero(entryIndex);\n        }\n        if (proof.length != 0) {\n            revert BatchingV1__ProofNotEmpty();\n        }\n        // In \"no batching\" mode: the batch root is the same as the entry value\n        return InterchainEntryLib.getEntryValue({srcWriter: srcWriter, dataHash: dataHash});\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    error InterchainDB__BatchConflict(address module, bytes32 existingBatchRoot, InterchainBatch newBatch);\n    error InterchainDB__BatchVersionMismatch(uint16 version, uint16 required);\n    error InterchainDB__ChainIdNotRemote(uint64 chainId);\n    error InterchainDB__EntryIndexOutOfRange(uint64 dbNonce, uint64 entryIndex, uint64 batchSize);\n    error InterchainDB__EntryRangeInvalid(uint64 dbNonce, uint64 start, uint64 end);\n    error InterchainDB__FeeAmountBelowMin(uint256 feeAmount, uint256 minRequired);\n    error InterchainDB__ModulesNotProvided();\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `requestBatchVerification` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntry(bytes32 dataHash) external returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Request the given Interchain Modules to verify an existing batch.\n    /// If the batch is not finalized, the module will verify it after finalization.\n    /// For the finalized batch the batch root is already available, and the module can verify it immediately.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any batch.\n    /// @dev Will revert if the batch with the given nonce does not exist.\n    /// @param dstChainId    The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the existing batch\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestBatchVerification(\n        uint64 dstChainId,\n        uint64 dbNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Then request the Interchain Modules to verify the batch containing the written entry on the destination chain.\n    /// See `writeEntry` and `requestBatchVerification` for more details.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntryWithVerification(\n        uint64 dstChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Allows the Interchain Module to verify the batch coming from the remote chain.\n    /// The module SHOULD verify the exact finalized batch from the remote chain. If the batch with a given nonce\n    /// is not finalized or does not exist, module CAN verify it with an empty root value. Once the batch is\n    /// finalized, the module SHOULD re-verify the batch with the correct root value.\n    /// Note: The DB will only accept the batch of the same version as the DB itself.\n    /// @dev Will revert if the batch with the same nonce but a different non-empty root is already verified.\n    /// @param versionedBatch   The versioned Interchain Batch to verify\n    function verifyRemoteBatch(bytes memory versionedBatch) external;\n\n    //  VIEWS \n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint64 dstChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce.\n    /// Note: the leafs are ordered by the index of the written entry in the current batch,\n    /// and the leafs value match the value of the written entry (srcWriter + dataHash hashed together).\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchLeafs(uint64 dbNonce) external view returns (bytes32[] memory);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce,\n    /// paginated by the given start and end indexes. The end index is exclusive.\n    /// Note: this is useful when the batch contains a large number of leafs, and calling `getBatchLeafs`\n    /// would result in a gas limit exceeded error.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the provided range is invalid.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param start        The start index of the paginated leafs, inclusive\n    /// @param end          The end index of the paginated leafs, exclusive\n    function getBatchLeafsPaginated(\n        uint64 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory);\n\n    /// @notice Returns the size of the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchSize(uint64 dbNonce) external view returns (uint64);\n\n    /// @notice Get the finalized Interchain Batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatch(uint64 dbNonce) external view returns (InterchainBatch memory);\n\n    /// @notice Get the versioned Interchain Batch with the given nonce.\n    /// Note: will return a batch with an empty root if the batch does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the batch\n    function getVersionedBatch(uint64 dbNonce) external view returns (bytes memory);\n\n    /// @notice Get the Interchain Entry's value written on the local chain with the given batch nonce and entry index.\n    /// Entry value is calculated as the hash of the writer address and the written data hash.\n    /// Note: the batch does not have to be finalized to fetch the entry value.\n    /// @dev Will revert if the batch with the given nonce does not exist,\n    /// or the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the existing batch\n    /// @param entryIndex   The index of the written entry within the batch\n    function getEntryValue(uint64 dbNonce, uint64 entryIndex) external view returns (bytes32);\n\n    /// @notice Get the Merkle proof of inclusion for the entry with the given index\n    /// in the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param entryIndex   The index of the written entry within the batch\n    /// @return proof       The Merkle proof of inclusion for the entry\n    function getEntryProof(uint64 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof);\n\n    /// @notice Get the nonce of the database, which is incremented every time a new batch is finalized.\n    /// This is the nonce of the current non-finalized batch.\n    function getDBNonce() external view returns (uint64);\n\n    /// @notice Get the index of the next entry to be written to the database.\n    /// @return dbNonce      The database nonce of the batch including the next entry\n    /// @return entryIndex   The index of the next entry within that batch\n    function getNextEntryIndex() external view returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Check if the batch is verified by the Interchain Module on the destination chain.\n    /// Note: returned zero value indicates that the module has not verified the batch.\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @param batch        The Interchain Batch to check\n    /// @return moduleVerifiedAt    The block timestamp at which the batch was verified by the module,\n    ///                             or ZERO if the module has not verified the batch.\n    function checkBatchVerification(\n        address dstModule,\n        InterchainBatch memory batch\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n\n    /// @notice Get the batch root containing the Interchain Entry with the given index.\n    /// @param entry         The Interchain Entry to get the batch root for\n    /// @param proof         The Merkle proof of inclusion for the entry in the batch\n    function getBatchRoot(InterchainEntry memory entry, bytes32[] memory proof) external pure returns (bytes32);\n\n    /// @notice Get the version of the Interchain DataBase.\n    // solhint-disable-next-line func-name-mixedcase\n    function DB_VERSION() external pure returns (uint16);\n}\n\n// contracts/InterchainDB.sol\n\ncontract InterchainDB is InterchainDBEvents, IInterchainDB {\n    using VersionedPayloadLib for bytes;\n\n    /// @notice Struct representing a batch of entries from the remote Interchain DataBase,\n    /// verified by the Interchain Module.\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param batchRoot    The Merkle root of the batch\n    struct RemoteBatch {\n        uint256 verifiedAt;\n        bytes32 batchRoot;\n    }\n\n    uint16 public constant DB_VERSION = 1;\n\n    bytes32[] internal _entryValues;\n    mapping(address module =\u003e mapping(BatchKey batchKey =\u003e RemoteBatch batch)) internal _remoteBatches;\n\n    modifier onlyRemoteChainId(uint64 chainId) {\n        if (chainId == block.chainid) {\n            revert InterchainDB__ChainIdNotRemote(chainId);\n        }\n        _;\n    }\n\n    //  WRITER-FACING \n\n    /// @inheritdoc IInterchainDB\n    function writeEntry(bytes32 dataHash) external returns (uint64 dbNonce, uint64 entryIndex) {\n        InterchainEntry memory entry = _writeEntry(dataHash);\n        (dbNonce, entryIndex) = (entry.dbNonce, entry.entryIndex);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function requestBatchVerification(\n        uint64 dstChainId,\n        uint64 dbNonce,\n        address[] calldata srcModules\n    )\n        external\n        payable\n        onlyRemoteChainId(dstChainId)\n    {\n        InterchainBatch memory batch = getBatch(dbNonce);\n        _requestVerification(dstChainId, batch, srcModules);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function writeEntryWithVerification(\n        uint64 dstChainId,\n        bytes32 dataHash,\n        address[] calldata srcModules\n    )\n        external\n        payable\n        onlyRemoteChainId(dstChainId)\n        returns (uint64 dbNonce, uint64 entryIndex)\n    {\n        InterchainEntry memory entry = _writeEntry(dataHash);\n        (dbNonce, entryIndex) = (entry.dbNonce, entry.entryIndex);\n        // In \"no batching\" mode: the batch root is the same as the entry value\n        InterchainBatch memory batch = InterchainBatchLib.constructLocalBatch(dbNonce, entry.entryValue());\n        _requestVerification(dstChainId, batch, srcModules);\n    }\n\n    //  MODULE-FACING \n\n    /// @inheritdoc IInterchainDB\n    function verifyRemoteBatch(bytes calldata versionedBatch) external {\n        InterchainBatch memory batch = _assertCorrectBatch(versionedBatch);\n        BatchKey batchKey = InterchainBatchLib.encodeBatchKey({srcChainId: batch.srcChainId, dbNonce: batch.dbNonce});\n        RemoteBatch memory existingBatch = _remoteBatches[msg.sender][batchKey];\n        // Check if that's the first time module verifies the batch\n        if (existingBatch.verifiedAt == 0) {\n            _saveVerifiedBatch(msg.sender, batchKey, batch);\n            return;\n        }\n        // No-op if the batch root is the same\n        if (existingBatch.batchRoot == batch.batchRoot) {\n            return;\n        }\n        // Overwriting an empty (non-existent) batch with a different one is allowed\n        if (existingBatch.batchRoot == 0) {\n            _saveVerifiedBatch(msg.sender, batchKey, batch);\n            return;\n        }\n        // Overwriting an existing batch with a different one is not allowed\n        revert InterchainDB__BatchConflict(msg.sender, existingBatch.batchRoot, batch);\n    }\n\n    //  VIEWS \n\n    /// @inheritdoc IInterchainDB\n    function getBatchLeafs(uint64 dbNonce) external view returns (bytes32[] memory leafs) {\n        uint256 batchSize = getBatchSize(dbNonce);\n        leafs = new bytes32[](batchSize);\n        for (uint64 i = 0; i \u003c batchSize; ++i) {\n            leafs[i] = getEntryValue(dbNonce, i);\n        }\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getBatchLeafsPaginated(\n        uint64 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory leafs)\n    {\n        uint256 size = getBatchSize(dbNonce);\n        if (start \u003e end || end \u003e size) {\n            revert InterchainDB__EntryRangeInvalid(dbNonce, start, end);\n        }\n        leafs = new bytes32[](end - start);\n        for (uint64 i = start; i \u003c end; ++i) {\n            leafs[i - start] = getEntryValue(dbNonce, i);\n        }\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getEntryProof(uint64 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof) {\n        // In \"no batching\" mode: the batch root is the same as the entry value, hence the proof is empty\n        _assertEntryExists(dbNonce, entryIndex);\n        return new bytes32[](0);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getInterchainFee(uint64 dstChainId, address[] calldata srcModules) external view returns (uint256 fee) {\n        (, fee) = _getModuleFees(dstChainId, getDBNonce(), srcModules);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getNextEntryIndex() external view returns (uint64 dbNonce, uint64 entryIndex) {\n        // In \"no batching\" mode: entry index is 0, batch size is 1\n        dbNonce = getDBNonce();\n        entryIndex = 0;\n    }\n\n    /// @inheritdoc IInterchainDB\n    function checkBatchVerification(\n        address dstModule,\n        InterchainBatch memory batch\n    )\n        external\n        view\n        onlyRemoteChainId(batch.srcChainId)\n        returns (uint256 moduleVerifiedAt)\n    {\n        BatchKey batchKey = InterchainBatchLib.encodeBatchKey({srcChainId: batch.srcChainId, dbNonce: batch.dbNonce});\n        RemoteBatch memory remoteBatch = _remoteBatches[dstModule][batchKey];\n        // Check if module verified anything for this batch key first\n        if (remoteBatch.verifiedAt == 0) {\n            return BATCH_UNVERIFIED;\n        }\n        // Check if the batch root matches the one verified by the module\n        return remoteBatch.batchRoot == batch.batchRoot ? remoteBatch.verifiedAt : BATCH_CONFLICT;\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getVersionedBatch(uint64 dbNonce) external view returns (bytes memory versionedBatch) {\n        InterchainBatch memory batch = getBatch(dbNonce);\n        return VersionedPayloadLib.encodeVersionedPayload({\n            version: DB_VERSION,\n            payload: InterchainBatchLib.encodeBatch(batch)\n        });\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getBatchRoot(InterchainEntry memory entry, bytes32[] calldata proof) external pure returns (bytes32) {\n        return BatchingV1Lib.getBatchRoot({\n            srcWriter: entry.srcWriter,\n            dataHash: entry.dataHash,\n            entryIndex: entry.entryIndex,\n            proof: proof\n        });\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getBatchSize(uint64 dbNonce) public view returns (uint64) {\n        // In \"no batching\" mode: the finalized batch size is 1, the pending batch size is 0\n        // We also return 0 for non-existent batches\n        return dbNonce \u003c getDBNonce() ? 1 : 0;\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getBatch(uint64 dbNonce) public view returns (InterchainBatch memory) {\n        // In \"no batching\" mode: the batch root is the same as the entry hash.\n        // For non-finalized or non-existent batches, the batch root is 0.\n        bytes32 batchRoot = dbNonce \u003c getDBNonce() ? getEntryValue(dbNonce, 0) : bytes32(0);\n        return InterchainBatchLib.constructLocalBatch(dbNonce, batchRoot);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getEntryValue(uint64 dbNonce, uint64 entryIndex) public view returns (bytes32) {\n        _assertEntryExists(dbNonce, entryIndex);\n        return _entryValues[dbNonce];\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getDBNonce() public view returns (uint64) {\n        // We can do the unsafe cast here as writing more than 2^64 entries is practically impossible\n        return uint64(_entryValues.length);\n    }\n\n    //  INTERNAL LOGIC \n\n    /// @dev Write the entry to the database and emit the event.\n    function _writeEntry(bytes32 dataHash) internal returns (InterchainEntry memory entry) {\n        uint64 dbNonce = getDBNonce();\n        entry = InterchainEntryLib.constructLocalEntry({\n            dbNonce: dbNonce,\n            entryIndex: 0,\n            writer: msg.sender,\n            dataHash: dataHash\n        });\n        bytes32 entryValue = entry.entryValue();\n        _entryValues.push(entryValue);\n        emit InterchainEntryWritten({\n            dbNonce: dbNonce,\n            entryIndex: 0,\n            srcWriter: TypeCasts.addressToBytes32(msg.sender),\n            dataHash: dataHash\n        });\n        // In the InterchainDB V1 the batch is finalized immediately after the entry is written\n        emit InterchainBatchFinalized({dbNonce: dbNonce, batchRoot: entryValue});\n    }\n\n    /// @dev Request the verification of the entry by the modules, and emit the event.\n    /// Note: the validity of the passed entry and chain id being remote is enforced in the calling function.\n    function _requestVerification(\n        uint64 dstChainId,\n        InterchainBatch memory batch,\n        address[] calldata srcModules\n    )\n        internal\n    {\n        (uint256[] memory fees, uint256 totalFee) = _getModuleFees(dstChainId, batch.dbNonce, srcModules);\n        if (msg.value \u003c totalFee) {\n            revert InterchainDB__FeeAmountBelowMin(msg.value, totalFee);\n        } else if (msg.value \u003e totalFee) {\n            // The exceeding amount goes to the first module\n            fees[0] += msg.value - totalFee;\n        }\n        uint256 len = srcModules.length;\n        bytes memory versionedBatch = VersionedPayloadLib.encodeVersionedPayload({\n            version: DB_VERSION,\n            payload: InterchainBatchLib.encodeBatch(batch)\n        });\n        for (uint256 i = 0; i \u003c len; ++i) {\n            IInterchainModule(srcModules[i]).requestBatchVerification{value: fees[i]}(\n                dstChainId, batch.dbNonce, versionedBatch\n            );\n        }\n        emit InterchainBatchVerificationRequested(dstChainId, batch.dbNonce, batch.batchRoot, srcModules);\n    }\n\n    /// @dev Save the verified batch to the database and emit the event.\n    function _saveVerifiedBatch(address module, BatchKey batchKey, InterchainBatch memory batch) internal {\n        _remoteBatches[module][batchKey] = RemoteBatch({verifiedAt: block.timestamp, batchRoot: batch.batchRoot});\n        emit InterchainBatchVerified(module, batch.srcChainId, batch.dbNonce, batch.batchRoot);\n    }\n\n    //  INTERNAL VIEWS \n\n    /// @dev Asserts that the batch version is correct and that batch originates from a remote chain.\n    /// Note: returns the decoded batch for chaining purposes.\n    function _assertCorrectBatch(bytes calldata versionedBatch) internal view returns (InterchainBatch memory batch) {\n        uint16 dbVersion = versionedBatch.getVersion();\n        if (dbVersion != DB_VERSION) {\n            revert InterchainDB__BatchVersionMismatch(dbVersion, DB_VERSION);\n        }\n        batch = InterchainBatchLib.decodeBatch(versionedBatch.getPayload());\n        if (batch.srcChainId == block.chainid) {\n            revert InterchainDB__ChainIdNotRemote(batch.srcChainId);\n        }\n    }\n\n    /// @dev Check that the entry index is within the batch size. Also checks that the batch exists.\n    function _assertEntryExists(uint64 dbNonce, uint64 entryIndex) internal view {\n        // This will revert if the batch does not exist\n        uint64 batchSize = getBatchSize(dbNonce);\n        if (entryIndex \u003e= batchSize) {\n            revert InterchainDB__EntryIndexOutOfRange(dbNonce, entryIndex, batchSize);\n        }\n    }\n\n    /// @dev Get the verification fees for the modules\n    function _getModuleFees(\n        uint64 dstChainId,\n        uint64 dbNonce,\n        address[] calldata srcModules\n    )\n        internal\n        view\n        returns (uint256[] memory fees, uint256 totalFee)\n    {\n        uint256 len = srcModules.length;\n        if (len == 0) {\n            revert InterchainDB__ModulesNotProvided();\n        }\n        fees = new uint256[](len);\n        for (uint256 i = 0; i \u003c len; ++i) {\n            fees[i] = IInterchainModule(srcModules[i]).getModuleFee(dstChainId, dbNonce);\n            totalFee += fees[i];\n        }\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"address","name":"caller","type":"address"}],"name":"InterchainModule__CallerNotInterchainDB","type":"error"},{"inputs":[{"internalType":"uint64","name":"chainId","type":"uint64"}],"name":"InterchainModule__ChainIdNotRemote","type":"error"},{"inputs":[{"internalType":"uint256","name":"feeAmount","type":"uint256"},{"internalType":"uint256","name":"minRequired","type":"uint256"}],"name":"InterchainModule__FeeAmountBelowMin","type":"error"},{"inputs":[{"internalType":"uint64","name":"dstChainId","type":"uint64"},{"internalType":"uint64","name":"dbNonce","type":"uint64"}],"name":"getModuleFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint64","name":"dstChainId","type":"uint64"},{"internalType":"uint64","name":"batchNonce","type":"uint64"},{"internalType":"bytes","name":"versionedBatch","type":"bytes"}],"name":"requestBatchVerification","outputs":[],"stateMutability":"payable","type":"function"}],"userDoc":{"kind":"user","methods":{"getModuleFee(uint64,uint64)":{"notice":"Get the Module fee for verifying a batch on the specified destination chain."},"requestBatchVerification(uint64,uint64,bytes)":{"notice":"Request the verification of a batch from the Interchain DataBase by the module. If the batch is not yet finalized, the verification on destination chain will be delayed until the finalization is done and batch root is saved on the source chain. Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`. Note: this will eventually trigger `InterchainDB.verifyRemoteBatch(batch)` function on destination chain, with no guarantee of ordering."}},"notice":"Every Module may opt a different method to confirm the verified entries on destination chain, therefore this is not a part of a common interface.","version":1},"developerDoc":{"kind":"dev","methods":{"getModuleFee(uint64,uint64)":{"params":{"dbNonce":"The database nonce of the batch on the source chain","dstChainId":"The chain id of the destination chain"}},"requestBatchVerification(uint64,uint64,bytes)":{"details":"Could be only called by the Interchain DataBase contract.","params":{"batchNonce":"The nonce of the batch on the source chain","dstChainId":"The chain id of the destination chain","versionedBatch":"The versioned batch to verify"}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"InterchainModule__CallerNotInterchainDB\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"}],\"name\":\"InterchainModule__ChainIdNotRemote\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minRequired\",\"type\":\"uint256\"}],\"name\":\"InterchainModule__FeeAmountBelowMin\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"dstChainId\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"}],\"name\":\"getModuleFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"dstChainId\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"batchNonce\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"versionedBatch\",\"type\":\"bytes\"}],\"name\":\"requestBatchVerification\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"getModuleFee(uint64,uint64)\":{\"params\":{\"dbNonce\":\"The database nonce of the batch on the source chain\",\"dstChainId\":\"The chain id of the destination chain\"}},\"requestBatchVerification(uint64,uint64,bytes)\":{\"details\":\"Could be only called by the Interchain DataBase contract.\",\"params\":{\"batchNonce\":\"The nonce of the batch on the source chain\",\"dstChainId\":\"The chain id of the destination chain\",\"versionedBatch\":\"The versioned batch to verify\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"getModuleFee(uint64,uint64)\":{\"notice\":\"Get the Module fee for verifying a batch on the specified destination chain.\"},\"requestBatchVerification(uint64,uint64,bytes)\":{\"notice\":\"Request the verification of a batch from the Interchain DataBase by the module. If the batch is not yet finalized, the verification on destination chain will be delayed until the finalization is done and batch root is saved on the source chain. Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`. Note: this will eventually trigger `InterchainDB.verifyRemoteBatch(batch)` function on destination chain, with no guarantee of ordering.\"}},\"notice\":\"Every Module may opt a different method to confirm the verified entries on destination chain, therefore this is not a part of a common interface.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainDB.sol\":\"IInterchainModule\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainDB.sol\":{\"keccak256\":\"0x4dd7dd2bde0a2d89cb06f57f8772f18d4b0547c65abb43503e5fc2dedf60ac3e\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://e22ed31c26dd9174d0f333bf9d8d5916d407c0c99aa908c56a6c4156756a5e1e\",\"dweb:/ipfs/QmTi96nhB9Vr3SRq9qa24zbPvctFSNubneRuohgndhAqHK\"]}},\"version\":1}"},"hashes":{"getModuleFee(uint64,uint64)":"1888f4d4","requestBatchVerification(uint64,uint64,bytes)":"6b8d469f"}},"solidity/InterchainDB.sol:InterchainBatchLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122055ac2861a25cd4b9af4d0d48f900ce01c87e48cef21cde0c9d186688759b83fb64736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122055ac2861a25cd4b9af4d0d48f900ce01c87e48cef21cde0c9d186688759b83fb64736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainDBEvents.sol\n\nabstract contract InterchainDBEvents {\n    /// @notice Emitted when a local entry is written to the database.\n    /// @param dbNonce      The nonce of the batch containing the entry.\n    /// @param entryIndex   The index of the entry within the batch.\n    /// @param srcWriter    The address of the writer.\n    /// @param dataHash     The written data hash.\n    event InterchainEntryWritten(\n        uint64 indexed dbNonce, uint64 entryIndex, bytes32 indexed srcWriter, bytes32 dataHash\n    );\n\n    /// @notice Emitted when a local batch is finalized.\n    /// @param dbNonce      The nonce of the finalized batch.\n    /// @param batchRoot    The Merkle root hash of the finalized batch.\n    event InterchainBatchFinalized(uint64 indexed dbNonce, bytes32 batchRoot);\n\n    /// @notice Emitted when a remote batch is verified by the Interchain Module.\n    /// @param module       The address of the Interchain Module that verified the batch.\n    /// @param srcChainId   The ID of the source chain.\n    /// @param dbNonce      The nonce of the verified batch.\n    /// @param batchRoot    The Merkle root hash of the verified batch.\n    event InterchainBatchVerified(\n        address indexed module, uint64 indexed srcChainId, uint64 indexed dbNonce, bytes32 batchRoot\n    );\n\n    /// @notice Emitted when a local batch is requested to be verified on a remote chain\n    /// using the set of Interchain Modules.\n    /// @param dstChainId   The ID of the destination chain.\n    /// @param dbNonce      The nonce of the batch to be verified.\n    /// @param batchRoot    The Merkle root hash of the batch to be verified.\n    /// @param srcModules   The addresses of the Interchain Modules that will verify the batch.\n    event InterchainBatchVerificationRequested(\n        uint64 indexed dstChainId, uint64 indexed dbNonce, bytes32 batchRoot, address[] srcModules\n    );\n}\n\n// contracts/interfaces/IInterchainModule.sol\n\n/// @notice Every Module may opt a different method to confirm the verified entries on destination chain,\n/// therefore this is not a part of a common interface.\ninterface IInterchainModule {\n    error InterchainModule__CallerNotInterchainDB(address caller);\n    error InterchainModule__ChainIdNotRemote(uint64 chainId);\n    error InterchainModule__FeeAmountBelowMin(uint256 feeAmount, uint256 minRequired);\n\n    /// @notice Request the verification of a batch from the Interchain DataBase by the module.\n    /// If the batch is not yet finalized, the verification on destination chain will be delayed until\n    /// the finalization is done and batch root is saved on the source chain.\n    /// Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`.\n    /// Note: this will eventually trigger `InterchainDB.verifyRemoteBatch(batch)` function on destination chain,\n    /// with no guarantee of ordering.\n    /// @dev Could be only called by the Interchain DataBase contract.\n    /// @param dstChainId       The chain id of the destination chain\n    /// @param batchNonce       The nonce of the batch on the source chain\n    /// @param versionedBatch   The versioned batch to verify\n    function requestBatchVerification(\n        uint64 dstChainId,\n        uint64 batchNonce,\n        bytes memory versionedBatch\n    )\n        external\n        payable;\n\n    /// @notice Get the Module fee for verifying a batch on the specified destination chain.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dbNonce      The database nonce of the batch on the source chain\n    function getModuleFee(uint64 dstChainId, uint64 dbNonce) external view returns (uint256);\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/VersionedPayload.sol\n\n// solhint-disable no-inline-assembly\n// solhint-disable ordering\nlibrary VersionedPayloadLib {\n    /// @notice Amount of bytes reserved for the version (uint16) in the versioned payload\n    uint256 internal constant VERSION_LENGTH = 2;\n\n    error VersionedPayload__PayloadTooShort(bytes versionedPayload);\n    error VersionedPayload__PrecompileFailed();\n\n    /// @notice Encodes the versioned payload into a single bytes array.\n    /// @param version  The payload's version.\n    /// @param payload  The payload to encode.\n    function encodeVersionedPayload(uint16 version, bytes memory payload) internal pure returns (bytes memory) {\n        return abi.encodePacked(version, payload);\n    }\n\n    /// @notice Extracts the version from the versioned payload (calldata reference).\n    /// @param versionedPayload     The versioned payload (calldata reference).\n    function getVersion(bytes calldata versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__PayloadTooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            version := shr(240, calldataload(versionedPayload.offset))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (calldata reference).\n    /// @dev The extracted payload is also returned as a calldata reference.\n    /// @param versionedPayload     The versioned payload.\n    function getPayload(bytes calldata versionedPayload) internal pure returns (bytes calldata) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__PayloadTooShort(versionedPayload);\n        }\n        return versionedPayload[VERSION_LENGTH:];\n    }\n\n    /// @notice Extracts the version from the versioned payload (memory reference).\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getVersionFromMemory(bytes memory versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__PayloadTooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            // We add 0x20 to skip the length of the bytes array.\n            version := shr(240, mload(add(versionedPayload, 0x20)))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (memory reference).\n    /// @dev The extracted payload is copied into a new memory location. Use `getPayload` when possible\n    /// to avoid extra memory allocation.\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getPayloadFromMemory(bytes memory versionedPayload) internal view returns (bytes memory payload) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__PayloadTooShort(versionedPayload);\n        }\n        // Figure how many bytes to copy and allocate the memory for the extracted payload.\n        uint256 toCopy;\n        unchecked {\n            toCopy = versionedPayload.length - VERSION_LENGTH;\n        }\n        payload = new bytes(toCopy);\n        // Use identity precompile (0x04) to copy the payload. Unlike MCOPY, this is available on all EVM chains.\n        bool res;\n        assembly {\n            // We add 0x20 to skip the length of the bytes array.\n            // We add 0x02 to skip the 2 bytes reserved for the version.\n            // Copy the payload to the previously allocated memory.\n            res := staticcall(gas(), 0x04, add(versionedPayload, 0x22), toCopy, add(payload, 0x20), toCopy)\n        }\n        if (!res) {\n            revert VersionedPayload__PrecompileFailed();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SafeCast.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value \u003e type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value \u003e type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value \u003e type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value \u003e type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value \u003e type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value \u003e type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value \u003e type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value \u003e type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value \u003e type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value \u003e type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value \u003e type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value \u003e type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value \u003e type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value \u003e type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value \u003e type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value \u003e type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value \u003e type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value \u003e type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value \u003e type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value \u003e type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value \u003e type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value \u003e type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value \u003e type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value \u003e type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value \u003e type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value \u003e type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value \u003e type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value \u003e type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value \u003e type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value \u003e type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value \u003e type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value \u003c 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value \u003e uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n}\n\n// contracts/libs/InterchainBatch.sol\n\ntype BatchKey is uint128;\n\n/// @notice Struct representing a batch of entries in the Interchain DataBase.\n/// Batched entries are put together in a Merkle tree, which root is saved.\n/// Batch has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: batchRoot\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch\n/// @param batchRoot    The root of the Merkle tree containing the batched entries\nstruct InterchainBatch {\n    uint64 srcChainId;\n    uint64 dbNonce;\n    bytes32 batchRoot;\n}\n\n/// @dev Signals that the module has not verified any batch with the given key.\nuint256 constant BATCH_UNVERIFIED = 0;\n/// @dev Signals that the module has verified a conflicting batch with the given key.\nuint256 constant BATCH_CONFLICT = type(uint256).max;\n\nlibrary InterchainBatchLib {\n    using VersionedPayloadLib for bytes;\n\n    /// @notice Constructs an InterchainBatch struct to be saved on the local chain.\n    /// @param dbNonce      The database nonce of the batch\n    /// @param batchRoot    The root of the Merkle tree containing the batched entries\n    /// @return batch       The constructed InterchainBatch struct\n    function constructLocalBatch(\n        uint64 dbNonce,\n        bytes32 batchRoot\n    )\n        internal\n        view\n        returns (InterchainBatch memory batch)\n    {\n        return InterchainBatch({srcChainId: SafeCast.toUint64(block.chainid), dbNonce: dbNonce, batchRoot: batchRoot});\n    }\n\n    /// @notice Encodes the InterchainBatch struct into a non-versioned batch payload.\n    function encodeBatch(InterchainBatch memory batch) internal pure returns (bytes memory) {\n        return abi.encode(encodeBatchKey(batch.srcChainId, batch.dbNonce), batch.batchRoot);\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in calldata.\n    function decodeBatch(bytes calldata data) internal pure returns (InterchainBatch memory batch) {\n        BatchKey key;\n        (key, batch.batchRoot) = abi.decode(data, (BatchKey, bytes32));\n        (batch.srcChainId, batch.dbNonce) = decodeBatchKey(key);\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in memory.\n    function decodeBatchFromMemory(bytes memory data) internal pure returns (InterchainBatch memory batch) {\n        BatchKey key;\n        (key, batch.batchRoot) = abi.decode(data, (BatchKey, bytes32));\n        (batch.srcChainId, batch.dbNonce) = decodeBatchKey(key);\n    }\n\n    /// @notice Encodes the uint128 key of the batch from uint64 srcChainId and uint64 dbNonce.\n    function encodeBatchKey(uint64 srcChainId, uint64 dbNonce) internal pure returns (BatchKey) {\n        return BatchKey.wrap((uint128(srcChainId) \u003c\u003c 64) | dbNonce);\n    }\n\n    /// @notice Decodes the uint128 key of the batch into uint64 srcChainId and uint64 dbNonce.\n    function decodeBatchKey(BatchKey key) internal pure returns (uint64 srcChainId, uint64 dbNonce) {\n        srcChainId = uint64(BatchKey.unwrap(key) \u003e\u003e 64);\n        dbNonce = uint64(BatchKey.unwrap(key));\n    }\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce + entryIndex\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch containing the entry\n/// @param entryIndex   The index of the entry in the batch\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint64 srcChainId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nusing InterchainEntryLib for InterchainEntry global;\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint64 dbNonce,\n        uint64 entryIndex,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: SafeCast.toUint64(block.chainid),\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return getEntryValue(entry.srcWriter, entry.dataHash);\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function getEntryValue(bytes32 srcWriter, bytes32 dataHash) internal pure returns (bytes32) {\n        return keccak256(abi.encode(srcWriter, dataHash));\n    }\n}\n\n// contracts/libs/BatchingV1.sol\n\nlibrary BatchingV1Lib {\n    error BatchingV1__EntryIndexNotZero(uint64 entryIndex);\n    error BatchingV1__ProofNotEmpty();\n\n    /// @notice Get the batch root containing the Interchain Entry with the given index.\n    /// @param srcWriter    The entry writer of the source chain\n    /// @param dataHash     The hash of the data of the entry\n    /// @param entryIndex   The index of the entry in the batch\n    /// @param proof        The Merkle proof of inclusion for the entry in the batch\n    /// @return batchRoot   The root of the batch containing the entry\n    function getBatchRoot(\n        bytes32 srcWriter,\n        bytes32 dataHash,\n        uint64 entryIndex,\n        bytes32[] calldata proof\n    )\n        internal\n        pure\n        returns (bytes32 batchRoot)\n    {\n        // In \"no batching\" mode: entry index is 0, proof is empty\n        if (entryIndex != 0) {\n            revert BatchingV1__EntryIndexNotZero(entryIndex);\n        }\n        if (proof.length != 0) {\n            revert BatchingV1__ProofNotEmpty();\n        }\n        // In \"no batching\" mode: the batch root is the same as the entry value\n        return InterchainEntryLib.getEntryValue({srcWriter: srcWriter, dataHash: dataHash});\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    error InterchainDB__BatchConflict(address module, bytes32 existingBatchRoot, InterchainBatch newBatch);\n    error InterchainDB__BatchVersionMismatch(uint16 version, uint16 required);\n    error InterchainDB__ChainIdNotRemote(uint64 chainId);\n    error InterchainDB__EntryIndexOutOfRange(uint64 dbNonce, uint64 entryIndex, uint64 batchSize);\n    error InterchainDB__EntryRangeInvalid(uint64 dbNonce, uint64 start, uint64 end);\n    error InterchainDB__FeeAmountBelowMin(uint256 feeAmount, uint256 minRequired);\n    error InterchainDB__ModulesNotProvided();\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `requestBatchVerification` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntry(bytes32 dataHash) external returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Request the given Interchain Modules to verify an existing batch.\n    /// If the batch is not finalized, the module will verify it after finalization.\n    /// For the finalized batch the batch root is already available, and the module can verify it immediately.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any batch.\n    /// @dev Will revert if the batch with the given nonce does not exist.\n    /// @param dstChainId    The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the existing batch\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestBatchVerification(\n        uint64 dstChainId,\n        uint64 dbNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Then request the Interchain Modules to verify the batch containing the written entry on the destination chain.\n    /// See `writeEntry` and `requestBatchVerification` for more details.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntryWithVerification(\n        uint64 dstChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Allows the Interchain Module to verify the batch coming from the remote chain.\n    /// The module SHOULD verify the exact finalized batch from the remote chain. If the batch with a given nonce\n    /// is not finalized or does not exist, module CAN verify it with an empty root value. Once the batch is\n    /// finalized, the module SHOULD re-verify the batch with the correct root value.\n    /// Note: The DB will only accept the batch of the same version as the DB itself.\n    /// @dev Will revert if the batch with the same nonce but a different non-empty root is already verified.\n    /// @param versionedBatch   The versioned Interchain Batch to verify\n    function verifyRemoteBatch(bytes memory versionedBatch) external;\n\n    //  VIEWS \n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint64 dstChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce.\n    /// Note: the leafs are ordered by the index of the written entry in the current batch,\n    /// and the leafs value match the value of the written entry (srcWriter + dataHash hashed together).\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchLeafs(uint64 dbNonce) external view returns (bytes32[] memory);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce,\n    /// paginated by the given start and end indexes. The end index is exclusive.\n    /// Note: this is useful when the batch contains a large number of leafs, and calling `getBatchLeafs`\n    /// would result in a gas limit exceeded error.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the provided range is invalid.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param start        The start index of the paginated leafs, inclusive\n    /// @param end          The end index of the paginated leafs, exclusive\n    function getBatchLeafsPaginated(\n        uint64 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory);\n\n    /// @notice Returns the size of the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchSize(uint64 dbNonce) external view returns (uint64);\n\n    /// @notice Get the finalized Interchain Batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatch(uint64 dbNonce) external view returns (InterchainBatch memory);\n\n    /// @notice Get the versioned Interchain Batch with the given nonce.\n    /// Note: will return a batch with an empty root if the batch does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the batch\n    function getVersionedBatch(uint64 dbNonce) external view returns (bytes memory);\n\n    /// @notice Get the Interchain Entry's value written on the local chain with the given batch nonce and entry index.\n    /// Entry value is calculated as the hash of the writer address and the written data hash.\n    /// Note: the batch does not have to be finalized to fetch the entry value.\n    /// @dev Will revert if the batch with the given nonce does not exist,\n    /// or the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the existing batch\n    /// @param entryIndex   The index of the written entry within the batch\n    function getEntryValue(uint64 dbNonce, uint64 entryIndex) external view returns (bytes32);\n\n    /// @notice Get the Merkle proof of inclusion for the entry with the given index\n    /// in the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param entryIndex   The index of the written entry within the batch\n    /// @return proof       The Merkle proof of inclusion for the entry\n    function getEntryProof(uint64 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof);\n\n    /// @notice Get the nonce of the database, which is incremented every time a new batch is finalized.\n    /// This is the nonce of the current non-finalized batch.\n    function getDBNonce() external view returns (uint64);\n\n    /// @notice Get the index of the next entry to be written to the database.\n    /// @return dbNonce      The database nonce of the batch including the next entry\n    /// @return entryIndex   The index of the next entry within that batch\n    function getNextEntryIndex() external view returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Check if the batch is verified by the Interchain Module on the destination chain.\n    /// Note: returned zero value indicates that the module has not verified the batch.\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @param batch        The Interchain Batch to check\n    /// @return moduleVerifiedAt    The block timestamp at which the batch was verified by the module,\n    ///                             or ZERO if the module has not verified the batch.\n    function checkBatchVerification(\n        address dstModule,\n        InterchainBatch memory batch\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n\n    /// @notice Get the batch root containing the Interchain Entry with the given index.\n    /// @param entry         The Interchain Entry to get the batch root for\n    /// @param proof         The Merkle proof of inclusion for the entry in the batch\n    function getBatchRoot(InterchainEntry memory entry, bytes32[] memory proof) external pure returns (bytes32);\n\n    /// @notice Get the version of the Interchain DataBase.\n    // solhint-disable-next-line func-name-mixedcase\n    function DB_VERSION() external pure returns (uint16);\n}\n\n// contracts/InterchainDB.sol\n\ncontract InterchainDB is InterchainDBEvents, IInterchainDB {\n    using VersionedPayloadLib for bytes;\n\n    /// @notice Struct representing a batch of entries from the remote Interchain DataBase,\n    /// verified by the Interchain Module.\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param batchRoot    The Merkle root of the batch\n    struct RemoteBatch {\n        uint256 verifiedAt;\n        bytes32 batchRoot;\n    }\n\n    uint16 public constant DB_VERSION = 1;\n\n    bytes32[] internal _entryValues;\n    mapping(address module =\u003e mapping(BatchKey batchKey =\u003e RemoteBatch batch)) internal _remoteBatches;\n\n    modifier onlyRemoteChainId(uint64 chainId) {\n        if (chainId == block.chainid) {\n            revert InterchainDB__ChainIdNotRemote(chainId);\n        }\n        _;\n    }\n\n    //  WRITER-FACING \n\n    /// @inheritdoc IInterchainDB\n    function writeEntry(bytes32 dataHash) external returns (uint64 dbNonce, uint64 entryIndex) {\n        InterchainEntry memory entry = _writeEntry(dataHash);\n        (dbNonce, entryIndex) = (entry.dbNonce, entry.entryIndex);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function requestBatchVerification(\n        uint64 dstChainId,\n        uint64 dbNonce,\n        address[] calldata srcModules\n    )\n        external\n        payable\n        onlyRemoteChainId(dstChainId)\n    {\n        InterchainBatch memory batch = getBatch(dbNonce);\n        _requestVerification(dstChainId, batch, srcModules);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function writeEntryWithVerification(\n        uint64 dstChainId,\n        bytes32 dataHash,\n        address[] calldata srcModules\n    )\n        external\n        payable\n        onlyRemoteChainId(dstChainId)\n        returns (uint64 dbNonce, uint64 entryIndex)\n    {\n        InterchainEntry memory entry = _writeEntry(dataHash);\n        (dbNonce, entryIndex) = (entry.dbNonce, entry.entryIndex);\n        // In \"no batching\" mode: the batch root is the same as the entry value\n        InterchainBatch memory batch = InterchainBatchLib.constructLocalBatch(dbNonce, entry.entryValue());\n        _requestVerification(dstChainId, batch, srcModules);\n    }\n\n    //  MODULE-FACING \n\n    /// @inheritdoc IInterchainDB\n    function verifyRemoteBatch(bytes calldata versionedBatch) external {\n        InterchainBatch memory batch = _assertCorrectBatch(versionedBatch);\n        BatchKey batchKey = InterchainBatchLib.encodeBatchKey({srcChainId: batch.srcChainId, dbNonce: batch.dbNonce});\n        RemoteBatch memory existingBatch = _remoteBatches[msg.sender][batchKey];\n        // Check if that's the first time module verifies the batch\n        if (existingBatch.verifiedAt == 0) {\n            _saveVerifiedBatch(msg.sender, batchKey, batch);\n            return;\n        }\n        // No-op if the batch root is the same\n        if (existingBatch.batchRoot == batch.batchRoot) {\n            return;\n        }\n        // Overwriting an empty (non-existent) batch with a different one is allowed\n        if (existingBatch.batchRoot == 0) {\n            _saveVerifiedBatch(msg.sender, batchKey, batch);\n            return;\n        }\n        // Overwriting an existing batch with a different one is not allowed\n        revert InterchainDB__BatchConflict(msg.sender, existingBatch.batchRoot, batch);\n    }\n\n    //  VIEWS \n\n    /// @inheritdoc IInterchainDB\n    function getBatchLeafs(uint64 dbNonce) external view returns (bytes32[] memory leafs) {\n        uint256 batchSize = getBatchSize(dbNonce);\n        leafs = new bytes32[](batchSize);\n        for (uint64 i = 0; i \u003c batchSize; ++i) {\n            leafs[i] = getEntryValue(dbNonce, i);\n        }\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getBatchLeafsPaginated(\n        uint64 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory leafs)\n    {\n        uint256 size = getBatchSize(dbNonce);\n        if (start \u003e end || end \u003e size) {\n            revert InterchainDB__EntryRangeInvalid(dbNonce, start, end);\n        }\n        leafs = new bytes32[](end - start);\n        for (uint64 i = start; i \u003c end; ++i) {\n            leafs[i - start] = getEntryValue(dbNonce, i);\n        }\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getEntryProof(uint64 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof) {\n        // In \"no batching\" mode: the batch root is the same as the entry value, hence the proof is empty\n        _assertEntryExists(dbNonce, entryIndex);\n        return new bytes32[](0);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getInterchainFee(uint64 dstChainId, address[] calldata srcModules) external view returns (uint256 fee) {\n        (, fee) = _getModuleFees(dstChainId, getDBNonce(), srcModules);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getNextEntryIndex() external view returns (uint64 dbNonce, uint64 entryIndex) {\n        // In \"no batching\" mode: entry index is 0, batch size is 1\n        dbNonce = getDBNonce();\n        entryIndex = 0;\n    }\n\n    /// @inheritdoc IInterchainDB\n    function checkBatchVerification(\n        address dstModule,\n        InterchainBatch memory batch\n    )\n        external\n        view\n        onlyRemoteChainId(batch.srcChainId)\n        returns (uint256 moduleVerifiedAt)\n    {\n        BatchKey batchKey = InterchainBatchLib.encodeBatchKey({srcChainId: batch.srcChainId, dbNonce: batch.dbNonce});\n        RemoteBatch memory remoteBatch = _remoteBatches[dstModule][batchKey];\n        // Check if module verified anything for this batch key first\n        if (remoteBatch.verifiedAt == 0) {\n            return BATCH_UNVERIFIED;\n        }\n        // Check if the batch root matches the one verified by the module\n        return remoteBatch.batchRoot == batch.batchRoot ? remoteBatch.verifiedAt : BATCH_CONFLICT;\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getVersionedBatch(uint64 dbNonce) external view returns (bytes memory versionedBatch) {\n        InterchainBatch memory batch = getBatch(dbNonce);\n        return VersionedPayloadLib.encodeVersionedPayload({\n            version: DB_VERSION,\n            payload: InterchainBatchLib.encodeBatch(batch)\n        });\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getBatchRoot(InterchainEntry memory entry, bytes32[] calldata proof) external pure returns (bytes32) {\n        return BatchingV1Lib.getBatchRoot({\n            srcWriter: entry.srcWriter,\n            dataHash: entry.dataHash,\n            entryIndex: entry.entryIndex,\n            proof: proof\n        });\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getBatchSize(uint64 dbNonce) public view returns (uint64) {\n        // In \"no batching\" mode: the finalized batch size is 1, the pending batch size is 0\n        // We also return 0 for non-existent batches\n        return dbNonce \u003c getDBNonce() ? 1 : 0;\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getBatch(uint64 dbNonce) public view returns (InterchainBatch memory) {\n        // In \"no batching\" mode: the batch root is the same as the entry hash.\n        // For non-finalized or non-existent batches, the batch root is 0.\n        bytes32 batchRoot = dbNonce \u003c getDBNonce() ? getEntryValue(dbNonce, 0) : bytes32(0);\n        return InterchainBatchLib.constructLocalBatch(dbNonce, batchRoot);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getEntryValue(uint64 dbNonce, uint64 entryIndex) public view returns (bytes32) {\n        _assertEntryExists(dbNonce, entryIndex);\n        return _entryValues[dbNonce];\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getDBNonce() public view returns (uint64) {\n        // We can do the unsafe cast here as writing more than 2^64 entries is practically impossible\n        return uint64(_entryValues.length);\n    }\n\n    //  INTERNAL LOGIC \n\n    /// @dev Write the entry to the database and emit the event.\n    function _writeEntry(bytes32 dataHash) internal returns (InterchainEntry memory entry) {\n        uint64 dbNonce = getDBNonce();\n        entry = InterchainEntryLib.constructLocalEntry({\n            dbNonce: dbNonce,\n            entryIndex: 0,\n            writer: msg.sender,\n            dataHash: dataHash\n        });\n        bytes32 entryValue = entry.entryValue();\n        _entryValues.push(entryValue);\n        emit InterchainEntryWritten({\n            dbNonce: dbNonce,\n            entryIndex: 0,\n            srcWriter: TypeCasts.addressToBytes32(msg.sender),\n            dataHash: dataHash\n        });\n        // In the InterchainDB V1 the batch is finalized immediately after the entry is written\n        emit InterchainBatchFinalized({dbNonce: dbNonce, batchRoot: entryValue});\n    }\n\n    /// @dev Request the verification of the entry by the modules, and emit the event.\n    /// Note: the validity of the passed entry and chain id being remote is enforced in the calling function.\n    function _requestVerification(\n        uint64 dstChainId,\n        InterchainBatch memory batch,\n        address[] calldata srcModules\n    )\n        internal\n    {\n        (uint256[] memory fees, uint256 totalFee) = _getModuleFees(dstChainId, batch.dbNonce, srcModules);\n        if (msg.value \u003c totalFee) {\n            revert InterchainDB__FeeAmountBelowMin(msg.value, totalFee);\n        } else if (msg.value \u003e totalFee) {\n            // The exceeding amount goes to the first module\n            fees[0] += msg.value - totalFee;\n        }\n        uint256 len = srcModules.length;\n        bytes memory versionedBatch = VersionedPayloadLib.encodeVersionedPayload({\n            version: DB_VERSION,\n            payload: InterchainBatchLib.encodeBatch(batch)\n        });\n        for (uint256 i = 0; i \u003c len; ++i) {\n            IInterchainModule(srcModules[i]).requestBatchVerification{value: fees[i]}(\n                dstChainId, batch.dbNonce, versionedBatch\n            );\n        }\n        emit InterchainBatchVerificationRequested(dstChainId, batch.dbNonce, batch.batchRoot, srcModules);\n    }\n\n    /// @dev Save the verified batch to the database and emit the event.\n    function _saveVerifiedBatch(address module, BatchKey batchKey, InterchainBatch memory batch) internal {\n        _remoteBatches[module][batchKey] = RemoteBatch({verifiedAt: block.timestamp, batchRoot: batch.batchRoot});\n        emit InterchainBatchVerified(module, batch.srcChainId, batch.dbNonce, batch.batchRoot);\n    }\n\n    //  INTERNAL VIEWS \n\n    /// @dev Asserts that the batch version is correct and that batch originates from a remote chain.\n    /// Note: returns the decoded batch for chaining purposes.\n    function _assertCorrectBatch(bytes calldata versionedBatch) internal view returns (InterchainBatch memory batch) {\n        uint16 dbVersion = versionedBatch.getVersion();\n        if (dbVersion != DB_VERSION) {\n            revert InterchainDB__BatchVersionMismatch(dbVersion, DB_VERSION);\n        }\n        batch = InterchainBatchLib.decodeBatch(versionedBatch.getPayload());\n        if (batch.srcChainId == block.chainid) {\n            revert InterchainDB__ChainIdNotRemote(batch.srcChainId);\n        }\n    }\n\n    /// @dev Check that the entry index is within the batch size. Also checks that the batch exists.\n    function _assertEntryExists(uint64 dbNonce, uint64 entryIndex) internal view {\n        // This will revert if the batch does not exist\n        uint64 batchSize = getBatchSize(dbNonce);\n        if (entryIndex \u003e= batchSize) {\n            revert InterchainDB__EntryIndexOutOfRange(dbNonce, entryIndex, batchSize);\n        }\n    }\n\n    /// @dev Get the verification fees for the modules\n    function _getModuleFees(\n        uint64 dstChainId,\n        uint64 dbNonce,\n        address[] calldata srcModules\n    )\n        internal\n        view\n        returns (uint256[] memory fees, uint256 totalFee)\n    {\n        uint256 len = srcModules.length;\n        if (len == 0) {\n            revert InterchainDB__ModulesNotProvided();\n        }\n        fees = new uint256[](len);\n        for (uint256 i = 0; i \u003c len; ++i) {\n            fees[i] = IInterchainModule(srcModules[i]).getModuleFee(dstChainId, dbNonce);\n            totalFee += fees[i];\n        }\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"43570:2269:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;43570:2269:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"43570:2269:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainDB.sol\":\"InterchainBatchLib\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainDB.sol\":{\"keccak256\":\"0x4dd7dd2bde0a2d89cb06f57f8772f18d4b0547c65abb43503e5fc2dedf60ac3e\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://e22ed31c26dd9174d0f333bf9d8d5916d407c0c99aa908c56a6c4156756a5e1e\",\"dweb:/ipfs/QmTi96nhB9Vr3SRq9qa24zbPvctFSNubneRuohgndhAqHK\"]}},\"version\":1}"},"hashes":{}},"solidity/InterchainDB.sol:InterchainDB":{"code":"0x608060405234801561001057600080fd5b50611dfd806100206000396000f3fe60806040526004361061010e5760003560e01c8063b8ba4ba1116100a5578063e39682c111610074578063f338140e11610059578063f338140e1461032c578063fc1ebc9114610341578063fec8dfb91461036157600080fd5b8063e39682c1146102f9578063eb20fbfd1461031957600080fd5b8063b8ba4ba11461026c578063c72657811461028c578063d180db6f146102b9578063d961a48e146102d957600080fd5b80636c49312c116100e15780636c49312c146101dc578063727a5f91146101f1578063888775d91461022a578063aa2f06ae1461025757600080fd5b80630166204f1461011357806315f53956146101465780631c679ac11461016e5780632ad8c7061461019b575b600080fd5b34801561011f57600080fd5b5061013361012e3660046115d5565b610381565b6040519081526020015b60405180910390f35b34801561015257600080fd5b5061015b600181565b60405161ffff909116815260200161013d565b34801561017a57600080fd5b5061018e6101893660046116bc565b6103a4565b60405161013d91906116ff565b3480156101a757600080fd5b506101bb6101b6366004611743565b610509565b6040805167ffffffffffffffff93841681529290911660208301520161013d565b6101ef6101ea36600461175c565b61052d565b005b3480156101fd57600080fd5b5061021161020c3660046117bd565b61059e565b60405167ffffffffffffffff909116815260200161013d565b34801561023657600080fd5b5061024a6102453660046117bd565b6105cf565b60405161013d91906117d8565b34801561026357600080fd5b506101bb61062f565b34801561027857600080fd5b50610133610287366004611808565b610644565b34801561029857600080fd5b506102ac6102a73660046117bd565b610663565b60405161013d91906118bc565b3480156102c557600080fd5b506101336102d43660046118cf565b610685565b3480156102e557600080fd5b506101ef6102f4366004611902565b6106c2565b34801561030557600080fd5b50610133610314366004611998565b6107cb565b6101bb610327366004611a67565b610905565b34801561033857600080fd5b50600054610211565b34801561034d57600080fd5b5061018e61035c3660046117bd565b6109d8565b34801561036d57600080fd5b5061018e61037c3660046118cf565b610a93565b600061039c8460600151856080015186604001518686610ab5565b949350505050565b606060006103b18561059e565b67ffffffffffffffff1690508267ffffffffffffffff168467ffffffffffffffff1611806103e85750808367ffffffffffffffff16115b15610440576040517f72833e0d00000000000000000000000000000000000000000000000000000000815267ffffffffffffffff80871660048301528086166024830152841660448201526064015b60405180910390fd5b61044a8484611ad8565b67ffffffffffffffff1667ffffffffffffffff81111561046c5761046c611544565b604051908082528060200260200182016040528015610495578160200160208202803683370190505b509150835b8367ffffffffffffffff168167ffffffffffffffff161015610500576104c08682610685565b836104cb8784611ad8565b67ffffffffffffffff16815181106104e5576104e5611af9565b60209081029190910101526104f981611b28565b905061049a565b50509392505050565b600080600061051784610b6d565b6020810151604090910151909590945092505050565b83468167ffffffffffffffff160361057d576040517fd9e106b000000000000000000000000000000000000000000000000000000000815267ffffffffffffffff82166004820152602401610437565b6000610588856105cf565b905061059686828686610cb1565b505050505050565b6000805467ffffffffffffffff168267ffffffffffffffff16106105c35760006105c6565b60015b60ff1692915050565b60408051606081018252600080825260208201819052918101919091526000805467ffffffffffffffff168367ffffffffffffffff161061061157600061061c565b61061c836000610685565b90506106288382610e8e565b9392505050565b60008061063b60005490565b92600092509050565b600061065a8461065360005490565b8585610eea565b95945050505050565b60606000610670836105cf565b90506106286001610680836110a1565b611114565b60006106918383611140565b60008367ffffffffffffffff16815481106106ae576106ae611af9565b906000526020600020015490505b92915050565b60006106ce83836111bb565b905060006107058260000151836020015167ffffffffffffffff1660409190911b6fffffffffffffffff0000000000000000161790565b3360009081526001602081815260408084206fffffffffffffffffffffffffffffffff861685528252808420815180830190925280548083529301549181019190915292935090036107635761075c338385611299565b5050505050565b8260400151816020015103610779575050505050565b60208101516000036107905761075c338385611299565b60208101516040517f5aa9d5ae0000000000000000000000000000000000000000000000000000000081526104379133918690600401611b4f565b80516000904667ffffffffffffffff82160361081f576040517fd9e106b000000000000000000000000000000000000000000000000000000000815267ffffffffffffffff82166004820152602401610437565b60006108548460000151856020015167ffffffffffffffff1660409190911b6fffffffffffffffff0000000000000000161790565b73ffffffffffffffffffffffffffffffffffffffff861660009081526001602081815260408084206fffffffffffffffffffffffffffffffff861685528252808420815180830190925280548083529301549181019190915292935090036108c1576000935050506108fe565b84604001518160200151146108f6577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff6108f9565b80515b935050505b5092915050565b60008085468167ffffffffffffffff1603610958576040517fd9e106b000000000000000000000000000000000000000000000000000000000815267ffffffffffffffff82166004820152602401610437565b600061096387610b6d565b602081015160408201519095509350905060006109be856109b98460006106bc82606001518360800151604080516020808201949094528082019290925280518083038201815260609092019052805191012090565b610e8e565b90506109cc89828989610cb1565b50505094509492505050565b606060006109e58361059e565b67ffffffffffffffff1690508067ffffffffffffffff811115610a0a57610a0a611544565b604051908082528060200260200182016040528015610a33578160200160208202803683370190505b50915060005b818167ffffffffffffffff161015610a8c57610a558482610685565b838267ffffffffffffffff1681518110610a7157610a71611af9565b6020908102919091010152610a8581611b28565b9050610a39565b5050919050565b6060610a9f8383611140565b5050604080516000815260208101909152919050565b600067ffffffffffffffff841615610b05576040517fd9c5be6100000000000000000000000000000000000000000000000000000000815267ffffffffffffffff85166004820152602401610437565b8115610b3d576040517f3537219200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b50506040805160208082019690965280820194909452805180850382018152606090940190525050805191012090565b6040805160a081018252600080825260208201819052918101829052606081018290526080810182905281549091610ba8908290338661134e565b91506000610beb8360006106bc82606001518360800151604080516020808201949094528082019290925280518083038201815260609092019052805191012090565b600080546001810182559080527f290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e5630181905590503360408051600081526020810187905267ffffffffffffffff8516917fb68afc0605cd0ae88c5b20fac83239f61bebdf93d94c8f6f6deed8e21cf2fa5d910160405180910390a38167ffffffffffffffff167fdd11870a5e3366ac946d45a056101b609703ff29dae8c7d889a0f3f6ee455ace82604051610ca291815260200190565b60405180910390a25050919050565b600080610cc48686602001518686610eea565b9150915080341015610d0b576040517f805af60d00000000000000000000000000000000000000000000000000000000815234600482015260248101829052604401610437565b80341115610d4857610d1d8134611ba2565b82600081518110610d3057610d30611af9565b60200260200101818151610d449190611bb5565b9052505b826000610d596001610680896110a1565b905060005b82811015610e2a57868682818110610d7857610d78611af9565b9050602002016020810190610d8d9190611bc8565b73ffffffffffffffffffffffffffffffffffffffff16636b8d469f868381518110610dba57610dba611af9565b60200260200101518b8b60200151866040518563ffffffff1660e01b8152600401610de793929190611be3565b6000604051808303818588803b158015610e0057600080fd5b505af1158015610e14573d6000803e3d6000fd5b505050505080610e2390611c10565b9050610d5e565b50866020015167ffffffffffffffff168867ffffffffffffffff167fddb2a81061691cd55f8c8bfa25d7d6da9dffe61f552c523de1821da5e1910ac189604001518989604051610e7c93929190611c48565b60405180910390a35050505050505050565b60408051606081018252600080825260208201819052918101919091526040518060600160405280610ebf466113ea565b67ffffffffffffffff1681526020018467ffffffffffffffff16815260200183815250905092915050565b6060600082808203610f28576040517f45e2ba7a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8067ffffffffffffffff811115610f4157610f41611544565b604051908082528060200260200182016040528015610f6a578160200160208202803683370190505b50925060005b8181101561109657858582818110610f8a57610f8a611af9565b9050602002016020810190610f9f9190611bc8565b6040517f1888f4d400000000000000000000000000000000000000000000000000000000815267ffffffffffffffff808b1660048301528916602482015273ffffffffffffffffffffffffffffffffffffffff9190911690631888f4d490604401602060405180830381865afa15801561101d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110419190611cab565b84828151811061105357611053611af9565b60200260200101818152505083818151811061107157611071611af9565b6020026020010151836110849190611bb5565b925061108f81611c10565b9050610f70565b505094509492505050565b60606110d68260000151836020015167ffffffffffffffff1660409190911b6fffffffffffffffff0000000000000000161790565b60408084015181516fffffffffffffffffffffffffffffffff9093166020840152908201526060016040516020818303038152906040529050919050565b60608282604051602001611129929190611cc4565b604051602081830303815290604052905092915050565b600061114b8361059e565b90508067ffffffffffffffff168267ffffffffffffffff16106111b6576040517f14c90ab800000000000000000000000000000000000000000000000000000000815267ffffffffffffffff8085166004830152808416602483015282166044820152606401610437565b505050565b60408051606081018252600080825260208201819052918101829052906111e2848461143e565b905061ffff811660011461122f576040517f3199e11700000000000000000000000000000000000000000000000000000000815261ffff8216600482015260016024820152604401610437565b61124161123c8585611488565b6114e3565b915046826000015167ffffffffffffffff16036108fe5781516040517fd9e106b000000000000000000000000000000000000000000000000000000000815267ffffffffffffffff9091166004820152602401610437565b6040805180820182524281528282018051602080840191825273ffffffffffffffffffffffffffffffffffffffff8816600081815260018084528782206fffffffffffffffffffffffffffffffff8b16835284529087902095518655925194909201939093558285015185519251945194855267ffffffffffffffff9081169492169290917f76a643c92bd448082982f23dc803017708bcce282ba837e92611b3e876c45927910160405180910390a4505050565b6040805160a0810182526000808252602082018190529181018290526060810182905260808101919091526040518060a0016040528061138d466113ea565b67ffffffffffffffff1681526020018667ffffffffffffffff1681526020018567ffffffffffffffff1681526020016113d98573ffffffffffffffffffffffffffffffffffffffff1690565b815260200192909252509392505050565b600067ffffffffffffffff82111561143a57604080517f6dfcc650000000000000000000000000000000000000000000000000000000008152600481019190915260248101839052604401610437565b5090565b6000600282101561147f5782826040517fb0818b62000000000000000000000000000000000000000000000000000000008152600401610437929190611d0f565b50503560f01c90565b36600060028310156114ca5783836040517fb0818b62000000000000000000000000000000000000000000000000000000008152600401610437929190611d0f565b6114d78360028187611d5c565b915091505b9250929050565b604080516060810182526000808252602082018190529181018290529061150c84840185611d86565b604084015290506115298167ffffffffffffffff604082901c1691565b67ffffffffffffffff90811660208501521682525092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b803567ffffffffffffffff8116811461158b57600080fd5b919050565b60008083601f8401126115a257600080fd5b50813567ffffffffffffffff8111156115ba57600080fd5b6020830191508360208260051b85010111156114dc57600080fd5b600080600083850360c08112156115eb57600080fd5b60a08112156115f957600080fd5b5060405160a0810167ffffffffffffffff8282108183111715611645577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b8160405261165287611573565b835261166060208801611573565b602084015261167160408801611573565b6040840152606087013560608401526080870135608084015282955060a08701359250808311156116a157600080fd5b50506116af86828701611590565b9497909650939450505050565b6000806000606084860312156116d157600080fd5b6116da84611573565b92506116e860208501611573565b91506116f660408501611573565b90509250925092565b6020808252825182820181905260009190848201906040850190845b818110156117375783518352928401929184019160010161171b565b50909695505050505050565b60006020828403121561175557600080fd5b5035919050565b6000806000806060858703121561177257600080fd5b61177b85611573565b935061178960208601611573565b9250604085013567ffffffffffffffff8111156117a557600080fd5b6117b187828801611590565b95989497509550505050565b6000602082840312156117cf57600080fd5b61062882611573565b815167ffffffffffffffff90811682526020808401519091169082015260408083015190820152606081016106bc565b60008060006040848603121561181d57600080fd5b61182684611573565b9250602084013567ffffffffffffffff81111561184257600080fd5b6116af86828701611590565b60005b83811015611869578181015183820152602001611851565b50506000910152565b6000815180845261188a81602086016020860161184e565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b6020815260006106286020830184611872565b600080604083850312156118e257600080fd5b6118eb83611573565b91506118f960208401611573565b90509250929050565b6000806020838503121561191557600080fd5b823567ffffffffffffffff8082111561192d57600080fd5b818501915085601f83011261194157600080fd5b81358181111561195057600080fd5b86602082850101111561196257600080fd5b60209290920196919550909350505050565b803573ffffffffffffffffffffffffffffffffffffffff8116811461158b57600080fd5b60008082840360808112156119ac57600080fd5b6119b584611974565b925060607fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0820112156119e757600080fd5b506040516060810181811067ffffffffffffffff82111715611a32577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b604052611a4160208501611573565b8152611a4f60408501611573565b60208201526060939093013560408401525092909150565b60008060008060608587031215611a7d57600080fd5b611a8685611573565b935060208501359250604085013567ffffffffffffffff8111156117a557600080fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b67ffffffffffffffff8281168282160390808211156108fe576108fe611aa9565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b600067ffffffffffffffff808316818103611b4557611b45611aa9565b6001019392505050565b73ffffffffffffffffffffffffffffffffffffffff841681526020808201849052825167ffffffffffffffff90811660408085019190915291840151166060830152820151608082015260a0810161039c565b818103818111156106bc576106bc611aa9565b808201808211156106bc576106bc611aa9565b600060208284031215611bda57600080fd5b61062882611974565b600067ffffffffffffffff80861683528085166020840152506060604083015261065a6060830184611872565b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203611c4157611c41611aa9565b5060010190565b83815260406020808301829052908201839052600090849060608401835b86811015611c9f5773ffffffffffffffffffffffffffffffffffffffff611c8c85611974565b1682529282019290820190600101611c66565b50979650505050505050565b600060208284031215611cbd57600080fd5b5051919050565b7fffff0000000000000000000000000000000000000000000000000000000000008360f01b16815260008251611d0181600285016020870161184e565b919091016002019392505050565b60208152816020820152818360408301376000818301604090810191909152601f9092017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0160101919050565b60008085851115611d6c57600080fd5b83861115611d7957600080fd5b5050820193919092039150565b60008060408385031215611d9957600080fd5b82356fffffffffffffffffffffffffffffffff81168114611db957600080fd5b94602093909301359350505056fea2646970667358221220e288bc9cb1c096f89a0da02ae0353d44f6de0d1230536b6a2b17cfcea00c583564736f6c63430008140033","runtime-code":"0x60806040526004361061010e5760003560e01c8063b8ba4ba1116100a5578063e39682c111610074578063f338140e11610059578063f338140e1461032c578063fc1ebc9114610341578063fec8dfb91461036157600080fd5b8063e39682c1146102f9578063eb20fbfd1461031957600080fd5b8063b8ba4ba11461026c578063c72657811461028c578063d180db6f146102b9578063d961a48e146102d957600080fd5b80636c49312c116100e15780636c49312c146101dc578063727a5f91146101f1578063888775d91461022a578063aa2f06ae1461025757600080fd5b80630166204f1461011357806315f53956146101465780631c679ac11461016e5780632ad8c7061461019b575b600080fd5b34801561011f57600080fd5b5061013361012e3660046115d5565b610381565b6040519081526020015b60405180910390f35b34801561015257600080fd5b5061015b600181565b60405161ffff909116815260200161013d565b34801561017a57600080fd5b5061018e6101893660046116bc565b6103a4565b60405161013d91906116ff565b3480156101a757600080fd5b506101bb6101b6366004611743565b610509565b6040805167ffffffffffffffff93841681529290911660208301520161013d565b6101ef6101ea36600461175c565b61052d565b005b3480156101fd57600080fd5b5061021161020c3660046117bd565b61059e565b60405167ffffffffffffffff909116815260200161013d565b34801561023657600080fd5b5061024a6102453660046117bd565b6105cf565b60405161013d91906117d8565b34801561026357600080fd5b506101bb61062f565b34801561027857600080fd5b50610133610287366004611808565b610644565b34801561029857600080fd5b506102ac6102a73660046117bd565b610663565b60405161013d91906118bc565b3480156102c557600080fd5b506101336102d43660046118cf565b610685565b3480156102e557600080fd5b506101ef6102f4366004611902565b6106c2565b34801561030557600080fd5b50610133610314366004611998565b6107cb565b6101bb610327366004611a67565b610905565b34801561033857600080fd5b50600054610211565b34801561034d57600080fd5b5061018e61035c3660046117bd565b6109d8565b34801561036d57600080fd5b5061018e61037c3660046118cf565b610a93565b600061039c8460600151856080015186604001518686610ab5565b949350505050565b606060006103b18561059e565b67ffffffffffffffff1690508267ffffffffffffffff168467ffffffffffffffff1611806103e85750808367ffffffffffffffff16115b15610440576040517f72833e0d00000000000000000000000000000000000000000000000000000000815267ffffffffffffffff80871660048301528086166024830152841660448201526064015b60405180910390fd5b61044a8484611ad8565b67ffffffffffffffff1667ffffffffffffffff81111561046c5761046c611544565b604051908082528060200260200182016040528015610495578160200160208202803683370190505b509150835b8367ffffffffffffffff168167ffffffffffffffff161015610500576104c08682610685565b836104cb8784611ad8565b67ffffffffffffffff16815181106104e5576104e5611af9565b60209081029190910101526104f981611b28565b905061049a565b50509392505050565b600080600061051784610b6d565b6020810151604090910151909590945092505050565b83468167ffffffffffffffff160361057d576040517fd9e106b000000000000000000000000000000000000000000000000000000000815267ffffffffffffffff82166004820152602401610437565b6000610588856105cf565b905061059686828686610cb1565b505050505050565b6000805467ffffffffffffffff168267ffffffffffffffff16106105c35760006105c6565b60015b60ff1692915050565b60408051606081018252600080825260208201819052918101919091526000805467ffffffffffffffff168367ffffffffffffffff161061061157600061061c565b61061c836000610685565b90506106288382610e8e565b9392505050565b60008061063b60005490565b92600092509050565b600061065a8461065360005490565b8585610eea565b95945050505050565b60606000610670836105cf565b90506106286001610680836110a1565b611114565b60006106918383611140565b60008367ffffffffffffffff16815481106106ae576106ae611af9565b906000526020600020015490505b92915050565b60006106ce83836111bb565b905060006107058260000151836020015167ffffffffffffffff1660409190911b6fffffffffffffffff0000000000000000161790565b3360009081526001602081815260408084206fffffffffffffffffffffffffffffffff861685528252808420815180830190925280548083529301549181019190915292935090036107635761075c338385611299565b5050505050565b8260400151816020015103610779575050505050565b60208101516000036107905761075c338385611299565b60208101516040517f5aa9d5ae0000000000000000000000000000000000000000000000000000000081526104379133918690600401611b4f565b80516000904667ffffffffffffffff82160361081f576040517fd9e106b000000000000000000000000000000000000000000000000000000000815267ffffffffffffffff82166004820152602401610437565b60006108548460000151856020015167ffffffffffffffff1660409190911b6fffffffffffffffff0000000000000000161790565b73ffffffffffffffffffffffffffffffffffffffff861660009081526001602081815260408084206fffffffffffffffffffffffffffffffff861685528252808420815180830190925280548083529301549181019190915292935090036108c1576000935050506108fe565b84604001518160200151146108f6577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff6108f9565b80515b935050505b5092915050565b60008085468167ffffffffffffffff1603610958576040517fd9e106b000000000000000000000000000000000000000000000000000000000815267ffffffffffffffff82166004820152602401610437565b600061096387610b6d565b602081015160408201519095509350905060006109be856109b98460006106bc82606001518360800151604080516020808201949094528082019290925280518083038201815260609092019052805191012090565b610e8e565b90506109cc89828989610cb1565b50505094509492505050565b606060006109e58361059e565b67ffffffffffffffff1690508067ffffffffffffffff811115610a0a57610a0a611544565b604051908082528060200260200182016040528015610a33578160200160208202803683370190505b50915060005b818167ffffffffffffffff161015610a8c57610a558482610685565b838267ffffffffffffffff1681518110610a7157610a71611af9565b6020908102919091010152610a8581611b28565b9050610a39565b5050919050565b6060610a9f8383611140565b5050604080516000815260208101909152919050565b600067ffffffffffffffff841615610b05576040517fd9c5be6100000000000000000000000000000000000000000000000000000000815267ffffffffffffffff85166004820152602401610437565b8115610b3d576040517f3537219200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b50506040805160208082019690965280820194909452805180850382018152606090940190525050805191012090565b6040805160a081018252600080825260208201819052918101829052606081018290526080810182905281549091610ba8908290338661134e565b91506000610beb8360006106bc82606001518360800151604080516020808201949094528082019290925280518083038201815260609092019052805191012090565b600080546001810182559080527f290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e5630181905590503360408051600081526020810187905267ffffffffffffffff8516917fb68afc0605cd0ae88c5b20fac83239f61bebdf93d94c8f6f6deed8e21cf2fa5d910160405180910390a38167ffffffffffffffff167fdd11870a5e3366ac946d45a056101b609703ff29dae8c7d889a0f3f6ee455ace82604051610ca291815260200190565b60405180910390a25050919050565b600080610cc48686602001518686610eea565b9150915080341015610d0b576040517f805af60d00000000000000000000000000000000000000000000000000000000815234600482015260248101829052604401610437565b80341115610d4857610d1d8134611ba2565b82600081518110610d3057610d30611af9565b60200260200101818151610d449190611bb5565b9052505b826000610d596001610680896110a1565b905060005b82811015610e2a57868682818110610d7857610d78611af9565b9050602002016020810190610d8d9190611bc8565b73ffffffffffffffffffffffffffffffffffffffff16636b8d469f868381518110610dba57610dba611af9565b60200260200101518b8b60200151866040518563ffffffff1660e01b8152600401610de793929190611be3565b6000604051808303818588803b158015610e0057600080fd5b505af1158015610e14573d6000803e3d6000fd5b505050505080610e2390611c10565b9050610d5e565b50866020015167ffffffffffffffff168867ffffffffffffffff167fddb2a81061691cd55f8c8bfa25d7d6da9dffe61f552c523de1821da5e1910ac189604001518989604051610e7c93929190611c48565b60405180910390a35050505050505050565b60408051606081018252600080825260208201819052918101919091526040518060600160405280610ebf466113ea565b67ffffffffffffffff1681526020018467ffffffffffffffff16815260200183815250905092915050565b6060600082808203610f28576040517f45e2ba7a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8067ffffffffffffffff811115610f4157610f41611544565b604051908082528060200260200182016040528015610f6a578160200160208202803683370190505b50925060005b8181101561109657858582818110610f8a57610f8a611af9565b9050602002016020810190610f9f9190611bc8565b6040517f1888f4d400000000000000000000000000000000000000000000000000000000815267ffffffffffffffff808b1660048301528916602482015273ffffffffffffffffffffffffffffffffffffffff9190911690631888f4d490604401602060405180830381865afa15801561101d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110419190611cab565b84828151811061105357611053611af9565b60200260200101818152505083818151811061107157611071611af9565b6020026020010151836110849190611bb5565b925061108f81611c10565b9050610f70565b505094509492505050565b60606110d68260000151836020015167ffffffffffffffff1660409190911b6fffffffffffffffff0000000000000000161790565b60408084015181516fffffffffffffffffffffffffffffffff9093166020840152908201526060016040516020818303038152906040529050919050565b60608282604051602001611129929190611cc4565b604051602081830303815290604052905092915050565b600061114b8361059e565b90508067ffffffffffffffff168267ffffffffffffffff16106111b6576040517f14c90ab800000000000000000000000000000000000000000000000000000000815267ffffffffffffffff8085166004830152808416602483015282166044820152606401610437565b505050565b60408051606081018252600080825260208201819052918101829052906111e2848461143e565b905061ffff811660011461122f576040517f3199e11700000000000000000000000000000000000000000000000000000000815261ffff8216600482015260016024820152604401610437565b61124161123c8585611488565b6114e3565b915046826000015167ffffffffffffffff16036108fe5781516040517fd9e106b000000000000000000000000000000000000000000000000000000000815267ffffffffffffffff9091166004820152602401610437565b6040805180820182524281528282018051602080840191825273ffffffffffffffffffffffffffffffffffffffff8816600081815260018084528782206fffffffffffffffffffffffffffffffff8b16835284529087902095518655925194909201939093558285015185519251945194855267ffffffffffffffff9081169492169290917f76a643c92bd448082982f23dc803017708bcce282ba837e92611b3e876c45927910160405180910390a4505050565b6040805160a0810182526000808252602082018190529181018290526060810182905260808101919091526040518060a0016040528061138d466113ea565b67ffffffffffffffff1681526020018667ffffffffffffffff1681526020018567ffffffffffffffff1681526020016113d98573ffffffffffffffffffffffffffffffffffffffff1690565b815260200192909252509392505050565b600067ffffffffffffffff82111561143a57604080517f6dfcc650000000000000000000000000000000000000000000000000000000008152600481019190915260248101839052604401610437565b5090565b6000600282101561147f5782826040517fb0818b62000000000000000000000000000000000000000000000000000000008152600401610437929190611d0f565b50503560f01c90565b36600060028310156114ca5783836040517fb0818b62000000000000000000000000000000000000000000000000000000008152600401610437929190611d0f565b6114d78360028187611d5c565b915091505b9250929050565b604080516060810182526000808252602082018190529181018290529061150c84840185611d86565b604084015290506115298167ffffffffffffffff604082901c1691565b67ffffffffffffffff90811660208501521682525092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b803567ffffffffffffffff8116811461158b57600080fd5b919050565b60008083601f8401126115a257600080fd5b50813567ffffffffffffffff8111156115ba57600080fd5b6020830191508360208260051b85010111156114dc57600080fd5b600080600083850360c08112156115eb57600080fd5b60a08112156115f957600080fd5b5060405160a0810167ffffffffffffffff8282108183111715611645577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b8160405261165287611573565b835261166060208801611573565b602084015261167160408801611573565b6040840152606087013560608401526080870135608084015282955060a08701359250808311156116a157600080fd5b50506116af86828701611590565b9497909650939450505050565b6000806000606084860312156116d157600080fd5b6116da84611573565b92506116e860208501611573565b91506116f660408501611573565b90509250925092565b6020808252825182820181905260009190848201906040850190845b818110156117375783518352928401929184019160010161171b565b50909695505050505050565b60006020828403121561175557600080fd5b5035919050565b6000806000806060858703121561177257600080fd5b61177b85611573565b935061178960208601611573565b9250604085013567ffffffffffffffff8111156117a557600080fd5b6117b187828801611590565b95989497509550505050565b6000602082840312156117cf57600080fd5b61062882611573565b815167ffffffffffffffff90811682526020808401519091169082015260408083015190820152606081016106bc565b60008060006040848603121561181d57600080fd5b61182684611573565b9250602084013567ffffffffffffffff81111561184257600080fd5b6116af86828701611590565b60005b83811015611869578181015183820152602001611851565b50506000910152565b6000815180845261188a81602086016020860161184e565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b6020815260006106286020830184611872565b600080604083850312156118e257600080fd5b6118eb83611573565b91506118f960208401611573565b90509250929050565b6000806020838503121561191557600080fd5b823567ffffffffffffffff8082111561192d57600080fd5b818501915085601f83011261194157600080fd5b81358181111561195057600080fd5b86602082850101111561196257600080fd5b60209290920196919550909350505050565b803573ffffffffffffffffffffffffffffffffffffffff8116811461158b57600080fd5b60008082840360808112156119ac57600080fd5b6119b584611974565b925060607fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0820112156119e757600080fd5b506040516060810181811067ffffffffffffffff82111715611a32577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b604052611a4160208501611573565b8152611a4f60408501611573565b60208201526060939093013560408401525092909150565b60008060008060608587031215611a7d57600080fd5b611a8685611573565b935060208501359250604085013567ffffffffffffffff8111156117a557600080fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b67ffffffffffffffff8281168282160390808211156108fe576108fe611aa9565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b600067ffffffffffffffff808316818103611b4557611b45611aa9565b6001019392505050565b73ffffffffffffffffffffffffffffffffffffffff841681526020808201849052825167ffffffffffffffff90811660408085019190915291840151166060830152820151608082015260a0810161039c565b818103818111156106bc576106bc611aa9565b808201808211156106bc576106bc611aa9565b600060208284031215611bda57600080fd5b61062882611974565b600067ffffffffffffffff80861683528085166020840152506060604083015261065a6060830184611872565b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203611c4157611c41611aa9565b5060010190565b83815260406020808301829052908201839052600090849060608401835b86811015611c9f5773ffffffffffffffffffffffffffffffffffffffff611c8c85611974565b1682529282019290820190600101611c66565b50979650505050505050565b600060208284031215611cbd57600080fd5b5051919050565b7fffff0000000000000000000000000000000000000000000000000000000000008360f01b16815260008251611d0181600285016020870161184e565b919091016002019392505050565b60208152816020820152818360408301376000818301604090810191909152601f9092017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0160101919050565b60008085851115611d6c57600080fd5b83861115611d7957600080fd5b5050820193919092039150565b60008060408385031215611d9957600080fd5b82356fffffffffffffffffffffffffffffffff81168114611db957600080fd5b94602093909301359350505056fea2646970667358221220e288bc9cb1c096f89a0da02ae0353d44f6de0d1230536b6a2b17cfcea00c583564736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainDBEvents.sol\n\nabstract contract InterchainDBEvents {\n    /// @notice Emitted when a local entry is written to the database.\n    /// @param dbNonce      The nonce of the batch containing the entry.\n    /// @param entryIndex   The index of the entry within the batch.\n    /// @param srcWriter    The address of the writer.\n    /// @param dataHash     The written data hash.\n    event InterchainEntryWritten(\n        uint64 indexed dbNonce, uint64 entryIndex, bytes32 indexed srcWriter, bytes32 dataHash\n    );\n\n    /// @notice Emitted when a local batch is finalized.\n    /// @param dbNonce      The nonce of the finalized batch.\n    /// @param batchRoot    The Merkle root hash of the finalized batch.\n    event InterchainBatchFinalized(uint64 indexed dbNonce, bytes32 batchRoot);\n\n    /// @notice Emitted when a remote batch is verified by the Interchain Module.\n    /// @param module       The address of the Interchain Module that verified the batch.\n    /// @param srcChainId   The ID of the source chain.\n    /// @param dbNonce      The nonce of the verified batch.\n    /// @param batchRoot    The Merkle root hash of the verified batch.\n    event InterchainBatchVerified(\n        address indexed module, uint64 indexed srcChainId, uint64 indexed dbNonce, bytes32 batchRoot\n    );\n\n    /// @notice Emitted when a local batch is requested to be verified on a remote chain\n    /// using the set of Interchain Modules.\n    /// @param dstChainId   The ID of the destination chain.\n    /// @param dbNonce      The nonce of the batch to be verified.\n    /// @param batchRoot    The Merkle root hash of the batch to be verified.\n    /// @param srcModules   The addresses of the Interchain Modules that will verify the batch.\n    event InterchainBatchVerificationRequested(\n        uint64 indexed dstChainId, uint64 indexed dbNonce, bytes32 batchRoot, address[] srcModules\n    );\n}\n\n// contracts/interfaces/IInterchainModule.sol\n\n/// @notice Every Module may opt a different method to confirm the verified entries on destination chain,\n/// therefore this is not a part of a common interface.\ninterface IInterchainModule {\n    error InterchainModule__CallerNotInterchainDB(address caller);\n    error InterchainModule__ChainIdNotRemote(uint64 chainId);\n    error InterchainModule__FeeAmountBelowMin(uint256 feeAmount, uint256 minRequired);\n\n    /// @notice Request the verification of a batch from the Interchain DataBase by the module.\n    /// If the batch is not yet finalized, the verification on destination chain will be delayed until\n    /// the finalization is done and batch root is saved on the source chain.\n    /// Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`.\n    /// Note: this will eventually trigger `InterchainDB.verifyRemoteBatch(batch)` function on destination chain,\n    /// with no guarantee of ordering.\n    /// @dev Could be only called by the Interchain DataBase contract.\n    /// @param dstChainId       The chain id of the destination chain\n    /// @param batchNonce       The nonce of the batch on the source chain\n    /// @param versionedBatch   The versioned batch to verify\n    function requestBatchVerification(\n        uint64 dstChainId,\n        uint64 batchNonce,\n        bytes memory versionedBatch\n    )\n        external\n        payable;\n\n    /// @notice Get the Module fee for verifying a batch on the specified destination chain.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dbNonce      The database nonce of the batch on the source chain\n    function getModuleFee(uint64 dstChainId, uint64 dbNonce) external view returns (uint256);\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/VersionedPayload.sol\n\n// solhint-disable no-inline-assembly\n// solhint-disable ordering\nlibrary VersionedPayloadLib {\n    /// @notice Amount of bytes reserved for the version (uint16) in the versioned payload\n    uint256 internal constant VERSION_LENGTH = 2;\n\n    error VersionedPayload__PayloadTooShort(bytes versionedPayload);\n    error VersionedPayload__PrecompileFailed();\n\n    /// @notice Encodes the versioned payload into a single bytes array.\n    /// @param version  The payload's version.\n    /// @param payload  The payload to encode.\n    function encodeVersionedPayload(uint16 version, bytes memory payload) internal pure returns (bytes memory) {\n        return abi.encodePacked(version, payload);\n    }\n\n    /// @notice Extracts the version from the versioned payload (calldata reference).\n    /// @param versionedPayload     The versioned payload (calldata reference).\n    function getVersion(bytes calldata versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__PayloadTooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            version := shr(240, calldataload(versionedPayload.offset))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (calldata reference).\n    /// @dev The extracted payload is also returned as a calldata reference.\n    /// @param versionedPayload     The versioned payload.\n    function getPayload(bytes calldata versionedPayload) internal pure returns (bytes calldata) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__PayloadTooShort(versionedPayload);\n        }\n        return versionedPayload[VERSION_LENGTH:];\n    }\n\n    /// @notice Extracts the version from the versioned payload (memory reference).\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getVersionFromMemory(bytes memory versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__PayloadTooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            // We add 0x20 to skip the length of the bytes array.\n            version := shr(240, mload(add(versionedPayload, 0x20)))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (memory reference).\n    /// @dev The extracted payload is copied into a new memory location. Use `getPayload` when possible\n    /// to avoid extra memory allocation.\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getPayloadFromMemory(bytes memory versionedPayload) internal view returns (bytes memory payload) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__PayloadTooShort(versionedPayload);\n        }\n        // Figure how many bytes to copy and allocate the memory for the extracted payload.\n        uint256 toCopy;\n        unchecked {\n            toCopy = versionedPayload.length - VERSION_LENGTH;\n        }\n        payload = new bytes(toCopy);\n        // Use identity precompile (0x04) to copy the payload. Unlike MCOPY, this is available on all EVM chains.\n        bool res;\n        assembly {\n            // We add 0x20 to skip the length of the bytes array.\n            // We add 0x02 to skip the 2 bytes reserved for the version.\n            // Copy the payload to the previously allocated memory.\n            res := staticcall(gas(), 0x04, add(versionedPayload, 0x22), toCopy, add(payload, 0x20), toCopy)\n        }\n        if (!res) {\n            revert VersionedPayload__PrecompileFailed();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SafeCast.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value \u003e type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value \u003e type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value \u003e type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value \u003e type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value \u003e type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value \u003e type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value \u003e type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value \u003e type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value \u003e type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value \u003e type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value \u003e type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value \u003e type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value \u003e type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value \u003e type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value \u003e type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value \u003e type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value \u003e type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value \u003e type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value \u003e type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value \u003e type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value \u003e type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value \u003e type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value \u003e type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value \u003e type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value \u003e type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value \u003e type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value \u003e type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value \u003e type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value \u003e type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value \u003e type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value \u003e type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value \u003c 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value \u003e uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n}\n\n// contracts/libs/InterchainBatch.sol\n\ntype BatchKey is uint128;\n\n/// @notice Struct representing a batch of entries in the Interchain DataBase.\n/// Batched entries are put together in a Merkle tree, which root is saved.\n/// Batch has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: batchRoot\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch\n/// @param batchRoot    The root of the Merkle tree containing the batched entries\nstruct InterchainBatch {\n    uint64 srcChainId;\n    uint64 dbNonce;\n    bytes32 batchRoot;\n}\n\n/// @dev Signals that the module has not verified any batch with the given key.\nuint256 constant BATCH_UNVERIFIED = 0;\n/// @dev Signals that the module has verified a conflicting batch with the given key.\nuint256 constant BATCH_CONFLICT = type(uint256).max;\n\nlibrary InterchainBatchLib {\n    using VersionedPayloadLib for bytes;\n\n    /// @notice Constructs an InterchainBatch struct to be saved on the local chain.\n    /// @param dbNonce      The database nonce of the batch\n    /// @param batchRoot    The root of the Merkle tree containing the batched entries\n    /// @return batch       The constructed InterchainBatch struct\n    function constructLocalBatch(\n        uint64 dbNonce,\n        bytes32 batchRoot\n    )\n        internal\n        view\n        returns (InterchainBatch memory batch)\n    {\n        return InterchainBatch({srcChainId: SafeCast.toUint64(block.chainid), dbNonce: dbNonce, batchRoot: batchRoot});\n    }\n\n    /// @notice Encodes the InterchainBatch struct into a non-versioned batch payload.\n    function encodeBatch(InterchainBatch memory batch) internal pure returns (bytes memory) {\n        return abi.encode(encodeBatchKey(batch.srcChainId, batch.dbNonce), batch.batchRoot);\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in calldata.\n    function decodeBatch(bytes calldata data) internal pure returns (InterchainBatch memory batch) {\n        BatchKey key;\n        (key, batch.batchRoot) = abi.decode(data, (BatchKey, bytes32));\n        (batch.srcChainId, batch.dbNonce) = decodeBatchKey(key);\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in memory.\n    function decodeBatchFromMemory(bytes memory data) internal pure returns (InterchainBatch memory batch) {\n        BatchKey key;\n        (key, batch.batchRoot) = abi.decode(data, (BatchKey, bytes32));\n        (batch.srcChainId, batch.dbNonce) = decodeBatchKey(key);\n    }\n\n    /// @notice Encodes the uint128 key of the batch from uint64 srcChainId and uint64 dbNonce.\n    function encodeBatchKey(uint64 srcChainId, uint64 dbNonce) internal pure returns (BatchKey) {\n        return BatchKey.wrap((uint128(srcChainId) \u003c\u003c 64) | dbNonce);\n    }\n\n    /// @notice Decodes the uint128 key of the batch into uint64 srcChainId and uint64 dbNonce.\n    function decodeBatchKey(BatchKey key) internal pure returns (uint64 srcChainId, uint64 dbNonce) {\n        srcChainId = uint64(BatchKey.unwrap(key) \u003e\u003e 64);\n        dbNonce = uint64(BatchKey.unwrap(key));\n    }\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce + entryIndex\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch containing the entry\n/// @param entryIndex   The index of the entry in the batch\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint64 srcChainId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nusing InterchainEntryLib for InterchainEntry global;\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint64 dbNonce,\n        uint64 entryIndex,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: SafeCast.toUint64(block.chainid),\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return getEntryValue(entry.srcWriter, entry.dataHash);\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function getEntryValue(bytes32 srcWriter, bytes32 dataHash) internal pure returns (bytes32) {\n        return keccak256(abi.encode(srcWriter, dataHash));\n    }\n}\n\n// contracts/libs/BatchingV1.sol\n\nlibrary BatchingV1Lib {\n    error BatchingV1__EntryIndexNotZero(uint64 entryIndex);\n    error BatchingV1__ProofNotEmpty();\n\n    /// @notice Get the batch root containing the Interchain Entry with the given index.\n    /// @param srcWriter    The entry writer of the source chain\n    /// @param dataHash     The hash of the data of the entry\n    /// @param entryIndex   The index of the entry in the batch\n    /// @param proof        The Merkle proof of inclusion for the entry in the batch\n    /// @return batchRoot   The root of the batch containing the entry\n    function getBatchRoot(\n        bytes32 srcWriter,\n        bytes32 dataHash,\n        uint64 entryIndex,\n        bytes32[] calldata proof\n    )\n        internal\n        pure\n        returns (bytes32 batchRoot)\n    {\n        // In \"no batching\" mode: entry index is 0, proof is empty\n        if (entryIndex != 0) {\n            revert BatchingV1__EntryIndexNotZero(entryIndex);\n        }\n        if (proof.length != 0) {\n            revert BatchingV1__ProofNotEmpty();\n        }\n        // In \"no batching\" mode: the batch root is the same as the entry value\n        return InterchainEntryLib.getEntryValue({srcWriter: srcWriter, dataHash: dataHash});\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    error InterchainDB__BatchConflict(address module, bytes32 existingBatchRoot, InterchainBatch newBatch);\n    error InterchainDB__BatchVersionMismatch(uint16 version, uint16 required);\n    error InterchainDB__ChainIdNotRemote(uint64 chainId);\n    error InterchainDB__EntryIndexOutOfRange(uint64 dbNonce, uint64 entryIndex, uint64 batchSize);\n    error InterchainDB__EntryRangeInvalid(uint64 dbNonce, uint64 start, uint64 end);\n    error InterchainDB__FeeAmountBelowMin(uint256 feeAmount, uint256 minRequired);\n    error InterchainDB__ModulesNotProvided();\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `requestBatchVerification` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntry(bytes32 dataHash) external returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Request the given Interchain Modules to verify an existing batch.\n    /// If the batch is not finalized, the module will verify it after finalization.\n    /// For the finalized batch the batch root is already available, and the module can verify it immediately.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any batch.\n    /// @dev Will revert if the batch with the given nonce does not exist.\n    /// @param dstChainId    The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the existing batch\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestBatchVerification(\n        uint64 dstChainId,\n        uint64 dbNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Then request the Interchain Modules to verify the batch containing the written entry on the destination chain.\n    /// See `writeEntry` and `requestBatchVerification` for more details.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntryWithVerification(\n        uint64 dstChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Allows the Interchain Module to verify the batch coming from the remote chain.\n    /// The module SHOULD verify the exact finalized batch from the remote chain. If the batch with a given nonce\n    /// is not finalized or does not exist, module CAN verify it with an empty root value. Once the batch is\n    /// finalized, the module SHOULD re-verify the batch with the correct root value.\n    /// Note: The DB will only accept the batch of the same version as the DB itself.\n    /// @dev Will revert if the batch with the same nonce but a different non-empty root is already verified.\n    /// @param versionedBatch   The versioned Interchain Batch to verify\n    function verifyRemoteBatch(bytes memory versionedBatch) external;\n\n    //  VIEWS \n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint64 dstChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce.\n    /// Note: the leafs are ordered by the index of the written entry in the current batch,\n    /// and the leafs value match the value of the written entry (srcWriter + dataHash hashed together).\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchLeafs(uint64 dbNonce) external view returns (bytes32[] memory);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce,\n    /// paginated by the given start and end indexes. The end index is exclusive.\n    /// Note: this is useful when the batch contains a large number of leafs, and calling `getBatchLeafs`\n    /// would result in a gas limit exceeded error.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the provided range is invalid.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param start        The start index of the paginated leafs, inclusive\n    /// @param end          The end index of the paginated leafs, exclusive\n    function getBatchLeafsPaginated(\n        uint64 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory);\n\n    /// @notice Returns the size of the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchSize(uint64 dbNonce) external view returns (uint64);\n\n    /// @notice Get the finalized Interchain Batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatch(uint64 dbNonce) external view returns (InterchainBatch memory);\n\n    /// @notice Get the versioned Interchain Batch with the given nonce.\n    /// Note: will return a batch with an empty root if the batch does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the batch\n    function getVersionedBatch(uint64 dbNonce) external view returns (bytes memory);\n\n    /// @notice Get the Interchain Entry's value written on the local chain with the given batch nonce and entry index.\n    /// Entry value is calculated as the hash of the writer address and the written data hash.\n    /// Note: the batch does not have to be finalized to fetch the entry value.\n    /// @dev Will revert if the batch with the given nonce does not exist,\n    /// or the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the existing batch\n    /// @param entryIndex   The index of the written entry within the batch\n    function getEntryValue(uint64 dbNonce, uint64 entryIndex) external view returns (bytes32);\n\n    /// @notice Get the Merkle proof of inclusion for the entry with the given index\n    /// in the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param entryIndex   The index of the written entry within the batch\n    /// @return proof       The Merkle proof of inclusion for the entry\n    function getEntryProof(uint64 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof);\n\n    /// @notice Get the nonce of the database, which is incremented every time a new batch is finalized.\n    /// This is the nonce of the current non-finalized batch.\n    function getDBNonce() external view returns (uint64);\n\n    /// @notice Get the index of the next entry to be written to the database.\n    /// @return dbNonce      The database nonce of the batch including the next entry\n    /// @return entryIndex   The index of the next entry within that batch\n    function getNextEntryIndex() external view returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Check if the batch is verified by the Interchain Module on the destination chain.\n    /// Note: returned zero value indicates that the module has not verified the batch.\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @param batch        The Interchain Batch to check\n    /// @return moduleVerifiedAt    The block timestamp at which the batch was verified by the module,\n    ///                             or ZERO if the module has not verified the batch.\n    function checkBatchVerification(\n        address dstModule,\n        InterchainBatch memory batch\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n\n    /// @notice Get the batch root containing the Interchain Entry with the given index.\n    /// @param entry         The Interchain Entry to get the batch root for\n    /// @param proof         The Merkle proof of inclusion for the entry in the batch\n    function getBatchRoot(InterchainEntry memory entry, bytes32[] memory proof) external pure returns (bytes32);\n\n    /// @notice Get the version of the Interchain DataBase.\n    // solhint-disable-next-line func-name-mixedcase\n    function DB_VERSION() external pure returns (uint16);\n}\n\n// contracts/InterchainDB.sol\n\ncontract InterchainDB is InterchainDBEvents, IInterchainDB {\n    using VersionedPayloadLib for bytes;\n\n    /// @notice Struct representing a batch of entries from the remote Interchain DataBase,\n    /// verified by the Interchain Module.\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param batchRoot    The Merkle root of the batch\n    struct RemoteBatch {\n        uint256 verifiedAt;\n        bytes32 batchRoot;\n    }\n\n    uint16 public constant DB_VERSION = 1;\n\n    bytes32[] internal _entryValues;\n    mapping(address module =\u003e mapping(BatchKey batchKey =\u003e RemoteBatch batch)) internal _remoteBatches;\n\n    modifier onlyRemoteChainId(uint64 chainId) {\n        if (chainId == block.chainid) {\n            revert InterchainDB__ChainIdNotRemote(chainId);\n        }\n        _;\n    }\n\n    //  WRITER-FACING \n\n    /// @inheritdoc IInterchainDB\n    function writeEntry(bytes32 dataHash) external returns (uint64 dbNonce, uint64 entryIndex) {\n        InterchainEntry memory entry = _writeEntry(dataHash);\n        (dbNonce, entryIndex) = (entry.dbNonce, entry.entryIndex);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function requestBatchVerification(\n        uint64 dstChainId,\n        uint64 dbNonce,\n        address[] calldata srcModules\n    )\n        external\n        payable\n        onlyRemoteChainId(dstChainId)\n    {\n        InterchainBatch memory batch = getBatch(dbNonce);\n        _requestVerification(dstChainId, batch, srcModules);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function writeEntryWithVerification(\n        uint64 dstChainId,\n        bytes32 dataHash,\n        address[] calldata srcModules\n    )\n        external\n        payable\n        onlyRemoteChainId(dstChainId)\n        returns (uint64 dbNonce, uint64 entryIndex)\n    {\n        InterchainEntry memory entry = _writeEntry(dataHash);\n        (dbNonce, entryIndex) = (entry.dbNonce, entry.entryIndex);\n        // In \"no batching\" mode: the batch root is the same as the entry value\n        InterchainBatch memory batch = InterchainBatchLib.constructLocalBatch(dbNonce, entry.entryValue());\n        _requestVerification(dstChainId, batch, srcModules);\n    }\n\n    //  MODULE-FACING \n\n    /// @inheritdoc IInterchainDB\n    function verifyRemoteBatch(bytes calldata versionedBatch) external {\n        InterchainBatch memory batch = _assertCorrectBatch(versionedBatch);\n        BatchKey batchKey = InterchainBatchLib.encodeBatchKey({srcChainId: batch.srcChainId, dbNonce: batch.dbNonce});\n        RemoteBatch memory existingBatch = _remoteBatches[msg.sender][batchKey];\n        // Check if that's the first time module verifies the batch\n        if (existingBatch.verifiedAt == 0) {\n            _saveVerifiedBatch(msg.sender, batchKey, batch);\n            return;\n        }\n        // No-op if the batch root is the same\n        if (existingBatch.batchRoot == batch.batchRoot) {\n            return;\n        }\n        // Overwriting an empty (non-existent) batch with a different one is allowed\n        if (existingBatch.batchRoot == 0) {\n            _saveVerifiedBatch(msg.sender, batchKey, batch);\n            return;\n        }\n        // Overwriting an existing batch with a different one is not allowed\n        revert InterchainDB__BatchConflict(msg.sender, existingBatch.batchRoot, batch);\n    }\n\n    //  VIEWS \n\n    /// @inheritdoc IInterchainDB\n    function getBatchLeafs(uint64 dbNonce) external view returns (bytes32[] memory leafs) {\n        uint256 batchSize = getBatchSize(dbNonce);\n        leafs = new bytes32[](batchSize);\n        for (uint64 i = 0; i \u003c batchSize; ++i) {\n            leafs[i] = getEntryValue(dbNonce, i);\n        }\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getBatchLeafsPaginated(\n        uint64 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory leafs)\n    {\n        uint256 size = getBatchSize(dbNonce);\n        if (start \u003e end || end \u003e size) {\n            revert InterchainDB__EntryRangeInvalid(dbNonce, start, end);\n        }\n        leafs = new bytes32[](end - start);\n        for (uint64 i = start; i \u003c end; ++i) {\n            leafs[i - start] = getEntryValue(dbNonce, i);\n        }\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getEntryProof(uint64 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof) {\n        // In \"no batching\" mode: the batch root is the same as the entry value, hence the proof is empty\n        _assertEntryExists(dbNonce, entryIndex);\n        return new bytes32[](0);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getInterchainFee(uint64 dstChainId, address[] calldata srcModules) external view returns (uint256 fee) {\n        (, fee) = _getModuleFees(dstChainId, getDBNonce(), srcModules);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getNextEntryIndex() external view returns (uint64 dbNonce, uint64 entryIndex) {\n        // In \"no batching\" mode: entry index is 0, batch size is 1\n        dbNonce = getDBNonce();\n        entryIndex = 0;\n    }\n\n    /// @inheritdoc IInterchainDB\n    function checkBatchVerification(\n        address dstModule,\n        InterchainBatch memory batch\n    )\n        external\n        view\n        onlyRemoteChainId(batch.srcChainId)\n        returns (uint256 moduleVerifiedAt)\n    {\n        BatchKey batchKey = InterchainBatchLib.encodeBatchKey({srcChainId: batch.srcChainId, dbNonce: batch.dbNonce});\n        RemoteBatch memory remoteBatch = _remoteBatches[dstModule][batchKey];\n        // Check if module verified anything for this batch key first\n        if (remoteBatch.verifiedAt == 0) {\n            return BATCH_UNVERIFIED;\n        }\n        // Check if the batch root matches the one verified by the module\n        return remoteBatch.batchRoot == batch.batchRoot ? remoteBatch.verifiedAt : BATCH_CONFLICT;\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getVersionedBatch(uint64 dbNonce) external view returns (bytes memory versionedBatch) {\n        InterchainBatch memory batch = getBatch(dbNonce);\n        return VersionedPayloadLib.encodeVersionedPayload({\n            version: DB_VERSION,\n            payload: InterchainBatchLib.encodeBatch(batch)\n        });\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getBatchRoot(InterchainEntry memory entry, bytes32[] calldata proof) external pure returns (bytes32) {\n        return BatchingV1Lib.getBatchRoot({\n            srcWriter: entry.srcWriter,\n            dataHash: entry.dataHash,\n            entryIndex: entry.entryIndex,\n            proof: proof\n        });\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getBatchSize(uint64 dbNonce) public view returns (uint64) {\n        // In \"no batching\" mode: the finalized batch size is 1, the pending batch size is 0\n        // We also return 0 for non-existent batches\n        return dbNonce \u003c getDBNonce() ? 1 : 0;\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getBatch(uint64 dbNonce) public view returns (InterchainBatch memory) {\n        // In \"no batching\" mode: the batch root is the same as the entry hash.\n        // For non-finalized or non-existent batches, the batch root is 0.\n        bytes32 batchRoot = dbNonce \u003c getDBNonce() ? getEntryValue(dbNonce, 0) : bytes32(0);\n        return InterchainBatchLib.constructLocalBatch(dbNonce, batchRoot);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getEntryValue(uint64 dbNonce, uint64 entryIndex) public view returns (bytes32) {\n        _assertEntryExists(dbNonce, entryIndex);\n        return _entryValues[dbNonce];\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getDBNonce() public view returns (uint64) {\n        // We can do the unsafe cast here as writing more than 2^64 entries is practically impossible\n        return uint64(_entryValues.length);\n    }\n\n    //  INTERNAL LOGIC \n\n    /// @dev Write the entry to the database and emit the event.\n    function _writeEntry(bytes32 dataHash) internal returns (InterchainEntry memory entry) {\n        uint64 dbNonce = getDBNonce();\n        entry = InterchainEntryLib.constructLocalEntry({\n            dbNonce: dbNonce,\n            entryIndex: 0,\n            writer: msg.sender,\n            dataHash: dataHash\n        });\n        bytes32 entryValue = entry.entryValue();\n        _entryValues.push(entryValue);\n        emit InterchainEntryWritten({\n            dbNonce: dbNonce,\n            entryIndex: 0,\n            srcWriter: TypeCasts.addressToBytes32(msg.sender),\n            dataHash: dataHash\n        });\n        // In the InterchainDB V1 the batch is finalized immediately after the entry is written\n        emit InterchainBatchFinalized({dbNonce: dbNonce, batchRoot: entryValue});\n    }\n\n    /// @dev Request the verification of the entry by the modules, and emit the event.\n    /// Note: the validity of the passed entry and chain id being remote is enforced in the calling function.\n    function _requestVerification(\n        uint64 dstChainId,\n        InterchainBatch memory batch,\n        address[] calldata srcModules\n    )\n        internal\n    {\n        (uint256[] memory fees, uint256 totalFee) = _getModuleFees(dstChainId, batch.dbNonce, srcModules);\n        if (msg.value \u003c totalFee) {\n            revert InterchainDB__FeeAmountBelowMin(msg.value, totalFee);\n        } else if (msg.value \u003e totalFee) {\n            // The exceeding amount goes to the first module\n            fees[0] += msg.value - totalFee;\n        }\n        uint256 len = srcModules.length;\n        bytes memory versionedBatch = VersionedPayloadLib.encodeVersionedPayload({\n            version: DB_VERSION,\n            payload: InterchainBatchLib.encodeBatch(batch)\n        });\n        for (uint256 i = 0; i \u003c len; ++i) {\n            IInterchainModule(srcModules[i]).requestBatchVerification{value: fees[i]}(\n                dstChainId, batch.dbNonce, versionedBatch\n            );\n        }\n        emit InterchainBatchVerificationRequested(dstChainId, batch.dbNonce, batch.batchRoot, srcModules);\n    }\n\n    /// @dev Save the verified batch to the database and emit the event.\n    function _saveVerifiedBatch(address module, BatchKey batchKey, InterchainBatch memory batch) internal {\n        _remoteBatches[module][batchKey] = RemoteBatch({verifiedAt: block.timestamp, batchRoot: batch.batchRoot});\n        emit InterchainBatchVerified(module, batch.srcChainId, batch.dbNonce, batch.batchRoot);\n    }\n\n    //  INTERNAL VIEWS \n\n    /// @dev Asserts that the batch version is correct and that batch originates from a remote chain.\n    /// Note: returns the decoded batch for chaining purposes.\n    function _assertCorrectBatch(bytes calldata versionedBatch) internal view returns (InterchainBatch memory batch) {\n        uint16 dbVersion = versionedBatch.getVersion();\n        if (dbVersion != DB_VERSION) {\n            revert InterchainDB__BatchVersionMismatch(dbVersion, DB_VERSION);\n        }\n        batch = InterchainBatchLib.decodeBatch(versionedBatch.getPayload());\n        if (batch.srcChainId == block.chainid) {\n            revert InterchainDB__ChainIdNotRemote(batch.srcChainId);\n        }\n    }\n\n    /// @dev Check that the entry index is within the batch size. Also checks that the batch exists.\n    function _assertEntryExists(uint64 dbNonce, uint64 entryIndex) internal view {\n        // This will revert if the batch does not exist\n        uint64 batchSize = getBatchSize(dbNonce);\n        if (entryIndex \u003e= batchSize) {\n            revert InterchainDB__EntryIndexOutOfRange(dbNonce, entryIndex, batchSize);\n        }\n    }\n\n    /// @dev Get the verification fees for the modules\n    function _getModuleFees(\n        uint64 dstChainId,\n        uint64 dbNonce,\n        address[] calldata srcModules\n    )\n        internal\n        view\n        returns (uint256[] memory fees, uint256 totalFee)\n    {\n        uint256 len = srcModules.length;\n        if (len == 0) {\n            revert InterchainDB__ModulesNotProvided();\n        }\n        fees = new uint256[](len);\n        for (uint256 i = 0; i \u003c len; ++i) {\n            fees[i] = IInterchainModule(srcModules[i]).getModuleFee(dstChainId, dbNonce);\n            totalFee += fees[i];\n        }\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"59770:13631:0:-:0;;;;;;;;;;;;;;;;;;;","srcMapRuntime":"59770:13631:0:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;66939:318;;;;;;;;;;-1:-1:-1;66939:318:0;;;;;:::i;:::-;;:::i;:::-;;;2181:25:1;;;2169:2;2154:18;66939:318:0;;;;;;;;60250:37;;;;;;;;;;;;60286:1;60250:37;;;;;2391:6:1;2379:19;;;2361:38;;2349:2;2334:18;60250:37:0;2217:188:1;64390:515:0;;;;;;;;;;-1:-1:-1;64390:515:0;;;;;:::i;:::-;;:::i;:::-;;;;;;;:::i;60965:227::-;;;;;;;;;;-1:-1:-1;60965:227:0;;;;;:::i;:::-;;:::i;:::-;;;;3745:18:1;3790:15;;;3772:34;;3842:15;;;;3837:2;3822:18;;3815:43;3708:18;60965:227:0;3565:299:1;61232:331:0;;;;;;:::i;:::-;;:::i;:::-;;67297:267;;;;;;;;;;-1:-1:-1;67297:267:0;;;;;:::i;:::-;;:::i;:::-;;;4818:18:1;4806:31;;;4788:50;;4776:2;4761:18;67297:267:0;4644:200:1;67604:409:0;;;;;;;;;;-1:-1:-1;67604:409:0;;;;;:::i;:::-;;:::i;:::-;;;;;;;:::i;65516:218::-;;;;;;;;;;;;;:::i;65285:191::-;;;;;;;;;;-1:-1:-1;65285:191:0;;;;;:::i;:::-;;:::i;66575:324::-;;;;;;;;;;-1:-1:-1;66575:324:0;;;;;:::i;:::-;;:::i;:::-;;;;;;;:::i;68053:182::-;;;;;;;;;;-1:-1:-1;68053:182:0;;;;;:::i;:::-;;:::i;62607:1074::-;;;;;;;;;;-1:-1:-1;62607:1074:0;;;;;:::i;:::-;;:::i;65774:761::-;;;;;;;;;;-1:-1:-1;65774:761:0;;;;;:::i;:::-;;:::i;61603:646::-;;;;;;:::i;:::-;;:::i;68275:204::-;;;;;;;;;;-1:-1:-1;68318:6:0;68452:19;68275:204;;64055:295;;;;;;;;;;-1:-1:-1;64055:295:0;;;;;:::i;:::-;;:::i;64945:300::-;;;;;;;;;;-1:-1:-1;64945:300:0;;;;;:::i;:::-;;:::i;66939:318::-;67040:7;67066:184;67118:5;:15;;;67157:5;:14;;;67197:5;:16;;;67234:5;;67066:26;:184::i;:::-;67059:191;66939:318;-1:-1:-1;;;;66939:318:0:o;64390:515::-;64541:22;64579:12;64594:21;64607:7;64594:12;:21::i;:::-;64579:36;;;;64637:3;64629:11;;:5;:11;;;:25;;;;64650:4;64644:3;:10;;;64629:25;64625:115;;;64677:52;;;;;9711:18:1;9756:15;;;64677:52:0;;;9738:34:1;9808:15;;;9788:18;;;9781:43;9860:15;;9840:18;;;9833:43;9674:18;;64677:52:0;;;;;;;;64625:115;64771:11;64777:5;64771:3;:11;:::i;:::-;64757:26;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;64757:26:0;-1:-1:-1;64749:34:0;-1:-1:-1;64809:5:0;64793:106;64820:3;64816:7;;:1;:7;;;64793:106;;;64863:25;64877:7;64886:1;64863:13;:25::i;:::-;64844:5;64850:9;64854:5;64850:1;:9;:::i;:::-;64844:16;;;;;;;;;;:::i;:::-;;;;;;;;;;:44;64825:3;;;:::i;:::-;;;64793:106;;;;64569:336;64390:515;;;;;:::o;60965:227::-;61021:14;61037:17;61066:28;61097:21;61109:8;61097:11;:21::i;:::-;61153:13;;;;61168:16;;;;;61153:13;;61168:16;;-1:-1:-1;60965:227:0;-1:-1:-1;;;60965:227:0:o;61232:331::-;61421:10;60504:13;60493:7;:24;;;60489:101;;60540:39;;;;;4818:18:1;4806:31;;60540:39:0;;;4788:50:1;4761:18;;60540:39:0;4644:200:1;60489:101:0;61447:28:::1;61478:17;61487:7;61478:8;:17::i;:::-;61447:48;;61505:51;61526:10;61538:5;61545:10;;61505:20;:51::i;:::-;61437:126;61232:331:::0;;;;;:::o;67297:267::-;67356:6;68452:19;;67527:22;;:7;:22;;;:30;;67556:1;67527:30;;;67552:1;67527:30;67520:37;;;67297:267;-1:-1:-1;;67297:267:0:o;67604:409::-;-1:-1:-1;;;;;;;;;;;;;;;;;;;;;;;;;67848:17:0;68452:19;;67868:22;;:7;:22;;;:63;;67929:1;67868:63;;;67893:25;67907:7;67916:1;67893:13;:25::i;:::-;67848:83;;67948:58;67987:7;67996:9;67948:38;:58::i;:::-;67941:65;67604:409;-1:-1:-1;;;67604:409:0:o;65516:218::-;65568:14;65584:17;65691:12;68318:6;68452:19;;68275:204;65691:12;65681:22;65726:1;;-1:-1:-1;65516:218:0;-1:-1:-1;65516:218:0:o;65285:191::-;65384:11;65417:52;65432:10;65444:12;68318:6;68452:19;;68275:204;65444:12;65458:10;;65417:14;:52::i;:::-;65407:62;65285:191;-1:-1:-1;;;;;65285:191:0:o;66575:324::-;66641:27;66680:28;66711:17;66720:7;66711:8;:17::i;:::-;66680:48;;66745:147;60286:1;66844:37;66875:5;66844:30;:37::i;:::-;66745:42;:147::i;68053:182::-;68132:7;68151:39;68170:7;68179:10;68151:18;:39::i;:::-;68207:12;68220:7;68207:21;;;;;;;;;;:::i;:::-;;;;;;;;;68200:28;;68053:182;;;;;:::o;62607:1074::-;62684:28;62715:35;62735:14;;62715:19;:35::i;:::-;62684:66;;62760:17;62780:89;62827:5;:16;;;62854:5;:13;;;45482:37;;45506:2;45483:25;;;;;;45482:37;;45359:168;62780:89;62929:10;62879:32;62914:26;;;:14;:26;;;;;;;;:36;;;;;;;;;;62879:71;;;;;;;;;;;;;;;;;;;;;;;62760:109;;-1:-1:-1;63032:29:0;;63028:127;;63077:47;63096:10;63108:8;63118:5;63077:18;:47::i;:::-;63138:7;;;62607:1074;;:::o;63028:127::-;63242:5;:15;;;63215:13;:23;;;:42;63211:79;;63273:7;;;62607:1074;;:::o;63211:79::-;63388:23;;;;63415:1;63388:28;63384:126;;63432:47;63451:10;63463:8;63473:5;63432:18;:47::i;63384:126::-;63643:23;;;;63603:71;;;;;;;63631:10;;63668:5;;63603:71;;;:::i;65774:761::-;65933:16;;65968:24;;60504:13;60493:24;;;;60489:101;;60540:39;;;;;4818:18:1;4806:31;;60540:39:0;;;4788:50:1;4761:18;;60540:39:0;4644:200:1;60489:101:0;66008:17:::1;66028:89;66075:5;:16;;;66102:5;:13;;;45482:37:::0;;45506:2;45483:25;;;;;;45482:37;;45359:168;66028:89:::1;66160:25;::::0;::::1;66127:30;66160:25:::0;;;:14:::1;:25;::::0;;;;;;;:35:::1;::::0;::::1;::::0;;;;;;;66127:68;;;;::::1;::::0;;;;;;;;;::::1;::::0;;;::::1;::::0;;;;66008:109;;-1:-1:-1;66279:27:0;;66275:81:::1;;43427:1;66322:23;;;;;;66275:81;66471:5;:15;;;66446:11;:21;;;:40;:82;;43550:17;66446:82;;;66489:22:::0;;66446:82:::1;66439:89;;;;60599:1;65774:761:::0;;;;;:::o;61603:646::-;61825:14;61841:17;61796:10;60504:13;60493:7;:24;;;60489:101;;60540:39;;;;;4818:18:1;4806:31;;60540:39:0;;;4788:50:1;4761:18;;60540:39:0;4644:200:1;60489:101:0;61874:28:::1;61905:21;61917:8;61905:11;:21::i;:::-;61961:13;::::0;::::1;::::0;61976:16:::1;::::0;::::1;::::0;61961:13;;-1:-1:-1;61976:16:0;-1:-1:-1;61874:52:0;-1:-1:-1;62083:28:0::1;62114:67;61961:13:::0;62162:18:::1;61874:52:::0;47679:7;47705:46;47719:5;:15;;;47736:5;:14;;;47965:31;;;;;;;11593:25:1;;;;11634:18;;;11627:34;;;;47965:31:0;;;;;;;;;11566:18:1;;;;47965:31:0;;47955:42;;;;;;47846:158;62162:18:::1;62114:38;:67::i;:::-;62083:98;;62191:51;62212:10;62224:5;62231:10;;62191:20;:51::i;:::-;61864:385;;61603:646:::0;;;;;;;;:::o;64055:295::-;64117:22;64151:17;64171:21;64184:7;64171:12;:21::i;:::-;64151:41;;;;64224:9;64210:24;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;64210:24:0;;64202:32;;64249:8;64244:100;64267:9;64263:1;:13;;;64244:100;;;64308:25;64322:7;64331:1;64308:13;:25::i;:::-;64297:5;64303:1;64297:8;;;;;;;;;;:::i;:::-;;;;;;;;;;:36;64278:3;;;:::i;:::-;;;64244:100;;;;64141:209;64055:295;;;:::o;64945:300::-;65026:22;65166:39;65185:7;65194:10;65166:18;:39::i;:::-;-1:-1:-1;;65222:16:0;;;65236:1;65222:16;;;;;;;;;65215:23;-1:-1:-1;64945:300:0:o;48606:653::-;48795:17;48899:15;;;;48895:94;;48937:41;;;;;4818:18:1;4806:31;;48937:41:0;;;4788:50:1;4761:18;;48937:41:0;4644:200:1;48895:94:0;49002:17;;48998:82;;49042:27;;;;;;;;;;;;;;48998:82;-1:-1:-1;;47965:31:0;;;;;;;11593:25:1;;;;11634:18;;;11627:34;;;;47965:31:0;;;;;;;;;11566:18:1;;;;47965:31:0;;-1:-1:-1;;47955:42:0;;;;;;48606:653::o;68866:789::-;-1:-1:-1;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;68452:19:0;;-1:-1:-1;;69010:171:0;;68452:19;;69128:10;69162:8;69010:38;:171::i;:::-;69002:179;;69191:18;69212;:5;47679:7;47705:46;47719:5;:15;;;47736:5;:14;;;47965:31;;;;;;;11593:25:1;;;;11634:18;;;11627:34;;;;47965:31:0;;;;;;;;;11566:18:1;;;;47965:31:0;;47955:42;;;;;;47846:158;69212:18;69240:12;:29;;;;;;;;;;;;;;;;-1:-1:-1;69416:10:0;69284:186;;;69363:1;11315:50:1;;11396:2;11381:18;;11374:34;;;69284:186:0;;;;;;11288:18:1;69284:186:0;;;;;;;69616:7;69581:67;;;69636:10;69581:67;;;;2181:25:1;;2169:2;2154:18;;2035:177;69581:67:0;;;;;;;;68953:702;;68866:789;;;:::o;69858:1092::-;70030:21;70053:16;70073:53;70088:10;70100:5;:13;;;70115:10;;70073:14;:53::i;:::-;70029:97;;;;70152:8;70140:9;:20;70136:259;;;70183:52;;;;;70215:9;70183:52;;;11593:25:1;11634:18;;;11627:34;;;11566:18;;70183:52:0;11419:248:1;70136:259:0;70268:8;70256:9;:20;70252:143;;;70364:20;70376:8;70364:9;:20;:::i;:::-;70353:4;70358:1;70353:7;;;;;;;;:::i;:::-;;;;;;:31;;;;;;;:::i;:::-;;;-1:-1:-1;70252:143:0;70418:10;70404:11;70475:147;60286:1;70574:37;70605:5;70574:30;:37::i;70475:147::-;70445:177;;70637:9;70632:205;70656:3;70652:1;:7;70632:205;;;70698:10;;70709:1;70698:13;;;;;;;:::i;:::-;;;;;;;;;;;;;;:::i;:::-;70680:57;;;70745:4;70750:1;70745:7;;;;;;;;:::i;:::-;;;;;;;70771:10;70783:5;:13;;;70798:14;70680:146;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;70661:3;;;;:::i;:::-;;;70632:205;;;;70900:5;:13;;;70851:92;;70888:10;70851:92;;;70915:5;:15;;;70932:10;;70851:92;;;;;;;;:::i;:::-;;;;;;;;70019:931;;;;69858:1092;;;;:::o;43944:294::-;-1:-1:-1;;;;;;;;;;;;;;;;;;;;;;;;;44128:103:0;;;;;;;;44157:32;44175:13;44157:17;:32::i;:::-;44128:103;;;;;;44200:7;44128:103;;;;;;44220:9;44128:103;;;44121:110;;43944:294;;;;:::o;72838:561::-;73005:21;73028:16;73074:10;73105:8;;;73101:80;;73136:34;;;;;;;;;;;;;;73101:80;73211:3;73197:18;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;73197:18:0;;73190:25;;73230:9;73225:168;73249:3;73245:1;:7;73225:168;;;73301:10;;73312:1;73301:13;;;;;;;:::i;:::-;;;;;;;;;;;;;;:::i;:::-;73283:66;;;;;3745:18:1;3790:15;;;73283:66:0;;;3772:34:1;3842:15;;3822:18;;;3815:43;73283:45:0;;;;;;;;3708:18:1;;73283:66:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;73273:4;73278:1;73273:7;;;;;;;;:::i;:::-;;;;;;:76;;;;;73375:4;73380:1;73375:7;;;;;;;;:::i;:::-;;;;;;;73363:19;;;;;:::i;:::-;;-1:-1:-1;73254:3:0;;;:::i;:::-;;;73225:168;;;;73050:349;72838:561;;;;;;;:::o;44331:188::-;44405:12;44447:47;44462:5;:16;;;44480:5;:13;;;45482:37;;45506:2;45483:25;;;;;;45482:37;;45359:168;44447:47;44496:15;;;;;44436:76;;13898:34:1;13886:47;;;44436:76:0;;;13868:66:1;13950:18;;;13943:34;13841:18;;44436:76:0;;;;;;;;;;;;44429:83;;44331:188;;;:::o;4650:165::-;4743:12;4791:7;4800;4774:34;;;;;;;;;:::i;:::-;;;;;;;;;;;;;4767:41;;4650:165;;;;:::o;72451:326::-;72594:16;72613:21;72626:7;72613:12;:21::i;:::-;72594:40;;72662:9;72648:23;;:10;:23;;;72644:127;;72694:66;;;;;9711:18:1;9756:15;;;72694:66:0;;;9738:34:1;9808:15;;;9788:18;;;9781:43;9860:15;;9840:18;;;9833:43;9674:18;;72694:66:0;9505:377:1;72644:127:0;72528:249;72451:326;;:::o;71836:508::-;-1:-1:-1;;;;;;;;;;;;;;;;;;;;;;;;;71978:27:0;:14;;:25;:27::i;:::-;71959:46;-1:-1:-1;72019:23:0;;;60286:1;72019:23;72015:118;;72065:57;;;;;14613:6:1;14646:15;;72065:57:0;;;14628:34:1;60286:1:0;14678:18:1;;;14671:43;14576:18;;72065:57:0;14433:287:1;72015:118:0;72150:59;72181:27;:14;;:25;:27::i;:::-;72150:30;:59::i;:::-;72142:67;;72243:13;72223:5;:16;;;:33;;;72219:119;;72310:16;;72279:48;;;;;4818:18:1;4806:31;;;72279:48:0;;;4788:50:1;4761:18;;72279:48:0;4644:200:1;71029:320:0;71176:70;;;;;;;;71201:15;71176:70;;71229:15;;;;;71176:70;;;;;;;71141:22;;;-1:-1:-1;71141:22:0;;;:14;:22;;;;;;:32;;;;;;;;;;;:105;;;;;;;;;;;;;;71311:13;;;;71293:16;;71326:15;;71261:81;;2181:25:1;;;71261:81:0;;;;;;;;71141:22;;71261:81;;2154:18:1;71261:81:0;;;;;;;71029:320;;;:::o;47035:483::-;-1:-1:-1;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;47269:242:0;;;;;;;;47311:32;47329:13;47311:17;:32::i;:::-;47269:242;;;;;;47366:7;47269:242;;;;;;47399:10;47269:242;;;;;;47434:34;47461:6;3922:22;;;3825:127;47434:34;47269:242;;;;;;;;-1:-1:-1;47262:249:0;47035:483;-1:-1:-1;;;47035:483:0:o;21281:213::-;21337:6;21367:16;21359:24;;21355:103;;;21437:2;21406:41;;;;;;;;15159:36:1;;;;15211:18;;;15204:34;;;15132:18;;21406:41:0;14978:266:1;21355:103:0;-1:-1:-1;21481:5:0;21281:213::o;4987:432::-;5063:14;4357:1;5093:40;;5089:129;;;5190:16;;5156:51;;;;;;;;;;;;:::i;5089:129::-;-1:-1:-1;;5365:37:0;5360:3;5356:47;;4987:432::o;5647:287::-;5723:14;;4357:1;5753:40;;5749:129;;;5850:16;;5816:51;;;;;;;;;;;;:::i;5749:129::-;5894:33;:16;4357:1;5894:16;;:33;:::i;:::-;5887:40;;;;5647:287;;;;;;:::o;44624:261::-;-1:-1:-1;;;;;;;;;;;;;;;;;;;;;;;;;44776:37:0;;;;;;:::i;:::-;44757:15;;;44751:62;;-1:-1:-1;44859:19:0;44751:62;45755:26;45779:2;45755:26;;;;;45629:208;44859:19;44823:55;;;;44842:13;;;44823:55;;;;-1:-1:-1;44824:5:0;44624:261;-1:-1:-1;;44624:261:0:o;14:184:1:-;66:77;63:1;56:88;163:4;160:1;153:15;187:4;184:1;177:15;203:171;270:20;;330:18;319:30;;309:41;;299:69;;364:1;361;354:12;299:69;203:171;;;:::o;379:367::-;442:8;452:6;506:3;499:4;491:6;487:17;483:27;473:55;;524:1;521;514:12;473:55;-1:-1:-1;547:20:1;;590:18;579:30;;576:50;;;622:1;619;612:12;576:50;659:4;651:6;647:17;635:29;;719:3;712:4;702:6;699:1;695:14;687:6;683:27;679:38;676:47;673:67;;;736:1;733;726:12;751:1279;879:6;887;895;939:9;930:7;926:23;969:3;965:2;961:12;958:32;;;986:1;983;976:12;958:32;1010:4;1006:2;1002:13;999:33;;;1028:1;1025;1018:12;999:33;;1061:2;1055:9;1103:4;1095:6;1091:17;1127:18;1195:6;1183:10;1180:22;1175:2;1163:10;1160:18;1157:46;1154:226;;;1236:77;1233:1;1226:88;1337:4;1334:1;1327:15;1365:4;1362:1;1355:15;1154:226;1400:10;1396:2;1389:22;1435:28;1453:9;1435:28;:::i;:::-;1427:6;1420:44;1497:37;1530:2;1519:9;1515:18;1497:37;:::i;:::-;1492:2;1484:6;1480:15;1473:62;1568:37;1601:2;1590:9;1586:18;1568:37;:::i;:::-;1563:2;1555:6;1551:15;1544:62;1667:2;1656:9;1652:18;1639:32;1634:2;1626:6;1622:15;1615:57;1734:3;1723:9;1719:19;1706:33;1700:3;1692:6;1688:16;1681:59;1759:6;1749:16;;1816:4;1805:9;1801:20;1788:34;1774:48;;1845:2;1837:6;1834:14;1831:34;;;1861:1;1858;1851:12;1831:34;;;1900:70;1962:7;1953:6;1942:9;1938:22;1900:70;:::i;:::-;751:1279;;1989:8;;-1:-1:-1;1874:96:1;;-1:-1:-1;;;;751:1279:1:o;2410:328::-;2484:6;2492;2500;2553:2;2541:9;2532:7;2528:23;2524:32;2521:52;;;2569:1;2566;2559:12;2521:52;2592:28;2610:9;2592:28;:::i;:::-;2582:38;;2639:37;2672:2;2661:9;2657:18;2639:37;:::i;:::-;2629:47;;2695:37;2728:2;2717:9;2713:18;2695:37;:::i;:::-;2685:47;;2410:328;;;;;:::o;2743:632::-;2914:2;2966:21;;;3036:13;;2939:18;;;3058:22;;;2885:4;;2914:2;3137:15;;;;3111:2;3096:18;;;2885:4;3180:169;3194:6;3191:1;3188:13;3180:169;;;3255:13;;3243:26;;3324:15;;;;3289:12;;;;3216:1;3209:9;3180:169;;;-1:-1:-1;3366:3:1;;2743:632;-1:-1:-1;;;;;;2743:632:1:o;3380:180::-;3439:6;3492:2;3480:9;3471:7;3467:23;3463:32;3460:52;;;3508:1;3505;3498:12;3460:52;-1:-1:-1;3531:23:1;;3380:180;-1:-1:-1;3380:180:1:o;3869:581::-;3971:6;3979;3987;3995;4048:2;4036:9;4027:7;4023:23;4019:32;4016:52;;;4064:1;4061;4054:12;4016:52;4087:28;4105:9;4087:28;:::i;:::-;4077:38;;4134:37;4167:2;4156:9;4152:18;4134:37;:::i;:::-;4124:47;;4222:2;4211:9;4207:18;4194:32;4249:18;4241:6;4238:30;4235:50;;;4281:1;4278;4271:12;4235:50;4320:70;4382:7;4373:6;4362:9;4358:22;4320:70;:::i;:::-;3869:581;;;;-1:-1:-1;4409:8:1;-1:-1:-1;;;;3869:581:1:o;4455:184::-;4513:6;4566:2;4554:9;4545:7;4541:23;4537:32;4534:52;;;4582:1;4579;4572:12;4534:52;4605:28;4623:9;4605:28;:::i;5121:270::-;4971:12;;4928:18;4967:21;;;4955:34;;5042:4;5031:16;;;5025:23;5021:32;;;5005:14;;;4998:56;5103:4;5092:16;;;5086:23;5070:14;;;5063:47;5321:2;5306:18;;5333:52;4849:267;5396:509;5490:6;5498;5506;5559:2;5547:9;5538:7;5534:23;5530:32;5527:52;;;5575:1;5572;5565:12;5527:52;5598:28;5616:9;5598:28;:::i;:::-;5588:38;;5677:2;5666:9;5662:18;5649:32;5704:18;5696:6;5693:30;5690:50;;;5736:1;5733;5726:12;5690:50;5775:70;5837:7;5828:6;5817:9;5813:22;5775:70;:::i;6092:250::-;6177:1;6187:113;6201:6;6198:1;6195:13;6187:113;;;6277:11;;;6271:18;6258:11;;;6251:39;6223:2;6216:10;6187:113;;;-1:-1:-1;;6334:1:1;6316:16;;6309:27;6092:250::o;6347:329::-;6388:3;6426:5;6420:12;6453:6;6448:3;6441:19;6469:76;6538:6;6531:4;6526:3;6522:14;6515:4;6508:5;6504:16;6469:76;:::i;:::-;6590:2;6578:15;6595:66;6574:88;6565:98;;;;6665:4;6561:109;;6347:329;-1:-1:-1;;6347:329:1:o;6681:217::-;6828:2;6817:9;6810:21;6791:4;6848:44;6888:2;6877:9;6873:18;6865:6;6848:44;:::i;6903:256::-;6969:6;6977;7030:2;7018:9;7009:7;7005:23;7001:32;6998:52;;;7046:1;7043;7036:12;6998:52;7069:28;7087:9;7069:28;:::i;:::-;7059:38;;7116:37;7149:2;7138:9;7134:18;7116:37;:::i;:::-;7106:47;;6903:256;;;;;:::o;7164:591::-;7234:6;7242;7295:2;7283:9;7274:7;7270:23;7266:32;7263:52;;;7311:1;7308;7301:12;7263:52;7351:9;7338:23;7380:18;7421:2;7413:6;7410:14;7407:34;;;7437:1;7434;7427:12;7407:34;7475:6;7464:9;7460:22;7450:32;;7520:7;7513:4;7509:2;7505:13;7501:27;7491:55;;7542:1;7539;7532:12;7491:55;7582:2;7569:16;7608:2;7600:6;7597:14;7594:34;;;7624:1;7621;7614:12;7594:34;7669:7;7664:2;7655:6;7651:2;7647:15;7643:24;7640:37;7637:57;;;7690:1;7687;7680:12;7637:57;7721:2;7713:11;;;;;7743:6;;-1:-1:-1;7164:591:1;;-1:-1:-1;;;;7164:591:1:o;7760:196::-;7828:20;;7888:42;7877:54;;7867:65;;7857:93;;7946:1;7943;7936:12;7961:957;8062:6;8070;8114:9;8105:7;8101:23;8144:3;8140:2;8136:12;8133:32;;;8161:1;8158;8151:12;8133:32;8184:29;8203:9;8184:29;:::i;:::-;8174:39;;8306:4;8237:66;8233:2;8229:75;8225:86;8222:106;;;8324:1;8321;8314:12;8222:106;;8357:2;8351:9;8399:4;8391:6;8387:17;8470:6;8458:10;8455:22;8434:18;8422:10;8419:34;8416:62;8413:242;;;8511:77;8508:1;8501:88;8612:4;8609:1;8602:15;8640:4;8637:1;8630:15;8413:242;8671:2;8664:22;8710:37;8743:2;8728:18;;8710:37;:::i;:::-;8702:6;8695:53;8781:37;8814:2;8803:9;8799:18;8781:37;:::i;:::-;8776:2;8764:15;;8757:62;8880:4;8865:20;;;;8852:34;8847:2;8835:15;;8828:59;-1:-1:-1;7961:957:1;8768:6;;-1:-1:-1;7961:957:1:o;8923:577::-;9026:6;9034;9042;9050;9103:2;9091:9;9082:7;9078:23;9074:32;9071:52;;;9119:1;9116;9109:12;9071:52;9142:28;9160:9;9142:28;:::i;:::-;9132:38;;9217:2;9206:9;9202:18;9189:32;9179:42;;9272:2;9261:9;9257:18;9244:32;9299:18;9291:6;9288:30;9285:50;;;9331:1;9328;9321:12;9887:184;9939:77;9936:1;9929:88;10036:4;10033:1;10026:15;10060:4;10057:1;10050:15;10076:183;10144:18;10195:10;;;10183;;;10179:27;;10218:12;;;10215:38;;;10233:18;;:::i;10264:184::-;10316:77;10313:1;10306:88;10413:4;10410:1;10403:15;10437:4;10434:1;10427:15;10453:209;10491:3;10519:18;10572:2;10565:5;10561:14;10599:2;10590:7;10587:15;10584:41;;10605:18;;:::i;:::-;10654:1;10641:15;;10453:209;-1:-1:-1;;;10453:209:1:o;10667:462::-;10966:42;10954:55;;10936:74;;11041:2;11026:18;;;11019:34;;;4971:12;;4928:18;4967:21;;;11119:2;11104:18;;;4955:34;;;;5031:16;;;5025:23;5021:32;5005:14;;;4998:56;5092:16;;5086:23;5070:14;;;5063:47;10923:3;10908:19;;11062:61;4849:267;11672:128;11739:9;;;11760:11;;;11757:37;;;11774:18;;:::i;11805:125::-;11870:9;;;11891:10;;;11888:36;;;11904:18;;:::i;11935:186::-;11994:6;12047:2;12035:9;12026:7;12022:23;12018:32;12015:52;;;12063:1;12060;12053:12;12015:52;12086:29;12105:9;12086:29;:::i;12126:410::-;12288:4;12317:18;12374:2;12366:6;12362:15;12351:9;12344:34;12426:2;12418:6;12414:15;12409:2;12398:9;12394:18;12387:43;;12466:2;12461;12450:9;12446:18;12439:30;12486:44;12526:2;12515:9;12511:18;12503:6;12486:44;:::i;12541:195::-;12580:3;12611:66;12604:5;12601:77;12598:103;;12681:18;;:::i;:::-;-1:-1:-1;12728:1:1;12717:13;;12541:195::o;12741:730::-;12981:25;;;12969:2;13025;13043:18;;;13036:30;;;12954:18;;;13101:22;;;12921:4;;13180:6;;13154:2;13139:18;;12921:4;13214:231;13228:6;13225:1;13222:13;13214:231;;;13321:42;13293:26;13312:6;13293:26;:::i;:::-;13289:75;13277:88;;13420:15;;;;13385:12;;;;13250:1;13243:9;13214:231;;;-1:-1:-1;13462:3:1;12741:730;-1:-1:-1;;;;;;;12741:730:1:o;13476:184::-;13546:6;13599:2;13587:9;13578:7;13574:23;13570:32;13567:52;;;13615:1;13612;13605:12;13567:52;-1:-1:-1;13638:16:1;;13476:184;-1:-1:-1;13476:184:1:o;13988:440::-;14195:66;14186:6;14181:3;14177:16;14173:89;14168:3;14161:102;14143:3;14292:6;14286:13;14308:74;14375:6;14371:1;14366:3;14362:11;14355:4;14347:6;14343:17;14308:74;:::i;:::-;14402:16;;;;14420:1;14398:24;;13988:440;-1:-1:-1;;;13988:440:1:o;15249:447::-;15406:2;15395:9;15388:21;15445:6;15440:2;15429:9;15425:18;15418:34;15502:6;15494;15489:2;15478:9;15474:18;15461:48;15558:1;15529:22;;;15553:2;15525:31;;;15518:42;;;;15612:2;15600:15;;;15617:66;15596:88;15581:104;15577:113;;15249:447;-1:-1:-1;15249:447:1:o;15701:331::-;15806:9;15817;15859:8;15847:10;15844:24;15841:44;;;15881:1;15878;15871:12;15841:44;15910:6;15900:8;15897:20;15894:40;;;15930:1;15927;15920:12;15894:40;-1:-1:-1;;15956:23:1;;;16001:25;;;;;-1:-1:-1;15701:331:1:o;16037:398::-;16134:6;16142;16195:2;16183:9;16174:7;16170:23;16166:32;16163:52;;;16211:1;16208;16201:12;16163:52;16250:9;16237:23;16300:34;16293:5;16289:46;16282:5;16279:57;16269:85;;16350:1;16347;16340:12;16269:85;16373:5;16425:2;16410:18;;;;16397:32;;-1:-1:-1;;;16037:398:1:o","abiDefinition":[{"inputs":[{"internalType":"uint64","name":"entryIndex","type":"uint64"}],"name":"BatchingV1__EntryIndexNotZero","type":"error"},{"inputs":[],"name":"BatchingV1__ProofNotEmpty","type":"error"},{"inputs":[{"internalType":"address","name":"module","type":"address"},{"internalType":"bytes32","name":"existingBatchRoot","type":"bytes32"},{"components":[{"internalType":"uint64","name":"srcChainId","type":"uint64"},{"internalType":"uint64","name":"dbNonce","type":"uint64"},{"internalType":"bytes32","name":"batchRoot","type":"bytes32"}],"internalType":"struct InterchainBatch","name":"newBatch","type":"tuple"}],"name":"InterchainDB__BatchConflict","type":"error"},{"inputs":[{"internalType":"uint16","name":"version","type":"uint16"},{"internalType":"uint16","name":"required","type":"uint16"}],"name":"InterchainDB__BatchVersionMismatch","type":"error"},{"inputs":[{"internalType":"uint64","name":"chainId","type":"uint64"}],"name":"InterchainDB__ChainIdNotRemote","type":"error"},{"inputs":[{"internalType":"uint64","name":"dbNonce","type":"uint64"},{"internalType":"uint64","name":"entryIndex","type":"uint64"},{"internalType":"uint64","name":"batchSize","type":"uint64"}],"name":"InterchainDB__EntryIndexOutOfRange","type":"error"},{"inputs":[{"internalType":"uint64","name":"dbNonce","type":"uint64"},{"internalType":"uint64","name":"start","type":"uint64"},{"internalType":"uint64","name":"end","type":"uint64"}],"name":"InterchainDB__EntryRangeInvalid","type":"error"},{"inputs":[{"internalType":"uint256","name":"feeAmount","type":"uint256"},{"internalType":"uint256","name":"minRequired","type":"uint256"}],"name":"InterchainDB__FeeAmountBelowMin","type":"error"},{"inputs":[],"name":"InterchainDB__ModulesNotProvided","type":"error"},{"inputs":[{"internalType":"uint8","name":"bits","type":"uint8"},{"internalType":"uint256","name":"value","type":"uint256"}],"name":"SafeCastOverflowedUintDowncast","type":"error"},{"inputs":[{"internalType":"bytes","name":"versionedPayload","type":"bytes"}],"name":"VersionedPayload__PayloadTooShort","type":"error"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint64","name":"dbNonce","type":"uint64"},{"indexed":false,"internalType":"bytes32","name":"batchRoot","type":"bytes32"}],"name":"InterchainBatchFinalized","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint64","name":"dstChainId","type":"uint64"},{"indexed":true,"internalType":"uint64","name":"dbNonce","type":"uint64"},{"indexed":false,"internalType":"bytes32","name":"batchRoot","type":"bytes32"},{"indexed":false,"internalType":"address[]","name":"srcModules","type":"address[]"}],"name":"InterchainBatchVerificationRequested","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"module","type":"address"},{"indexed":true,"internalType":"uint64","name":"srcChainId","type":"uint64"},{"indexed":true,"internalType":"uint64","name":"dbNonce","type":"uint64"},{"indexed":false,"internalType":"bytes32","name":"batchRoot","type":"bytes32"}],"name":"InterchainBatchVerified","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint64","name":"dbNonce","type":"uint64"},{"indexed":false,"internalType":"uint64","name":"entryIndex","type":"uint64"},{"indexed":true,"internalType":"bytes32","name":"srcWriter","type":"bytes32"},{"indexed":false,"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"name":"InterchainEntryWritten","type":"event"},{"inputs":[],"name":"DB_VERSION","outputs":[{"internalType":"uint16","name":"","type":"uint16"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"dstModule","type":"address"},{"components":[{"internalType":"uint64","name":"srcChainId","type":"uint64"},{"internalType":"uint64","name":"dbNonce","type":"uint64"},{"internalType":"bytes32","name":"batchRoot","type":"bytes32"}],"internalType":"struct InterchainBatch","name":"batch","type":"tuple"}],"name":"checkBatchVerification","outputs":[{"internalType":"uint256","name":"moduleVerifiedAt","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint64","name":"dbNonce","type":"uint64"}],"name":"getBatch","outputs":[{"components":[{"internalType":"uint64","name":"srcChainId","type":"uint64"},{"internalType":"uint64","name":"dbNonce","type":"uint64"},{"internalType":"bytes32","name":"batchRoot","type":"bytes32"}],"internalType":"struct InterchainBatch","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint64","name":"dbNonce","type":"uint64"}],"name":"getBatchLeafs","outputs":[{"internalType":"bytes32[]","name":"leafs","type":"bytes32[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint64","name":"dbNonce","type":"uint64"},{"internalType":"uint64","name":"start","type":"uint64"},{"internalType":"uint64","name":"end","type":"uint64"}],"name":"getBatchLeafsPaginated","outputs":[{"internalType":"bytes32[]","name":"leafs","type":"bytes32[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"components":[{"internalType":"uint64","name":"srcChainId","type":"uint64"},{"internalType":"uint64","name":"dbNonce","type":"uint64"},{"internalType":"uint64","name":"entryIndex","type":"uint64"},{"internalType":"bytes32","name":"srcWriter","type":"bytes32"},{"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"internalType":"struct InterchainEntry","name":"entry","type":"tuple"},{"internalType":"bytes32[]","name":"proof","type":"bytes32[]"}],"name":"getBatchRoot","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint64","name":"dbNonce","type":"uint64"}],"name":"getBatchSize","outputs":[{"internalType":"uint64","name":"","type":"uint64"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getDBNonce","outputs":[{"internalType":"uint64","name":"","type":"uint64"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint64","name":"dbNonce","type":"uint64"},{"internalType":"uint64","name":"entryIndex","type":"uint64"}],"name":"getEntryProof","outputs":[{"internalType":"bytes32[]","name":"proof","type":"bytes32[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint64","name":"dbNonce","type":"uint64"},{"internalType":"uint64","name":"entryIndex","type":"uint64"}],"name":"getEntryValue","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint64","name":"dstChainId","type":"uint64"},{"internalType":"address[]","name":"srcModules","type":"address[]"}],"name":"getInterchainFee","outputs":[{"internalType":"uint256","name":"fee","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getNextEntryIndex","outputs":[{"internalType":"uint64","name":"dbNonce","type":"uint64"},{"internalType":"uint64","name":"entryIndex","type":"uint64"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint64","name":"dbNonce","type":"uint64"}],"name":"getVersionedBatch","outputs":[{"internalType":"bytes","name":"versionedBatch","type":"bytes"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint64","name":"dstChainId","type":"uint64"},{"internalType":"uint64","name":"dbNonce","type":"uint64"},{"internalType":"address[]","name":"srcModules","type":"address[]"}],"name":"requestBatchVerification","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"bytes","name":"versionedBatch","type":"bytes"}],"name":"verifyRemoteBatch","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"name":"writeEntry","outputs":[{"internalType":"uint64","name":"dbNonce","type":"uint64"},{"internalType":"uint64","name":"entryIndex","type":"uint64"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint64","name":"dstChainId","type":"uint64"},{"internalType":"bytes32","name":"dataHash","type":"bytes32"},{"internalType":"address[]","name":"srcModules","type":"address[]"}],"name":"writeEntryWithVerification","outputs":[{"internalType":"uint64","name":"dbNonce","type":"uint64"},{"internalType":"uint64","name":"entryIndex","type":"uint64"}],"stateMutability":"payable","type":"function"}],"userDoc":{"events":{"InterchainBatchFinalized(uint64,bytes32)":{"notice":"Emitted when a local batch is finalized."},"InterchainBatchVerificationRequested(uint64,uint64,bytes32,address[])":{"notice":"Emitted when a local batch is requested to be verified on a remote chain using the set of Interchain Modules."},"InterchainBatchVerified(address,uint64,uint64,bytes32)":{"notice":"Emitted when a remote batch is verified by the Interchain Module."},"InterchainEntryWritten(uint64,uint64,bytes32,bytes32)":{"notice":"Emitted when a local entry is written to the database."}},"kind":"user","methods":{"DB_VERSION()":{"notice":"Get the version of the Interchain DataBase."},"checkBatchVerification(address,(uint64,uint64,bytes32))":{"notice":"Check if the batch is verified by the Interchain Module on the destination chain. Note: returned zero value indicates that the module has not verified the batch."},"getBatch(uint64)":{"notice":"Get the finalized Interchain Batch with the given nonce."},"getBatchLeafs(uint64)":{"notice":"Returns the list of leafs of the finalized batch with the given nonce. Note: the leafs are ordered by the index of the written entry in the current batch, and the leafs value match the value of the written entry (srcWriter + dataHash hashed together)."},"getBatchLeafsPaginated(uint64,uint64,uint64)":{"notice":"Returns the list of leafs of the finalized batch with the given nonce, paginated by the given start and end indexes. The end index is exclusive. Note: this is useful when the batch contains a large number of leafs, and calling `getBatchLeafs` would result in a gas limit exceeded error."},"getBatchRoot((uint64,uint64,uint64,bytes32,bytes32),bytes32[])":{"notice":"Get the batch root containing the Interchain Entry with the given index."},"getBatchSize(uint64)":{"notice":"Returns the size of the finalized batch with the given nonce."},"getDBNonce()":{"notice":"Get the nonce of the database, which is incremented every time a new batch is finalized. This is the nonce of the current non-finalized batch."},"getEntryProof(uint64,uint64)":{"notice":"Get the Merkle proof of inclusion for the entry with the given index in the finalized batch with the given nonce."},"getEntryValue(uint64,uint64)":{"notice":"Get the Interchain Entry's value written on the local chain with the given batch nonce and entry index. Entry value is calculated as the hash of the writer address and the written data hash. Note: the batch does not have to be finalized to fetch the entry value."},"getInterchainFee(uint64,address[])":{"notice":"Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain using the provided Interchain Modules."},"getNextEntryIndex()":{"notice":"Get the index of the next entry to be written to the database."},"getVersionedBatch(uint64)":{"notice":"Get the versioned Interchain Batch with the given nonce. Note: will return a batch with an empty root if the batch does not exist, or is not finalized."},"requestBatchVerification(uint64,uint64,address[])":{"notice":"Request the given Interchain Modules to verify an existing batch. If the batch is not finalized, the module will verify it after finalization. For the finalized batch the batch root is already available, and the module can verify it immediately. Note: every module has a separate fee paid in the native gas token of the source chain, and `msg.value` must be equal to the sum of all fees. Note: this method is permissionless, and anyone can request verification for any batch."},"verifyRemoteBatch(bytes)":{"notice":"Allows the Interchain Module to verify the batch coming from the remote chain. The module SHOULD verify the exact finalized batch from the remote chain. If the batch with a given nonce is not finalized or does not exist, module CAN verify it with an empty root value. Once the batch is finalized, the module SHOULD re-verify the batch with the correct root value. Note: The DB will only accept the batch of the same version as the DB itself."},"writeEntry(bytes32)":{"notice":"Write data to the Interchain DataBase as a new entry in the current batch. Note: there are no guarantees that this entry will be available for reading on any of the remote chains. Use `requestBatchVerification` to ensure that the entry is available for reading on the destination chain."},"writeEntryWithVerification(uint64,bytes32,address[])":{"notice":"Write data to the Interchain DataBase as a new entry in the current batch. Then request the Interchain Modules to verify the batch containing the written entry on the destination chain. See `writeEntry` and `requestBatchVerification` for more details."}},"version":1},"developerDoc":{"errors":{"SafeCastOverflowedUintDowncast(uint8,uint256)":[{"details":"Value doesn't fit in an uint of `bits` size."}]},"events":{"InterchainBatchFinalized(uint64,bytes32)":{"params":{"batchRoot":"The Merkle root hash of the finalized batch.","dbNonce":"The nonce of the finalized batch."}},"InterchainBatchVerificationRequested(uint64,uint64,bytes32,address[])":{"params":{"batchRoot":"The Merkle root hash of the batch to be verified.","dbNonce":"The nonce of the batch to be verified.","dstChainId":"The ID of the destination chain.","srcModules":"The addresses of the Interchain Modules that will verify the batch."}},"InterchainBatchVerified(address,uint64,uint64,bytes32)":{"params":{"batchRoot":"The Merkle root hash of the verified batch.","dbNonce":"The nonce of the verified batch.","module":"The address of the Interchain Module that verified the batch.","srcChainId":"The ID of the source chain."}},"InterchainEntryWritten(uint64,uint64,bytes32,bytes32)":{"params":{"dataHash":"The written data hash.","dbNonce":"The nonce of the batch containing the entry.","entryIndex":"The index of the entry within the batch.","srcWriter":"The address of the writer."}}},"kind":"dev","methods":{"checkBatchVerification(address,(uint64,uint64,bytes32))":{"params":{"batch":"The Interchain Batch to check","dstModule":"The destination chain addresses of the Interchain Modules to use for verification"},"returns":{"moduleVerifiedAt":"   The block timestamp at which the batch was verified by the module,                             or ZERO if the module has not verified the batch."}},"getBatch(uint64)":{"details":"Will revert if the batch with the given nonce does not exist, or is not finalized.","params":{"dbNonce":"The database nonce of the finalized batch"}},"getBatchLeafs(uint64)":{"details":"Will revert if the batch with the given nonce does not exist, or is not finalized.","params":{"dbNonce":"The database nonce of the finalized batch"}},"getBatchLeafsPaginated(uint64,uint64,uint64)":{"details":"Will revert if the batch with the given nonce does not exist, or is not finalized. Will revert if the provided range is invalid.","params":{"dbNonce":"The database nonce of the finalized batch","end":"The end index of the paginated leafs, exclusive","start":"The start index of the paginated leafs, inclusive"}},"getBatchRoot((uint64,uint64,uint64,bytes32,bytes32),bytes32[])":{"params":{"entry":"The Interchain Entry to get the batch root for","proof":"The Merkle proof of inclusion for the entry in the batch"}},"getBatchSize(uint64)":{"details":"Will revert if the batch with the given nonce does not exist, or is not finalized.","params":{"dbNonce":"The database nonce of the finalized batch"}},"getEntryProof(uint64,uint64)":{"details":"Will revert if the batch with the given nonce does not exist, or is not finalized. Will revert if the entry with the given index does not exist within the batch.","params":{"dbNonce":"The database nonce of the finalized batch","entryIndex":"The index of the written entry within the batch"},"returns":{"proof":"      The Merkle proof of inclusion for the entry"}},"getEntryValue(uint64,uint64)":{"details":"Will revert if the batch with the given nonce does not exist, or the entry with the given index does not exist within the batch.","params":{"dbNonce":"The database nonce of the existing batch","entryIndex":"The index of the written entry within the batch"}},"getInterchainFee(uint64,address[])":{"details":"Will revert if the empty array of modules is provided.","params":{"dstChainId":"The chain id of the destination chain","srcModules":"The source chain addresses of the Interchain Modules to use for verification"}},"getNextEntryIndex()":{"returns":{"dbNonce":"     The database nonce of the batch including the next entry","entryIndex":"  The index of the next entry within that batch"}},"getVersionedBatch(uint64)":{"params":{"dbNonce":"The database nonce of the batch"}},"requestBatchVerification(uint64,uint64,address[])":{"details":"Will revert if the batch with the given nonce does not exist.","params":{"dbNonce":"The database nonce of the existing batch","dstChainId":"The chain id of the destination chain","srcModules":"The source chain addresses of the Interchain Modules to use for verification"}},"verifyRemoteBatch(bytes)":{"details":"Will revert if the batch with the same nonce but a different non-empty root is already verified.","params":{"versionedBatch":"The versioned Interchain Batch to verify"}},"writeEntry(bytes32)":{"params":{"dataHash":"The hash of the data to be written to the Interchain DataBase as a new entry"},"returns":{"dbNonce":"    The database nonce of the batch containing the written entry","entryIndex":" The index of the written entry within the batch"}},"writeEntryWithVerification(uint64,bytes32,address[])":{"details":"Will revert if the empty array of modules is provided.","params":{"dataHash":"The hash of the data to be written to the Interchain DataBase as a new entry","dstChainId":"The chain id of the destination chain","srcModules":"The source chain addresses of the Interchain Modules to use for verification"},"returns":{"dbNonce":"    The database nonce of the batch containing the written entry","entryIndex":" The index of the written entry within the batch"}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"}],\"name\":\"BatchingV1__EntryIndexNotZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BatchingV1__ProofNotEmpty\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"existingBatchRoot\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"srcChainId\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"batchRoot\",\"type\":\"bytes32\"}],\"internalType\":\"struct InterchainBatch\",\"name\":\"newBatch\",\"type\":\"tuple\"}],\"name\":\"InterchainDB__BatchConflict\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"version\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"required\",\"type\":\"uint16\"}],\"name\":\"InterchainDB__BatchVersionMismatch\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"}],\"name\":\"InterchainDB__ChainIdNotRemote\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"batchSize\",\"type\":\"uint64\"}],\"name\":\"InterchainDB__EntryIndexOutOfRange\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"start\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"end\",\"type\":\"uint64\"}],\"name\":\"InterchainDB__EntryRangeInvalid\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minRequired\",\"type\":\"uint256\"}],\"name\":\"InterchainDB__FeeAmountBelowMin\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InterchainDB__ModulesNotProvided\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"bits\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"SafeCastOverflowedUintDowncast\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"versionedPayload\",\"type\":\"bytes\"}],\"name\":\"VersionedPayload__PayloadTooShort\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"batchRoot\",\"type\":\"bytes32\"}],\"name\":\"InterchainBatchFinalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"dstChainId\",\"type\":\"uint64\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"batchRoot\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"}],\"name\":\"InterchainBatchVerificationRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"srcChainId\",\"type\":\"uint64\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"batchRoot\",\"type\":\"bytes32\"}],\"name\":\"InterchainBatchVerified\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"srcWriter\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"name\":\"InterchainEntryWritten\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DB_VERSION\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dstModule\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"srcChainId\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"batchRoot\",\"type\":\"bytes32\"}],\"internalType\":\"struct InterchainBatch\",\"name\":\"batch\",\"type\":\"tuple\"}],\"name\":\"checkBatchVerification\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"moduleVerifiedAt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"}],\"name\":\"getBatch\",\"outputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"srcChainId\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"batchRoot\",\"type\":\"bytes32\"}],\"internalType\":\"struct InterchainBatch\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"}],\"name\":\"getBatchLeafs\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"leafs\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"start\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"end\",\"type\":\"uint64\"}],\"name\":\"getBatchLeafsPaginated\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"leafs\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"srcChainId\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"srcWriter\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"internalType\":\"struct InterchainEntry\",\"name\":\"entry\",\"type\":\"tuple\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"getBatchRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"}],\"name\":\"getBatchSize\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDBNonce\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"}],\"name\":\"getEntryProof\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"}],\"name\":\"getEntryValue\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"dstChainId\",\"type\":\"uint64\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"}],\"name\":\"getInterchainFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNextEntryIndex\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"}],\"name\":\"getVersionedBatch\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"versionedBatch\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"dstChainId\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"}],\"name\":\"requestBatchVerification\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"versionedBatch\",\"type\":\"bytes\"}],\"name\":\"verifyRemoteBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"name\":\"writeEntry\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"dstChainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"}],\"name\":\"writeEntryWithVerification\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"}],\"stateMutability\":\"payable\",\"type\":\"function\"}],\"devdoc\":{\"errors\":{\"SafeCastOverflowedUintDowncast(uint8,uint256)\":[{\"details\":\"Value doesn't fit in an uint of `bits` size.\"}]},\"events\":{\"InterchainBatchFinalized(uint64,bytes32)\":{\"params\":{\"batchRoot\":\"The Merkle root hash of the finalized batch.\",\"dbNonce\":\"The nonce of the finalized batch.\"}},\"InterchainBatchVerificationRequested(uint64,uint64,bytes32,address[])\":{\"params\":{\"batchRoot\":\"The Merkle root hash of the batch to be verified.\",\"dbNonce\":\"The nonce of the batch to be verified.\",\"dstChainId\":\"The ID of the destination chain.\",\"srcModules\":\"The addresses of the Interchain Modules that will verify the batch.\"}},\"InterchainBatchVerified(address,uint64,uint64,bytes32)\":{\"params\":{\"batchRoot\":\"The Merkle root hash of the verified batch.\",\"dbNonce\":\"The nonce of the verified batch.\",\"module\":\"The address of the Interchain Module that verified the batch.\",\"srcChainId\":\"The ID of the source chain.\"}},\"InterchainEntryWritten(uint64,uint64,bytes32,bytes32)\":{\"params\":{\"dataHash\":\"The written data hash.\",\"dbNonce\":\"The nonce of the batch containing the entry.\",\"entryIndex\":\"The index of the entry within the batch.\",\"srcWriter\":\"The address of the writer.\"}}},\"kind\":\"dev\",\"methods\":{\"checkBatchVerification(address,(uint64,uint64,bytes32))\":{\"params\":{\"batch\":\"The Interchain Batch to check\",\"dstModule\":\"The destination chain addresses of the Interchain Modules to use for verification\"},\"returns\":{\"moduleVerifiedAt\":\"   The block timestamp at which the batch was verified by the module,                             or ZERO if the module has not verified the batch.\"}},\"getBatch(uint64)\":{\"details\":\"Will revert if the batch with the given nonce does not exist, or is not finalized.\",\"params\":{\"dbNonce\":\"The database nonce of the finalized batch\"}},\"getBatchLeafs(uint64)\":{\"details\":\"Will revert if the batch with the given nonce does not exist, or is not finalized.\",\"params\":{\"dbNonce\":\"The database nonce of the finalized batch\"}},\"getBatchLeafsPaginated(uint64,uint64,uint64)\":{\"details\":\"Will revert if the batch with the given nonce does not exist, or is not finalized. Will revert if the provided range is invalid.\",\"params\":{\"dbNonce\":\"The database nonce of the finalized batch\",\"end\":\"The end index of the paginated leafs, exclusive\",\"start\":\"The start index of the paginated leafs, inclusive\"}},\"getBatchRoot((uint64,uint64,uint64,bytes32,bytes32),bytes32[])\":{\"params\":{\"entry\":\"The Interchain Entry to get the batch root for\",\"proof\":\"The Merkle proof of inclusion for the entry in the batch\"}},\"getBatchSize(uint64)\":{\"details\":\"Will revert if the batch with the given nonce does not exist, or is not finalized.\",\"params\":{\"dbNonce\":\"The database nonce of the finalized batch\"}},\"getEntryProof(uint64,uint64)\":{\"details\":\"Will revert if the batch with the given nonce does not exist, or is not finalized. Will revert if the entry with the given index does not exist within the batch.\",\"params\":{\"dbNonce\":\"The database nonce of the finalized batch\",\"entryIndex\":\"The index of the written entry within the batch\"},\"returns\":{\"proof\":\"      The Merkle proof of inclusion for the entry\"}},\"getEntryValue(uint64,uint64)\":{\"details\":\"Will revert if the batch with the given nonce does not exist, or the entry with the given index does not exist within the batch.\",\"params\":{\"dbNonce\":\"The database nonce of the existing batch\",\"entryIndex\":\"The index of the written entry within the batch\"}},\"getInterchainFee(uint64,address[])\":{\"details\":\"Will revert if the empty array of modules is provided.\",\"params\":{\"dstChainId\":\"The chain id of the destination chain\",\"srcModules\":\"The source chain addresses of the Interchain Modules to use for verification\"}},\"getNextEntryIndex()\":{\"returns\":{\"dbNonce\":\"     The database nonce of the batch including the next entry\",\"entryIndex\":\"  The index of the next entry within that batch\"}},\"getVersionedBatch(uint64)\":{\"params\":{\"dbNonce\":\"The database nonce of the batch\"}},\"requestBatchVerification(uint64,uint64,address[])\":{\"details\":\"Will revert if the batch with the given nonce does not exist.\",\"params\":{\"dbNonce\":\"The database nonce of the existing batch\",\"dstChainId\":\"The chain id of the destination chain\",\"srcModules\":\"The source chain addresses of the Interchain Modules to use for verification\"}},\"verifyRemoteBatch(bytes)\":{\"details\":\"Will revert if the batch with the same nonce but a different non-empty root is already verified.\",\"params\":{\"versionedBatch\":\"The versioned Interchain Batch to verify\"}},\"writeEntry(bytes32)\":{\"params\":{\"dataHash\":\"The hash of the data to be written to the Interchain DataBase as a new entry\"},\"returns\":{\"dbNonce\":\"    The database nonce of the batch containing the written entry\",\"entryIndex\":\" The index of the written entry within the batch\"}},\"writeEntryWithVerification(uint64,bytes32,address[])\":{\"details\":\"Will revert if the empty array of modules is provided.\",\"params\":{\"dataHash\":\"The hash of the data to be written to the Interchain DataBase as a new entry\",\"dstChainId\":\"The chain id of the destination chain\",\"srcModules\":\"The source chain addresses of the Interchain Modules to use for verification\"},\"returns\":{\"dbNonce\":\"    The database nonce of the batch containing the written entry\",\"entryIndex\":\" The index of the written entry within the batch\"}}},\"version\":1},\"userdoc\":{\"events\":{\"InterchainBatchFinalized(uint64,bytes32)\":{\"notice\":\"Emitted when a local batch is finalized.\"},\"InterchainBatchVerificationRequested(uint64,uint64,bytes32,address[])\":{\"notice\":\"Emitted when a local batch is requested to be verified on a remote chain using the set of Interchain Modules.\"},\"InterchainBatchVerified(address,uint64,uint64,bytes32)\":{\"notice\":\"Emitted when a remote batch is verified by the Interchain Module.\"},\"InterchainEntryWritten(uint64,uint64,bytes32,bytes32)\":{\"notice\":\"Emitted when a local entry is written to the database.\"}},\"kind\":\"user\",\"methods\":{\"DB_VERSION()\":{\"notice\":\"Get the version of the Interchain DataBase.\"},\"checkBatchVerification(address,(uint64,uint64,bytes32))\":{\"notice\":\"Check if the batch is verified by the Interchain Module on the destination chain. Note: returned zero value indicates that the module has not verified the batch.\"},\"getBatch(uint64)\":{\"notice\":\"Get the finalized Interchain Batch with the given nonce.\"},\"getBatchLeafs(uint64)\":{\"notice\":\"Returns the list of leafs of the finalized batch with the given nonce. Note: the leafs are ordered by the index of the written entry in the current batch, and the leafs value match the value of the written entry (srcWriter + dataHash hashed together).\"},\"getBatchLeafsPaginated(uint64,uint64,uint64)\":{\"notice\":\"Returns the list of leafs of the finalized batch with the given nonce, paginated by the given start and end indexes. The end index is exclusive. Note: this is useful when the batch contains a large number of leafs, and calling `getBatchLeafs` would result in a gas limit exceeded error.\"},\"getBatchRoot((uint64,uint64,uint64,bytes32,bytes32),bytes32[])\":{\"notice\":\"Get the batch root containing the Interchain Entry with the given index.\"},\"getBatchSize(uint64)\":{\"notice\":\"Returns the size of the finalized batch with the given nonce.\"},\"getDBNonce()\":{\"notice\":\"Get the nonce of the database, which is incremented every time a new batch is finalized. This is the nonce of the current non-finalized batch.\"},\"getEntryProof(uint64,uint64)\":{\"notice\":\"Get the Merkle proof of inclusion for the entry with the given index in the finalized batch with the given nonce.\"},\"getEntryValue(uint64,uint64)\":{\"notice\":\"Get the Interchain Entry's value written on the local chain with the given batch nonce and entry index. Entry value is calculated as the hash of the writer address and the written data hash. Note: the batch does not have to be finalized to fetch the entry value.\"},\"getInterchainFee(uint64,address[])\":{\"notice\":\"Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain using the provided Interchain Modules.\"},\"getNextEntryIndex()\":{\"notice\":\"Get the index of the next entry to be written to the database.\"},\"getVersionedBatch(uint64)\":{\"notice\":\"Get the versioned Interchain Batch with the given nonce. Note: will return a batch with an empty root if the batch does not exist, or is not finalized.\"},\"requestBatchVerification(uint64,uint64,address[])\":{\"notice\":\"Request the given Interchain Modules to verify an existing batch. If the batch is not finalized, the module will verify it after finalization. For the finalized batch the batch root is already available, and the module can verify it immediately. Note: every module has a separate fee paid in the native gas token of the source chain, and `msg.value` must be equal to the sum of all fees. Note: this method is permissionless, and anyone can request verification for any batch.\"},\"verifyRemoteBatch(bytes)\":{\"notice\":\"Allows the Interchain Module to verify the batch coming from the remote chain. The module SHOULD verify the exact finalized batch from the remote chain. If the batch with a given nonce is not finalized or does not exist, module CAN verify it with an empty root value. Once the batch is finalized, the module SHOULD re-verify the batch with the correct root value. Note: The DB will only accept the batch of the same version as the DB itself.\"},\"writeEntry(bytes32)\":{\"notice\":\"Write data to the Interchain DataBase as a new entry in the current batch. Note: there are no guarantees that this entry will be available for reading on any of the remote chains. Use `requestBatchVerification` to ensure that the entry is available for reading on the destination chain.\"},\"writeEntryWithVerification(uint64,bytes32,address[])\":{\"notice\":\"Write data to the Interchain DataBase as a new entry in the current batch. Then request the Interchain Modules to verify the batch containing the written entry on the destination chain. See `writeEntry` and `requestBatchVerification` for more details.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainDB.sol\":\"InterchainDB\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainDB.sol\":{\"keccak256\":\"0x4dd7dd2bde0a2d89cb06f57f8772f18d4b0547c65abb43503e5fc2dedf60ac3e\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://e22ed31c26dd9174d0f333bf9d8d5916d407c0c99aa908c56a6c4156756a5e1e\",\"dweb:/ipfs/QmTi96nhB9Vr3SRq9qa24zbPvctFSNubneRuohgndhAqHK\"]}},\"version\":1}"},"hashes":{"DB_VERSION()":"15f53956","checkBatchVerification(address,(uint64,uint64,bytes32))":"e39682c1","getBatch(uint64)":"888775d9","getBatchLeafs(uint64)":"fc1ebc91","getBatchLeafsPaginated(uint64,uint64,uint64)":"1c679ac1","getBatchRoot((uint64,uint64,uint64,bytes32,bytes32),bytes32[])":"0166204f","getBatchSize(uint64)":"727a5f91","getDBNonce()":"f338140e","getEntryProof(uint64,uint64)":"fec8dfb9","getEntryValue(uint64,uint64)":"d180db6f","getInterchainFee(uint64,address[])":"b8ba4ba1","getNextEntryIndex()":"aa2f06ae","getVersionedBatch(uint64)":"c7265781","requestBatchVerification(uint64,uint64,address[])":"6c49312c","verifyRemoteBatch(bytes)":"d961a48e","writeEntry(bytes32)":"2ad8c706","writeEntryWithVerification(uint64,bytes32,address[])":"eb20fbfd"}},"solidity/InterchainDB.sol:InterchainDBEvents":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainDBEvents.sol\n\nabstract contract InterchainDBEvents {\n    /// @notice Emitted when a local entry is written to the database.\n    /// @param dbNonce      The nonce of the batch containing the entry.\n    /// @param entryIndex   The index of the entry within the batch.\n    /// @param srcWriter    The address of the writer.\n    /// @param dataHash     The written data hash.\n    event InterchainEntryWritten(\n        uint64 indexed dbNonce, uint64 entryIndex, bytes32 indexed srcWriter, bytes32 dataHash\n    );\n\n    /// @notice Emitted when a local batch is finalized.\n    /// @param dbNonce      The nonce of the finalized batch.\n    /// @param batchRoot    The Merkle root hash of the finalized batch.\n    event InterchainBatchFinalized(uint64 indexed dbNonce, bytes32 batchRoot);\n\n    /// @notice Emitted when a remote batch is verified by the Interchain Module.\n    /// @param module       The address of the Interchain Module that verified the batch.\n    /// @param srcChainId   The ID of the source chain.\n    /// @param dbNonce      The nonce of the verified batch.\n    /// @param batchRoot    The Merkle root hash of the verified batch.\n    event InterchainBatchVerified(\n        address indexed module, uint64 indexed srcChainId, uint64 indexed dbNonce, bytes32 batchRoot\n    );\n\n    /// @notice Emitted when a local batch is requested to be verified on a remote chain\n    /// using the set of Interchain Modules.\n    /// @param dstChainId   The ID of the destination chain.\n    /// @param dbNonce      The nonce of the batch to be verified.\n    /// @param batchRoot    The Merkle root hash of the batch to be verified.\n    /// @param srcModules   The addresses of the Interchain Modules that will verify the batch.\n    event InterchainBatchVerificationRequested(\n        uint64 indexed dstChainId, uint64 indexed dbNonce, bytes32 batchRoot, address[] srcModules\n    );\n}\n\n// contracts/interfaces/IInterchainModule.sol\n\n/// @notice Every Module may opt a different method to confirm the verified entries on destination chain,\n/// therefore this is not a part of a common interface.\ninterface IInterchainModule {\n    error InterchainModule__CallerNotInterchainDB(address caller);\n    error InterchainModule__ChainIdNotRemote(uint64 chainId);\n    error InterchainModule__FeeAmountBelowMin(uint256 feeAmount, uint256 minRequired);\n\n    /// @notice Request the verification of a batch from the Interchain DataBase by the module.\n    /// If the batch is not yet finalized, the verification on destination chain will be delayed until\n    /// the finalization is done and batch root is saved on the source chain.\n    /// Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`.\n    /// Note: this will eventually trigger `InterchainDB.verifyRemoteBatch(batch)` function on destination chain,\n    /// with no guarantee of ordering.\n    /// @dev Could be only called by the Interchain DataBase contract.\n    /// @param dstChainId       The chain id of the destination chain\n    /// @param batchNonce       The nonce of the batch on the source chain\n    /// @param versionedBatch   The versioned batch to verify\n    function requestBatchVerification(\n        uint64 dstChainId,\n        uint64 batchNonce,\n        bytes memory versionedBatch\n    )\n        external\n        payable;\n\n    /// @notice Get the Module fee for verifying a batch on the specified destination chain.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dbNonce      The database nonce of the batch on the source chain\n    function getModuleFee(uint64 dstChainId, uint64 dbNonce) external view returns (uint256);\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/VersionedPayload.sol\n\n// solhint-disable no-inline-assembly\n// solhint-disable ordering\nlibrary VersionedPayloadLib {\n    /// @notice Amount of bytes reserved for the version (uint16) in the versioned payload\n    uint256 internal constant VERSION_LENGTH = 2;\n\n    error VersionedPayload__PayloadTooShort(bytes versionedPayload);\n    error VersionedPayload__PrecompileFailed();\n\n    /// @notice Encodes the versioned payload into a single bytes array.\n    /// @param version  The payload's version.\n    /// @param payload  The payload to encode.\n    function encodeVersionedPayload(uint16 version, bytes memory payload) internal pure returns (bytes memory) {\n        return abi.encodePacked(version, payload);\n    }\n\n    /// @notice Extracts the version from the versioned payload (calldata reference).\n    /// @param versionedPayload     The versioned payload (calldata reference).\n    function getVersion(bytes calldata versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__PayloadTooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            version := shr(240, calldataload(versionedPayload.offset))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (calldata reference).\n    /// @dev The extracted payload is also returned as a calldata reference.\n    /// @param versionedPayload     The versioned payload.\n    function getPayload(bytes calldata versionedPayload) internal pure returns (bytes calldata) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__PayloadTooShort(versionedPayload);\n        }\n        return versionedPayload[VERSION_LENGTH:];\n    }\n\n    /// @notice Extracts the version from the versioned payload (memory reference).\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getVersionFromMemory(bytes memory versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__PayloadTooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            // We add 0x20 to skip the length of the bytes array.\n            version := shr(240, mload(add(versionedPayload, 0x20)))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (memory reference).\n    /// @dev The extracted payload is copied into a new memory location. Use `getPayload` when possible\n    /// to avoid extra memory allocation.\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getPayloadFromMemory(bytes memory versionedPayload) internal view returns (bytes memory payload) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__PayloadTooShort(versionedPayload);\n        }\n        // Figure how many bytes to copy and allocate the memory for the extracted payload.\n        uint256 toCopy;\n        unchecked {\n            toCopy = versionedPayload.length - VERSION_LENGTH;\n        }\n        payload = new bytes(toCopy);\n        // Use identity precompile (0x04) to copy the payload. Unlike MCOPY, this is available on all EVM chains.\n        bool res;\n        assembly {\n            // We add 0x20 to skip the length of the bytes array.\n            // We add 0x02 to skip the 2 bytes reserved for the version.\n            // Copy the payload to the previously allocated memory.\n            res := staticcall(gas(), 0x04, add(versionedPayload, 0x22), toCopy, add(payload, 0x20), toCopy)\n        }\n        if (!res) {\n            revert VersionedPayload__PrecompileFailed();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SafeCast.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value \u003e type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value \u003e type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value \u003e type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value \u003e type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value \u003e type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value \u003e type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value \u003e type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value \u003e type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value \u003e type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value \u003e type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value \u003e type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value \u003e type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value \u003e type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value \u003e type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value \u003e type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value \u003e type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value \u003e type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value \u003e type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value \u003e type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value \u003e type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value \u003e type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value \u003e type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value \u003e type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value \u003e type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value \u003e type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value \u003e type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value \u003e type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value \u003e type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value \u003e type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value \u003e type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value \u003e type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value \u003c 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value \u003e uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n}\n\n// contracts/libs/InterchainBatch.sol\n\ntype BatchKey is uint128;\n\n/// @notice Struct representing a batch of entries in the Interchain DataBase.\n/// Batched entries are put together in a Merkle tree, which root is saved.\n/// Batch has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: batchRoot\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch\n/// @param batchRoot    The root of the Merkle tree containing the batched entries\nstruct InterchainBatch {\n    uint64 srcChainId;\n    uint64 dbNonce;\n    bytes32 batchRoot;\n}\n\n/// @dev Signals that the module has not verified any batch with the given key.\nuint256 constant BATCH_UNVERIFIED = 0;\n/// @dev Signals that the module has verified a conflicting batch with the given key.\nuint256 constant BATCH_CONFLICT = type(uint256).max;\n\nlibrary InterchainBatchLib {\n    using VersionedPayloadLib for bytes;\n\n    /// @notice Constructs an InterchainBatch struct to be saved on the local chain.\n    /// @param dbNonce      The database nonce of the batch\n    /// @param batchRoot    The root of the Merkle tree containing the batched entries\n    /// @return batch       The constructed InterchainBatch struct\n    function constructLocalBatch(\n        uint64 dbNonce,\n        bytes32 batchRoot\n    )\n        internal\n        view\n        returns (InterchainBatch memory batch)\n    {\n        return InterchainBatch({srcChainId: SafeCast.toUint64(block.chainid), dbNonce: dbNonce, batchRoot: batchRoot});\n    }\n\n    /// @notice Encodes the InterchainBatch struct into a non-versioned batch payload.\n    function encodeBatch(InterchainBatch memory batch) internal pure returns (bytes memory) {\n        return abi.encode(encodeBatchKey(batch.srcChainId, batch.dbNonce), batch.batchRoot);\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in calldata.\n    function decodeBatch(bytes calldata data) internal pure returns (InterchainBatch memory batch) {\n        BatchKey key;\n        (key, batch.batchRoot) = abi.decode(data, (BatchKey, bytes32));\n        (batch.srcChainId, batch.dbNonce) = decodeBatchKey(key);\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in memory.\n    function decodeBatchFromMemory(bytes memory data) internal pure returns (InterchainBatch memory batch) {\n        BatchKey key;\n        (key, batch.batchRoot) = abi.decode(data, (BatchKey, bytes32));\n        (batch.srcChainId, batch.dbNonce) = decodeBatchKey(key);\n    }\n\n    /// @notice Encodes the uint128 key of the batch from uint64 srcChainId and uint64 dbNonce.\n    function encodeBatchKey(uint64 srcChainId, uint64 dbNonce) internal pure returns (BatchKey) {\n        return BatchKey.wrap((uint128(srcChainId) \u003c\u003c 64) | dbNonce);\n    }\n\n    /// @notice Decodes the uint128 key of the batch into uint64 srcChainId and uint64 dbNonce.\n    function decodeBatchKey(BatchKey key) internal pure returns (uint64 srcChainId, uint64 dbNonce) {\n        srcChainId = uint64(BatchKey.unwrap(key) \u003e\u003e 64);\n        dbNonce = uint64(BatchKey.unwrap(key));\n    }\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce + entryIndex\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch containing the entry\n/// @param entryIndex   The index of the entry in the batch\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint64 srcChainId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nusing InterchainEntryLib for InterchainEntry global;\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint64 dbNonce,\n        uint64 entryIndex,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: SafeCast.toUint64(block.chainid),\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return getEntryValue(entry.srcWriter, entry.dataHash);\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function getEntryValue(bytes32 srcWriter, bytes32 dataHash) internal pure returns (bytes32) {\n        return keccak256(abi.encode(srcWriter, dataHash));\n    }\n}\n\n// contracts/libs/BatchingV1.sol\n\nlibrary BatchingV1Lib {\n    error BatchingV1__EntryIndexNotZero(uint64 entryIndex);\n    error BatchingV1__ProofNotEmpty();\n\n    /// @notice Get the batch root containing the Interchain Entry with the given index.\n    /// @param srcWriter    The entry writer of the source chain\n    /// @param dataHash     The hash of the data of the entry\n    /// @param entryIndex   The index of the entry in the batch\n    /// @param proof        The Merkle proof of inclusion for the entry in the batch\n    /// @return batchRoot   The root of the batch containing the entry\n    function getBatchRoot(\n        bytes32 srcWriter,\n        bytes32 dataHash,\n        uint64 entryIndex,\n        bytes32[] calldata proof\n    )\n        internal\n        pure\n        returns (bytes32 batchRoot)\n    {\n        // In \"no batching\" mode: entry index is 0, proof is empty\n        if (entryIndex != 0) {\n            revert BatchingV1__EntryIndexNotZero(entryIndex);\n        }\n        if (proof.length != 0) {\n            revert BatchingV1__ProofNotEmpty();\n        }\n        // In \"no batching\" mode: the batch root is the same as the entry value\n        return InterchainEntryLib.getEntryValue({srcWriter: srcWriter, dataHash: dataHash});\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    error InterchainDB__BatchConflict(address module, bytes32 existingBatchRoot, InterchainBatch newBatch);\n    error InterchainDB__BatchVersionMismatch(uint16 version, uint16 required);\n    error InterchainDB__ChainIdNotRemote(uint64 chainId);\n    error InterchainDB__EntryIndexOutOfRange(uint64 dbNonce, uint64 entryIndex, uint64 batchSize);\n    error InterchainDB__EntryRangeInvalid(uint64 dbNonce, uint64 start, uint64 end);\n    error InterchainDB__FeeAmountBelowMin(uint256 feeAmount, uint256 minRequired);\n    error InterchainDB__ModulesNotProvided();\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `requestBatchVerification` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntry(bytes32 dataHash) external returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Request the given Interchain Modules to verify an existing batch.\n    /// If the batch is not finalized, the module will verify it after finalization.\n    /// For the finalized batch the batch root is already available, and the module can verify it immediately.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any batch.\n    /// @dev Will revert if the batch with the given nonce does not exist.\n    /// @param dstChainId    The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the existing batch\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestBatchVerification(\n        uint64 dstChainId,\n        uint64 dbNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Then request the Interchain Modules to verify the batch containing the written entry on the destination chain.\n    /// See `writeEntry` and `requestBatchVerification` for more details.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntryWithVerification(\n        uint64 dstChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Allows the Interchain Module to verify the batch coming from the remote chain.\n    /// The module SHOULD verify the exact finalized batch from the remote chain. If the batch with a given nonce\n    /// is not finalized or does not exist, module CAN verify it with an empty root value. Once the batch is\n    /// finalized, the module SHOULD re-verify the batch with the correct root value.\n    /// Note: The DB will only accept the batch of the same version as the DB itself.\n    /// @dev Will revert if the batch with the same nonce but a different non-empty root is already verified.\n    /// @param versionedBatch   The versioned Interchain Batch to verify\n    function verifyRemoteBatch(bytes memory versionedBatch) external;\n\n    //  VIEWS \n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint64 dstChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce.\n    /// Note: the leafs are ordered by the index of the written entry in the current batch,\n    /// and the leafs value match the value of the written entry (srcWriter + dataHash hashed together).\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchLeafs(uint64 dbNonce) external view returns (bytes32[] memory);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce,\n    /// paginated by the given start and end indexes. The end index is exclusive.\n    /// Note: this is useful when the batch contains a large number of leafs, and calling `getBatchLeafs`\n    /// would result in a gas limit exceeded error.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the provided range is invalid.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param start        The start index of the paginated leafs, inclusive\n    /// @param end          The end index of the paginated leafs, exclusive\n    function getBatchLeafsPaginated(\n        uint64 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory);\n\n    /// @notice Returns the size of the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchSize(uint64 dbNonce) external view returns (uint64);\n\n    /// @notice Get the finalized Interchain Batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatch(uint64 dbNonce) external view returns (InterchainBatch memory);\n\n    /// @notice Get the versioned Interchain Batch with the given nonce.\n    /// Note: will return a batch with an empty root if the batch does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the batch\n    function getVersionedBatch(uint64 dbNonce) external view returns (bytes memory);\n\n    /// @notice Get the Interchain Entry's value written on the local chain with the given batch nonce and entry index.\n    /// Entry value is calculated as the hash of the writer address and the written data hash.\n    /// Note: the batch does not have to be finalized to fetch the entry value.\n    /// @dev Will revert if the batch with the given nonce does not exist,\n    /// or the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the existing batch\n    /// @param entryIndex   The index of the written entry within the batch\n    function getEntryValue(uint64 dbNonce, uint64 entryIndex) external view returns (bytes32);\n\n    /// @notice Get the Merkle proof of inclusion for the entry with the given index\n    /// in the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param entryIndex   The index of the written entry within the batch\n    /// @return proof       The Merkle proof of inclusion for the entry\n    function getEntryProof(uint64 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof);\n\n    /// @notice Get the nonce of the database, which is incremented every time a new batch is finalized.\n    /// This is the nonce of the current non-finalized batch.\n    function getDBNonce() external view returns (uint64);\n\n    /// @notice Get the index of the next entry to be written to the database.\n    /// @return dbNonce      The database nonce of the batch including the next entry\n    /// @return entryIndex   The index of the next entry within that batch\n    function getNextEntryIndex() external view returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Check if the batch is verified by the Interchain Module on the destination chain.\n    /// Note: returned zero value indicates that the module has not verified the batch.\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @param batch        The Interchain Batch to check\n    /// @return moduleVerifiedAt    The block timestamp at which the batch was verified by the module,\n    ///                             or ZERO if the module has not verified the batch.\n    function checkBatchVerification(\n        address dstModule,\n        InterchainBatch memory batch\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n\n    /// @notice Get the batch root containing the Interchain Entry with the given index.\n    /// @param entry         The Interchain Entry to get the batch root for\n    /// @param proof         The Merkle proof of inclusion for the entry in the batch\n    function getBatchRoot(InterchainEntry memory entry, bytes32[] memory proof) external pure returns (bytes32);\n\n    /// @notice Get the version of the Interchain DataBase.\n    // solhint-disable-next-line func-name-mixedcase\n    function DB_VERSION() external pure returns (uint16);\n}\n\n// contracts/InterchainDB.sol\n\ncontract InterchainDB is InterchainDBEvents, IInterchainDB {\n    using VersionedPayloadLib for bytes;\n\n    /// @notice Struct representing a batch of entries from the remote Interchain DataBase,\n    /// verified by the Interchain Module.\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param batchRoot    The Merkle root of the batch\n    struct RemoteBatch {\n        uint256 verifiedAt;\n        bytes32 batchRoot;\n    }\n\n    uint16 public constant DB_VERSION = 1;\n\n    bytes32[] internal _entryValues;\n    mapping(address module =\u003e mapping(BatchKey batchKey =\u003e RemoteBatch batch)) internal _remoteBatches;\n\n    modifier onlyRemoteChainId(uint64 chainId) {\n        if (chainId == block.chainid) {\n            revert InterchainDB__ChainIdNotRemote(chainId);\n        }\n        _;\n    }\n\n    //  WRITER-FACING \n\n    /// @inheritdoc IInterchainDB\n    function writeEntry(bytes32 dataHash) external returns (uint64 dbNonce, uint64 entryIndex) {\n        InterchainEntry memory entry = _writeEntry(dataHash);\n        (dbNonce, entryIndex) = (entry.dbNonce, entry.entryIndex);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function requestBatchVerification(\n        uint64 dstChainId,\n        uint64 dbNonce,\n        address[] calldata srcModules\n    )\n        external\n        payable\n        onlyRemoteChainId(dstChainId)\n    {\n        InterchainBatch memory batch = getBatch(dbNonce);\n        _requestVerification(dstChainId, batch, srcModules);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function writeEntryWithVerification(\n        uint64 dstChainId,\n        bytes32 dataHash,\n        address[] calldata srcModules\n    )\n        external\n        payable\n        onlyRemoteChainId(dstChainId)\n        returns (uint64 dbNonce, uint64 entryIndex)\n    {\n        InterchainEntry memory entry = _writeEntry(dataHash);\n        (dbNonce, entryIndex) = (entry.dbNonce, entry.entryIndex);\n        // In \"no batching\" mode: the batch root is the same as the entry value\n        InterchainBatch memory batch = InterchainBatchLib.constructLocalBatch(dbNonce, entry.entryValue());\n        _requestVerification(dstChainId, batch, srcModules);\n    }\n\n    //  MODULE-FACING \n\n    /// @inheritdoc IInterchainDB\n    function verifyRemoteBatch(bytes calldata versionedBatch) external {\n        InterchainBatch memory batch = _assertCorrectBatch(versionedBatch);\n        BatchKey batchKey = InterchainBatchLib.encodeBatchKey({srcChainId: batch.srcChainId, dbNonce: batch.dbNonce});\n        RemoteBatch memory existingBatch = _remoteBatches[msg.sender][batchKey];\n        // Check if that's the first time module verifies the batch\n        if (existingBatch.verifiedAt == 0) {\n            _saveVerifiedBatch(msg.sender, batchKey, batch);\n            return;\n        }\n        // No-op if the batch root is the same\n        if (existingBatch.batchRoot == batch.batchRoot) {\n            return;\n        }\n        // Overwriting an empty (non-existent) batch with a different one is allowed\n        if (existingBatch.batchRoot == 0) {\n            _saveVerifiedBatch(msg.sender, batchKey, batch);\n            return;\n        }\n        // Overwriting an existing batch with a different one is not allowed\n        revert InterchainDB__BatchConflict(msg.sender, existingBatch.batchRoot, batch);\n    }\n\n    //  VIEWS \n\n    /// @inheritdoc IInterchainDB\n    function getBatchLeafs(uint64 dbNonce) external view returns (bytes32[] memory leafs) {\n        uint256 batchSize = getBatchSize(dbNonce);\n        leafs = new bytes32[](batchSize);\n        for (uint64 i = 0; i \u003c batchSize; ++i) {\n            leafs[i] = getEntryValue(dbNonce, i);\n        }\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getBatchLeafsPaginated(\n        uint64 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory leafs)\n    {\n        uint256 size = getBatchSize(dbNonce);\n        if (start \u003e end || end \u003e size) {\n            revert InterchainDB__EntryRangeInvalid(dbNonce, start, end);\n        }\n        leafs = new bytes32[](end - start);\n        for (uint64 i = start; i \u003c end; ++i) {\n            leafs[i - start] = getEntryValue(dbNonce, i);\n        }\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getEntryProof(uint64 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof) {\n        // In \"no batching\" mode: the batch root is the same as the entry value, hence the proof is empty\n        _assertEntryExists(dbNonce, entryIndex);\n        return new bytes32[](0);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getInterchainFee(uint64 dstChainId, address[] calldata srcModules) external view returns (uint256 fee) {\n        (, fee) = _getModuleFees(dstChainId, getDBNonce(), srcModules);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getNextEntryIndex() external view returns (uint64 dbNonce, uint64 entryIndex) {\n        // In \"no batching\" mode: entry index is 0, batch size is 1\n        dbNonce = getDBNonce();\n        entryIndex = 0;\n    }\n\n    /// @inheritdoc IInterchainDB\n    function checkBatchVerification(\n        address dstModule,\n        InterchainBatch memory batch\n    )\n        external\n        view\n        onlyRemoteChainId(batch.srcChainId)\n        returns (uint256 moduleVerifiedAt)\n    {\n        BatchKey batchKey = InterchainBatchLib.encodeBatchKey({srcChainId: batch.srcChainId, dbNonce: batch.dbNonce});\n        RemoteBatch memory remoteBatch = _remoteBatches[dstModule][batchKey];\n        // Check if module verified anything for this batch key first\n        if (remoteBatch.verifiedAt == 0) {\n            return BATCH_UNVERIFIED;\n        }\n        // Check if the batch root matches the one verified by the module\n        return remoteBatch.batchRoot == batch.batchRoot ? remoteBatch.verifiedAt : BATCH_CONFLICT;\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getVersionedBatch(uint64 dbNonce) external view returns (bytes memory versionedBatch) {\n        InterchainBatch memory batch = getBatch(dbNonce);\n        return VersionedPayloadLib.encodeVersionedPayload({\n            version: DB_VERSION,\n            payload: InterchainBatchLib.encodeBatch(batch)\n        });\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getBatchRoot(InterchainEntry memory entry, bytes32[] calldata proof) external pure returns (bytes32) {\n        return BatchingV1Lib.getBatchRoot({\n            srcWriter: entry.srcWriter,\n            dataHash: entry.dataHash,\n            entryIndex: entry.entryIndex,\n            proof: proof\n        });\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getBatchSize(uint64 dbNonce) public view returns (uint64) {\n        // In \"no batching\" mode: the finalized batch size is 1, the pending batch size is 0\n        // We also return 0 for non-existent batches\n        return dbNonce \u003c getDBNonce() ? 1 : 0;\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getBatch(uint64 dbNonce) public view returns (InterchainBatch memory) {\n        // In \"no batching\" mode: the batch root is the same as the entry hash.\n        // For non-finalized or non-existent batches, the batch root is 0.\n        bytes32 batchRoot = dbNonce \u003c getDBNonce() ? getEntryValue(dbNonce, 0) : bytes32(0);\n        return InterchainBatchLib.constructLocalBatch(dbNonce, batchRoot);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getEntryValue(uint64 dbNonce, uint64 entryIndex) public view returns (bytes32) {\n        _assertEntryExists(dbNonce, entryIndex);\n        return _entryValues[dbNonce];\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getDBNonce() public view returns (uint64) {\n        // We can do the unsafe cast here as writing more than 2^64 entries is practically impossible\n        return uint64(_entryValues.length);\n    }\n\n    //  INTERNAL LOGIC \n\n    /// @dev Write the entry to the database and emit the event.\n    function _writeEntry(bytes32 dataHash) internal returns (InterchainEntry memory entry) {\n        uint64 dbNonce = getDBNonce();\n        entry = InterchainEntryLib.constructLocalEntry({\n            dbNonce: dbNonce,\n            entryIndex: 0,\n            writer: msg.sender,\n            dataHash: dataHash\n        });\n        bytes32 entryValue = entry.entryValue();\n        _entryValues.push(entryValue);\n        emit InterchainEntryWritten({\n            dbNonce: dbNonce,\n            entryIndex: 0,\n            srcWriter: TypeCasts.addressToBytes32(msg.sender),\n            dataHash: dataHash\n        });\n        // In the InterchainDB V1 the batch is finalized immediately after the entry is written\n        emit InterchainBatchFinalized({dbNonce: dbNonce, batchRoot: entryValue});\n    }\n\n    /// @dev Request the verification of the entry by the modules, and emit the event.\n    /// Note: the validity of the passed entry and chain id being remote is enforced in the calling function.\n    function _requestVerification(\n        uint64 dstChainId,\n        InterchainBatch memory batch,\n        address[] calldata srcModules\n    )\n        internal\n    {\n        (uint256[] memory fees, uint256 totalFee) = _getModuleFees(dstChainId, batch.dbNonce, srcModules);\n        if (msg.value \u003c totalFee) {\n            revert InterchainDB__FeeAmountBelowMin(msg.value, totalFee);\n        } else if (msg.value \u003e totalFee) {\n            // The exceeding amount goes to the first module\n            fees[0] += msg.value - totalFee;\n        }\n        uint256 len = srcModules.length;\n        bytes memory versionedBatch = VersionedPayloadLib.encodeVersionedPayload({\n            version: DB_VERSION,\n            payload: InterchainBatchLib.encodeBatch(batch)\n        });\n        for (uint256 i = 0; i \u003c len; ++i) {\n            IInterchainModule(srcModules[i]).requestBatchVerification{value: fees[i]}(\n                dstChainId, batch.dbNonce, versionedBatch\n            );\n        }\n        emit InterchainBatchVerificationRequested(dstChainId, batch.dbNonce, batch.batchRoot, srcModules);\n    }\n\n    /// @dev Save the verified batch to the database and emit the event.\n    function _saveVerifiedBatch(address module, BatchKey batchKey, InterchainBatch memory batch) internal {\n        _remoteBatches[module][batchKey] = RemoteBatch({verifiedAt: block.timestamp, batchRoot: batch.batchRoot});\n        emit InterchainBatchVerified(module, batch.srcChainId, batch.dbNonce, batch.batchRoot);\n    }\n\n    //  INTERNAL VIEWS \n\n    /// @dev Asserts that the batch version is correct and that batch originates from a remote chain.\n    /// Note: returns the decoded batch for chaining purposes.\n    function _assertCorrectBatch(bytes calldata versionedBatch) internal view returns (InterchainBatch memory batch) {\n        uint16 dbVersion = versionedBatch.getVersion();\n        if (dbVersion != DB_VERSION) {\n            revert InterchainDB__BatchVersionMismatch(dbVersion, DB_VERSION);\n        }\n        batch = InterchainBatchLib.decodeBatch(versionedBatch.getPayload());\n        if (batch.srcChainId == block.chainid) {\n            revert InterchainDB__ChainIdNotRemote(batch.srcChainId);\n        }\n    }\n\n    /// @dev Check that the entry index is within the batch size. Also checks that the batch exists.\n    function _assertEntryExists(uint64 dbNonce, uint64 entryIndex) internal view {\n        // This will revert if the batch does not exist\n        uint64 batchSize = getBatchSize(dbNonce);\n        if (entryIndex \u003e= batchSize) {\n            revert InterchainDB__EntryIndexOutOfRange(dbNonce, entryIndex, batchSize);\n        }\n    }\n\n    /// @dev Get the verification fees for the modules\n    function _getModuleFees(\n        uint64 dstChainId,\n        uint64 dbNonce,\n        address[] calldata srcModules\n    )\n        internal\n        view\n        returns (uint256[] memory fees, uint256 totalFee)\n    {\n        uint256 len = srcModules.length;\n        if (len == 0) {\n            revert InterchainDB__ModulesNotProvided();\n        }\n        fees = new uint256[](len);\n        for (uint256 i = 0; i \u003c len; ++i) {\n            fees[i] = IInterchainModule(srcModules[i]).getModuleFee(dstChainId, dbNonce);\n            totalFee += fees[i];\n        }\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint64","name":"dbNonce","type":"uint64"},{"indexed":false,"internalType":"bytes32","name":"batchRoot","type":"bytes32"}],"name":"InterchainBatchFinalized","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint64","name":"dstChainId","type":"uint64"},{"indexed":true,"internalType":"uint64","name":"dbNonce","type":"uint64"},{"indexed":false,"internalType":"bytes32","name":"batchRoot","type":"bytes32"},{"indexed":false,"internalType":"address[]","name":"srcModules","type":"address[]"}],"name":"InterchainBatchVerificationRequested","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"module","type":"address"},{"indexed":true,"internalType":"uint64","name":"srcChainId","type":"uint64"},{"indexed":true,"internalType":"uint64","name":"dbNonce","type":"uint64"},{"indexed":false,"internalType":"bytes32","name":"batchRoot","type":"bytes32"}],"name":"InterchainBatchVerified","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint64","name":"dbNonce","type":"uint64"},{"indexed":false,"internalType":"uint64","name":"entryIndex","type":"uint64"},{"indexed":true,"internalType":"bytes32","name":"srcWriter","type":"bytes32"},{"indexed":false,"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"name":"InterchainEntryWritten","type":"event"}],"userDoc":{"events":{"InterchainBatchFinalized(uint64,bytes32)":{"notice":"Emitted when a local batch is finalized."},"InterchainBatchVerificationRequested(uint64,uint64,bytes32,address[])":{"notice":"Emitted when a local batch is requested to be verified on a remote chain using the set of Interchain Modules."},"InterchainBatchVerified(address,uint64,uint64,bytes32)":{"notice":"Emitted when a remote batch is verified by the Interchain Module."},"InterchainEntryWritten(uint64,uint64,bytes32,bytes32)":{"notice":"Emitted when a local entry is written to the database."}},"kind":"user","methods":{},"version":1},"developerDoc":{"events":{"InterchainBatchFinalized(uint64,bytes32)":{"params":{"batchRoot":"The Merkle root hash of the finalized batch.","dbNonce":"The nonce of the finalized batch."}},"InterchainBatchVerificationRequested(uint64,uint64,bytes32,address[])":{"params":{"batchRoot":"The Merkle root hash of the batch to be verified.","dbNonce":"The nonce of the batch to be verified.","dstChainId":"The ID of the destination chain.","srcModules":"The addresses of the Interchain Modules that will verify the batch."}},"InterchainBatchVerified(address,uint64,uint64,bytes32)":{"params":{"batchRoot":"The Merkle root hash of the verified batch.","dbNonce":"The nonce of the verified batch.","module":"The address of the Interchain Module that verified the batch.","srcChainId":"The ID of the source chain."}},"InterchainEntryWritten(uint64,uint64,bytes32,bytes32)":{"params":{"dataHash":"The written data hash.","dbNonce":"The nonce of the batch containing the entry.","entryIndex":"The index of the entry within the batch.","srcWriter":"The address of the writer."}}},"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"batchRoot\",\"type\":\"bytes32\"}],\"name\":\"InterchainBatchFinalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"dstChainId\",\"type\":\"uint64\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"batchRoot\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"}],\"name\":\"InterchainBatchVerificationRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"srcChainId\",\"type\":\"uint64\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"batchRoot\",\"type\":\"bytes32\"}],\"name\":\"InterchainBatchVerified\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"dbNonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"srcWriter\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"name\":\"InterchainEntryWritten\",\"type\":\"event\"}],\"devdoc\":{\"events\":{\"InterchainBatchFinalized(uint64,bytes32)\":{\"params\":{\"batchRoot\":\"The Merkle root hash of the finalized batch.\",\"dbNonce\":\"The nonce of the finalized batch.\"}},\"InterchainBatchVerificationRequested(uint64,uint64,bytes32,address[])\":{\"params\":{\"batchRoot\":\"The Merkle root hash of the batch to be verified.\",\"dbNonce\":\"The nonce of the batch to be verified.\",\"dstChainId\":\"The ID of the destination chain.\",\"srcModules\":\"The addresses of the Interchain Modules that will verify the batch.\"}},\"InterchainBatchVerified(address,uint64,uint64,bytes32)\":{\"params\":{\"batchRoot\":\"The Merkle root hash of the verified batch.\",\"dbNonce\":\"The nonce of the verified batch.\",\"module\":\"The address of the Interchain Module that verified the batch.\",\"srcChainId\":\"The ID of the source chain.\"}},\"InterchainEntryWritten(uint64,uint64,bytes32,bytes32)\":{\"params\":{\"dataHash\":\"The written data hash.\",\"dbNonce\":\"The nonce of the batch containing the entry.\",\"entryIndex\":\"The index of the entry within the batch.\",\"srcWriter\":\"The address of the writer.\"}}},\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"events\":{\"InterchainBatchFinalized(uint64,bytes32)\":{\"notice\":\"Emitted when a local batch is finalized.\"},\"InterchainBatchVerificationRequested(uint64,uint64,bytes32,address[])\":{\"notice\":\"Emitted when a local batch is requested to be verified on a remote chain using the set of Interchain Modules.\"},\"InterchainBatchVerified(address,uint64,uint64,bytes32)\":{\"notice\":\"Emitted when a remote batch is verified by the Interchain Module.\"},\"InterchainEntryWritten(uint64,uint64,bytes32,bytes32)\":{\"notice\":\"Emitted when a local entry is written to the database.\"}},\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainDB.sol\":\"InterchainDBEvents\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainDB.sol\":{\"keccak256\":\"0x4dd7dd2bde0a2d89cb06f57f8772f18d4b0547c65abb43503e5fc2dedf60ac3e\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://e22ed31c26dd9174d0f333bf9d8d5916d407c0c99aa908c56a6c4156756a5e1e\",\"dweb:/ipfs/QmTi96nhB9Vr3SRq9qa24zbPvctFSNubneRuohgndhAqHK\"]}},\"version\":1}"},"hashes":{}},"solidity/InterchainDB.sol:InterchainEntryLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122058dc206f46b8bd8df93b47be485f3752d42e4f1d6a622c646a10773d8172fdbe64736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122058dc206f46b8bd8df93b47be485f3752d42e4f1d6a622c646a10773d8172fdbe64736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainDBEvents.sol\n\nabstract contract InterchainDBEvents {\n    /// @notice Emitted when a local entry is written to the database.\n    /// @param dbNonce      The nonce of the batch containing the entry.\n    /// @param entryIndex   The index of the entry within the batch.\n    /// @param srcWriter    The address of the writer.\n    /// @param dataHash     The written data hash.\n    event InterchainEntryWritten(\n        uint64 indexed dbNonce, uint64 entryIndex, bytes32 indexed srcWriter, bytes32 dataHash\n    );\n\n    /// @notice Emitted when a local batch is finalized.\n    /// @param dbNonce      The nonce of the finalized batch.\n    /// @param batchRoot    The Merkle root hash of the finalized batch.\n    event InterchainBatchFinalized(uint64 indexed dbNonce, bytes32 batchRoot);\n\n    /// @notice Emitted when a remote batch is verified by the Interchain Module.\n    /// @param module       The address of the Interchain Module that verified the batch.\n    /// @param srcChainId   The ID of the source chain.\n    /// @param dbNonce      The nonce of the verified batch.\n    /// @param batchRoot    The Merkle root hash of the verified batch.\n    event InterchainBatchVerified(\n        address indexed module, uint64 indexed srcChainId, uint64 indexed dbNonce, bytes32 batchRoot\n    );\n\n    /// @notice Emitted when a local batch is requested to be verified on a remote chain\n    /// using the set of Interchain Modules.\n    /// @param dstChainId   The ID of the destination chain.\n    /// @param dbNonce      The nonce of the batch to be verified.\n    /// @param batchRoot    The Merkle root hash of the batch to be verified.\n    /// @param srcModules   The addresses of the Interchain Modules that will verify the batch.\n    event InterchainBatchVerificationRequested(\n        uint64 indexed dstChainId, uint64 indexed dbNonce, bytes32 batchRoot, address[] srcModules\n    );\n}\n\n// contracts/interfaces/IInterchainModule.sol\n\n/// @notice Every Module may opt a different method to confirm the verified entries on destination chain,\n/// therefore this is not a part of a common interface.\ninterface IInterchainModule {\n    error InterchainModule__CallerNotInterchainDB(address caller);\n    error InterchainModule__ChainIdNotRemote(uint64 chainId);\n    error InterchainModule__FeeAmountBelowMin(uint256 feeAmount, uint256 minRequired);\n\n    /// @notice Request the verification of a batch from the Interchain DataBase by the module.\n    /// If the batch is not yet finalized, the verification on destination chain will be delayed until\n    /// the finalization is done and batch root is saved on the source chain.\n    /// Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`.\n    /// Note: this will eventually trigger `InterchainDB.verifyRemoteBatch(batch)` function on destination chain,\n    /// with no guarantee of ordering.\n    /// @dev Could be only called by the Interchain DataBase contract.\n    /// @param dstChainId       The chain id of the destination chain\n    /// @param batchNonce       The nonce of the batch on the source chain\n    /// @param versionedBatch   The versioned batch to verify\n    function requestBatchVerification(\n        uint64 dstChainId,\n        uint64 batchNonce,\n        bytes memory versionedBatch\n    )\n        external\n        payable;\n\n    /// @notice Get the Module fee for verifying a batch on the specified destination chain.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dbNonce      The database nonce of the batch on the source chain\n    function getModuleFee(uint64 dstChainId, uint64 dbNonce) external view returns (uint256);\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/VersionedPayload.sol\n\n// solhint-disable no-inline-assembly\n// solhint-disable ordering\nlibrary VersionedPayloadLib {\n    /// @notice Amount of bytes reserved for the version (uint16) in the versioned payload\n    uint256 internal constant VERSION_LENGTH = 2;\n\n    error VersionedPayload__PayloadTooShort(bytes versionedPayload);\n    error VersionedPayload__PrecompileFailed();\n\n    /// @notice Encodes the versioned payload into a single bytes array.\n    /// @param version  The payload's version.\n    /// @param payload  The payload to encode.\n    function encodeVersionedPayload(uint16 version, bytes memory payload) internal pure returns (bytes memory) {\n        return abi.encodePacked(version, payload);\n    }\n\n    /// @notice Extracts the version from the versioned payload (calldata reference).\n    /// @param versionedPayload     The versioned payload (calldata reference).\n    function getVersion(bytes calldata versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__PayloadTooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            version := shr(240, calldataload(versionedPayload.offset))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (calldata reference).\n    /// @dev The extracted payload is also returned as a calldata reference.\n    /// @param versionedPayload     The versioned payload.\n    function getPayload(bytes calldata versionedPayload) internal pure returns (bytes calldata) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__PayloadTooShort(versionedPayload);\n        }\n        return versionedPayload[VERSION_LENGTH:];\n    }\n\n    /// @notice Extracts the version from the versioned payload (memory reference).\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getVersionFromMemory(bytes memory versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__PayloadTooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            // We add 0x20 to skip the length of the bytes array.\n            version := shr(240, mload(add(versionedPayload, 0x20)))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (memory reference).\n    /// @dev The extracted payload is copied into a new memory location. Use `getPayload` when possible\n    /// to avoid extra memory allocation.\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getPayloadFromMemory(bytes memory versionedPayload) internal view returns (bytes memory payload) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__PayloadTooShort(versionedPayload);\n        }\n        // Figure how many bytes to copy and allocate the memory for the extracted payload.\n        uint256 toCopy;\n        unchecked {\n            toCopy = versionedPayload.length - VERSION_LENGTH;\n        }\n        payload = new bytes(toCopy);\n        // Use identity precompile (0x04) to copy the payload. Unlike MCOPY, this is available on all EVM chains.\n        bool res;\n        assembly {\n            // We add 0x20 to skip the length of the bytes array.\n            // We add 0x02 to skip the 2 bytes reserved for the version.\n            // Copy the payload to the previously allocated memory.\n            res := staticcall(gas(), 0x04, add(versionedPayload, 0x22), toCopy, add(payload, 0x20), toCopy)\n        }\n        if (!res) {\n            revert VersionedPayload__PrecompileFailed();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SafeCast.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value \u003e type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value \u003e type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value \u003e type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value \u003e type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value \u003e type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value \u003e type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value \u003e type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value \u003e type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value \u003e type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value \u003e type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value \u003e type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value \u003e type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value \u003e type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value \u003e type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value \u003e type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value \u003e type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value \u003e type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value \u003e type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value \u003e type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value \u003e type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value \u003e type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value \u003e type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value \u003e type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value \u003e type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value \u003e type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value \u003e type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value \u003e type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value \u003e type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value \u003e type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value \u003e type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value \u003e type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value \u003c 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value \u003e uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n}\n\n// contracts/libs/InterchainBatch.sol\n\ntype BatchKey is uint128;\n\n/// @notice Struct representing a batch of entries in the Interchain DataBase.\n/// Batched entries are put together in a Merkle tree, which root is saved.\n/// Batch has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: batchRoot\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch\n/// @param batchRoot    The root of the Merkle tree containing the batched entries\nstruct InterchainBatch {\n    uint64 srcChainId;\n    uint64 dbNonce;\n    bytes32 batchRoot;\n}\n\n/// @dev Signals that the module has not verified any batch with the given key.\nuint256 constant BATCH_UNVERIFIED = 0;\n/// @dev Signals that the module has verified a conflicting batch with the given key.\nuint256 constant BATCH_CONFLICT = type(uint256).max;\n\nlibrary InterchainBatchLib {\n    using VersionedPayloadLib for bytes;\n\n    /// @notice Constructs an InterchainBatch struct to be saved on the local chain.\n    /// @param dbNonce      The database nonce of the batch\n    /// @param batchRoot    The root of the Merkle tree containing the batched entries\n    /// @return batch       The constructed InterchainBatch struct\n    function constructLocalBatch(\n        uint64 dbNonce,\n        bytes32 batchRoot\n    )\n        internal\n        view\n        returns (InterchainBatch memory batch)\n    {\n        return InterchainBatch({srcChainId: SafeCast.toUint64(block.chainid), dbNonce: dbNonce, batchRoot: batchRoot});\n    }\n\n    /// @notice Encodes the InterchainBatch struct into a non-versioned batch payload.\n    function encodeBatch(InterchainBatch memory batch) internal pure returns (bytes memory) {\n        return abi.encode(encodeBatchKey(batch.srcChainId, batch.dbNonce), batch.batchRoot);\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in calldata.\n    function decodeBatch(bytes calldata data) internal pure returns (InterchainBatch memory batch) {\n        BatchKey key;\n        (key, batch.batchRoot) = abi.decode(data, (BatchKey, bytes32));\n        (batch.srcChainId, batch.dbNonce) = decodeBatchKey(key);\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in memory.\n    function decodeBatchFromMemory(bytes memory data) internal pure returns (InterchainBatch memory batch) {\n        BatchKey key;\n        (key, batch.batchRoot) = abi.decode(data, (BatchKey, bytes32));\n        (batch.srcChainId, batch.dbNonce) = decodeBatchKey(key);\n    }\n\n    /// @notice Encodes the uint128 key of the batch from uint64 srcChainId and uint64 dbNonce.\n    function encodeBatchKey(uint64 srcChainId, uint64 dbNonce) internal pure returns (BatchKey) {\n        return BatchKey.wrap((uint128(srcChainId) \u003c\u003c 64) | dbNonce);\n    }\n\n    /// @notice Decodes the uint128 key of the batch into uint64 srcChainId and uint64 dbNonce.\n    function decodeBatchKey(BatchKey key) internal pure returns (uint64 srcChainId, uint64 dbNonce) {\n        srcChainId = uint64(BatchKey.unwrap(key) \u003e\u003e 64);\n        dbNonce = uint64(BatchKey.unwrap(key));\n    }\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce + entryIndex\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch containing the entry\n/// @param entryIndex   The index of the entry in the batch\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint64 srcChainId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nusing InterchainEntryLib for InterchainEntry global;\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint64 dbNonce,\n        uint64 entryIndex,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: SafeCast.toUint64(block.chainid),\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return getEntryValue(entry.srcWriter, entry.dataHash);\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function getEntryValue(bytes32 srcWriter, bytes32 dataHash) internal pure returns (bytes32) {\n        return keccak256(abi.encode(srcWriter, dataHash));\n    }\n}\n\n// contracts/libs/BatchingV1.sol\n\nlibrary BatchingV1Lib {\n    error BatchingV1__EntryIndexNotZero(uint64 entryIndex);\n    error BatchingV1__ProofNotEmpty();\n\n    /// @notice Get the batch root containing the Interchain Entry with the given index.\n    /// @param srcWriter    The entry writer of the source chain\n    /// @param dataHash     The hash of the data of the entry\n    /// @param entryIndex   The index of the entry in the batch\n    /// @param proof        The Merkle proof of inclusion for the entry in the batch\n    /// @return batchRoot   The root of the batch containing the entry\n    function getBatchRoot(\n        bytes32 srcWriter,\n        bytes32 dataHash,\n        uint64 entryIndex,\n        bytes32[] calldata proof\n    )\n        internal\n        pure\n        returns (bytes32 batchRoot)\n    {\n        // In \"no batching\" mode: entry index is 0, proof is empty\n        if (entryIndex != 0) {\n            revert BatchingV1__EntryIndexNotZero(entryIndex);\n        }\n        if (proof.length != 0) {\n            revert BatchingV1__ProofNotEmpty();\n        }\n        // In \"no batching\" mode: the batch root is the same as the entry value\n        return InterchainEntryLib.getEntryValue({srcWriter: srcWriter, dataHash: dataHash});\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    error InterchainDB__BatchConflict(address module, bytes32 existingBatchRoot, InterchainBatch newBatch);\n    error InterchainDB__BatchVersionMismatch(uint16 version, uint16 required);\n    error InterchainDB__ChainIdNotRemote(uint64 chainId);\n    error InterchainDB__EntryIndexOutOfRange(uint64 dbNonce, uint64 entryIndex, uint64 batchSize);\n    error InterchainDB__EntryRangeInvalid(uint64 dbNonce, uint64 start, uint64 end);\n    error InterchainDB__FeeAmountBelowMin(uint256 feeAmount, uint256 minRequired);\n    error InterchainDB__ModulesNotProvided();\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `requestBatchVerification` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntry(bytes32 dataHash) external returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Request the given Interchain Modules to verify an existing batch.\n    /// If the batch is not finalized, the module will verify it after finalization.\n    /// For the finalized batch the batch root is already available, and the module can verify it immediately.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any batch.\n    /// @dev Will revert if the batch with the given nonce does not exist.\n    /// @param dstChainId    The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the existing batch\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestBatchVerification(\n        uint64 dstChainId,\n        uint64 dbNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Then request the Interchain Modules to verify the batch containing the written entry on the destination chain.\n    /// See `writeEntry` and `requestBatchVerification` for more details.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntryWithVerification(\n        uint64 dstChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Allows the Interchain Module to verify the batch coming from the remote chain.\n    /// The module SHOULD verify the exact finalized batch from the remote chain. If the batch with a given nonce\n    /// is not finalized or does not exist, module CAN verify it with an empty root value. Once the batch is\n    /// finalized, the module SHOULD re-verify the batch with the correct root value.\n    /// Note: The DB will only accept the batch of the same version as the DB itself.\n    /// @dev Will revert if the batch with the same nonce but a different non-empty root is already verified.\n    /// @param versionedBatch   The versioned Interchain Batch to verify\n    function verifyRemoteBatch(bytes memory versionedBatch) external;\n\n    //  VIEWS \n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint64 dstChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce.\n    /// Note: the leafs are ordered by the index of the written entry in the current batch,\n    /// and the leafs value match the value of the written entry (srcWriter + dataHash hashed together).\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchLeafs(uint64 dbNonce) external view returns (bytes32[] memory);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce,\n    /// paginated by the given start and end indexes. The end index is exclusive.\n    /// Note: this is useful when the batch contains a large number of leafs, and calling `getBatchLeafs`\n    /// would result in a gas limit exceeded error.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the provided range is invalid.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param start        The start index of the paginated leafs, inclusive\n    /// @param end          The end index of the paginated leafs, exclusive\n    function getBatchLeafsPaginated(\n        uint64 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory);\n\n    /// @notice Returns the size of the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchSize(uint64 dbNonce) external view returns (uint64);\n\n    /// @notice Get the finalized Interchain Batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatch(uint64 dbNonce) external view returns (InterchainBatch memory);\n\n    /// @notice Get the versioned Interchain Batch with the given nonce.\n    /// Note: will return a batch with an empty root if the batch does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the batch\n    function getVersionedBatch(uint64 dbNonce) external view returns (bytes memory);\n\n    /// @notice Get the Interchain Entry's value written on the local chain with the given batch nonce and entry index.\n    /// Entry value is calculated as the hash of the writer address and the written data hash.\n    /// Note: the batch does not have to be finalized to fetch the entry value.\n    /// @dev Will revert if the batch with the given nonce does not exist,\n    /// or the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the existing batch\n    /// @param entryIndex   The index of the written entry within the batch\n    function getEntryValue(uint64 dbNonce, uint64 entryIndex) external view returns (bytes32);\n\n    /// @notice Get the Merkle proof of inclusion for the entry with the given index\n    /// in the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param entryIndex   The index of the written entry within the batch\n    /// @return proof       The Merkle proof of inclusion for the entry\n    function getEntryProof(uint64 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof);\n\n    /// @notice Get the nonce of the database, which is incremented every time a new batch is finalized.\n    /// This is the nonce of the current non-finalized batch.\n    function getDBNonce() external view returns (uint64);\n\n    /// @notice Get the index of the next entry to be written to the database.\n    /// @return dbNonce      The database nonce of the batch including the next entry\n    /// @return entryIndex   The index of the next entry within that batch\n    function getNextEntryIndex() external view returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Check if the batch is verified by the Interchain Module on the destination chain.\n    /// Note: returned zero value indicates that the module has not verified the batch.\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @param batch        The Interchain Batch to check\n    /// @return moduleVerifiedAt    The block timestamp at which the batch was verified by the module,\n    ///                             or ZERO if the module has not verified the batch.\n    function checkBatchVerification(\n        address dstModule,\n        InterchainBatch memory batch\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n\n    /// @notice Get the batch root containing the Interchain Entry with the given index.\n    /// @param entry         The Interchain Entry to get the batch root for\n    /// @param proof         The Merkle proof of inclusion for the entry in the batch\n    function getBatchRoot(InterchainEntry memory entry, bytes32[] memory proof) external pure returns (bytes32);\n\n    /// @notice Get the version of the Interchain DataBase.\n    // solhint-disable-next-line func-name-mixedcase\n    function DB_VERSION() external pure returns (uint16);\n}\n\n// contracts/InterchainDB.sol\n\ncontract InterchainDB is InterchainDBEvents, IInterchainDB {\n    using VersionedPayloadLib for bytes;\n\n    /// @notice Struct representing a batch of entries from the remote Interchain DataBase,\n    /// verified by the Interchain Module.\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param batchRoot    The Merkle root of the batch\n    struct RemoteBatch {\n        uint256 verifiedAt;\n        bytes32 batchRoot;\n    }\n\n    uint16 public constant DB_VERSION = 1;\n\n    bytes32[] internal _entryValues;\n    mapping(address module =\u003e mapping(BatchKey batchKey =\u003e RemoteBatch batch)) internal _remoteBatches;\n\n    modifier onlyRemoteChainId(uint64 chainId) {\n        if (chainId == block.chainid) {\n            revert InterchainDB__ChainIdNotRemote(chainId);\n        }\n        _;\n    }\n\n    //  WRITER-FACING \n\n    /// @inheritdoc IInterchainDB\n    function writeEntry(bytes32 dataHash) external returns (uint64 dbNonce, uint64 entryIndex) {\n        InterchainEntry memory entry = _writeEntry(dataHash);\n        (dbNonce, entryIndex) = (entry.dbNonce, entry.entryIndex);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function requestBatchVerification(\n        uint64 dstChainId,\n        uint64 dbNonce,\n        address[] calldata srcModules\n    )\n        external\n        payable\n        onlyRemoteChainId(dstChainId)\n    {\n        InterchainBatch memory batch = getBatch(dbNonce);\n        _requestVerification(dstChainId, batch, srcModules);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function writeEntryWithVerification(\n        uint64 dstChainId,\n        bytes32 dataHash,\n        address[] calldata srcModules\n    )\n        external\n        payable\n        onlyRemoteChainId(dstChainId)\n        returns (uint64 dbNonce, uint64 entryIndex)\n    {\n        InterchainEntry memory entry = _writeEntry(dataHash);\n        (dbNonce, entryIndex) = (entry.dbNonce, entry.entryIndex);\n        // In \"no batching\" mode: the batch root is the same as the entry value\n        InterchainBatch memory batch = InterchainBatchLib.constructLocalBatch(dbNonce, entry.entryValue());\n        _requestVerification(dstChainId, batch, srcModules);\n    }\n\n    //  MODULE-FACING \n\n    /// @inheritdoc IInterchainDB\n    function verifyRemoteBatch(bytes calldata versionedBatch) external {\n        InterchainBatch memory batch = _assertCorrectBatch(versionedBatch);\n        BatchKey batchKey = InterchainBatchLib.encodeBatchKey({srcChainId: batch.srcChainId, dbNonce: batch.dbNonce});\n        RemoteBatch memory existingBatch = _remoteBatches[msg.sender][batchKey];\n        // Check if that's the first time module verifies the batch\n        if (existingBatch.verifiedAt == 0) {\n            _saveVerifiedBatch(msg.sender, batchKey, batch);\n            return;\n        }\n        // No-op if the batch root is the same\n        if (existingBatch.batchRoot == batch.batchRoot) {\n            return;\n        }\n        // Overwriting an empty (non-existent) batch with a different one is allowed\n        if (existingBatch.batchRoot == 0) {\n            _saveVerifiedBatch(msg.sender, batchKey, batch);\n            return;\n        }\n        // Overwriting an existing batch with a different one is not allowed\n        revert InterchainDB__BatchConflict(msg.sender, existingBatch.batchRoot, batch);\n    }\n\n    //  VIEWS \n\n    /// @inheritdoc IInterchainDB\n    function getBatchLeafs(uint64 dbNonce) external view returns (bytes32[] memory leafs) {\n        uint256 batchSize = getBatchSize(dbNonce);\n        leafs = new bytes32[](batchSize);\n        for (uint64 i = 0; i \u003c batchSize; ++i) {\n            leafs[i] = getEntryValue(dbNonce, i);\n        }\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getBatchLeafsPaginated(\n        uint64 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory leafs)\n    {\n        uint256 size = getBatchSize(dbNonce);\n        if (start \u003e end || end \u003e size) {\n            revert InterchainDB__EntryRangeInvalid(dbNonce, start, end);\n        }\n        leafs = new bytes32[](end - start);\n        for (uint64 i = start; i \u003c end; ++i) {\n            leafs[i - start] = getEntryValue(dbNonce, i);\n        }\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getEntryProof(uint64 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof) {\n        // In \"no batching\" mode: the batch root is the same as the entry value, hence the proof is empty\n        _assertEntryExists(dbNonce, entryIndex);\n        return new bytes32[](0);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getInterchainFee(uint64 dstChainId, address[] calldata srcModules) external view returns (uint256 fee) {\n        (, fee) = _getModuleFees(dstChainId, getDBNonce(), srcModules);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getNextEntryIndex() external view returns (uint64 dbNonce, uint64 entryIndex) {\n        // In \"no batching\" mode: entry index is 0, batch size is 1\n        dbNonce = getDBNonce();\n        entryIndex = 0;\n    }\n\n    /// @inheritdoc IInterchainDB\n    function checkBatchVerification(\n        address dstModule,\n        InterchainBatch memory batch\n    )\n        external\n        view\n        onlyRemoteChainId(batch.srcChainId)\n        returns (uint256 moduleVerifiedAt)\n    {\n        BatchKey batchKey = InterchainBatchLib.encodeBatchKey({srcChainId: batch.srcChainId, dbNonce: batch.dbNonce});\n        RemoteBatch memory remoteBatch = _remoteBatches[dstModule][batchKey];\n        // Check if module verified anything for this batch key first\n        if (remoteBatch.verifiedAt == 0) {\n            return BATCH_UNVERIFIED;\n        }\n        // Check if the batch root matches the one verified by the module\n        return remoteBatch.batchRoot == batch.batchRoot ? remoteBatch.verifiedAt : BATCH_CONFLICT;\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getVersionedBatch(uint64 dbNonce) external view returns (bytes memory versionedBatch) {\n        InterchainBatch memory batch = getBatch(dbNonce);\n        return VersionedPayloadLib.encodeVersionedPayload({\n            version: DB_VERSION,\n            payload: InterchainBatchLib.encodeBatch(batch)\n        });\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getBatchRoot(InterchainEntry memory entry, bytes32[] calldata proof) external pure returns (bytes32) {\n        return BatchingV1Lib.getBatchRoot({\n            srcWriter: entry.srcWriter,\n            dataHash: entry.dataHash,\n            entryIndex: entry.entryIndex,\n            proof: proof\n        });\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getBatchSize(uint64 dbNonce) public view returns (uint64) {\n        // In \"no batching\" mode: the finalized batch size is 1, the pending batch size is 0\n        // We also return 0 for non-existent batches\n        return dbNonce \u003c getDBNonce() ? 1 : 0;\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getBatch(uint64 dbNonce) public view returns (InterchainBatch memory) {\n        // In \"no batching\" mode: the batch root is the same as the entry hash.\n        // For non-finalized or non-existent batches, the batch root is 0.\n        bytes32 batchRoot = dbNonce \u003c getDBNonce() ? getEntryValue(dbNonce, 0) : bytes32(0);\n        return InterchainBatchLib.constructLocalBatch(dbNonce, batchRoot);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getEntryValue(uint64 dbNonce, uint64 entryIndex) public view returns (bytes32) {\n        _assertEntryExists(dbNonce, entryIndex);\n        return _entryValues[dbNonce];\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getDBNonce() public view returns (uint64) {\n        // We can do the unsafe cast here as writing more than 2^64 entries is practically impossible\n        return uint64(_entryValues.length);\n    }\n\n    //  INTERNAL LOGIC \n\n    /// @dev Write the entry to the database and emit the event.\n    function _writeEntry(bytes32 dataHash) internal returns (InterchainEntry memory entry) {\n        uint64 dbNonce = getDBNonce();\n        entry = InterchainEntryLib.constructLocalEntry({\n            dbNonce: dbNonce,\n            entryIndex: 0,\n            writer: msg.sender,\n            dataHash: dataHash\n        });\n        bytes32 entryValue = entry.entryValue();\n        _entryValues.push(entryValue);\n        emit InterchainEntryWritten({\n            dbNonce: dbNonce,\n            entryIndex: 0,\n            srcWriter: TypeCasts.addressToBytes32(msg.sender),\n            dataHash: dataHash\n        });\n        // In the InterchainDB V1 the batch is finalized immediately after the entry is written\n        emit InterchainBatchFinalized({dbNonce: dbNonce, batchRoot: entryValue});\n    }\n\n    /// @dev Request the verification of the entry by the modules, and emit the event.\n    /// Note: the validity of the passed entry and chain id being remote is enforced in the calling function.\n    function _requestVerification(\n        uint64 dstChainId,\n        InterchainBatch memory batch,\n        address[] calldata srcModules\n    )\n        internal\n    {\n        (uint256[] memory fees, uint256 totalFee) = _getModuleFees(dstChainId, batch.dbNonce, srcModules);\n        if (msg.value \u003c totalFee) {\n            revert InterchainDB__FeeAmountBelowMin(msg.value, totalFee);\n        } else if (msg.value \u003e totalFee) {\n            // The exceeding amount goes to the first module\n            fees[0] += msg.value - totalFee;\n        }\n        uint256 len = srcModules.length;\n        bytes memory versionedBatch = VersionedPayloadLib.encodeVersionedPayload({\n            version: DB_VERSION,\n            payload: InterchainBatchLib.encodeBatch(batch)\n        });\n        for (uint256 i = 0; i \u003c len; ++i) {\n            IInterchainModule(srcModules[i]).requestBatchVerification{value: fees[i]}(\n                dstChainId, batch.dbNonce, versionedBatch\n            );\n        }\n        emit InterchainBatchVerificationRequested(dstChainId, batch.dbNonce, batch.batchRoot, srcModules);\n    }\n\n    /// @dev Save the verified batch to the database and emit the event.\n    function _saveVerifiedBatch(address module, BatchKey batchKey, InterchainBatch memory batch) internal {\n        _remoteBatches[module][batchKey] = RemoteBatch({verifiedAt: block.timestamp, batchRoot: batch.batchRoot});\n        emit InterchainBatchVerified(module, batch.srcChainId, batch.dbNonce, batch.batchRoot);\n    }\n\n    //  INTERNAL VIEWS \n\n    /// @dev Asserts that the batch version is correct and that batch originates from a remote chain.\n    /// Note: returns the decoded batch for chaining purposes.\n    function _assertCorrectBatch(bytes calldata versionedBatch) internal view returns (InterchainBatch memory batch) {\n        uint16 dbVersion = versionedBatch.getVersion();\n        if (dbVersion != DB_VERSION) {\n            revert InterchainDB__BatchVersionMismatch(dbVersion, DB_VERSION);\n        }\n        batch = InterchainBatchLib.decodeBatch(versionedBatch.getPayload());\n        if (batch.srcChainId == block.chainid) {\n            revert InterchainDB__ChainIdNotRemote(batch.srcChainId);\n        }\n    }\n\n    /// @dev Check that the entry index is within the batch size. Also checks that the batch exists.\n    function _assertEntryExists(uint64 dbNonce, uint64 entryIndex) internal view {\n        // This will revert if the batch does not exist\n        uint64 batchSize = getBatchSize(dbNonce);\n        if (entryIndex \u003e= batchSize) {\n            revert InterchainDB__EntryIndexOutOfRange(dbNonce, entryIndex, batchSize);\n        }\n    }\n\n    /// @dev Get the verification fees for the modules\n    function _getModuleFees(\n        uint64 dstChainId,\n        uint64 dbNonce,\n        address[] calldata srcModules\n    )\n        internal\n        view\n        returns (uint256[] memory fees, uint256 totalFee)\n    {\n        uint256 len = srcModules.length;\n        if (len == 0) {\n            revert InterchainDB__ModulesNotProvided();\n        }\n        fees = new uint256[](len);\n        for (uint256 i = 0; i \u003c len; ++i) {\n            fees[i] = IInterchainModule(srcModules[i]).getModuleFee(dstChainId, dbNonce);\n            totalFee += fees[i];\n        }\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"46620:1386:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;46620:1386:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"46620:1386:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainDB.sol\":\"InterchainEntryLib\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainDB.sol\":{\"keccak256\":\"0x4dd7dd2bde0a2d89cb06f57f8772f18d4b0547c65abb43503e5fc2dedf60ac3e\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://e22ed31c26dd9174d0f333bf9d8d5916d407c0c99aa908c56a6c4156756a5e1e\",\"dweb:/ipfs/QmTi96nhB9Vr3SRq9qa24zbPvctFSNubneRuohgndhAqHK\"]}},\"version\":1}"},"hashes":{}},"solidity/InterchainDB.sol:SafeCast":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220f040f698d96380a387445a68d5c9028d230f194a10373042a7a9ba89cc928c7464736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220f040f698d96380a387445a68d5c9028d230f194a10373042a7a9ba89cc928c7464736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainDBEvents.sol\n\nabstract contract InterchainDBEvents {\n    /// @notice Emitted when a local entry is written to the database.\n    /// @param dbNonce      The nonce of the batch containing the entry.\n    /// @param entryIndex   The index of the entry within the batch.\n    /// @param srcWriter    The address of the writer.\n    /// @param dataHash     The written data hash.\n    event InterchainEntryWritten(\n        uint64 indexed dbNonce, uint64 entryIndex, bytes32 indexed srcWriter, bytes32 dataHash\n    );\n\n    /// @notice Emitted when a local batch is finalized.\n    /// @param dbNonce      The nonce of the finalized batch.\n    /// @param batchRoot    The Merkle root hash of the finalized batch.\n    event InterchainBatchFinalized(uint64 indexed dbNonce, bytes32 batchRoot);\n\n    /// @notice Emitted when a remote batch is verified by the Interchain Module.\n    /// @param module       The address of the Interchain Module that verified the batch.\n    /// @param srcChainId   The ID of the source chain.\n    /// @param dbNonce      The nonce of the verified batch.\n    /// @param batchRoot    The Merkle root hash of the verified batch.\n    event InterchainBatchVerified(\n        address indexed module, uint64 indexed srcChainId, uint64 indexed dbNonce, bytes32 batchRoot\n    );\n\n    /// @notice Emitted when a local batch is requested to be verified on a remote chain\n    /// using the set of Interchain Modules.\n    /// @param dstChainId   The ID of the destination chain.\n    /// @param dbNonce      The nonce of the batch to be verified.\n    /// @param batchRoot    The Merkle root hash of the batch to be verified.\n    /// @param srcModules   The addresses of the Interchain Modules that will verify the batch.\n    event InterchainBatchVerificationRequested(\n        uint64 indexed dstChainId, uint64 indexed dbNonce, bytes32 batchRoot, address[] srcModules\n    );\n}\n\n// contracts/interfaces/IInterchainModule.sol\n\n/// @notice Every Module may opt a different method to confirm the verified entries on destination chain,\n/// therefore this is not a part of a common interface.\ninterface IInterchainModule {\n    error InterchainModule__CallerNotInterchainDB(address caller);\n    error InterchainModule__ChainIdNotRemote(uint64 chainId);\n    error InterchainModule__FeeAmountBelowMin(uint256 feeAmount, uint256 minRequired);\n\n    /// @notice Request the verification of a batch from the Interchain DataBase by the module.\n    /// If the batch is not yet finalized, the verification on destination chain will be delayed until\n    /// the finalization is done and batch root is saved on the source chain.\n    /// Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`.\n    /// Note: this will eventually trigger `InterchainDB.verifyRemoteBatch(batch)` function on destination chain,\n    /// with no guarantee of ordering.\n    /// @dev Could be only called by the Interchain DataBase contract.\n    /// @param dstChainId       The chain id of the destination chain\n    /// @param batchNonce       The nonce of the batch on the source chain\n    /// @param versionedBatch   The versioned batch to verify\n    function requestBatchVerification(\n        uint64 dstChainId,\n        uint64 batchNonce,\n        bytes memory versionedBatch\n    )\n        external\n        payable;\n\n    /// @notice Get the Module fee for verifying a batch on the specified destination chain.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dbNonce      The database nonce of the batch on the source chain\n    function getModuleFee(uint64 dstChainId, uint64 dbNonce) external view returns (uint256);\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/VersionedPayload.sol\n\n// solhint-disable no-inline-assembly\n// solhint-disable ordering\nlibrary VersionedPayloadLib {\n    /// @notice Amount of bytes reserved for the version (uint16) in the versioned payload\n    uint256 internal constant VERSION_LENGTH = 2;\n\n    error VersionedPayload__PayloadTooShort(bytes versionedPayload);\n    error VersionedPayload__PrecompileFailed();\n\n    /// @notice Encodes the versioned payload into a single bytes array.\n    /// @param version  The payload's version.\n    /// @param payload  The payload to encode.\n    function encodeVersionedPayload(uint16 version, bytes memory payload) internal pure returns (bytes memory) {\n        return abi.encodePacked(version, payload);\n    }\n\n    /// @notice Extracts the version from the versioned payload (calldata reference).\n    /// @param versionedPayload     The versioned payload (calldata reference).\n    function getVersion(bytes calldata versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__PayloadTooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            version := shr(240, calldataload(versionedPayload.offset))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (calldata reference).\n    /// @dev The extracted payload is also returned as a calldata reference.\n    /// @param versionedPayload     The versioned payload.\n    function getPayload(bytes calldata versionedPayload) internal pure returns (bytes calldata) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__PayloadTooShort(versionedPayload);\n        }\n        return versionedPayload[VERSION_LENGTH:];\n    }\n\n    /// @notice Extracts the version from the versioned payload (memory reference).\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getVersionFromMemory(bytes memory versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__PayloadTooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            // We add 0x20 to skip the length of the bytes array.\n            version := shr(240, mload(add(versionedPayload, 0x20)))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (memory reference).\n    /// @dev The extracted payload is copied into a new memory location. Use `getPayload` when possible\n    /// to avoid extra memory allocation.\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getPayloadFromMemory(bytes memory versionedPayload) internal view returns (bytes memory payload) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__PayloadTooShort(versionedPayload);\n        }\n        // Figure how many bytes to copy and allocate the memory for the extracted payload.\n        uint256 toCopy;\n        unchecked {\n            toCopy = versionedPayload.length - VERSION_LENGTH;\n        }\n        payload = new bytes(toCopy);\n        // Use identity precompile (0x04) to copy the payload. Unlike MCOPY, this is available on all EVM chains.\n        bool res;\n        assembly {\n            // We add 0x20 to skip the length of the bytes array.\n            // We add 0x02 to skip the 2 bytes reserved for the version.\n            // Copy the payload to the previously allocated memory.\n            res := staticcall(gas(), 0x04, add(versionedPayload, 0x22), toCopy, add(payload, 0x20), toCopy)\n        }\n        if (!res) {\n            revert VersionedPayload__PrecompileFailed();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SafeCast.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value \u003e type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value \u003e type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value \u003e type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value \u003e type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value \u003e type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value \u003e type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value \u003e type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value \u003e type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value \u003e type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value \u003e type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value \u003e type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value \u003e type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value \u003e type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value \u003e type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value \u003e type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value \u003e type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value \u003e type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value \u003e type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value \u003e type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value \u003e type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value \u003e type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value \u003e type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value \u003e type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value \u003e type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value \u003e type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value \u003e type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value \u003e type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value \u003e type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value \u003e type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value \u003e type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value \u003e type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value \u003c 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value \u003e uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n}\n\n// contracts/libs/InterchainBatch.sol\n\ntype BatchKey is uint128;\n\n/// @notice Struct representing a batch of entries in the Interchain DataBase.\n/// Batched entries are put together in a Merkle tree, which root is saved.\n/// Batch has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: batchRoot\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch\n/// @param batchRoot    The root of the Merkle tree containing the batched entries\nstruct InterchainBatch {\n    uint64 srcChainId;\n    uint64 dbNonce;\n    bytes32 batchRoot;\n}\n\n/// @dev Signals that the module has not verified any batch with the given key.\nuint256 constant BATCH_UNVERIFIED = 0;\n/// @dev Signals that the module has verified a conflicting batch with the given key.\nuint256 constant BATCH_CONFLICT = type(uint256).max;\n\nlibrary InterchainBatchLib {\n    using VersionedPayloadLib for bytes;\n\n    /// @notice Constructs an InterchainBatch struct to be saved on the local chain.\n    /// @param dbNonce      The database nonce of the batch\n    /// @param batchRoot    The root of the Merkle tree containing the batched entries\n    /// @return batch       The constructed InterchainBatch struct\n    function constructLocalBatch(\n        uint64 dbNonce,\n        bytes32 batchRoot\n    )\n        internal\n        view\n        returns (InterchainBatch memory batch)\n    {\n        return InterchainBatch({srcChainId: SafeCast.toUint64(block.chainid), dbNonce: dbNonce, batchRoot: batchRoot});\n    }\n\n    /// @notice Encodes the InterchainBatch struct into a non-versioned batch payload.\n    function encodeBatch(InterchainBatch memory batch) internal pure returns (bytes memory) {\n        return abi.encode(encodeBatchKey(batch.srcChainId, batch.dbNonce), batch.batchRoot);\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in calldata.\n    function decodeBatch(bytes calldata data) internal pure returns (InterchainBatch memory batch) {\n        BatchKey key;\n        (key, batch.batchRoot) = abi.decode(data, (BatchKey, bytes32));\n        (batch.srcChainId, batch.dbNonce) = decodeBatchKey(key);\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in memory.\n    function decodeBatchFromMemory(bytes memory data) internal pure returns (InterchainBatch memory batch) {\n        BatchKey key;\n        (key, batch.batchRoot) = abi.decode(data, (BatchKey, bytes32));\n        (batch.srcChainId, batch.dbNonce) = decodeBatchKey(key);\n    }\n\n    /// @notice Encodes the uint128 key of the batch from uint64 srcChainId and uint64 dbNonce.\n    function encodeBatchKey(uint64 srcChainId, uint64 dbNonce) internal pure returns (BatchKey) {\n        return BatchKey.wrap((uint128(srcChainId) \u003c\u003c 64) | dbNonce);\n    }\n\n    /// @notice Decodes the uint128 key of the batch into uint64 srcChainId and uint64 dbNonce.\n    function decodeBatchKey(BatchKey key) internal pure returns (uint64 srcChainId, uint64 dbNonce) {\n        srcChainId = uint64(BatchKey.unwrap(key) \u003e\u003e 64);\n        dbNonce = uint64(BatchKey.unwrap(key));\n    }\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce + entryIndex\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch containing the entry\n/// @param entryIndex   The index of the entry in the batch\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint64 srcChainId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nusing InterchainEntryLib for InterchainEntry global;\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint64 dbNonce,\n        uint64 entryIndex,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: SafeCast.toUint64(block.chainid),\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return getEntryValue(entry.srcWriter, entry.dataHash);\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function getEntryValue(bytes32 srcWriter, bytes32 dataHash) internal pure returns (bytes32) {\n        return keccak256(abi.encode(srcWriter, dataHash));\n    }\n}\n\n// contracts/libs/BatchingV1.sol\n\nlibrary BatchingV1Lib {\n    error BatchingV1__EntryIndexNotZero(uint64 entryIndex);\n    error BatchingV1__ProofNotEmpty();\n\n    /// @notice Get the batch root containing the Interchain Entry with the given index.\n    /// @param srcWriter    The entry writer of the source chain\n    /// @param dataHash     The hash of the data of the entry\n    /// @param entryIndex   The index of the entry in the batch\n    /// @param proof        The Merkle proof of inclusion for the entry in the batch\n    /// @return batchRoot   The root of the batch containing the entry\n    function getBatchRoot(\n        bytes32 srcWriter,\n        bytes32 dataHash,\n        uint64 entryIndex,\n        bytes32[] calldata proof\n    )\n        internal\n        pure\n        returns (bytes32 batchRoot)\n    {\n        // In \"no batching\" mode: entry index is 0, proof is empty\n        if (entryIndex != 0) {\n            revert BatchingV1__EntryIndexNotZero(entryIndex);\n        }\n        if (proof.length != 0) {\n            revert BatchingV1__ProofNotEmpty();\n        }\n        // In \"no batching\" mode: the batch root is the same as the entry value\n        return InterchainEntryLib.getEntryValue({srcWriter: srcWriter, dataHash: dataHash});\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    error InterchainDB__BatchConflict(address module, bytes32 existingBatchRoot, InterchainBatch newBatch);\n    error InterchainDB__BatchVersionMismatch(uint16 version, uint16 required);\n    error InterchainDB__ChainIdNotRemote(uint64 chainId);\n    error InterchainDB__EntryIndexOutOfRange(uint64 dbNonce, uint64 entryIndex, uint64 batchSize);\n    error InterchainDB__EntryRangeInvalid(uint64 dbNonce, uint64 start, uint64 end);\n    error InterchainDB__FeeAmountBelowMin(uint256 feeAmount, uint256 minRequired);\n    error InterchainDB__ModulesNotProvided();\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `requestBatchVerification` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntry(bytes32 dataHash) external returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Request the given Interchain Modules to verify an existing batch.\n    /// If the batch is not finalized, the module will verify it after finalization.\n    /// For the finalized batch the batch root is already available, and the module can verify it immediately.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any batch.\n    /// @dev Will revert if the batch with the given nonce does not exist.\n    /// @param dstChainId    The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the existing batch\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestBatchVerification(\n        uint64 dstChainId,\n        uint64 dbNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Then request the Interchain Modules to verify the batch containing the written entry on the destination chain.\n    /// See `writeEntry` and `requestBatchVerification` for more details.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntryWithVerification(\n        uint64 dstChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Allows the Interchain Module to verify the batch coming from the remote chain.\n    /// The module SHOULD verify the exact finalized batch from the remote chain. If the batch with a given nonce\n    /// is not finalized or does not exist, module CAN verify it with an empty root value. Once the batch is\n    /// finalized, the module SHOULD re-verify the batch with the correct root value.\n    /// Note: The DB will only accept the batch of the same version as the DB itself.\n    /// @dev Will revert if the batch with the same nonce but a different non-empty root is already verified.\n    /// @param versionedBatch   The versioned Interchain Batch to verify\n    function verifyRemoteBatch(bytes memory versionedBatch) external;\n\n    //  VIEWS \n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint64 dstChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce.\n    /// Note: the leafs are ordered by the index of the written entry in the current batch,\n    /// and the leafs value match the value of the written entry (srcWriter + dataHash hashed together).\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchLeafs(uint64 dbNonce) external view returns (bytes32[] memory);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce,\n    /// paginated by the given start and end indexes. The end index is exclusive.\n    /// Note: this is useful when the batch contains a large number of leafs, and calling `getBatchLeafs`\n    /// would result in a gas limit exceeded error.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the provided range is invalid.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param start        The start index of the paginated leafs, inclusive\n    /// @param end          The end index of the paginated leafs, exclusive\n    function getBatchLeafsPaginated(\n        uint64 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory);\n\n    /// @notice Returns the size of the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchSize(uint64 dbNonce) external view returns (uint64);\n\n    /// @notice Get the finalized Interchain Batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatch(uint64 dbNonce) external view returns (InterchainBatch memory);\n\n    /// @notice Get the versioned Interchain Batch with the given nonce.\n    /// Note: will return a batch with an empty root if the batch does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the batch\n    function getVersionedBatch(uint64 dbNonce) external view returns (bytes memory);\n\n    /// @notice Get the Interchain Entry's value written on the local chain with the given batch nonce and entry index.\n    /// Entry value is calculated as the hash of the writer address and the written data hash.\n    /// Note: the batch does not have to be finalized to fetch the entry value.\n    /// @dev Will revert if the batch with the given nonce does not exist,\n    /// or the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the existing batch\n    /// @param entryIndex   The index of the written entry within the batch\n    function getEntryValue(uint64 dbNonce, uint64 entryIndex) external view returns (bytes32);\n\n    /// @notice Get the Merkle proof of inclusion for the entry with the given index\n    /// in the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param entryIndex   The index of the written entry within the batch\n    /// @return proof       The Merkle proof of inclusion for the entry\n    function getEntryProof(uint64 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof);\n\n    /// @notice Get the nonce of the database, which is incremented every time a new batch is finalized.\n    /// This is the nonce of the current non-finalized batch.\n    function getDBNonce() external view returns (uint64);\n\n    /// @notice Get the index of the next entry to be written to the database.\n    /// @return dbNonce      The database nonce of the batch including the next entry\n    /// @return entryIndex   The index of the next entry within that batch\n    function getNextEntryIndex() external view returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Check if the batch is verified by the Interchain Module on the destination chain.\n    /// Note: returned zero value indicates that the module has not verified the batch.\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @param batch        The Interchain Batch to check\n    /// @return moduleVerifiedAt    The block timestamp at which the batch was verified by the module,\n    ///                             or ZERO if the module has not verified the batch.\n    function checkBatchVerification(\n        address dstModule,\n        InterchainBatch memory batch\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n\n    /// @notice Get the batch root containing the Interchain Entry with the given index.\n    /// @param entry         The Interchain Entry to get the batch root for\n    /// @param proof         The Merkle proof of inclusion for the entry in the batch\n    function getBatchRoot(InterchainEntry memory entry, bytes32[] memory proof) external pure returns (bytes32);\n\n    /// @notice Get the version of the Interchain DataBase.\n    // solhint-disable-next-line func-name-mixedcase\n    function DB_VERSION() external pure returns (uint16);\n}\n\n// contracts/InterchainDB.sol\n\ncontract InterchainDB is InterchainDBEvents, IInterchainDB {\n    using VersionedPayloadLib for bytes;\n\n    /// @notice Struct representing a batch of entries from the remote Interchain DataBase,\n    /// verified by the Interchain Module.\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param batchRoot    The Merkle root of the batch\n    struct RemoteBatch {\n        uint256 verifiedAt;\n        bytes32 batchRoot;\n    }\n\n    uint16 public constant DB_VERSION = 1;\n\n    bytes32[] internal _entryValues;\n    mapping(address module =\u003e mapping(BatchKey batchKey =\u003e RemoteBatch batch)) internal _remoteBatches;\n\n    modifier onlyRemoteChainId(uint64 chainId) {\n        if (chainId == block.chainid) {\n            revert InterchainDB__ChainIdNotRemote(chainId);\n        }\n        _;\n    }\n\n    //  WRITER-FACING \n\n    /// @inheritdoc IInterchainDB\n    function writeEntry(bytes32 dataHash) external returns (uint64 dbNonce, uint64 entryIndex) {\n        InterchainEntry memory entry = _writeEntry(dataHash);\n        (dbNonce, entryIndex) = (entry.dbNonce, entry.entryIndex);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function requestBatchVerification(\n        uint64 dstChainId,\n        uint64 dbNonce,\n        address[] calldata srcModules\n    )\n        external\n        payable\n        onlyRemoteChainId(dstChainId)\n    {\n        InterchainBatch memory batch = getBatch(dbNonce);\n        _requestVerification(dstChainId, batch, srcModules);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function writeEntryWithVerification(\n        uint64 dstChainId,\n        bytes32 dataHash,\n        address[] calldata srcModules\n    )\n        external\n        payable\n        onlyRemoteChainId(dstChainId)\n        returns (uint64 dbNonce, uint64 entryIndex)\n    {\n        InterchainEntry memory entry = _writeEntry(dataHash);\n        (dbNonce, entryIndex) = (entry.dbNonce, entry.entryIndex);\n        // In \"no batching\" mode: the batch root is the same as the entry value\n        InterchainBatch memory batch = InterchainBatchLib.constructLocalBatch(dbNonce, entry.entryValue());\n        _requestVerification(dstChainId, batch, srcModules);\n    }\n\n    //  MODULE-FACING \n\n    /// @inheritdoc IInterchainDB\n    function verifyRemoteBatch(bytes calldata versionedBatch) external {\n        InterchainBatch memory batch = _assertCorrectBatch(versionedBatch);\n        BatchKey batchKey = InterchainBatchLib.encodeBatchKey({srcChainId: batch.srcChainId, dbNonce: batch.dbNonce});\n        RemoteBatch memory existingBatch = _remoteBatches[msg.sender][batchKey];\n        // Check if that's the first time module verifies the batch\n        if (existingBatch.verifiedAt == 0) {\n            _saveVerifiedBatch(msg.sender, batchKey, batch);\n            return;\n        }\n        // No-op if the batch root is the same\n        if (existingBatch.batchRoot == batch.batchRoot) {\n            return;\n        }\n        // Overwriting an empty (non-existent) batch with a different one is allowed\n        if (existingBatch.batchRoot == 0) {\n            _saveVerifiedBatch(msg.sender, batchKey, batch);\n            return;\n        }\n        // Overwriting an existing batch with a different one is not allowed\n        revert InterchainDB__BatchConflict(msg.sender, existingBatch.batchRoot, batch);\n    }\n\n    //  VIEWS \n\n    /// @inheritdoc IInterchainDB\n    function getBatchLeafs(uint64 dbNonce) external view returns (bytes32[] memory leafs) {\n        uint256 batchSize = getBatchSize(dbNonce);\n        leafs = new bytes32[](batchSize);\n        for (uint64 i = 0; i \u003c batchSize; ++i) {\n            leafs[i] = getEntryValue(dbNonce, i);\n        }\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getBatchLeafsPaginated(\n        uint64 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory leafs)\n    {\n        uint256 size = getBatchSize(dbNonce);\n        if (start \u003e end || end \u003e size) {\n            revert InterchainDB__EntryRangeInvalid(dbNonce, start, end);\n        }\n        leafs = new bytes32[](end - start);\n        for (uint64 i = start; i \u003c end; ++i) {\n            leafs[i - start] = getEntryValue(dbNonce, i);\n        }\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getEntryProof(uint64 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof) {\n        // In \"no batching\" mode: the batch root is the same as the entry value, hence the proof is empty\n        _assertEntryExists(dbNonce, entryIndex);\n        return new bytes32[](0);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getInterchainFee(uint64 dstChainId, address[] calldata srcModules) external view returns (uint256 fee) {\n        (, fee) = _getModuleFees(dstChainId, getDBNonce(), srcModules);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getNextEntryIndex() external view returns (uint64 dbNonce, uint64 entryIndex) {\n        // In \"no batching\" mode: entry index is 0, batch size is 1\n        dbNonce = getDBNonce();\n        entryIndex = 0;\n    }\n\n    /// @inheritdoc IInterchainDB\n    function checkBatchVerification(\n        address dstModule,\n        InterchainBatch memory batch\n    )\n        external\n        view\n        onlyRemoteChainId(batch.srcChainId)\n        returns (uint256 moduleVerifiedAt)\n    {\n        BatchKey batchKey = InterchainBatchLib.encodeBatchKey({srcChainId: batch.srcChainId, dbNonce: batch.dbNonce});\n        RemoteBatch memory remoteBatch = _remoteBatches[dstModule][batchKey];\n        // Check if module verified anything for this batch key first\n        if (remoteBatch.verifiedAt == 0) {\n            return BATCH_UNVERIFIED;\n        }\n        // Check if the batch root matches the one verified by the module\n        return remoteBatch.batchRoot == batch.batchRoot ? remoteBatch.verifiedAt : BATCH_CONFLICT;\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getVersionedBatch(uint64 dbNonce) external view returns (bytes memory versionedBatch) {\n        InterchainBatch memory batch = getBatch(dbNonce);\n        return VersionedPayloadLib.encodeVersionedPayload({\n            version: DB_VERSION,\n            payload: InterchainBatchLib.encodeBatch(batch)\n        });\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getBatchRoot(InterchainEntry memory entry, bytes32[] calldata proof) external pure returns (bytes32) {\n        return BatchingV1Lib.getBatchRoot({\n            srcWriter: entry.srcWriter,\n            dataHash: entry.dataHash,\n            entryIndex: entry.entryIndex,\n            proof: proof\n        });\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getBatchSize(uint64 dbNonce) public view returns (uint64) {\n        // In \"no batching\" mode: the finalized batch size is 1, the pending batch size is 0\n        // We also return 0 for non-existent batches\n        return dbNonce \u003c getDBNonce() ? 1 : 0;\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getBatch(uint64 dbNonce) public view returns (InterchainBatch memory) {\n        // In \"no batching\" mode: the batch root is the same as the entry hash.\n        // For non-finalized or non-existent batches, the batch root is 0.\n        bytes32 batchRoot = dbNonce \u003c getDBNonce() ? getEntryValue(dbNonce, 0) : bytes32(0);\n        return InterchainBatchLib.constructLocalBatch(dbNonce, batchRoot);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getEntryValue(uint64 dbNonce, uint64 entryIndex) public view returns (bytes32) {\n        _assertEntryExists(dbNonce, entryIndex);\n        return _entryValues[dbNonce];\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getDBNonce() public view returns (uint64) {\n        // We can do the unsafe cast here as writing more than 2^64 entries is practically impossible\n        return uint64(_entryValues.length);\n    }\n\n    //  INTERNAL LOGIC \n\n    /// @dev Write the entry to the database and emit the event.\n    function _writeEntry(bytes32 dataHash) internal returns (InterchainEntry memory entry) {\n        uint64 dbNonce = getDBNonce();\n        entry = InterchainEntryLib.constructLocalEntry({\n            dbNonce: dbNonce,\n            entryIndex: 0,\n            writer: msg.sender,\n            dataHash: dataHash\n        });\n        bytes32 entryValue = entry.entryValue();\n        _entryValues.push(entryValue);\n        emit InterchainEntryWritten({\n            dbNonce: dbNonce,\n            entryIndex: 0,\n            srcWriter: TypeCasts.addressToBytes32(msg.sender),\n            dataHash: dataHash\n        });\n        // In the InterchainDB V1 the batch is finalized immediately after the entry is written\n        emit InterchainBatchFinalized({dbNonce: dbNonce, batchRoot: entryValue});\n    }\n\n    /// @dev Request the verification of the entry by the modules, and emit the event.\n    /// Note: the validity of the passed entry and chain id being remote is enforced in the calling function.\n    function _requestVerification(\n        uint64 dstChainId,\n        InterchainBatch memory batch,\n        address[] calldata srcModules\n    )\n        internal\n    {\n        (uint256[] memory fees, uint256 totalFee) = _getModuleFees(dstChainId, batch.dbNonce, srcModules);\n        if (msg.value \u003c totalFee) {\n            revert InterchainDB__FeeAmountBelowMin(msg.value, totalFee);\n        } else if (msg.value \u003e totalFee) {\n            // The exceeding amount goes to the first module\n            fees[0] += msg.value - totalFee;\n        }\n        uint256 len = srcModules.length;\n        bytes memory versionedBatch = VersionedPayloadLib.encodeVersionedPayload({\n            version: DB_VERSION,\n            payload: InterchainBatchLib.encodeBatch(batch)\n        });\n        for (uint256 i = 0; i \u003c len; ++i) {\n            IInterchainModule(srcModules[i]).requestBatchVerification{value: fees[i]}(\n                dstChainId, batch.dbNonce, versionedBatch\n            );\n        }\n        emit InterchainBatchVerificationRequested(dstChainId, batch.dbNonce, batch.batchRoot, srcModules);\n    }\n\n    /// @dev Save the verified batch to the database and emit the event.\n    function _saveVerifiedBatch(address module, BatchKey batchKey, InterchainBatch memory batch) internal {\n        _remoteBatches[module][batchKey] = RemoteBatch({verifiedAt: block.timestamp, batchRoot: batch.batchRoot});\n        emit InterchainBatchVerified(module, batch.srcChainId, batch.dbNonce, batch.batchRoot);\n    }\n\n    //  INTERNAL VIEWS \n\n    /// @dev Asserts that the batch version is correct and that batch originates from a remote chain.\n    /// Note: returns the decoded batch for chaining purposes.\n    function _assertCorrectBatch(bytes calldata versionedBatch) internal view returns (InterchainBatch memory batch) {\n        uint16 dbVersion = versionedBatch.getVersion();\n        if (dbVersion != DB_VERSION) {\n            revert InterchainDB__BatchVersionMismatch(dbVersion, DB_VERSION);\n        }\n        batch = InterchainBatchLib.decodeBatch(versionedBatch.getPayload());\n        if (batch.srcChainId == block.chainid) {\n            revert InterchainDB__ChainIdNotRemote(batch.srcChainId);\n        }\n    }\n\n    /// @dev Check that the entry index is within the batch size. Also checks that the batch exists.\n    function _assertEntryExists(uint64 dbNonce, uint64 entryIndex) internal view {\n        // This will revert if the batch does not exist\n        uint64 batchSize = getBatchSize(dbNonce);\n        if (entryIndex \u003e= batchSize) {\n            revert InterchainDB__EntryIndexOutOfRange(dbNonce, entryIndex, batchSize);\n        }\n    }\n\n    /// @dev Get the verification fees for the modules\n    function _getModuleFees(\n        uint64 dstChainId,\n        uint64 dbNonce,\n        address[] calldata srcModules\n    )\n        internal\n        view\n        returns (uint256[] memory fees, uint256 totalFee)\n    {\n        uint256 len = srcModules.length;\n        if (len == 0) {\n            revert InterchainDB__ModulesNotProvided();\n        }\n        fees = new uint256[](len);\n        for (uint256 i = 0; i \u003c len; ++i) {\n            fees[i] = IInterchainModule(srcModules[i]).getModuleFee(dstChainId, dbNonce);\n            totalFee += fees[i];\n        }\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"8754:33927:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;8754:33927:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"8754:33927:0:-:0;;;;;;;;","abiDefinition":[{"inputs":[{"internalType":"uint8","name":"bits","type":"uint8"},{"internalType":"int256","name":"value","type":"int256"}],"name":"SafeCastOverflowedIntDowncast","type":"error"},{"inputs":[{"internalType":"int256","name":"value","type":"int256"}],"name":"SafeCastOverflowedIntToUint","type":"error"},{"inputs":[{"internalType":"uint8","name":"bits","type":"uint8"},{"internalType":"uint256","name":"value","type":"uint256"}],"name":"SafeCastOverflowedUintDowncast","type":"error"},{"inputs":[{"internalType":"uint256","name":"value","type":"uint256"}],"name":"SafeCastOverflowedUintToInt","type":"error"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"details":"Wrappers over Solidity's uintXX/intXX casting operators with added overflow checks. Downcasting from uint256/int256 in Solidity does not revert on overflow. This can easily result in undesired exploitation or bugs, since developers usually assume that overflows raise errors. `SafeCast` restores this intuition by reverting the transaction when such an operation overflows. Using this library instead of the unchecked operations eliminates an entire class of bugs, so it's recommended to use it always.","errors":{"SafeCastOverflowedIntDowncast(uint8,int256)":[{"details":"Value doesn't fit in an int of `bits` size."}],"SafeCastOverflowedIntToUint(int256)":[{"details":"An int value doesn't fit in an uint of `bits` size."}],"SafeCastOverflowedUintDowncast(uint8,uint256)":[{"details":"Value doesn't fit in an uint of `bits` size."}],"SafeCastOverflowedUintToInt(uint256)":[{"details":"An uint value doesn't fit in an int of `bits` size."}]},"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"bits\",\"type\":\"uint8\"},{\"internalType\":\"int256\",\"name\":\"value\",\"type\":\"int256\"}],\"name\":\"SafeCastOverflowedIntDowncast\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"value\",\"type\":\"int256\"}],\"name\":\"SafeCastOverflowedIntToUint\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"bits\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"SafeCastOverflowedUintDowncast\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"SafeCastOverflowedUintToInt\",\"type\":\"error\"}],\"devdoc\":{\"details\":\"Wrappers over Solidity's uintXX/intXX casting operators with added overflow checks. Downcasting from uint256/int256 in Solidity does not revert on overflow. This can easily result in undesired exploitation or bugs, since developers usually assume that overflows raise errors. `SafeCast` restores this intuition by reverting the transaction when such an operation overflows. Using this library instead of the unchecked operations eliminates an entire class of bugs, so it's recommended to use it always.\",\"errors\":{\"SafeCastOverflowedIntDowncast(uint8,int256)\":[{\"details\":\"Value doesn't fit in an int of `bits` size.\"}],\"SafeCastOverflowedIntToUint(int256)\":[{\"details\":\"An int value doesn't fit in an uint of `bits` size.\"}],\"SafeCastOverflowedUintDowncast(uint8,uint256)\":[{\"details\":\"Value doesn't fit in an uint of `bits` size.\"}],\"SafeCastOverflowedUintToInt(uint256)\":[{\"details\":\"An uint value doesn't fit in an int of `bits` size.\"}]},\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainDB.sol\":\"SafeCast\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainDB.sol\":{\"keccak256\":\"0x4dd7dd2bde0a2d89cb06f57f8772f18d4b0547c65abb43503e5fc2dedf60ac3e\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://e22ed31c26dd9174d0f333bf9d8d5916d407c0c99aa908c56a6c4156756a5e1e\",\"dweb:/ipfs/QmTi96nhB9Vr3SRq9qa24zbPvctFSNubneRuohgndhAqHK\"]}},\"version\":1}"},"hashes":{}},"solidity/InterchainDB.sol:TypeCasts":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212202e92cbfb006c3e23db78b2472287abb2da7d12d259aba0066c8cdb3de23e7f5a64736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212202e92cbfb006c3e23db78b2472287abb2da7d12d259aba0066c8cdb3de23e7f5a64736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainDBEvents.sol\n\nabstract contract InterchainDBEvents {\n    /// @notice Emitted when a local entry is written to the database.\n    /// @param dbNonce      The nonce of the batch containing the entry.\n    /// @param entryIndex   The index of the entry within the batch.\n    /// @param srcWriter    The address of the writer.\n    /// @param dataHash     The written data hash.\n    event InterchainEntryWritten(\n        uint64 indexed dbNonce, uint64 entryIndex, bytes32 indexed srcWriter, bytes32 dataHash\n    );\n\n    /// @notice Emitted when a local batch is finalized.\n    /// @param dbNonce      The nonce of the finalized batch.\n    /// @param batchRoot    The Merkle root hash of the finalized batch.\n    event InterchainBatchFinalized(uint64 indexed dbNonce, bytes32 batchRoot);\n\n    /// @notice Emitted when a remote batch is verified by the Interchain Module.\n    /// @param module       The address of the Interchain Module that verified the batch.\n    /// @param srcChainId   The ID of the source chain.\n    /// @param dbNonce      The nonce of the verified batch.\n    /// @param batchRoot    The Merkle root hash of the verified batch.\n    event InterchainBatchVerified(\n        address indexed module, uint64 indexed srcChainId, uint64 indexed dbNonce, bytes32 batchRoot\n    );\n\n    /// @notice Emitted when a local batch is requested to be verified on a remote chain\n    /// using the set of Interchain Modules.\n    /// @param dstChainId   The ID of the destination chain.\n    /// @param dbNonce      The nonce of the batch to be verified.\n    /// @param batchRoot    The Merkle root hash of the batch to be verified.\n    /// @param srcModules   The addresses of the Interchain Modules that will verify the batch.\n    event InterchainBatchVerificationRequested(\n        uint64 indexed dstChainId, uint64 indexed dbNonce, bytes32 batchRoot, address[] srcModules\n    );\n}\n\n// contracts/interfaces/IInterchainModule.sol\n\n/// @notice Every Module may opt a different method to confirm the verified entries on destination chain,\n/// therefore this is not a part of a common interface.\ninterface IInterchainModule {\n    error InterchainModule__CallerNotInterchainDB(address caller);\n    error InterchainModule__ChainIdNotRemote(uint64 chainId);\n    error InterchainModule__FeeAmountBelowMin(uint256 feeAmount, uint256 minRequired);\n\n    /// @notice Request the verification of a batch from the Interchain DataBase by the module.\n    /// If the batch is not yet finalized, the verification on destination chain will be delayed until\n    /// the finalization is done and batch root is saved on the source chain.\n    /// Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`.\n    /// Note: this will eventually trigger `InterchainDB.verifyRemoteBatch(batch)` function on destination chain,\n    /// with no guarantee of ordering.\n    /// @dev Could be only called by the Interchain DataBase contract.\n    /// @param dstChainId       The chain id of the destination chain\n    /// @param batchNonce       The nonce of the batch on the source chain\n    /// @param versionedBatch   The versioned batch to verify\n    function requestBatchVerification(\n        uint64 dstChainId,\n        uint64 batchNonce,\n        bytes memory versionedBatch\n    )\n        external\n        payable;\n\n    /// @notice Get the Module fee for verifying a batch on the specified destination chain.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dbNonce      The database nonce of the batch on the source chain\n    function getModuleFee(uint64 dstChainId, uint64 dbNonce) external view returns (uint256);\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/VersionedPayload.sol\n\n// solhint-disable no-inline-assembly\n// solhint-disable ordering\nlibrary VersionedPayloadLib {\n    /// @notice Amount of bytes reserved for the version (uint16) in the versioned payload\n    uint256 internal constant VERSION_LENGTH = 2;\n\n    error VersionedPayload__PayloadTooShort(bytes versionedPayload);\n    error VersionedPayload__PrecompileFailed();\n\n    /// @notice Encodes the versioned payload into a single bytes array.\n    /// @param version  The payload's version.\n    /// @param payload  The payload to encode.\n    function encodeVersionedPayload(uint16 version, bytes memory payload) internal pure returns (bytes memory) {\n        return abi.encodePacked(version, payload);\n    }\n\n    /// @notice Extracts the version from the versioned payload (calldata reference).\n    /// @param versionedPayload     The versioned payload (calldata reference).\n    function getVersion(bytes calldata versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__PayloadTooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            version := shr(240, calldataload(versionedPayload.offset))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (calldata reference).\n    /// @dev The extracted payload is also returned as a calldata reference.\n    /// @param versionedPayload     The versioned payload.\n    function getPayload(bytes calldata versionedPayload) internal pure returns (bytes calldata) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__PayloadTooShort(versionedPayload);\n        }\n        return versionedPayload[VERSION_LENGTH:];\n    }\n\n    /// @notice Extracts the version from the versioned payload (memory reference).\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getVersionFromMemory(bytes memory versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__PayloadTooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            // We add 0x20 to skip the length of the bytes array.\n            version := shr(240, mload(add(versionedPayload, 0x20)))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (memory reference).\n    /// @dev The extracted payload is copied into a new memory location. Use `getPayload` when possible\n    /// to avoid extra memory allocation.\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getPayloadFromMemory(bytes memory versionedPayload) internal view returns (bytes memory payload) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__PayloadTooShort(versionedPayload);\n        }\n        // Figure how many bytes to copy and allocate the memory for the extracted payload.\n        uint256 toCopy;\n        unchecked {\n            toCopy = versionedPayload.length - VERSION_LENGTH;\n        }\n        payload = new bytes(toCopy);\n        // Use identity precompile (0x04) to copy the payload. Unlike MCOPY, this is available on all EVM chains.\n        bool res;\n        assembly {\n            // We add 0x20 to skip the length of the bytes array.\n            // We add 0x02 to skip the 2 bytes reserved for the version.\n            // Copy the payload to the previously allocated memory.\n            res := staticcall(gas(), 0x04, add(versionedPayload, 0x22), toCopy, add(payload, 0x20), toCopy)\n        }\n        if (!res) {\n            revert VersionedPayload__PrecompileFailed();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SafeCast.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value \u003e type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value \u003e type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value \u003e type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value \u003e type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value \u003e type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value \u003e type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value \u003e type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value \u003e type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value \u003e type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value \u003e type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value \u003e type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value \u003e type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value \u003e type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value \u003e type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value \u003e type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value \u003e type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value \u003e type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value \u003e type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value \u003e type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value \u003e type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value \u003e type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value \u003e type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value \u003e type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value \u003e type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value \u003e type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value \u003e type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value \u003e type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value \u003e type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value \u003e type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value \u003e type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value \u003e type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value \u003c 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value \u003e uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n}\n\n// contracts/libs/InterchainBatch.sol\n\ntype BatchKey is uint128;\n\n/// @notice Struct representing a batch of entries in the Interchain DataBase.\n/// Batched entries are put together in a Merkle tree, which root is saved.\n/// Batch has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: batchRoot\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch\n/// @param batchRoot    The root of the Merkle tree containing the batched entries\nstruct InterchainBatch {\n    uint64 srcChainId;\n    uint64 dbNonce;\n    bytes32 batchRoot;\n}\n\n/// @dev Signals that the module has not verified any batch with the given key.\nuint256 constant BATCH_UNVERIFIED = 0;\n/// @dev Signals that the module has verified a conflicting batch with the given key.\nuint256 constant BATCH_CONFLICT = type(uint256).max;\n\nlibrary InterchainBatchLib {\n    using VersionedPayloadLib for bytes;\n\n    /// @notice Constructs an InterchainBatch struct to be saved on the local chain.\n    /// @param dbNonce      The database nonce of the batch\n    /// @param batchRoot    The root of the Merkle tree containing the batched entries\n    /// @return batch       The constructed InterchainBatch struct\n    function constructLocalBatch(\n        uint64 dbNonce,\n        bytes32 batchRoot\n    )\n        internal\n        view\n        returns (InterchainBatch memory batch)\n    {\n        return InterchainBatch({srcChainId: SafeCast.toUint64(block.chainid), dbNonce: dbNonce, batchRoot: batchRoot});\n    }\n\n    /// @notice Encodes the InterchainBatch struct into a non-versioned batch payload.\n    function encodeBatch(InterchainBatch memory batch) internal pure returns (bytes memory) {\n        return abi.encode(encodeBatchKey(batch.srcChainId, batch.dbNonce), batch.batchRoot);\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in calldata.\n    function decodeBatch(bytes calldata data) internal pure returns (InterchainBatch memory batch) {\n        BatchKey key;\n        (key, batch.batchRoot) = abi.decode(data, (BatchKey, bytes32));\n        (batch.srcChainId, batch.dbNonce) = decodeBatchKey(key);\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in memory.\n    function decodeBatchFromMemory(bytes memory data) internal pure returns (InterchainBatch memory batch) {\n        BatchKey key;\n        (key, batch.batchRoot) = abi.decode(data, (BatchKey, bytes32));\n        (batch.srcChainId, batch.dbNonce) = decodeBatchKey(key);\n    }\n\n    /// @notice Encodes the uint128 key of the batch from uint64 srcChainId and uint64 dbNonce.\n    function encodeBatchKey(uint64 srcChainId, uint64 dbNonce) internal pure returns (BatchKey) {\n        return BatchKey.wrap((uint128(srcChainId) \u003c\u003c 64) | dbNonce);\n    }\n\n    /// @notice Decodes the uint128 key of the batch into uint64 srcChainId and uint64 dbNonce.\n    function decodeBatchKey(BatchKey key) internal pure returns (uint64 srcChainId, uint64 dbNonce) {\n        srcChainId = uint64(BatchKey.unwrap(key) \u003e\u003e 64);\n        dbNonce = uint64(BatchKey.unwrap(key));\n    }\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce + entryIndex\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch containing the entry\n/// @param entryIndex   The index of the entry in the batch\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint64 srcChainId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nusing InterchainEntryLib for InterchainEntry global;\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint64 dbNonce,\n        uint64 entryIndex,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: SafeCast.toUint64(block.chainid),\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return getEntryValue(entry.srcWriter, entry.dataHash);\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function getEntryValue(bytes32 srcWriter, bytes32 dataHash) internal pure returns (bytes32) {\n        return keccak256(abi.encode(srcWriter, dataHash));\n    }\n}\n\n// contracts/libs/BatchingV1.sol\n\nlibrary BatchingV1Lib {\n    error BatchingV1__EntryIndexNotZero(uint64 entryIndex);\n    error BatchingV1__ProofNotEmpty();\n\n    /// @notice Get the batch root containing the Interchain Entry with the given index.\n    /// @param srcWriter    The entry writer of the source chain\n    /// @param dataHash     The hash of the data of the entry\n    /// @param entryIndex   The index of the entry in the batch\n    /// @param proof        The Merkle proof of inclusion for the entry in the batch\n    /// @return batchRoot   The root of the batch containing the entry\n    function getBatchRoot(\n        bytes32 srcWriter,\n        bytes32 dataHash,\n        uint64 entryIndex,\n        bytes32[] calldata proof\n    )\n        internal\n        pure\n        returns (bytes32 batchRoot)\n    {\n        // In \"no batching\" mode: entry index is 0, proof is empty\n        if (entryIndex != 0) {\n            revert BatchingV1__EntryIndexNotZero(entryIndex);\n        }\n        if (proof.length != 0) {\n            revert BatchingV1__ProofNotEmpty();\n        }\n        // In \"no batching\" mode: the batch root is the same as the entry value\n        return InterchainEntryLib.getEntryValue({srcWriter: srcWriter, dataHash: dataHash});\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    error InterchainDB__BatchConflict(address module, bytes32 existingBatchRoot, InterchainBatch newBatch);\n    error InterchainDB__BatchVersionMismatch(uint16 version, uint16 required);\n    error InterchainDB__ChainIdNotRemote(uint64 chainId);\n    error InterchainDB__EntryIndexOutOfRange(uint64 dbNonce, uint64 entryIndex, uint64 batchSize);\n    error InterchainDB__EntryRangeInvalid(uint64 dbNonce, uint64 start, uint64 end);\n    error InterchainDB__FeeAmountBelowMin(uint256 feeAmount, uint256 minRequired);\n    error InterchainDB__ModulesNotProvided();\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `requestBatchVerification` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntry(bytes32 dataHash) external returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Request the given Interchain Modules to verify an existing batch.\n    /// If the batch is not finalized, the module will verify it after finalization.\n    /// For the finalized batch the batch root is already available, and the module can verify it immediately.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any batch.\n    /// @dev Will revert if the batch with the given nonce does not exist.\n    /// @param dstChainId    The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the existing batch\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestBatchVerification(\n        uint64 dstChainId,\n        uint64 dbNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Then request the Interchain Modules to verify the batch containing the written entry on the destination chain.\n    /// See `writeEntry` and `requestBatchVerification` for more details.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntryWithVerification(\n        uint64 dstChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Allows the Interchain Module to verify the batch coming from the remote chain.\n    /// The module SHOULD verify the exact finalized batch from the remote chain. If the batch with a given nonce\n    /// is not finalized or does not exist, module CAN verify it with an empty root value. Once the batch is\n    /// finalized, the module SHOULD re-verify the batch with the correct root value.\n    /// Note: The DB will only accept the batch of the same version as the DB itself.\n    /// @dev Will revert if the batch with the same nonce but a different non-empty root is already verified.\n    /// @param versionedBatch   The versioned Interchain Batch to verify\n    function verifyRemoteBatch(bytes memory versionedBatch) external;\n\n    //  VIEWS \n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint64 dstChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce.\n    /// Note: the leafs are ordered by the index of the written entry in the current batch,\n    /// and the leafs value match the value of the written entry (srcWriter + dataHash hashed together).\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchLeafs(uint64 dbNonce) external view returns (bytes32[] memory);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce,\n    /// paginated by the given start and end indexes. The end index is exclusive.\n    /// Note: this is useful when the batch contains a large number of leafs, and calling `getBatchLeafs`\n    /// would result in a gas limit exceeded error.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the provided range is invalid.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param start        The start index of the paginated leafs, inclusive\n    /// @param end          The end index of the paginated leafs, exclusive\n    function getBatchLeafsPaginated(\n        uint64 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory);\n\n    /// @notice Returns the size of the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchSize(uint64 dbNonce) external view returns (uint64);\n\n    /// @notice Get the finalized Interchain Batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatch(uint64 dbNonce) external view returns (InterchainBatch memory);\n\n    /// @notice Get the versioned Interchain Batch with the given nonce.\n    /// Note: will return a batch with an empty root if the batch does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the batch\n    function getVersionedBatch(uint64 dbNonce) external view returns (bytes memory);\n\n    /// @notice Get the Interchain Entry's value written on the local chain with the given batch nonce and entry index.\n    /// Entry value is calculated as the hash of the writer address and the written data hash.\n    /// Note: the batch does not have to be finalized to fetch the entry value.\n    /// @dev Will revert if the batch with the given nonce does not exist,\n    /// or the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the existing batch\n    /// @param entryIndex   The index of the written entry within the batch\n    function getEntryValue(uint64 dbNonce, uint64 entryIndex) external view returns (bytes32);\n\n    /// @notice Get the Merkle proof of inclusion for the entry with the given index\n    /// in the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param entryIndex   The index of the written entry within the batch\n    /// @return proof       The Merkle proof of inclusion for the entry\n    function getEntryProof(uint64 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof);\n\n    /// @notice Get the nonce of the database, which is incremented every time a new batch is finalized.\n    /// This is the nonce of the current non-finalized batch.\n    function getDBNonce() external view returns (uint64);\n\n    /// @notice Get the index of the next entry to be written to the database.\n    /// @return dbNonce      The database nonce of the batch including the next entry\n    /// @return entryIndex   The index of the next entry within that batch\n    function getNextEntryIndex() external view returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Check if the batch is verified by the Interchain Module on the destination chain.\n    /// Note: returned zero value indicates that the module has not verified the batch.\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @param batch        The Interchain Batch to check\n    /// @return moduleVerifiedAt    The block timestamp at which the batch was verified by the module,\n    ///                             or ZERO if the module has not verified the batch.\n    function checkBatchVerification(\n        address dstModule,\n        InterchainBatch memory batch\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n\n    /// @notice Get the batch root containing the Interchain Entry with the given index.\n    /// @param entry         The Interchain Entry to get the batch root for\n    /// @param proof         The Merkle proof of inclusion for the entry in the batch\n    function getBatchRoot(InterchainEntry memory entry, bytes32[] memory proof) external pure returns (bytes32);\n\n    /// @notice Get the version of the Interchain DataBase.\n    // solhint-disable-next-line func-name-mixedcase\n    function DB_VERSION() external pure returns (uint16);\n}\n\n// contracts/InterchainDB.sol\n\ncontract InterchainDB is InterchainDBEvents, IInterchainDB {\n    using VersionedPayloadLib for bytes;\n\n    /// @notice Struct representing a batch of entries from the remote Interchain DataBase,\n    /// verified by the Interchain Module.\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param batchRoot    The Merkle root of the batch\n    struct RemoteBatch {\n        uint256 verifiedAt;\n        bytes32 batchRoot;\n    }\n\n    uint16 public constant DB_VERSION = 1;\n\n    bytes32[] internal _entryValues;\n    mapping(address module =\u003e mapping(BatchKey batchKey =\u003e RemoteBatch batch)) internal _remoteBatches;\n\n    modifier onlyRemoteChainId(uint64 chainId) {\n        if (chainId == block.chainid) {\n            revert InterchainDB__ChainIdNotRemote(chainId);\n        }\n        _;\n    }\n\n    //  WRITER-FACING \n\n    /// @inheritdoc IInterchainDB\n    function writeEntry(bytes32 dataHash) external returns (uint64 dbNonce, uint64 entryIndex) {\n        InterchainEntry memory entry = _writeEntry(dataHash);\n        (dbNonce, entryIndex) = (entry.dbNonce, entry.entryIndex);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function requestBatchVerification(\n        uint64 dstChainId,\n        uint64 dbNonce,\n        address[] calldata srcModules\n    )\n        external\n        payable\n        onlyRemoteChainId(dstChainId)\n    {\n        InterchainBatch memory batch = getBatch(dbNonce);\n        _requestVerification(dstChainId, batch, srcModules);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function writeEntryWithVerification(\n        uint64 dstChainId,\n        bytes32 dataHash,\n        address[] calldata srcModules\n    )\n        external\n        payable\n        onlyRemoteChainId(dstChainId)\n        returns (uint64 dbNonce, uint64 entryIndex)\n    {\n        InterchainEntry memory entry = _writeEntry(dataHash);\n        (dbNonce, entryIndex) = (entry.dbNonce, entry.entryIndex);\n        // In \"no batching\" mode: the batch root is the same as the entry value\n        InterchainBatch memory batch = InterchainBatchLib.constructLocalBatch(dbNonce, entry.entryValue());\n        _requestVerification(dstChainId, batch, srcModules);\n    }\n\n    //  MODULE-FACING \n\n    /// @inheritdoc IInterchainDB\n    function verifyRemoteBatch(bytes calldata versionedBatch) external {\n        InterchainBatch memory batch = _assertCorrectBatch(versionedBatch);\n        BatchKey batchKey = InterchainBatchLib.encodeBatchKey({srcChainId: batch.srcChainId, dbNonce: batch.dbNonce});\n        RemoteBatch memory existingBatch = _remoteBatches[msg.sender][batchKey];\n        // Check if that's the first time module verifies the batch\n        if (existingBatch.verifiedAt == 0) {\n            _saveVerifiedBatch(msg.sender, batchKey, batch);\n            return;\n        }\n        // No-op if the batch root is the same\n        if (existingBatch.batchRoot == batch.batchRoot) {\n            return;\n        }\n        // Overwriting an empty (non-existent) batch with a different one is allowed\n        if (existingBatch.batchRoot == 0) {\n            _saveVerifiedBatch(msg.sender, batchKey, batch);\n            return;\n        }\n        // Overwriting an existing batch with a different one is not allowed\n        revert InterchainDB__BatchConflict(msg.sender, existingBatch.batchRoot, batch);\n    }\n\n    //  VIEWS \n\n    /// @inheritdoc IInterchainDB\n    function getBatchLeafs(uint64 dbNonce) external view returns (bytes32[] memory leafs) {\n        uint256 batchSize = getBatchSize(dbNonce);\n        leafs = new bytes32[](batchSize);\n        for (uint64 i = 0; i \u003c batchSize; ++i) {\n            leafs[i] = getEntryValue(dbNonce, i);\n        }\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getBatchLeafsPaginated(\n        uint64 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory leafs)\n    {\n        uint256 size = getBatchSize(dbNonce);\n        if (start \u003e end || end \u003e size) {\n            revert InterchainDB__EntryRangeInvalid(dbNonce, start, end);\n        }\n        leafs = new bytes32[](end - start);\n        for (uint64 i = start; i \u003c end; ++i) {\n            leafs[i - start] = getEntryValue(dbNonce, i);\n        }\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getEntryProof(uint64 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof) {\n        // In \"no batching\" mode: the batch root is the same as the entry value, hence the proof is empty\n        _assertEntryExists(dbNonce, entryIndex);\n        return new bytes32[](0);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getInterchainFee(uint64 dstChainId, address[] calldata srcModules) external view returns (uint256 fee) {\n        (, fee) = _getModuleFees(dstChainId, getDBNonce(), srcModules);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getNextEntryIndex() external view returns (uint64 dbNonce, uint64 entryIndex) {\n        // In \"no batching\" mode: entry index is 0, batch size is 1\n        dbNonce = getDBNonce();\n        entryIndex = 0;\n    }\n\n    /// @inheritdoc IInterchainDB\n    function checkBatchVerification(\n        address dstModule,\n        InterchainBatch memory batch\n    )\n        external\n        view\n        onlyRemoteChainId(batch.srcChainId)\n        returns (uint256 moduleVerifiedAt)\n    {\n        BatchKey batchKey = InterchainBatchLib.encodeBatchKey({srcChainId: batch.srcChainId, dbNonce: batch.dbNonce});\n        RemoteBatch memory remoteBatch = _remoteBatches[dstModule][batchKey];\n        // Check if module verified anything for this batch key first\n        if (remoteBatch.verifiedAt == 0) {\n            return BATCH_UNVERIFIED;\n        }\n        // Check if the batch root matches the one verified by the module\n        return remoteBatch.batchRoot == batch.batchRoot ? remoteBatch.verifiedAt : BATCH_CONFLICT;\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getVersionedBatch(uint64 dbNonce) external view returns (bytes memory versionedBatch) {\n        InterchainBatch memory batch = getBatch(dbNonce);\n        return VersionedPayloadLib.encodeVersionedPayload({\n            version: DB_VERSION,\n            payload: InterchainBatchLib.encodeBatch(batch)\n        });\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getBatchRoot(InterchainEntry memory entry, bytes32[] calldata proof) external pure returns (bytes32) {\n        return BatchingV1Lib.getBatchRoot({\n            srcWriter: entry.srcWriter,\n            dataHash: entry.dataHash,\n            entryIndex: entry.entryIndex,\n            proof: proof\n        });\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getBatchSize(uint64 dbNonce) public view returns (uint64) {\n        // In \"no batching\" mode: the finalized batch size is 1, the pending batch size is 0\n        // We also return 0 for non-existent batches\n        return dbNonce \u003c getDBNonce() ? 1 : 0;\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getBatch(uint64 dbNonce) public view returns (InterchainBatch memory) {\n        // In \"no batching\" mode: the batch root is the same as the entry hash.\n        // For non-finalized or non-existent batches, the batch root is 0.\n        bytes32 batchRoot = dbNonce \u003c getDBNonce() ? getEntryValue(dbNonce, 0) : bytes32(0);\n        return InterchainBatchLib.constructLocalBatch(dbNonce, batchRoot);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getEntryValue(uint64 dbNonce, uint64 entryIndex) public view returns (bytes32) {\n        _assertEntryExists(dbNonce, entryIndex);\n        return _entryValues[dbNonce];\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getDBNonce() public view returns (uint64) {\n        // We can do the unsafe cast here as writing more than 2^64 entries is practically impossible\n        return uint64(_entryValues.length);\n    }\n\n    //  INTERNAL LOGIC \n\n    /// @dev Write the entry to the database and emit the event.\n    function _writeEntry(bytes32 dataHash) internal returns (InterchainEntry memory entry) {\n        uint64 dbNonce = getDBNonce();\n        entry = InterchainEntryLib.constructLocalEntry({\n            dbNonce: dbNonce,\n            entryIndex: 0,\n            writer: msg.sender,\n            dataHash: dataHash\n        });\n        bytes32 entryValue = entry.entryValue();\n        _entryValues.push(entryValue);\n        emit InterchainEntryWritten({\n            dbNonce: dbNonce,\n            entryIndex: 0,\n            srcWriter: TypeCasts.addressToBytes32(msg.sender),\n            dataHash: dataHash\n        });\n        // In the InterchainDB V1 the batch is finalized immediately after the entry is written\n        emit InterchainBatchFinalized({dbNonce: dbNonce, batchRoot: entryValue});\n    }\n\n    /// @dev Request the verification of the entry by the modules, and emit the event.\n    /// Note: the validity of the passed entry and chain id being remote is enforced in the calling function.\n    function _requestVerification(\n        uint64 dstChainId,\n        InterchainBatch memory batch,\n        address[] calldata srcModules\n    )\n        internal\n    {\n        (uint256[] memory fees, uint256 totalFee) = _getModuleFees(dstChainId, batch.dbNonce, srcModules);\n        if (msg.value \u003c totalFee) {\n            revert InterchainDB__FeeAmountBelowMin(msg.value, totalFee);\n        } else if (msg.value \u003e totalFee) {\n            // The exceeding amount goes to the first module\n            fees[0] += msg.value - totalFee;\n        }\n        uint256 len = srcModules.length;\n        bytes memory versionedBatch = VersionedPayloadLib.encodeVersionedPayload({\n            version: DB_VERSION,\n            payload: InterchainBatchLib.encodeBatch(batch)\n        });\n        for (uint256 i = 0; i \u003c len; ++i) {\n            IInterchainModule(srcModules[i]).requestBatchVerification{value: fees[i]}(\n                dstChainId, batch.dbNonce, versionedBatch\n            );\n        }\n        emit InterchainBatchVerificationRequested(dstChainId, batch.dbNonce, batch.batchRoot, srcModules);\n    }\n\n    /// @dev Save the verified batch to the database and emit the event.\n    function _saveVerifiedBatch(address module, BatchKey batchKey, InterchainBatch memory batch) internal {\n        _remoteBatches[module][batchKey] = RemoteBatch({verifiedAt: block.timestamp, batchRoot: batch.batchRoot});\n        emit InterchainBatchVerified(module, batch.srcChainId, batch.dbNonce, batch.batchRoot);\n    }\n\n    //  INTERNAL VIEWS \n\n    /// @dev Asserts that the batch version is correct and that batch originates from a remote chain.\n    /// Note: returns the decoded batch for chaining purposes.\n    function _assertCorrectBatch(bytes calldata versionedBatch) internal view returns (InterchainBatch memory batch) {\n        uint16 dbVersion = versionedBatch.getVersion();\n        if (dbVersion != DB_VERSION) {\n            revert InterchainDB__BatchVersionMismatch(dbVersion, DB_VERSION);\n        }\n        batch = InterchainBatchLib.decodeBatch(versionedBatch.getPayload());\n        if (batch.srcChainId == block.chainid) {\n            revert InterchainDB__ChainIdNotRemote(batch.srcChainId);\n        }\n    }\n\n    /// @dev Check that the entry index is within the batch size. Also checks that the batch exists.\n    function _assertEntryExists(uint64 dbNonce, uint64 entryIndex) internal view {\n        // This will revert if the batch does not exist\n        uint64 batchSize = getBatchSize(dbNonce);\n        if (entryIndex \u003e= batchSize) {\n            revert InterchainDB__EntryIndexOutOfRange(dbNonce, entryIndex, batchSize);\n        }\n    }\n\n    /// @dev Get the verification fees for the modules\n    function _getModuleFees(\n        uint64 dstChainId,\n        uint64 dbNonce,\n        address[] calldata srcModules\n    )\n        internal\n        view\n        returns (uint256[] memory fees, uint256 totalFee)\n    {\n        uint256 len = srcModules.length;\n        if (len == 0) {\n            revert InterchainDB__ModulesNotProvided();\n        }\n        fees = new uint256[](len);\n        for (uint256 i = 0; i \u003c len; ++i) {\n            fees[i] = IInterchainModule(srcModules[i]).getModuleFee(dstChainId, dbNonce);\n            totalFee += fees[i];\n        }\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"3801:280:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;3801:280:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"3801:280:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainDB.sol\":\"TypeCasts\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainDB.sol\":{\"keccak256\":\"0x4dd7dd2bde0a2d89cb06f57f8772f18d4b0547c65abb43503e5fc2dedf60ac3e\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://e22ed31c26dd9174d0f333bf9d8d5916d407c0c99aa908c56a6c4156756a5e1e\",\"dweb:/ipfs/QmTi96nhB9Vr3SRq9qa24zbPvctFSNubneRuohgndhAqHK\"]}},\"version\":1}"},"hashes":{}},"solidity/InterchainDB.sol:VersionedPayloadLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220e512ea18ea133d65b68e9660035a5faf448e277a3922b9af8426a62c954149e864736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220e512ea18ea133d65b68e9660035a5faf448e277a3922b9af8426a62c954149e864736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainDBEvents.sol\n\nabstract contract InterchainDBEvents {\n    /// @notice Emitted when a local entry is written to the database.\n    /// @param dbNonce      The nonce of the batch containing the entry.\n    /// @param entryIndex   The index of the entry within the batch.\n    /// @param srcWriter    The address of the writer.\n    /// @param dataHash     The written data hash.\n    event InterchainEntryWritten(\n        uint64 indexed dbNonce, uint64 entryIndex, bytes32 indexed srcWriter, bytes32 dataHash\n    );\n\n    /// @notice Emitted when a local batch is finalized.\n    /// @param dbNonce      The nonce of the finalized batch.\n    /// @param batchRoot    The Merkle root hash of the finalized batch.\n    event InterchainBatchFinalized(uint64 indexed dbNonce, bytes32 batchRoot);\n\n    /// @notice Emitted when a remote batch is verified by the Interchain Module.\n    /// @param module       The address of the Interchain Module that verified the batch.\n    /// @param srcChainId   The ID of the source chain.\n    /// @param dbNonce      The nonce of the verified batch.\n    /// @param batchRoot    The Merkle root hash of the verified batch.\n    event InterchainBatchVerified(\n        address indexed module, uint64 indexed srcChainId, uint64 indexed dbNonce, bytes32 batchRoot\n    );\n\n    /// @notice Emitted when a local batch is requested to be verified on a remote chain\n    /// using the set of Interchain Modules.\n    /// @param dstChainId   The ID of the destination chain.\n    /// @param dbNonce      The nonce of the batch to be verified.\n    /// @param batchRoot    The Merkle root hash of the batch to be verified.\n    /// @param srcModules   The addresses of the Interchain Modules that will verify the batch.\n    event InterchainBatchVerificationRequested(\n        uint64 indexed dstChainId, uint64 indexed dbNonce, bytes32 batchRoot, address[] srcModules\n    );\n}\n\n// contracts/interfaces/IInterchainModule.sol\n\n/// @notice Every Module may opt a different method to confirm the verified entries on destination chain,\n/// therefore this is not a part of a common interface.\ninterface IInterchainModule {\n    error InterchainModule__CallerNotInterchainDB(address caller);\n    error InterchainModule__ChainIdNotRemote(uint64 chainId);\n    error InterchainModule__FeeAmountBelowMin(uint256 feeAmount, uint256 minRequired);\n\n    /// @notice Request the verification of a batch from the Interchain DataBase by the module.\n    /// If the batch is not yet finalized, the verification on destination chain will be delayed until\n    /// the finalization is done and batch root is saved on the source chain.\n    /// Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`.\n    /// Note: this will eventually trigger `InterchainDB.verifyRemoteBatch(batch)` function on destination chain,\n    /// with no guarantee of ordering.\n    /// @dev Could be only called by the Interchain DataBase contract.\n    /// @param dstChainId       The chain id of the destination chain\n    /// @param batchNonce       The nonce of the batch on the source chain\n    /// @param versionedBatch   The versioned batch to verify\n    function requestBatchVerification(\n        uint64 dstChainId,\n        uint64 batchNonce,\n        bytes memory versionedBatch\n    )\n        external\n        payable;\n\n    /// @notice Get the Module fee for verifying a batch on the specified destination chain.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dbNonce      The database nonce of the batch on the source chain\n    function getModuleFee(uint64 dstChainId, uint64 dbNonce) external view returns (uint256);\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/VersionedPayload.sol\n\n// solhint-disable no-inline-assembly\n// solhint-disable ordering\nlibrary VersionedPayloadLib {\n    /// @notice Amount of bytes reserved for the version (uint16) in the versioned payload\n    uint256 internal constant VERSION_LENGTH = 2;\n\n    error VersionedPayload__PayloadTooShort(bytes versionedPayload);\n    error VersionedPayload__PrecompileFailed();\n\n    /// @notice Encodes the versioned payload into a single bytes array.\n    /// @param version  The payload's version.\n    /// @param payload  The payload to encode.\n    function encodeVersionedPayload(uint16 version, bytes memory payload) internal pure returns (bytes memory) {\n        return abi.encodePacked(version, payload);\n    }\n\n    /// @notice Extracts the version from the versioned payload (calldata reference).\n    /// @param versionedPayload     The versioned payload (calldata reference).\n    function getVersion(bytes calldata versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__PayloadTooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            version := shr(240, calldataload(versionedPayload.offset))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (calldata reference).\n    /// @dev The extracted payload is also returned as a calldata reference.\n    /// @param versionedPayload     The versioned payload.\n    function getPayload(bytes calldata versionedPayload) internal pure returns (bytes calldata) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__PayloadTooShort(versionedPayload);\n        }\n        return versionedPayload[VERSION_LENGTH:];\n    }\n\n    /// @notice Extracts the version from the versioned payload (memory reference).\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getVersionFromMemory(bytes memory versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__PayloadTooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            // We add 0x20 to skip the length of the bytes array.\n            version := shr(240, mload(add(versionedPayload, 0x20)))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (memory reference).\n    /// @dev The extracted payload is copied into a new memory location. Use `getPayload` when possible\n    /// to avoid extra memory allocation.\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getPayloadFromMemory(bytes memory versionedPayload) internal view returns (bytes memory payload) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__PayloadTooShort(versionedPayload);\n        }\n        // Figure how many bytes to copy and allocate the memory for the extracted payload.\n        uint256 toCopy;\n        unchecked {\n            toCopy = versionedPayload.length - VERSION_LENGTH;\n        }\n        payload = new bytes(toCopy);\n        // Use identity precompile (0x04) to copy the payload. Unlike MCOPY, this is available on all EVM chains.\n        bool res;\n        assembly {\n            // We add 0x20 to skip the length of the bytes array.\n            // We add 0x02 to skip the 2 bytes reserved for the version.\n            // Copy the payload to the previously allocated memory.\n            res := staticcall(gas(), 0x04, add(versionedPayload, 0x22), toCopy, add(payload, 0x20), toCopy)\n        }\n        if (!res) {\n            revert VersionedPayload__PrecompileFailed();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SafeCast.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value \u003e type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value \u003e type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value \u003e type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value \u003e type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value \u003e type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value \u003e type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value \u003e type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value \u003e type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value \u003e type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value \u003e type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value \u003e type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value \u003e type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value \u003e type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value \u003e type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value \u003e type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value \u003e type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value \u003e type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value \u003e type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value \u003e type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value \u003e type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value \u003e type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value \u003e type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value \u003e type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value \u003e type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value \u003e type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value \u003e type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value \u003e type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value \u003e type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value \u003e type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value \u003e type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value \u003e type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value \u003c 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value \u003e uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n}\n\n// contracts/libs/InterchainBatch.sol\n\ntype BatchKey is uint128;\n\n/// @notice Struct representing a batch of entries in the Interchain DataBase.\n/// Batched entries are put together in a Merkle tree, which root is saved.\n/// Batch has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: batchRoot\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch\n/// @param batchRoot    The root of the Merkle tree containing the batched entries\nstruct InterchainBatch {\n    uint64 srcChainId;\n    uint64 dbNonce;\n    bytes32 batchRoot;\n}\n\n/// @dev Signals that the module has not verified any batch with the given key.\nuint256 constant BATCH_UNVERIFIED = 0;\n/// @dev Signals that the module has verified a conflicting batch with the given key.\nuint256 constant BATCH_CONFLICT = type(uint256).max;\n\nlibrary InterchainBatchLib {\n    using VersionedPayloadLib for bytes;\n\n    /// @notice Constructs an InterchainBatch struct to be saved on the local chain.\n    /// @param dbNonce      The database nonce of the batch\n    /// @param batchRoot    The root of the Merkle tree containing the batched entries\n    /// @return batch       The constructed InterchainBatch struct\n    function constructLocalBatch(\n        uint64 dbNonce,\n        bytes32 batchRoot\n    )\n        internal\n        view\n        returns (InterchainBatch memory batch)\n    {\n        return InterchainBatch({srcChainId: SafeCast.toUint64(block.chainid), dbNonce: dbNonce, batchRoot: batchRoot});\n    }\n\n    /// @notice Encodes the InterchainBatch struct into a non-versioned batch payload.\n    function encodeBatch(InterchainBatch memory batch) internal pure returns (bytes memory) {\n        return abi.encode(encodeBatchKey(batch.srcChainId, batch.dbNonce), batch.batchRoot);\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in calldata.\n    function decodeBatch(bytes calldata data) internal pure returns (InterchainBatch memory batch) {\n        BatchKey key;\n        (key, batch.batchRoot) = abi.decode(data, (BatchKey, bytes32));\n        (batch.srcChainId, batch.dbNonce) = decodeBatchKey(key);\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in memory.\n    function decodeBatchFromMemory(bytes memory data) internal pure returns (InterchainBatch memory batch) {\n        BatchKey key;\n        (key, batch.batchRoot) = abi.decode(data, (BatchKey, bytes32));\n        (batch.srcChainId, batch.dbNonce) = decodeBatchKey(key);\n    }\n\n    /// @notice Encodes the uint128 key of the batch from uint64 srcChainId and uint64 dbNonce.\n    function encodeBatchKey(uint64 srcChainId, uint64 dbNonce) internal pure returns (BatchKey) {\n        return BatchKey.wrap((uint128(srcChainId) \u003c\u003c 64) | dbNonce);\n    }\n\n    /// @notice Decodes the uint128 key of the batch into uint64 srcChainId and uint64 dbNonce.\n    function decodeBatchKey(BatchKey key) internal pure returns (uint64 srcChainId, uint64 dbNonce) {\n        srcChainId = uint64(BatchKey.unwrap(key) \u003e\u003e 64);\n        dbNonce = uint64(BatchKey.unwrap(key));\n    }\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce + entryIndex\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch containing the entry\n/// @param entryIndex   The index of the entry in the batch\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint64 srcChainId;\n    uint64 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nusing InterchainEntryLib for InterchainEntry global;\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint64 dbNonce,\n        uint64 entryIndex,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: SafeCast.toUint64(block.chainid),\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return getEntryValue(entry.srcWriter, entry.dataHash);\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function getEntryValue(bytes32 srcWriter, bytes32 dataHash) internal pure returns (bytes32) {\n        return keccak256(abi.encode(srcWriter, dataHash));\n    }\n}\n\n// contracts/libs/BatchingV1.sol\n\nlibrary BatchingV1Lib {\n    error BatchingV1__EntryIndexNotZero(uint64 entryIndex);\n    error BatchingV1__ProofNotEmpty();\n\n    /// @notice Get the batch root containing the Interchain Entry with the given index.\n    /// @param srcWriter    The entry writer of the source chain\n    /// @param dataHash     The hash of the data of the entry\n    /// @param entryIndex   The index of the entry in the batch\n    /// @param proof        The Merkle proof of inclusion for the entry in the batch\n    /// @return batchRoot   The root of the batch containing the entry\n    function getBatchRoot(\n        bytes32 srcWriter,\n        bytes32 dataHash,\n        uint64 entryIndex,\n        bytes32[] calldata proof\n    )\n        internal\n        pure\n        returns (bytes32 batchRoot)\n    {\n        // In \"no batching\" mode: entry index is 0, proof is empty\n        if (entryIndex != 0) {\n            revert BatchingV1__EntryIndexNotZero(entryIndex);\n        }\n        if (proof.length != 0) {\n            revert BatchingV1__ProofNotEmpty();\n        }\n        // In \"no batching\" mode: the batch root is the same as the entry value\n        return InterchainEntryLib.getEntryValue({srcWriter: srcWriter, dataHash: dataHash});\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    error InterchainDB__BatchConflict(address module, bytes32 existingBatchRoot, InterchainBatch newBatch);\n    error InterchainDB__BatchVersionMismatch(uint16 version, uint16 required);\n    error InterchainDB__ChainIdNotRemote(uint64 chainId);\n    error InterchainDB__EntryIndexOutOfRange(uint64 dbNonce, uint64 entryIndex, uint64 batchSize);\n    error InterchainDB__EntryRangeInvalid(uint64 dbNonce, uint64 start, uint64 end);\n    error InterchainDB__FeeAmountBelowMin(uint256 feeAmount, uint256 minRequired);\n    error InterchainDB__ModulesNotProvided();\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `requestBatchVerification` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntry(bytes32 dataHash) external returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Request the given Interchain Modules to verify an existing batch.\n    /// If the batch is not finalized, the module will verify it after finalization.\n    /// For the finalized batch the batch root is already available, and the module can verify it immediately.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any batch.\n    /// @dev Will revert if the batch with the given nonce does not exist.\n    /// @param dstChainId    The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the existing batch\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestBatchVerification(\n        uint64 dstChainId,\n        uint64 dbNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Then request the Interchain Modules to verify the batch containing the written entry on the destination chain.\n    /// See `writeEntry` and `requestBatchVerification` for more details.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntryWithVerification(\n        uint64 dstChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Allows the Interchain Module to verify the batch coming from the remote chain.\n    /// The module SHOULD verify the exact finalized batch from the remote chain. If the batch with a given nonce\n    /// is not finalized or does not exist, module CAN verify it with an empty root value. Once the batch is\n    /// finalized, the module SHOULD re-verify the batch with the correct root value.\n    /// Note: The DB will only accept the batch of the same version as the DB itself.\n    /// @dev Will revert if the batch with the same nonce but a different non-empty root is already verified.\n    /// @param versionedBatch   The versioned Interchain Batch to verify\n    function verifyRemoteBatch(bytes memory versionedBatch) external;\n\n    //  VIEWS \n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint64 dstChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce.\n    /// Note: the leafs are ordered by the index of the written entry in the current batch,\n    /// and the leafs value match the value of the written entry (srcWriter + dataHash hashed together).\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchLeafs(uint64 dbNonce) external view returns (bytes32[] memory);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce,\n    /// paginated by the given start and end indexes. The end index is exclusive.\n    /// Note: this is useful when the batch contains a large number of leafs, and calling `getBatchLeafs`\n    /// would result in a gas limit exceeded error.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the provided range is invalid.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param start        The start index of the paginated leafs, inclusive\n    /// @param end          The end index of the paginated leafs, exclusive\n    function getBatchLeafsPaginated(\n        uint64 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory);\n\n    /// @notice Returns the size of the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchSize(uint64 dbNonce) external view returns (uint64);\n\n    /// @notice Get the finalized Interchain Batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatch(uint64 dbNonce) external view returns (InterchainBatch memory);\n\n    /// @notice Get the versioned Interchain Batch with the given nonce.\n    /// Note: will return a batch with an empty root if the batch does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the batch\n    function getVersionedBatch(uint64 dbNonce) external view returns (bytes memory);\n\n    /// @notice Get the Interchain Entry's value written on the local chain with the given batch nonce and entry index.\n    /// Entry value is calculated as the hash of the writer address and the written data hash.\n    /// Note: the batch does not have to be finalized to fetch the entry value.\n    /// @dev Will revert if the batch with the given nonce does not exist,\n    /// or the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the existing batch\n    /// @param entryIndex   The index of the written entry within the batch\n    function getEntryValue(uint64 dbNonce, uint64 entryIndex) external view returns (bytes32);\n\n    /// @notice Get the Merkle proof of inclusion for the entry with the given index\n    /// in the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param entryIndex   The index of the written entry within the batch\n    /// @return proof       The Merkle proof of inclusion for the entry\n    function getEntryProof(uint64 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof);\n\n    /// @notice Get the nonce of the database, which is incremented every time a new batch is finalized.\n    /// This is the nonce of the current non-finalized batch.\n    function getDBNonce() external view returns (uint64);\n\n    /// @notice Get the index of the next entry to be written to the database.\n    /// @return dbNonce      The database nonce of the batch including the next entry\n    /// @return entryIndex   The index of the next entry within that batch\n    function getNextEntryIndex() external view returns (uint64 dbNonce, uint64 entryIndex);\n\n    /// @notice Check if the batch is verified by the Interchain Module on the destination chain.\n    /// Note: returned zero value indicates that the module has not verified the batch.\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @param batch        The Interchain Batch to check\n    /// @return moduleVerifiedAt    The block timestamp at which the batch was verified by the module,\n    ///                             or ZERO if the module has not verified the batch.\n    function checkBatchVerification(\n        address dstModule,\n        InterchainBatch memory batch\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n\n    /// @notice Get the batch root containing the Interchain Entry with the given index.\n    /// @param entry         The Interchain Entry to get the batch root for\n    /// @param proof         The Merkle proof of inclusion for the entry in the batch\n    function getBatchRoot(InterchainEntry memory entry, bytes32[] memory proof) external pure returns (bytes32);\n\n    /// @notice Get the version of the Interchain DataBase.\n    // solhint-disable-next-line func-name-mixedcase\n    function DB_VERSION() external pure returns (uint16);\n}\n\n// contracts/InterchainDB.sol\n\ncontract InterchainDB is InterchainDBEvents, IInterchainDB {\n    using VersionedPayloadLib for bytes;\n\n    /// @notice Struct representing a batch of entries from the remote Interchain DataBase,\n    /// verified by the Interchain Module.\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param batchRoot    The Merkle root of the batch\n    struct RemoteBatch {\n        uint256 verifiedAt;\n        bytes32 batchRoot;\n    }\n\n    uint16 public constant DB_VERSION = 1;\n\n    bytes32[] internal _entryValues;\n    mapping(address module =\u003e mapping(BatchKey batchKey =\u003e RemoteBatch batch)) internal _remoteBatches;\n\n    modifier onlyRemoteChainId(uint64 chainId) {\n        if (chainId == block.chainid) {\n            revert InterchainDB__ChainIdNotRemote(chainId);\n        }\n        _;\n    }\n\n    //  WRITER-FACING \n\n    /// @inheritdoc IInterchainDB\n    function writeEntry(bytes32 dataHash) external returns (uint64 dbNonce, uint64 entryIndex) {\n        InterchainEntry memory entry = _writeEntry(dataHash);\n        (dbNonce, entryIndex) = (entry.dbNonce, entry.entryIndex);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function requestBatchVerification(\n        uint64 dstChainId,\n        uint64 dbNonce,\n        address[] calldata srcModules\n    )\n        external\n        payable\n        onlyRemoteChainId(dstChainId)\n    {\n        InterchainBatch memory batch = getBatch(dbNonce);\n        _requestVerification(dstChainId, batch, srcModules);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function writeEntryWithVerification(\n        uint64 dstChainId,\n        bytes32 dataHash,\n        address[] calldata srcModules\n    )\n        external\n        payable\n        onlyRemoteChainId(dstChainId)\n        returns (uint64 dbNonce, uint64 entryIndex)\n    {\n        InterchainEntry memory entry = _writeEntry(dataHash);\n        (dbNonce, entryIndex) = (entry.dbNonce, entry.entryIndex);\n        // In \"no batching\" mode: the batch root is the same as the entry value\n        InterchainBatch memory batch = InterchainBatchLib.constructLocalBatch(dbNonce, entry.entryValue());\n        _requestVerification(dstChainId, batch, srcModules);\n    }\n\n    //  MODULE-FACING \n\n    /// @inheritdoc IInterchainDB\n    function verifyRemoteBatch(bytes calldata versionedBatch) external {\n        InterchainBatch memory batch = _assertCorrectBatch(versionedBatch);\n        BatchKey batchKey = InterchainBatchLib.encodeBatchKey({srcChainId: batch.srcChainId, dbNonce: batch.dbNonce});\n        RemoteBatch memory existingBatch = _remoteBatches[msg.sender][batchKey];\n        // Check if that's the first time module verifies the batch\n        if (existingBatch.verifiedAt == 0) {\n            _saveVerifiedBatch(msg.sender, batchKey, batch);\n            return;\n        }\n        // No-op if the batch root is the same\n        if (existingBatch.batchRoot == batch.batchRoot) {\n            return;\n        }\n        // Overwriting an empty (non-existent) batch with a different one is allowed\n        if (existingBatch.batchRoot == 0) {\n            _saveVerifiedBatch(msg.sender, batchKey, batch);\n            return;\n        }\n        // Overwriting an existing batch with a different one is not allowed\n        revert InterchainDB__BatchConflict(msg.sender, existingBatch.batchRoot, batch);\n    }\n\n    //  VIEWS \n\n    /// @inheritdoc IInterchainDB\n    function getBatchLeafs(uint64 dbNonce) external view returns (bytes32[] memory leafs) {\n        uint256 batchSize = getBatchSize(dbNonce);\n        leafs = new bytes32[](batchSize);\n        for (uint64 i = 0; i \u003c batchSize; ++i) {\n            leafs[i] = getEntryValue(dbNonce, i);\n        }\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getBatchLeafsPaginated(\n        uint64 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory leafs)\n    {\n        uint256 size = getBatchSize(dbNonce);\n        if (start \u003e end || end \u003e size) {\n            revert InterchainDB__EntryRangeInvalid(dbNonce, start, end);\n        }\n        leafs = new bytes32[](end - start);\n        for (uint64 i = start; i \u003c end; ++i) {\n            leafs[i - start] = getEntryValue(dbNonce, i);\n        }\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getEntryProof(uint64 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof) {\n        // In \"no batching\" mode: the batch root is the same as the entry value, hence the proof is empty\n        _assertEntryExists(dbNonce, entryIndex);\n        return new bytes32[](0);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getInterchainFee(uint64 dstChainId, address[] calldata srcModules) external view returns (uint256 fee) {\n        (, fee) = _getModuleFees(dstChainId, getDBNonce(), srcModules);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getNextEntryIndex() external view returns (uint64 dbNonce, uint64 entryIndex) {\n        // In \"no batching\" mode: entry index is 0, batch size is 1\n        dbNonce = getDBNonce();\n        entryIndex = 0;\n    }\n\n    /// @inheritdoc IInterchainDB\n    function checkBatchVerification(\n        address dstModule,\n        InterchainBatch memory batch\n    )\n        external\n        view\n        onlyRemoteChainId(batch.srcChainId)\n        returns (uint256 moduleVerifiedAt)\n    {\n        BatchKey batchKey = InterchainBatchLib.encodeBatchKey({srcChainId: batch.srcChainId, dbNonce: batch.dbNonce});\n        RemoteBatch memory remoteBatch = _remoteBatches[dstModule][batchKey];\n        // Check if module verified anything for this batch key first\n        if (remoteBatch.verifiedAt == 0) {\n            return BATCH_UNVERIFIED;\n        }\n        // Check if the batch root matches the one verified by the module\n        return remoteBatch.batchRoot == batch.batchRoot ? remoteBatch.verifiedAt : BATCH_CONFLICT;\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getVersionedBatch(uint64 dbNonce) external view returns (bytes memory versionedBatch) {\n        InterchainBatch memory batch = getBatch(dbNonce);\n        return VersionedPayloadLib.encodeVersionedPayload({\n            version: DB_VERSION,\n            payload: InterchainBatchLib.encodeBatch(batch)\n        });\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getBatchRoot(InterchainEntry memory entry, bytes32[] calldata proof) external pure returns (bytes32) {\n        return BatchingV1Lib.getBatchRoot({\n            srcWriter: entry.srcWriter,\n            dataHash: entry.dataHash,\n            entryIndex: entry.entryIndex,\n            proof: proof\n        });\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getBatchSize(uint64 dbNonce) public view returns (uint64) {\n        // In \"no batching\" mode: the finalized batch size is 1, the pending batch size is 0\n        // We also return 0 for non-existent batches\n        return dbNonce \u003c getDBNonce() ? 1 : 0;\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getBatch(uint64 dbNonce) public view returns (InterchainBatch memory) {\n        // In \"no batching\" mode: the batch root is the same as the entry hash.\n        // For non-finalized or non-existent batches, the batch root is 0.\n        bytes32 batchRoot = dbNonce \u003c getDBNonce() ? getEntryValue(dbNonce, 0) : bytes32(0);\n        return InterchainBatchLib.constructLocalBatch(dbNonce, batchRoot);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getEntryValue(uint64 dbNonce, uint64 entryIndex) public view returns (bytes32) {\n        _assertEntryExists(dbNonce, entryIndex);\n        return _entryValues[dbNonce];\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getDBNonce() public view returns (uint64) {\n        // We can do the unsafe cast here as writing more than 2^64 entries is practically impossible\n        return uint64(_entryValues.length);\n    }\n\n    //  INTERNAL LOGIC \n\n    /// @dev Write the entry to the database and emit the event.\n    function _writeEntry(bytes32 dataHash) internal returns (InterchainEntry memory entry) {\n        uint64 dbNonce = getDBNonce();\n        entry = InterchainEntryLib.constructLocalEntry({\n            dbNonce: dbNonce,\n            entryIndex: 0,\n            writer: msg.sender,\n            dataHash: dataHash\n        });\n        bytes32 entryValue = entry.entryValue();\n        _entryValues.push(entryValue);\n        emit InterchainEntryWritten({\n            dbNonce: dbNonce,\n            entryIndex: 0,\n            srcWriter: TypeCasts.addressToBytes32(msg.sender),\n            dataHash: dataHash\n        });\n        // In the InterchainDB V1 the batch is finalized immediately after the entry is written\n        emit InterchainBatchFinalized({dbNonce: dbNonce, batchRoot: entryValue});\n    }\n\n    /// @dev Request the verification of the entry by the modules, and emit the event.\n    /// Note: the validity of the passed entry and chain id being remote is enforced in the calling function.\n    function _requestVerification(\n        uint64 dstChainId,\n        InterchainBatch memory batch,\n        address[] calldata srcModules\n    )\n        internal\n    {\n        (uint256[] memory fees, uint256 totalFee) = _getModuleFees(dstChainId, batch.dbNonce, srcModules);\n        if (msg.value \u003c totalFee) {\n            revert InterchainDB__FeeAmountBelowMin(msg.value, totalFee);\n        } else if (msg.value \u003e totalFee) {\n            // The exceeding amount goes to the first module\n            fees[0] += msg.value - totalFee;\n        }\n        uint256 len = srcModules.length;\n        bytes memory versionedBatch = VersionedPayloadLib.encodeVersionedPayload({\n            version: DB_VERSION,\n            payload: InterchainBatchLib.encodeBatch(batch)\n        });\n        for (uint256 i = 0; i \u003c len; ++i) {\n            IInterchainModule(srcModules[i]).requestBatchVerification{value: fees[i]}(\n                dstChainId, batch.dbNonce, versionedBatch\n            );\n        }\n        emit InterchainBatchVerificationRequested(dstChainId, batch.dbNonce, batch.batchRoot, srcModules);\n    }\n\n    /// @dev Save the verified batch to the database and emit the event.\n    function _saveVerifiedBatch(address module, BatchKey batchKey, InterchainBatch memory batch) internal {\n        _remoteBatches[module][batchKey] = RemoteBatch({verifiedAt: block.timestamp, batchRoot: batch.batchRoot});\n        emit InterchainBatchVerified(module, batch.srcChainId, batch.dbNonce, batch.batchRoot);\n    }\n\n    //  INTERNAL VIEWS \n\n    /// @dev Asserts that the batch version is correct and that batch originates from a remote chain.\n    /// Note: returns the decoded batch for chaining purposes.\n    function _assertCorrectBatch(bytes calldata versionedBatch) internal view returns (InterchainBatch memory batch) {\n        uint16 dbVersion = versionedBatch.getVersion();\n        if (dbVersion != DB_VERSION) {\n            revert InterchainDB__BatchVersionMismatch(dbVersion, DB_VERSION);\n        }\n        batch = InterchainBatchLib.decodeBatch(versionedBatch.getPayload());\n        if (batch.srcChainId == block.chainid) {\n            revert InterchainDB__ChainIdNotRemote(batch.srcChainId);\n        }\n    }\n\n    /// @dev Check that the entry index is within the batch size. Also checks that the batch exists.\n    function _assertEntryExists(uint64 dbNonce, uint64 entryIndex) internal view {\n        // This will revert if the batch does not exist\n        uint64 batchSize = getBatchSize(dbNonce);\n        if (entryIndex \u003e= batchSize) {\n            revert InterchainDB__EntryIndexOutOfRange(dbNonce, entryIndex, batchSize);\n        }\n    }\n\n    /// @dev Get the verification fees for the modules\n    function _getModuleFees(\n        uint64 dstChainId,\n        uint64 dbNonce,\n        address[] calldata srcModules\n    )\n        internal\n        view\n        returns (uint256[] memory fees, uint256 totalFee)\n    {\n        uint256 len = srcModules.length;\n        if (len == 0) {\n            revert InterchainDB__ModulesNotProvided();\n        }\n        fees = new uint256[](len);\n        for (uint256 i = 0; i \u003c len; ++i) {\n            fees[i] = IInterchainModule(srcModules[i]).getModuleFee(dstChainId, dbNonce);\n            totalFee += fees[i];\n        }\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"4189:3792:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;4189:3792:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"4189:3792:0:-:0;;;;;;;;","abiDefinition":[{"inputs":[{"internalType":"bytes","name":"versionedPayload","type":"bytes"}],"name":"VersionedPayload__PayloadTooShort","type":"error"},{"inputs":[],"name":"VersionedPayload__PrecompileFailed","type":"error"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"versionedPayload\",\"type\":\"bytes\"}],\"name\":\"VersionedPayload__PayloadTooShort\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VersionedPayload__PrecompileFailed\",\"type\":\"error\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainDB.sol\":\"VersionedPayloadLib\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainDB.sol\":{\"keccak256\":\"0x4dd7dd2bde0a2d89cb06f57f8772f18d4b0547c65abb43503e5fc2dedf60ac3e\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://e22ed31c26dd9174d0f333bf9d8d5916d407c0c99aa908c56a6c4156756a5e1e\",\"dweb:/ipfs/QmTi96nhB9Vr3SRq9qa24zbPvctFSNubneRuohgndhAqHK\"]}},\"version\":1}"},"hashes":{}}}