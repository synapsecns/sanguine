package exporters

import (
	"context"
	"math/big"

	"github.com/hedzr/log"
	"github.com/synapsecns/sanguine/core/metrics"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/metric"
)

//go:generate go run github.com/vburenin/ifacemaker -f otel.go -s otelRecorder -i iOtelRecorder -p exporters -o otel_generated.go -c "autogenerated file"
type otelRecorder struct {
	metrics metrics.Handler
	meter   metric.Meter

	// vprice stats
	vPrice float64

	// tokenBalance stats
	gasBalance    float64
	bridgeBalance float64
	feeBalance    float64
	totalSupply   float64

	// dfk stats
	stuckHeroes int64

	chainID int

	// sbumitter stats
	td      tokenData
	nonce   int64
	address string
	balance float64
	name    string

	// vprice
	vpriceGauge metric.Float64ObservableGauge

	// bridge
	gasBalanceGauge    metric.Float64ObservableGauge
	bridgeBalanceGauge metric.Float64ObservableGauge
	feeBalanceGauge    metric.Float64ObservableGauge
	totalSupplyGauge   metric.Float64ObservableGauge

	//submitter
	balanceGauge metric.Float64ObservableGauge
	nonceGauge   metric.Int64ObservableGauge
	// dfk
	stuckCount metric.Int64ObservableGauge
}

func newOtelRecorder(meterHandler metrics.Handler) iOtelRecorder {
	otr := otelRecorder{
		metrics: meterHandler,
		meter:   meterHandler.Meter(meterName),
	}
	// todo: make an option
	metricName := func(metricName string) string {
		return metricName
	}

	var err error
	if otr.vpriceGauge, err = otr.meter.Float64ObservableGauge(
		metricName("promexporter.vpriceGauge"),
		metric.WithDescription("vprice gauge"),
		metric.WithUnit("price")); err != nil {
		log.Warnf("failed to create gauge: %v", err)
	}

	if otr.bridgeBalanceGauge, err = otr.meter.Float64ObservableGauge(
		metricName("promexporter.bridgeBalanceGauge"),
		metric.WithDescription("bridge balance"),
		metric.WithUnit("eth")); err != nil {
		log.Warnf("failed to create gauge: %v", err)
	}

	if otr.feeBalanceGauge, err = otr.meter.Float64ObservableGauge(
		metricName("promexporter.feeBalanceGauage"),
		metric.WithDescription("fee balance gauge"),
		metric.WithUnit("gwei")); err != nil {
		log.Warnf("failed to create gauge: %v", err)
	}

	if otr.totalSupplyGauge, err = otr.meter.Float64ObservableGauge(
		metricName("promexporter.vpriceGauage"),
		metric.WithDescription("vprice gauge"),
		metric.WithUnit("virtual price")); err != nil {
		log.Warnf("failed to create gauge: %v", err)
	}

	if otr.gasBalanceGauge, err = otr.meter.Float64ObservableGauge(
		metricName("promexporter.gasBalance"),
		metric.WithDescription("vprice gauge"),
		metric.WithUnit("virtual price")); err != nil {
		log.Warnf("failed to create gauge: %v", err)
	}

	if otr.balanceGauge, err = otr.meter.Float64ObservableGauge(
		metricName("promexporter.balanceGauge"),
		metric.WithDescription("balance gauge"),
		metric.WithUnit("eth")); err != nil {
		log.Warnf("failed to create gauge: %v", err)
	}

	if otr.nonceGauge, err = otr.meter.Int64ObservableGauge(
		metricName("promexporter.nonceGauge"),
		metric.WithDescription("nonce gauge"),
		metric.WithUnit("nonce")); err != nil {
		log.Warnf("failed to create gauge: %v", err)
	}

	if otr.stuckCount, err = otr.meter.Int64ObservableGauge(
		metricName("promexporter.stuckCount"),
		metric.WithDescription("stuck count gauge"),
		metric.WithUnit("count")); err != nil {
		log.Warnf("failed to create gauge: %v", err)
	}

	// Register VPrice callback
	if _, err = otr.meter.RegisterCallback(
		otr.recordVpriceGauge,
		otr.vpriceGauge,
	); err != nil {
		log.Warnf("failed to register callback for vprice gauge: %v", err)
	}

	// Register DFK Stuck Heroes Callback
	if _, err = otr.meter.RegisterCallback(
		otr.recordStuckHeroCount,
		otr.stuckCount,
	); err != nil {
		log.Warnf("failed to register callback for gas balance gauge: %v", err)
	}

	// Register Token Balance Callback
	if _, err = otr.meter.RegisterCallback(
		otr.recordTokenBalance,
		otr.gasBalanceGauge,
		otr.bridgeBalanceGauge,
		otr.feeBalanceGauge,
		otr.totalSupplyGauge,
	); err != nil {
		log.Warnf("failed to register callback for gas balance gauge: %v", err)
	}

	// Register Submitter Stats Callback
	if _, err = otr.meter.RegisterCallback(
		otr.recordSubmitterStats,
		otr.balanceGauge,
		otr.nonceGauge,
	); err != nil {
		log.Warnf("failed to register callback for bridge balance gauge: %v", err)
	}

	// register callbacks
	return &otr
}

// Virtual Price Metrics
func (o *otelRecorder) RecordVPrice(vPrice float64) {
	o.vPrice = vPrice
}

func (o *otelRecorder) recordVpriceGauge(
	parentCtx context.Context,
	observer metric.Observer,
) (err error) {
	if o.metrics == nil || o.vpriceGauge == nil {
		return nil
	}

	observer.ObserveFloat64(
		o.vpriceGauge,
		o.vPrice,
		metric.WithAttributes(attribute.Int(metrics.ChainID, o.chainID)),
	)

	return nil
}

type tokenData struct {
	metadata        TokenConfig
	contractBalance *big.Int
	totalSuppply    *big.Int
	feeBalance      *big.Int
}

// Token Balance Metrics
func (o *otelRecorder) RecordTokenBalance(
	parentCtx context.Context,
	bridgeBalance float64,
	feeBalance float64,
	totalSupply float64,
	chainID int,
	tokenData []tokenData,
) (err error) {
	o.bridgeBalance = bridgeBalance
	o.feeBalance = feeBalance
	o.totalSupply = totalSupply
	return nil
}

func (o *otelRecorder) recordTokenBalance(
	parentCtx context.Context,
	observer metric.Observer,
) (err error) {

	tokenAttributes := attribute.NewSet(
		attribute.String("tokenID", o.td.metadata.TokenID),
		attribute.Int(metrics.ChainID, o.td.metadata.ChainID),
	)

	if o.metrics == nil || o.bridgeBalanceGauge == nil {
		return nil
	}

	observer.ObserveFloat64(
		o.gasBalanceGauge,
		o.gasBalance,
		metric.WithAttributes(attribute.Int(metrics.ChainID, o.chainID)),
	)

	observer.ObserveFloat64(
		o.bridgeBalanceGauge,
		o.bridgeBalance,
		metric.WithAttributeSet(tokenAttributes),
	)

	observer.ObserveFloat64(
		o.feeBalanceGauge,
		o.feeBalance,
		metric.WithAttributeSet(tokenAttributes),
	)

	observer.ObserveFloat64(
		o.totalSupplyGauge,
		o.totalSupply,
		metric.WithAttributeSet(tokenAttributes),
	)

	return nil

}

// DFK Metrics
func (o *otelRecorder) RecordStuckHeroCount(stuckHeroes int64) {
	o.stuckHeroes = stuckHeroes
}

func (o *otelRecorder) recordStuckHeroCount(
	_ context.Context,
	observer metric.Observer,
) (err error) {
	if o.metrics == nil || o.stuckCount == nil {
		return nil
	}

	observer.ObserveInt64(
		o.stuckCount,
		o.stuckHeroes,
		metric.WithAttributes(attribute.Int(metrics.ChainID, o.chainID)),
	)

	return nil
}

// Submitter stats
func (o *otelRecorder) RecordSubmitterStats(nonce int64, balance float64, gasCheckName string) {
	o.nonce = nonce
	o.balance = balance
	o.name = gasCheckName
}

func (o *otelRecorder) recordSubmitterStats(
	_ context.Context,
	observer metric.Observer,
) (err error) {
	if o.metrics == nil || o.nonceGauge == nil {
		return nil
	}

	observer.ObserveInt64(
		o.nonceGauge,
		o.nonce,
		metric.WithAttributes(attribute.Int(metrics.ChainID, o.chainID)),
	)

	observer.ObserveFloat64(
		o.balanceGauge,
		o.balance,
		metric.WithAttributes(
			attribute.Int(metrics.ChainID, o.chainID),
			attribute.String(metrics.EOAAddress, o.address),
			attribute.String("name", o.name),
		),
	)

	return nil
}
