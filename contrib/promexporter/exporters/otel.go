package exporters

import (
	"context"
	"math/big"

	"github.com/cornelk/hashmap"
	"github.com/hedzr/log"
	"github.com/synapsecns/sanguine/core/metrics"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/metric"
)

//go:generate go run github.com/vburenin/ifacemaker -f otel.go -s otelRecorder -i iOtelRecorder -p exporters -o otel_generated.go -c "autogenerated file"
type otelRecorder struct {
	metrics metrics.Handler
	meter   metric.Meter

	// vprice stats
	vPrice *hashmap.Map[int, float64]

	// tokenBalance stats
	gasBalance    *hashmap.Map[int, float64]
	bridgeBalance *hashmap.Map[int, float64]
	feeBalance    *hashmap.Map[int, float64]
	totalSupply   *hashmap.Map[int, float64]

	// dfk stats
	stuckHeroes int64

	// sbumitter stats
	td      *hashmap.Map[int, tokenData]
	nonce   *hashmap.Map[int, int64]
	balance *hashmap.Map[int, float64]
	name    *hashmap.Map[int, string]

	// vprice
	vpriceGauge metric.Float64ObservableGauge

	// bridge
	gasBalanceGauge    metric.Float64ObservableGauge
	bridgeBalanceGauge metric.Float64ObservableGauge
	feeBalanceGauge    metric.Float64ObservableGauge
	totalSupplyGauge   metric.Float64ObservableGauge

	//submitter
	balanceGauge metric.Float64ObservableGauge
	nonceGauge   metric.Int64ObservableGauge
	// dfk
	stuckCount metric.Int64ObservableGauge
}

func newOtelRecorder(meterHandler metrics.Handler) iOtelRecorder {
	otr := otelRecorder{
		metrics: meterHandler,
		meter:   meterHandler.Meter(meterName),
	}
	// todo: make an option
	metricName := func(metricName string) string {
		return metricName
	}

	var err error
	if otr.vpriceGauge, err = otr.meter.Float64ObservableGauge(
		metricName("promexporter.vpriceGauge"),
		metric.WithDescription("vprice gauge"),
		metric.WithUnit("price")); err != nil {
		log.Warnf("failed to create gauge: %v", err)
	}

	if otr.bridgeBalanceGauge, err = otr.meter.Float64ObservableGauge(
		metricName("promexporter.bridgeBalanceGauge"),
		metric.WithDescription("bridge balance"),
		metric.WithUnit("eth")); err != nil {
		log.Warnf("failed to create gauge: %v", err)
	}

	if otr.feeBalanceGauge, err = otr.meter.Float64ObservableGauge(
		metricName("promexporter.feeBalanceGauage"),
		metric.WithDescription("fee balance gauge"),
		metric.WithUnit("gwei")); err != nil {
		log.Warnf("failed to create gauge: %v", err)
	}

	if otr.totalSupplyGauge, err = otr.meter.Float64ObservableGauge(
		metricName("promexporter.vpriceGauage"),
		metric.WithDescription("vprice gauge"),
		metric.WithUnit("virtual price")); err != nil {
		log.Warnf("failed to create gauge: %v", err)
	}

	if otr.gasBalanceGauge, err = otr.meter.Float64ObservableGauge(
		metricName("promexporter.gasBalance"),
		metric.WithDescription("vprice gauge"),
		metric.WithUnit("virtual price")); err != nil {
		log.Warnf("failed to create gauge: %v", err)
	}

	if otr.balanceGauge, err = otr.meter.Float64ObservableGauge(
		metricName("promexporter.balanceGauge"),
		metric.WithDescription("balance gauge"),
		metric.WithUnit("eth")); err != nil {
		log.Warnf("failed to create gauge: %v", err)
	}

	if otr.nonceGauge, err = otr.meter.Int64ObservableGauge(
		metricName("promexporter.nonceGauge"),
		metric.WithDescription("nonce gauge"),
		metric.WithUnit("nonce")); err != nil {
		log.Warnf("failed to create gauge: %v", err)
	}

	if otr.stuckCount, err = otr.meter.Int64ObservableGauge(
		metricName("promexporter.stuckCount"),
		metric.WithDescription("stuck count gauge"),
		metric.WithUnit("count")); err != nil {
		log.Warnf("failed to create gauge: %v", err)
	}

	// Register VPrice callback
	if _, err = otr.meter.RegisterCallback(
		otr.recordVpriceGauge,
		otr.vpriceGauge,
	); err != nil {
		log.Warnf("failed to register callback for vprice gauge: %v", err)
	}

	// Register DFK Stuck Heroes Callback
	if _, err = otr.meter.RegisterCallback(
		otr.recordStuckHeroCount,
		otr.stuckCount,
	); err != nil {
		log.Warnf("failed to register callback for gas balance gauge: %v", err)
	}

	// Register Token Balance Callback
	if _, err = otr.meter.RegisterCallback(
		otr.recordTokenBalance,
		otr.gasBalanceGauge,
		otr.bridgeBalanceGauge,
		otr.feeBalanceGauge,
		otr.totalSupplyGauge,
	); err != nil {
		log.Warnf("failed to register callback for gas balance gauge: %v", err)
	}

	// Register Submitter Stats Callback
	if _, err = otr.meter.RegisterCallback(
		otr.recordSubmitterStats,
		otr.balanceGauge,
		otr.nonceGauge,
	); err != nil {
		log.Warnf("failed to register callback for bridge balance gauge: %v", err)
	}

	// register callbacks
	return &otr
}

// Virtual Price Metrics
func (o *otelRecorder) RecordVPrice(chainid int, vPrice float64) {
	o.vPrice.Set(chainid, vPrice)
}

func (o *otelRecorder) recordVpriceGauge(
	parentCtx context.Context,
	observer metric.Observer,
) (err error) {
	if o.metrics == nil || o.vpriceGauge == nil {
		return nil
	}

	o.vPrice.Range(
		func(chainid int, vprice float64) bool {
			observer.ObserveFloat64(
				o.vpriceGauge,
				vprice,
				metric.WithAttributes(attribute.Int(metrics.ChainID, chainid)),
			)

			return true
		},
	)

	return nil
}

type tokenData struct {
	metadata        TokenConfig
	contractBalance *big.Int
	totalSuppply    *big.Int
	feeBalance      *big.Int
}

// Token Balance Metrics
func (o *otelRecorder) RecordTokenBalance(
	parentCtx context.Context,
	bridgeBalance float64,
	feeBalance float64,
	totalSupply float64,
	chainID int,
	tokenData []tokenData,
) {
	o.bridgeBalance.Set(chainID, bridgeBalance)
	o.feeBalance.Set(chainID, feeBalance)
	o.totalSupply.Set(chainID, totalSupply)
}

func (o *otelRecorder) recordTokenBalance(
	parentCtx context.Context,
	observer metric.Observer,
) (err error) {
	if o.metrics == nil || o.bridgeBalanceGauge == nil {
		return nil
	}

	o.td.Range(func(chainID int, td tokenData) bool {
		tokenAttributes := attribute.NewSet(
			attribute.String("tokenID", td.metadata.TokenID),
			attribute.Int(metrics.ChainID, td.metadata.ChainID),
		)

		gasBalance, ok := o.gasBalance.Get(chainID)
		if !ok {
			return false
		}
		observer.ObserveFloat64(
			o.gasBalanceGauge,
			gasBalance,
			metric.WithAttributeSet(tokenAttributes),
		)

		bridgeBalance, ok := o.bridgeBalance.Get(chainID)
		if !ok {
			return false
		}
		observer.ObserveFloat64(
			o.bridgeBalanceGauge,
			bridgeBalance,
			metric.WithAttributeSet(tokenAttributes),
		)

		feeBalance, ok := o.feeBalance.Get(chainID)
		if !ok {
			return false
		}
		observer.ObserveFloat64(
			o.feeBalanceGauge,
			feeBalance,
			metric.WithAttributeSet(tokenAttributes),
		)

		totalSupply, ok := o.totalSupply.Get(chainID)
		if !ok {
			return false
		}
		observer.ObserveFloat64(
			o.totalSupplyGauge,
			totalSupply,
			metric.WithAttributeSet(tokenAttributes),
		)

		return true
	})

	return nil
}

// DFK Metrics
func (o *otelRecorder) RecordStuckHeroCount(stuckHeroes int64) {
	o.stuckHeroes = stuckHeroes
}

func (o *otelRecorder) recordStuckHeroCount(
	_ context.Context,
	observer metric.Observer,
) (err error) {
	if o.metrics == nil || o.stuckCount == nil {
		return nil
	}

	observer.ObserveInt64(
		o.stuckCount,
		o.stuckHeroes,
	)

	return nil
}

// Submitter stats
func (o *otelRecorder) RecordSubmitterStats(chainid int, nonce int64, balance float64, gasCheckName string) {
	o.nonce.Set(chainid, nonce)
	o.balance.Set(chainid, balance)
	o.name.Set(chainid, gasCheckName)
}

func (o *otelRecorder) recordSubmitterStats(
	_ context.Context,
	observer metric.Observer,
) (err error) {
	if o.metrics == nil || o.nonceGauge == nil {
		return nil
	}

	o.nonce.Range(func(chainID int, nonce int64) bool {
		observer.ObserveInt64(
			o.nonceGauge,
			nonce,
			metric.WithAttributes(attribute.Int(metrics.ChainID, chainID)),
		)
		return true
	})

	o.balance.Range(func(chainID int, balance float64) bool {
		observer.ObserveFloat64(
			o.balanceGauge,
			balance,
			metric.WithAttributes(
				attribute.Int(metrics.ChainID, chainID),
			),
		)
		return true
	})

	return nil
}
