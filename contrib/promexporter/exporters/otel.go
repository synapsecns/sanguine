package exporters

import (
	"context"
	"math/big"

	"github.com/cornelk/hashmap"
	"github.com/hedzr/log"
	"github.com/synapsecns/sanguine/core/metrics"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/metric"
)

//go:generate go run github.com/vburenin/ifacemaker -f otel.go -s otelRecorder -i iOtelRecorder -p exporters -o otel_generated.go -c "autogenerated file"
type otelRecorder struct {
	metrics metrics.Handler
	meter   metric.Meter

	// VPRICE
	vPrice      *hashmap.Map[int, float64]
	vpriceGauge metric.Float64ObservableGauge

	// BRIDGE
	gasBalance         *hashmap.Map[int, float64]
	bridgeBalance      *hashmap.Map[int, float64]
	feeBalance         *hashmap.Map[int, float64]
	totalSupply        *hashmap.Map[int, float64]
	gasBalanceGauge    metric.Float64ObservableGauge
	bridgeBalanceGauge metric.Float64ObservableGauge
	feeBalanceGauge    metric.Float64ObservableGauge
	totalSupplyGauge   metric.Float64ObservableGauge

	// dfk stats
	stuckHeroes      int64
	stuckHeroesGauge metric.Int64ObservableGauge

	// submitter stats
	td           *hashmap.Map[int, tokenData]
	nonce        *hashmap.Map[int, int64]
	balance      *hashmap.Map[int, float64]
	name         *hashmap.Map[int, string]
	balanceGauge metric.Float64ObservableGauge
	nonceGauge   metric.Int64ObservableGauge
}

// TODO: unexport all methods.
// nolint: cyclop
func newOtelRecorder(meterHandler metrics.Handler) iOtelRecorder {
	otr := otelRecorder{
		metrics:       meterHandler,
		meter:         meterHandler.Meter(meterName),
		vPrice:        hashmap.New[int, float64](),
		gasBalance:    hashmap.New[int, float64](),
		bridgeBalance: hashmap.New[int, float64](),
		feeBalance:    hashmap.New[int, float64](),
		totalSupply:   hashmap.New[int, float64](),
		td:            hashmap.New[int, tokenData](),
		nonce:         hashmap.New[int, int64](),
		balance:       hashmap.New[int, float64](),
		name:          hashmap.New[int, string](),
	}
	// todo: make an option
	metricName := func(metricName string) string {
		return metricName
	}

	var err error
	if otr.vpriceGauge, err = otr.meter.Float64ObservableGauge(
		metricName("promexporter.vpriceGauge"),
		metric.WithDescription("vprice gauge"),
		metric.WithUnit("price")); err != nil {
		log.Warnf("failed to create vprice gauge: %v", err)
	}

	if otr.bridgeBalanceGauge, err = otr.meter.Float64ObservableGauge(
		metricName("promexporter.bridgeBalanceGauge"),
		metric.WithDescription("bridge balance"),
		metric.WithUnit("eth")); err != nil {
		log.Warnf("failed to create bridgeBalance gauge: %v", err)
	}
	if otr.feeBalanceGauge, err = otr.meter.Float64ObservableGauge(
		metricName("promexporter.feeBalanceGauge"),
		metric.WithDescription("fee balance gauge"),
		metric.WithUnit("gwei")); err != nil {
		log.Warnf("failed to create feeBalance gauge: %v", err)
	}
	if otr.totalSupplyGauge, err = otr.meter.Float64ObservableGauge(
		metricName("promexporter.totalSupplyGauge"),
		metric.WithDescription("total supply gauge"),
		metric.WithUnit("eth")); err != nil {
		log.Warnf("failed to create totalSupply gauge: %v", err)
	}
	if otr.gasBalanceGauge, err = otr.meter.Float64ObservableGauge(
		metricName("promexporter.gasBalanceGauge"),
		metric.WithDescription("gas balance"),
		metric.WithUnit("gwei")); err != nil {
		log.Warnf("failed to create gasBalance gauge: %v", err)
	}

	if otr.balanceGauge, err = otr.meter.Float64ObservableGauge(
		metricName("promexporter.balanceGauge"),
		metric.WithDescription("balance gauge"),
		metric.WithUnit("eth")); err != nil {
		log.Warnf("failed to create balance gauge: %v", err)
	}

	if otr.nonceGauge, err = otr.meter.Int64ObservableGauge(
		metricName("promexporter.nonceGauge"),
		metric.WithDescription("nonce gauge"),
		metric.WithUnit("nonce")); err != nil {
		log.Warnf("failed to create nonce gauge: %v", err)
	}

	if otr.stuckHeroesGauge, err = otr.meter.Int64ObservableGauge(
		metricName("promexporter.stuckHeroesGauge"),
		metric.WithDescription("stuck count gauge"),
		metric.WithUnit("count")); err != nil {
		log.Warnf("failed to create stuckHeroes gauge: %v", err)
	}

	// Register VPrice callback
	if _, err = otr.meter.RegisterCallback(
		otr.recordVpriceGauge,
		otr.vpriceGauge,
	); err != nil {
		log.Warnf("failed to register callback for vprice metrics: %v", err)
	}

	// Register DFK Stuck Heroes Callback
	if _, err = otr.meter.RegisterCallback(
		otr.recordStuckHeroCount,
		otr.stuckHeroesGauge,
	); err != nil {
		log.Warnf("failed to register callback for dfk stuck heroes metrics: %v", err)
	}

	// Register Token Balance Callback
	if _, err = otr.meter.RegisterCallback(
		otr.recordTokenBalance,
		otr.bridgeBalanceGauge,
		otr.feeBalanceGauge,
		otr.totalSupplyGauge,
	); err != nil {
		log.Warnf("failed to register callback for bridge metrics : %v", err)
	}

	// Register Submitter Stats Callback
	if _, err = otr.meter.RegisterCallback(
		otr.recordSubmitterStats,
		otr.balanceGauge,
		otr.nonceGauge,
	); err != nil {
		log.Warnf("failed to register callback for submitter metrics: %v", err)
	}

	if _, err = otr.meter.RegisterCallback(
		otr.recordBridgeGasBalance,
		otr.gasBalanceGauge,
	); err != nil {
		log.Warnf("failed to register callback for bridge gas balance metrics: %v", err)
	}

	return &otr
}

// Virtual Price Metrics.
func (o *otelRecorder) RecordVPrice(chainid int, vPrice float64) {
	o.vPrice.Set(chainid, vPrice)
}

func (o *otelRecorder) recordVpriceGauge(
	_ context.Context,
	observer metric.Observer,
) (err error) {
	if o.metrics == nil || o.vpriceGauge == nil {
		return nil
	}

	o.vPrice.Range(
		func(chainid int, vprice float64) bool {
			observer.ObserveFloat64(
				o.vpriceGauge,
				vprice,
				metric.WithAttributes(attribute.Int(metrics.ChainID, chainid)),
			)

			return true
		},
	)

	return nil
}

// Token Balance Metrics.
func (o *otelRecorder) RecordBridgeGasBalance(chainid int, gasBalance float64) {
	o.gasBalance.Set(chainid, gasBalance)
}

func (o *otelRecorder) recordBridgeGasBalance(_ context.Context, observer metric.Observer) (err error) {
	if o.metrics == nil || o.bridgeBalanceGauge == nil {
		return nil
	}

	o.gasBalance.Range(func(chainID int, gasBalance float64) bool {
		observer.ObserveFloat64(
			o.gasBalanceGauge,
			gasBalance,
			metric.WithAttributes(attribute.Int(metrics.ChainID, chainID)),
		)

		return true
	})

	return nil
}

type tokenData struct {
	metadata        TokenConfig
	contractBalance *big.Int
	totalSuppply    *big.Int
	feeBalance      *big.Int
}

func (o *otelRecorder) RecordTokenBalance(
	bridgeBalance float64,
	feeBalance float64,
	totalSupply float64,
	chainID int,
	tokenData tokenData,
) {
	o.bridgeBalance.Set(chainID, bridgeBalance)
	o.feeBalance.Set(chainID, feeBalance)
	o.totalSupply.Set(chainID, totalSupply)
	o.td.Set(chainID, tokenData)
}
func (o *otelRecorder) recordTokenBalance(
	_ context.Context,
	observer metric.Observer,
) (err error) {
	if o.metrics == nil || o.bridgeBalanceGauge == nil {
		return nil
	}

	o.td.Range(func(chainID int, td tokenData) bool {
		tokenAttributes := attribute.NewSet(
			attribute.String("tokenID", td.metadata.TokenID),
			attribute.Int(metrics.ChainID, td.metadata.ChainID),
		)

		bridgeBalance, ok := o.bridgeBalance.Get(chainID)
		if !ok {
			return false
		}
		observer.ObserveFloat64(
			o.bridgeBalanceGauge,
			bridgeBalance,
			metric.WithAttributeSet(tokenAttributes),
		)

		feeBalance, ok := o.feeBalance.Get(chainID)
		if !ok {
			return false
		}
		observer.ObserveFloat64(
			o.feeBalanceGauge,
			feeBalance,
			metric.WithAttributeSet(tokenAttributes),
		)

		totalSupply, ok := o.totalSupply.Get(chainID)
		if !ok {
			return false
		}
		observer.ObserveFloat64(
			o.totalSupplyGauge,
			totalSupply,
			metric.WithAttributeSet(tokenAttributes),
		)

		return true
	})

	return nil
}

// DFK Metrics.
func (o *otelRecorder) RecordStuckHeroCount(stuckHeroes int64) {
	o.stuckHeroes = stuckHeroes
}

func (o *otelRecorder) recordStuckHeroCount(
	_ context.Context,
	observer metric.Observer,
) (err error) {
	if o.metrics == nil || o.stuckHeroesGauge == nil {
		return nil
	}

	observer.ObserveInt64(
		o.stuckHeroesGauge,
		o.stuckHeroes,
	)

	return nil
}

// Submitter stats.
func (o *otelRecorder) RecordSubmitterStats(chainid int, nonce int64, balance float64, gasCheckName string) {
	o.nonce.Set(chainid, nonce)
	o.balance.Set(chainid, balance)
	o.name.Set(chainid, gasCheckName)
}

func (o *otelRecorder) recordSubmitterStats(
	_ context.Context,
	observer metric.Observer,
) (err error) {
	if o.metrics == nil || o.nonceGauge == nil {
		return nil
	}

	o.nonce.Range(func(chainID int, nonce int64) bool {
		observer.ObserveInt64(
			o.nonceGauge,
			nonce,
			metric.WithAttributes(attribute.Int(metrics.ChainID, chainID)),
		)
		return true
	})

	o.balance.Range(func(chainID int, balance float64) bool {
		observer.ObserveFloat64(
			o.balanceGauge,
			balance,
			metric.WithAttributes(
				attribute.Int(metrics.ChainID, chainID),
			),
		)
		return true
	})

	return nil
}
