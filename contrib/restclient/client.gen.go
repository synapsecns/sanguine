// Package restclient provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package restclient

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/oapi-codegen/runtime"
)

// Defines values for BigNumberType.
const (
	BigNumberTypeBigNumber BigNumberType = "BigNumber"
)

// Defines values for GetBridgeTxStatusParamsBridgeModule.
const (
	GetBridgeTxStatusParamsBridgeModuleSynapseBridge GetBridgeTxStatusParamsBridgeModule = "SynapseBridge"
	GetBridgeTxStatusParamsBridgeModuleSynapseCCTP   GetBridgeTxStatusParamsBridgeModule = "SynapseCCTP"
	GetBridgeTxStatusParamsBridgeModuleSynapseRFQ    GetBridgeTxStatusParamsBridgeModule = "SynapseRFQ"
)

// Defines values for GetSynapseTxIdParamsBridgeModule.
const (
	GetSynapseTxIdParamsBridgeModuleSynapseBridge GetSynapseTxIdParamsBridgeModule = "SynapseBridge"
	GetSynapseTxIdParamsBridgeModuleSynapseCCTP   GetSynapseTxIdParamsBridgeModule = "SynapseCCTP"
	GetSynapseTxIdParamsBridgeModuleSynapseRFQ    GetSynapseTxIdParamsBridgeModule = "SynapseRFQ"
)

// BigNumber defines model for BigNumber.
type BigNumber struct {
	Hex  *string        `json:"hex,omitempty"`
	Type *BigNumberType `json:"type,omitempty"`
}

// BigNumberType defines model for BigNumber.Type.
type BigNumberType string

// ModelGetContractsResponse defines model for model.GetContractsResponse.
type ModelGetContractsResponse struct {
	// Contracts Contracts is a map of chain id to contract address
	Contracts *map[string]string `json:"contracts,omitempty"`
}

// ModelGetOpenQuoteRequestsResponse defines model for model.GetOpenQuoteRequestsResponse.
type ModelGetOpenQuoteRequestsResponse struct {
	CreatedAt        *string `json:"created_at,omitempty"`
	DestChainId      *int    `json:"dest_chain_id,omitempty"`
	DestToken        *string `json:"dest_token,omitempty"`
	ExpirationWindow *int    `json:"expiration_window,omitempty"`
	OriginAmount     *string `json:"origin_amount,omitempty"`
	OriginChainId    *int    `json:"origin_chain_id,omitempty"`
	OriginToken      *string `json:"origin_token,omitempty"`
	UserAddress      *string `json:"user_address,omitempty"`
}

// ModelGetQuoteResponse defines model for model.GetQuoteResponse.
type ModelGetQuoteResponse struct {
	// DestAmount DestAmount is the max amount of liquidity which exists for a given destination token, provided in the destination token decimals
	DestAmount *string `json:"dest_amount,omitempty"`

	// DestChainId DestChainID is the chain which the relayer is willing to relay to
	DestChainId *int `json:"dest_chain_id,omitempty"`

	// DestFastBridgeAddress DestFastBridgeAddress is the address of the fast bridge contract on the destination chain
	DestFastBridgeAddress *string `json:"dest_fast_bridge_address,omitempty"`

	// DestTokenAddr DestToken is the token address for which the relayer willing to relay to
	DestTokenAddr *string `json:"dest_token_addr,omitempty"`

	// FixedFee FixedFee is the fixed fee for the quote, provided in the destination token terms
	FixedFee *string `json:"fixed_fee,omitempty"`

	// MaxOriginAmount MaxOriginAmount is the maximum amount of origin tokens bridgeable
	MaxOriginAmount *string `json:"max_origin_amount,omitempty"`

	// OriginChainId OriginChainID is the chain which the relayer is willing to relay from
	OriginChainId *int `json:"origin_chain_id,omitempty"`

	// OriginFastBridgeAddress OriginFastBridgeAddress is the address of the fast bridge contract on the origin chain
	OriginFastBridgeAddress *string `json:"origin_fast_bridge_address,omitempty"`

	// OriginTokenAddr OriginTokenAddr is the token address for which the relayer willing to relay from
	OriginTokenAddr *string `json:"origin_token_addr,omitempty"`

	// RelayerAddr Address of the relayer providing the quote
	RelayerAddr *string `json:"relayer_addr,omitempty"`

	// UpdatedAt UpdatedAt is the time that the quote was last upserted
	UpdatedAt *string `json:"updated_at,omitempty"`
}

// ModelPutBulkQuotesRequest defines model for model.PutBulkQuotesRequest.
type ModelPutBulkQuotesRequest struct {
	Quotes *[]ModelPutRelayerQuoteRequest `json:"quotes,omitempty"`
}

// ModelPutRFQRequest defines model for model.PutRFQRequest.
type ModelPutRFQRequest struct {
	Data         *ModelQuoteData `json:"data,omitempty"`
	IntegratorId *string         `json:"integrator_id,omitempty"`
	QuoteTypes   *[]string       `json:"quote_types,omitempty"`
	UserAddress  *string         `json:"user_address,omitempty"`
}

// ModelPutRFQResponse defines model for model.PutRFQResponse.
type ModelPutRFQResponse struct {
	DestAmount     *string `json:"dest_amount,omitempty"`
	QuoteId        *string `json:"quote_id,omitempty"`
	QuoteType      *string `json:"quote_type,omitempty"`
	Reason         *string `json:"reason,omitempty"`
	RelayerAddress *string `json:"relayer_address,omitempty"`
	Success        *bool   `json:"success,omitempty"`
}

// ModelPutRelayerQuoteRequest defines model for model.PutRelayerQuoteRequest.
type ModelPutRelayerQuoteRequest struct {
	DestAmount              *string `json:"dest_amount,omitempty"`
	DestChainId             *int    `json:"dest_chain_id,omitempty"`
	DestFastBridgeAddress   *string `json:"dest_fast_bridge_address,omitempty"`
	DestTokenAddr           *string `json:"dest_token_addr,omitempty"`
	FixedFee                *string `json:"fixed_fee,omitempty"`
	MaxOriginAmount         *string `json:"max_origin_amount,omitempty"`
	OriginChainId           *int    `json:"origin_chain_id,omitempty"`
	OriginFastBridgeAddress *string `json:"origin_fast_bridge_address,omitempty"`
	OriginTokenAddr         *string `json:"origin_token_addr,omitempty"`
}

// ModelQuoteData defines model for model.QuoteData.
type ModelQuoteData struct {
	DestAmount       *string `json:"dest_amount,omitempty"`
	DestChainId      *int    `json:"dest_chain_id,omitempty"`
	DestTokenAddr    *string `json:"dest_token_addr,omitempty"`
	ExpirationWindow *int    `json:"expiration_window,omitempty"`
	OriginAmount     *string `json:"origin_amount,omitempty"`
	OriginChainId    *int    `json:"origin_chain_id,omitempty"`
	OriginTokenAddr  *string `json:"origin_token_addr,omitempty"`
	QuoteId          *string `json:"quote_id,omitempty"`
	RelayerAddress   *string `json:"relayer_address,omitempty"`
}

// GetBridgeParams defines parameters for GetBridge.
type GetBridgeParams struct {
	// FromChain The source chain ID
	FromChain int `form:"fromChain" json:"fromChain"`

	// ToChain The destination chain ID
	ToChain int `form:"toChain" json:"toChain"`

	// FromToken The address of the token on the source chain
	FromToken string `form:"fromToken" json:"fromToken"`

	// ToToken The address of the token on the destination chain
	ToToken string `form:"toToken" json:"toToken"`

	// Amount The amount of tokens to bridge
	Amount float32 `form:"amount" json:"amount"`

	// OriginUserAddress The address of the user on the origin chain
	OriginUserAddress *string `form:"originUserAddress,omitempty" json:"originUserAddress,omitempty"`
}

// GetBridgeLimitsParams defines parameters for GetBridgeLimits.
type GetBridgeLimitsParams struct {
	// FromChain The source chain ID.
	FromChain int `form:"fromChain" json:"fromChain"`

	// ToChain The destination chain ID.
	ToChain int `form:"toChain" json:"toChain"`

	// FromToken The address of the token on the source chain.
	FromToken string `form:"fromToken" json:"fromToken"`

	// ToToken The address of the token on the destination chain.
	ToToken string `form:"toToken" json:"toToken"`
}

// GetBridgeTxInfoParams defines parameters for GetBridgeTxInfo.
type GetBridgeTxInfoParams struct {
	// FromChain The source chain ID
	FromChain int `form:"fromChain" json:"fromChain"`

	// FromToken The address of the token on the source chain
	FromToken string `form:"fromToken" json:"fromToken"`

	// ToChain The destination chain ID
	ToChain int `form:"toChain" json:"toChain"`

	// ToToken The address of the token on the destination chain
	ToToken string `form:"toToken" json:"toToken"`

	// Amount The amount of tokens to bridge
	Amount float32 `form:"amount" json:"amount"`

	// DestAddress The destination address for the bridged tokens
	DestAddress string `form:"destAddress" json:"destAddress"`

	// OriginUserAddress The address of the user on the origin chain
	OriginUserAddress *string `form:"originUserAddress,omitempty" json:"originUserAddress,omitempty"`
}

// GetBridgeTxStatusParams defines parameters for GetBridgeTxStatus.
type GetBridgeTxStatusParams struct {
	// DestChainId The ID of the destination chain
	DestChainId int `form:"destChainId" json:"destChainId"`

	// BridgeModule The bridge module used for the transaction
	BridgeModule GetBridgeTxStatusParamsBridgeModule `form:"bridgeModule" json:"bridgeModule"`

	// SynapseTxId The Synapse transaction ID
	SynapseTxId string `form:"synapseTxId" json:"synapseTxId"`
}

// GetBridgeTxStatusParamsBridgeModule defines parameters for GetBridgeTxStatus.
type GetBridgeTxStatusParamsBridgeModule string

// GetDestinationTokensParams defines parameters for GetDestinationTokens.
type GetDestinationTokensParams struct {
	// FromChain The source chain ID
	FromChain int `form:"fromChain" json:"fromChain"`

	// FromToken The address of the token on the source chain
	FromToken string `form:"fromToken" json:"fromToken"`
}

// GetDestinationTxParams defines parameters for GetDestinationTx.
type GetDestinationTxParams struct {
	// OriginChainId The ID of the origin chain where the transaction was initiated
	OriginChainId int `form:"originChainId" json:"originChainId"`

	// TxHash The transaction hash on the origin chain
	TxHash string `form:"txHash" json:"txHash"`
}

// GetQuotesParams defines parameters for GetQuotes.
type GetQuotesParams struct {
	// OriginChainID origin chain id to filter quotes by
	OriginChainID int `form:"originChainID" json:"originChainID"`

	// OriginTokenAddr origin chain id to filter quotes by
	OriginTokenAddr string `form:"originTokenAddr" json:"originTokenAddr"`

	// DestChainID destination chain id to filter quotes by
	DestChainID int `form:"destChainID" json:"destChainID"`

	// DestTokenAddr destination token address to filter quotes by
	DestTokenAddr string `form:"destTokenAddr" json:"destTokenAddr"`

	// RelayerAddr relayer address to filter quotes by
	RelayerAddr string `form:"relayerAddr" json:"relayerAddr"`
}

// GetSwapParams defines parameters for GetSwap.
type GetSwapParams struct {
	// Chain The chain ID where the swap will occur
	Chain int `form:"chain" json:"chain"`

	// FromToken The address of the token to swap from
	FromToken string `form:"fromToken" json:"fromToken"`

	// ToToken The address of the token to swap to
	ToToken string `form:"toToken" json:"toToken"`

	// Amount The amount of tokens to swap
	Amount float32 `form:"amount" json:"amount"`
}

// GetSwapTxInfoParams defines parameters for GetSwapTxInfo.
type GetSwapTxInfoParams struct {
	// Chain The chain ID where the swap will occur
	Chain int `form:"chain" json:"chain"`

	// FromToken The address of the token to swap from
	FromToken string `form:"fromToken" json:"fromToken"`

	// ToToken The address of the token to swap to
	ToToken string `form:"toToken" json:"toToken"`

	// Amount The amount of tokens to swap
	Amount float32 `form:"amount" json:"amount"`

	// Address The Ethereum address of the user performing the swap
	Address string `form:"address" json:"address"`
}

// GetSynapseTxIdParams defines parameters for GetSynapseTxId.
type GetSynapseTxIdParams struct {
	// OriginChainId The ID of the origin chain where the transaction was initiated
	OriginChainId int `form:"originChainId" json:"originChainId"`

	// BridgeModule The bridge module used for the transaction
	BridgeModule GetSynapseTxIdParamsBridgeModule `form:"bridgeModule" json:"bridgeModule"`

	// TxHash The transaction hash on the origin chain
	TxHash string `form:"txHash" json:"txHash"`
}

// GetSynapseTxIdParamsBridgeModule defines parameters for GetSynapseTxId.
type GetSynapseTxIdParamsBridgeModule string

// PutAckJSONRequestBody defines body for PutAck for application/json ContentType.
type PutAckJSONRequestBody = ModelPutRelayerQuoteRequest

// PutBulkQuotesJSONRequestBody defines body for PutBulkQuotes for application/json ContentType.
type PutBulkQuotesJSONRequestBody = ModelPutBulkQuotesRequest

// PutQuotesJSONRequestBody defines body for PutQuotes for application/json ContentType.
type PutQuotesJSONRequestBody = ModelPutRelayerQuoteRequest

// PutRfqJSONRequestBody defines body for PutRfq for application/json ContentType.
type PutRfqJSONRequestBody = ModelPutRFQRequest

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// Get request
	Get(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutAckWithBody request with any body
	PutAckWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutAck(ctx context.Context, body PutAckJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBridge request
	GetBridge(ctx context.Context, params *GetBridgeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBridgeLimits request
	GetBridgeLimits(ctx context.Context, params *GetBridgeLimitsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBridgeTxInfo request
	GetBridgeTxInfo(ctx context.Context, params *GetBridgeTxInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBridgeTxStatus request
	GetBridgeTxStatus(ctx context.Context, params *GetBridgeTxStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutBulkQuotesWithBody request with any body
	PutBulkQuotesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutBulkQuotes(ctx context.Context, body PutBulkQuotesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConflictingProofs request
	GetConflictingProofs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetContracts request
	GetContracts(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDestinationTokens request
	GetDestinationTokens(ctx context.Context, params *GetDestinationTokensParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDestinationTx request
	GetDestinationTx(ctx context.Context, params *GetDestinationTxParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDisputes request
	GetDisputes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInvalidRelays request
	GetInvalidRelays(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOpenQuoteRequests request
	GetOpenQuoteRequests(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPendingTransactionsExceedDeadline request
	GetPendingTransactionsExceedDeadline(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPendingTransactionsMissingClaim request
	GetPendingTransactionsMissingClaim(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPendingTransactionsMissingProof request
	GetPendingTransactionsMissingProof(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPendingTransactionsMissingRelay request
	GetPendingTransactionsMissingRelay(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetQuotes request
	GetQuotes(ctx context.Context, params *GetQuotesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutQuotesWithBody request with any body
	PutQuotesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutQuotes(ctx context.Context, body PutQuotesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRefundedAndRelayed request
	GetRefundedAndRelayed(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutRfqWithBody request with any body
	PutRfqWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutRfq(ctx context.Context, body PutRfqJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRfqStream request
	GetRfqStream(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSwap request
	GetSwap(ctx context.Context, params *GetSwapParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSwapTxInfo request
	GetSwapTxInfo(ctx context.Context, params *GetSwapTxInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSynapseTxId request
	GetSynapseTxId(ctx context.Context, params *GetSynapseTxIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTokenlist request
	GetTokenlist(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTransactionIdTransactionId request
	GetTransactionIdTransactionId(ctx context.Context, transactionId string, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) Get(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutAckWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutAckRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutAck(ctx context.Context, body PutAckJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutAckRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBridge(ctx context.Context, params *GetBridgeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBridgeRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBridgeLimits(ctx context.Context, params *GetBridgeLimitsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBridgeLimitsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBridgeTxInfo(ctx context.Context, params *GetBridgeTxInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBridgeTxInfoRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBridgeTxStatus(ctx context.Context, params *GetBridgeTxStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBridgeTxStatusRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutBulkQuotesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutBulkQuotesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutBulkQuotes(ctx context.Context, body PutBulkQuotesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutBulkQuotesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConflictingProofs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConflictingProofsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetContracts(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetContractsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDestinationTokens(ctx context.Context, params *GetDestinationTokensParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDestinationTokensRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDestinationTx(ctx context.Context, params *GetDestinationTxParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDestinationTxRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDisputes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDisputesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInvalidRelays(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInvalidRelaysRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOpenQuoteRequests(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOpenQuoteRequestsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPendingTransactionsExceedDeadline(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPendingTransactionsExceedDeadlineRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPendingTransactionsMissingClaim(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPendingTransactionsMissingClaimRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPendingTransactionsMissingProof(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPendingTransactionsMissingProofRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPendingTransactionsMissingRelay(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPendingTransactionsMissingRelayRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetQuotes(ctx context.Context, params *GetQuotesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetQuotesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutQuotesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutQuotesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutQuotes(ctx context.Context, body PutQuotesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutQuotesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRefundedAndRelayed(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRefundedAndRelayedRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutRfqWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutRfqRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutRfq(ctx context.Context, body PutRfqJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutRfqRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRfqStream(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRfqStreamRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSwap(ctx context.Context, params *GetSwapParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSwapRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSwapTxInfo(ctx context.Context, params *GetSwapTxInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSwapTxInfoRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSynapseTxId(ctx context.Context, params *GetSynapseTxIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSynapseTxIdRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTokenlist(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTokenlistRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTransactionIdTransactionId(ctx context.Context, transactionId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTransactionIdTransactionIdRequest(c.Server, transactionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetRequest generates requests for Get
func NewGetRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutAckRequest calls the generic PutAck builder with application/json body
func NewPutAckRequest(server string, body PutAckJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutAckRequestWithBody(server, "application/json", bodyReader)
}

// NewPutAckRequestWithBody generates requests for PutAck with any type of body
func NewPutAckRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ack")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetBridgeRequest generates requests for GetBridge
func NewGetBridgeRequest(server string, params *GetBridgeParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/bridge")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fromChain", runtime.ParamLocationQuery, params.FromChain); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "toChain", runtime.ParamLocationQuery, params.ToChain); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fromToken", runtime.ParamLocationQuery, params.FromToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "toToken", runtime.ParamLocationQuery, params.ToToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.OriginUserAddress != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "originUserAddress", runtime.ParamLocationQuery, *params.OriginUserAddress); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBridgeLimitsRequest generates requests for GetBridgeLimits
func NewGetBridgeLimitsRequest(server string, params *GetBridgeLimitsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/bridgeLimits")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fromChain", runtime.ParamLocationQuery, params.FromChain); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "toChain", runtime.ParamLocationQuery, params.ToChain); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fromToken", runtime.ParamLocationQuery, params.FromToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "toToken", runtime.ParamLocationQuery, params.ToToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBridgeTxInfoRequest generates requests for GetBridgeTxInfo
func NewGetBridgeTxInfoRequest(server string, params *GetBridgeTxInfoParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/bridgeTxInfo")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fromChain", runtime.ParamLocationQuery, params.FromChain); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fromToken", runtime.ParamLocationQuery, params.FromToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "toChain", runtime.ParamLocationQuery, params.ToChain); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "toToken", runtime.ParamLocationQuery, params.ToToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "destAddress", runtime.ParamLocationQuery, params.DestAddress); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.OriginUserAddress != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "originUserAddress", runtime.ParamLocationQuery, *params.OriginUserAddress); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBridgeTxStatusRequest generates requests for GetBridgeTxStatus
func NewGetBridgeTxStatusRequest(server string, params *GetBridgeTxStatusParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/bridgeTxStatus")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "destChainId", runtime.ParamLocationQuery, params.DestChainId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bridgeModule", runtime.ParamLocationQuery, params.BridgeModule); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "synapseTxId", runtime.ParamLocationQuery, params.SynapseTxId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutBulkQuotesRequest calls the generic PutBulkQuotes builder with application/json body
func NewPutBulkQuotesRequest(server string, body PutBulkQuotesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutBulkQuotesRequestWithBody(server, "application/json", bodyReader)
}

// NewPutBulkQuotesRequestWithBody generates requests for PutBulkQuotes with any type of body
func NewPutBulkQuotesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/bulk_quotes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetConflictingProofsRequest generates requests for GetConflictingProofs
func NewGetConflictingProofsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/conflicting-proofs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetContractsRequest generates requests for GetContracts
func NewGetContractsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/contracts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDestinationTokensRequest generates requests for GetDestinationTokens
func NewGetDestinationTokensRequest(server string, params *GetDestinationTokensParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/destinationTokens")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fromChain", runtime.ParamLocationQuery, params.FromChain); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fromToken", runtime.ParamLocationQuery, params.FromToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDestinationTxRequest generates requests for GetDestinationTx
func NewGetDestinationTxRequest(server string, params *GetDestinationTxParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/destinationTx")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "originChainId", runtime.ParamLocationQuery, params.OriginChainId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "txHash", runtime.ParamLocationQuery, params.TxHash); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDisputesRequest generates requests for GetDisputes
func NewGetDisputesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/disputes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInvalidRelaysRequest generates requests for GetInvalidRelays
func NewGetInvalidRelaysRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/invalid-relays")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOpenQuoteRequestsRequest generates requests for GetOpenQuoteRequests
func NewGetOpenQuoteRequestsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/open_quote_requests")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPendingTransactionsExceedDeadlineRequest generates requests for GetPendingTransactionsExceedDeadline
func NewGetPendingTransactionsExceedDeadlineRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pending-transactions/exceed-deadline")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPendingTransactionsMissingClaimRequest generates requests for GetPendingTransactionsMissingClaim
func NewGetPendingTransactionsMissingClaimRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pending-transactions/missing-claim")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPendingTransactionsMissingProofRequest generates requests for GetPendingTransactionsMissingProof
func NewGetPendingTransactionsMissingProofRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pending-transactions/missing-proof")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPendingTransactionsMissingRelayRequest generates requests for GetPendingTransactionsMissingRelay
func NewGetPendingTransactionsMissingRelayRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pending-transactions/missing-relay")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetQuotesRequest generates requests for GetQuotes
func NewGetQuotesRequest(server string, params *GetQuotesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/quotes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "originChainID", runtime.ParamLocationQuery, params.OriginChainID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "originTokenAddr", runtime.ParamLocationQuery, params.OriginTokenAddr); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "destChainID", runtime.ParamLocationQuery, params.DestChainID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "destTokenAddr", runtime.ParamLocationQuery, params.DestTokenAddr); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "relayerAddr", runtime.ParamLocationQuery, params.RelayerAddr); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutQuotesRequest calls the generic PutQuotes builder with application/json body
func NewPutQuotesRequest(server string, body PutQuotesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutQuotesRequestWithBody(server, "application/json", bodyReader)
}

// NewPutQuotesRequestWithBody generates requests for PutQuotes with any type of body
func NewPutQuotesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/quotes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetRefundedAndRelayedRequest generates requests for GetRefundedAndRelayed
func NewGetRefundedAndRelayedRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/refunded-and-relayed")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutRfqRequest calls the generic PutRfq builder with application/json body
func NewPutRfqRequest(server string, body PutRfqJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutRfqRequestWithBody(server, "application/json", bodyReader)
}

// NewPutRfqRequestWithBody generates requests for PutRfq with any type of body
func NewPutRfqRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rfq")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetRfqStreamRequest generates requests for GetRfqStream
func NewGetRfqStreamRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rfq_stream")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSwapRequest generates requests for GetSwap
func NewGetSwapRequest(server string, params *GetSwapParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/swap")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "chain", runtime.ParamLocationQuery, params.Chain); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fromToken", runtime.ParamLocationQuery, params.FromToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "toToken", runtime.ParamLocationQuery, params.ToToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSwapTxInfoRequest generates requests for GetSwapTxInfo
func NewGetSwapTxInfoRequest(server string, params *GetSwapTxInfoParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/swapTxInfo")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "chain", runtime.ParamLocationQuery, params.Chain); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fromToken", runtime.ParamLocationQuery, params.FromToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "toToken", runtime.ParamLocationQuery, params.ToToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "address", runtime.ParamLocationQuery, params.Address); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSynapseTxIdRequest generates requests for GetSynapseTxId
func NewGetSynapseTxIdRequest(server string, params *GetSynapseTxIdParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/synapseTxId")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "originChainId", runtime.ParamLocationQuery, params.OriginChainId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bridgeModule", runtime.ParamLocationQuery, params.BridgeModule); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "txHash", runtime.ParamLocationQuery, params.TxHash); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTokenlistRequest generates requests for GetTokenlist
func NewGetTokenlistRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tokenlist")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTransactionIdTransactionIdRequest generates requests for GetTransactionIdTransactionId
func NewGetTransactionIdTransactionIdRequest(server string, transactionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "transactionId", runtime.ParamLocationPath, transactionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transaction-id/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetWithResponse request
	GetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetResponse, error)

	// PutAckWithBodyWithResponse request with any body
	PutAckWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutAckResponse, error)

	PutAckWithResponse(ctx context.Context, body PutAckJSONRequestBody, reqEditors ...RequestEditorFn) (*PutAckResponse, error)

	// GetBridgeWithResponse request
	GetBridgeWithResponse(ctx context.Context, params *GetBridgeParams, reqEditors ...RequestEditorFn) (*GetBridgeResponse, error)

	// GetBridgeLimitsWithResponse request
	GetBridgeLimitsWithResponse(ctx context.Context, params *GetBridgeLimitsParams, reqEditors ...RequestEditorFn) (*GetBridgeLimitsResponse, error)

	// GetBridgeTxInfoWithResponse request
	GetBridgeTxInfoWithResponse(ctx context.Context, params *GetBridgeTxInfoParams, reqEditors ...RequestEditorFn) (*GetBridgeTxInfoResponse, error)

	// GetBridgeTxStatusWithResponse request
	GetBridgeTxStatusWithResponse(ctx context.Context, params *GetBridgeTxStatusParams, reqEditors ...RequestEditorFn) (*GetBridgeTxStatusResponse, error)

	// PutBulkQuotesWithBodyWithResponse request with any body
	PutBulkQuotesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutBulkQuotesResponse, error)

	PutBulkQuotesWithResponse(ctx context.Context, body PutBulkQuotesJSONRequestBody, reqEditors ...RequestEditorFn) (*PutBulkQuotesResponse, error)

	// GetConflictingProofsWithResponse request
	GetConflictingProofsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetConflictingProofsResponse, error)

	// GetContractsWithResponse request
	GetContractsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetContractsResponse, error)

	// GetDestinationTokensWithResponse request
	GetDestinationTokensWithResponse(ctx context.Context, params *GetDestinationTokensParams, reqEditors ...RequestEditorFn) (*GetDestinationTokensResponse, error)

	// GetDestinationTxWithResponse request
	GetDestinationTxWithResponse(ctx context.Context, params *GetDestinationTxParams, reqEditors ...RequestEditorFn) (*GetDestinationTxResponse, error)

	// GetDisputesWithResponse request
	GetDisputesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDisputesResponse, error)

	// GetInvalidRelaysWithResponse request
	GetInvalidRelaysWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetInvalidRelaysResponse, error)

	// GetOpenQuoteRequestsWithResponse request
	GetOpenQuoteRequestsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOpenQuoteRequestsResponse, error)

	// GetPendingTransactionsExceedDeadlineWithResponse request
	GetPendingTransactionsExceedDeadlineWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPendingTransactionsExceedDeadlineResponse, error)

	// GetPendingTransactionsMissingClaimWithResponse request
	GetPendingTransactionsMissingClaimWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPendingTransactionsMissingClaimResponse, error)

	// GetPendingTransactionsMissingProofWithResponse request
	GetPendingTransactionsMissingProofWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPendingTransactionsMissingProofResponse, error)

	// GetPendingTransactionsMissingRelayWithResponse request
	GetPendingTransactionsMissingRelayWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPendingTransactionsMissingRelayResponse, error)

	// GetQuotesWithResponse request
	GetQuotesWithResponse(ctx context.Context, params *GetQuotesParams, reqEditors ...RequestEditorFn) (*GetQuotesResponse, error)

	// PutQuotesWithBodyWithResponse request with any body
	PutQuotesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutQuotesResponse, error)

	PutQuotesWithResponse(ctx context.Context, body PutQuotesJSONRequestBody, reqEditors ...RequestEditorFn) (*PutQuotesResponse, error)

	// GetRefundedAndRelayedWithResponse request
	GetRefundedAndRelayedWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRefundedAndRelayedResponse, error)

	// PutRfqWithBodyWithResponse request with any body
	PutRfqWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutRfqResponse, error)

	PutRfqWithResponse(ctx context.Context, body PutRfqJSONRequestBody, reqEditors ...RequestEditorFn) (*PutRfqResponse, error)

	// GetRfqStreamWithResponse request
	GetRfqStreamWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRfqStreamResponse, error)

	// GetSwapWithResponse request
	GetSwapWithResponse(ctx context.Context, params *GetSwapParams, reqEditors ...RequestEditorFn) (*GetSwapResponse, error)

	// GetSwapTxInfoWithResponse request
	GetSwapTxInfoWithResponse(ctx context.Context, params *GetSwapTxInfoParams, reqEditors ...RequestEditorFn) (*GetSwapTxInfoResponse, error)

	// GetSynapseTxIdWithResponse request
	GetSynapseTxIdWithResponse(ctx context.Context, params *GetSynapseTxIdParams, reqEditors ...RequestEditorFn) (*GetSynapseTxIdResponse, error)

	// GetTokenlistWithResponse request
	GetTokenlistWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTokenlistResponse, error)

	// GetTransactionIdTransactionIdWithResponse request
	GetTransactionIdTransactionIdWithResponse(ctx context.Context, transactionId string, reqEditors ...RequestEditorFn) (*GetTransactionIdTransactionIdResponse, error)
}

type GetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AvailableChains List of available blockchain networks
		AvailableChains *[]struct {
			// Id Chain ID of the blockchain network
			Id *int `json:"id,omitempty"`

			// Name Name of the blockchain network
			Name *string `json:"name,omitempty"`
		} `json:"availableChains,omitempty"`

		// AvailableTokens List of available tokens across different chains
		AvailableTokens *[]struct {
			// Chains List of chains where the token is available
			Chains *[]struct {
				// Address Token contract address on the specific chain
				Address *string `json:"address,omitempty"`

				// ChainId Chain ID where the token is available
				ChainId *string `json:"chainId,omitempty"`
			} `json:"chains,omitempty"`

			// Symbol Token symbol
			Symbol *string `json:"symbol,omitempty"`
		} `json:"availableTokens,omitempty"`

		// Message Welcome message for the API
		Message *string `json:"message,omitempty"`
	}
	JSON500 *struct {
		Error *string `json:"error,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutAckResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PutAckResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutAckResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBridgeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		BridgeFeeFormatted *string                 `json:"bridgeFeeFormatted,omitempty"`
		BridgeModuleName   *string                 `json:"bridgeModuleName,omitempty"`
		DestChainId        *int                    `json:"destChainId,omitempty"`
		DestQuery          *map[string]interface{} `json:"destQuery,omitempty"`
		EstimatedTime      *int                    `json:"estimatedTime,omitempty"`
		FeeAmount          *BigNumber              `json:"feeAmount,omitempty"`
		FeeConfig          *struct {
			BridgeFee *int       `json:"bridgeFee,omitempty"`
			MaxFee    *BigNumber `json:"maxFee,omitempty"`
			MinFee    *BigNumber `json:"minFee,omitempty"`
		} `json:"feeConfig,omitempty"`
		GasDropAmount   *BigNumber              `json:"gasDropAmount,omitempty"`
		Id              *string                 `json:"id,omitempty"`
		MaxAmountOut    *BigNumber              `json:"maxAmountOut,omitempty"`
		MaxAmountOutStr *string                 `json:"maxAmountOutStr,omitempty"`
		OriginChainId   *int                    `json:"originChainId,omitempty"`
		OriginQuery     *map[string]interface{} `json:"originQuery,omitempty"`
		RouterAddress   *string                 `json:"routerAddress,omitempty"`
	}
	JSON400 *struct {
		Error *struct {
			Field    *string `json:"field,omitempty"`
			Location *string `json:"location,omitempty"`
			Message  *string `json:"message,omitempty"`
			Value    *string `json:"value,omitempty"`
		} `json:"error,omitempty"`
	}
	JSON500 *struct {
		Error *string `json:"error,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetBridgeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBridgeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBridgeLimitsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// MaxOriginAmount Maximum amount of tokens that can be bridged from the origin chain.
		MaxOriginAmount *string `json:"maxOriginAmount,omitempty"`

		// MinOriginAmount Minimum amount of tokens that can be bridged from the origin chain.
		MinOriginAmount *string `json:"minOriginAmount,omitempty"`
	}
	JSON400 *struct {
		Error *struct {
			Field    *string `json:"field,omitempty"`
			Location *string `json:"location,omitempty"`
			Message  *string `json:"message,omitempty"`
			Value    *string `json:"value,omitempty"`
		} `json:"error,omitempty"`
	}
	JSON500 *struct {
		Error *string `json:"error,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetBridgeLimitsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBridgeLimitsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBridgeTxInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// Data Encoded transaction data
		Data *string `json:"data,omitempty"`

		// To The address of the contract to interact with
		To *string `json:"to,omitempty"`

		// Value The amount of native currency to send with the transaction
		Value *struct {
			Hex  *string                      `json:"hex,omitempty"`
			Type *GetBridgeTxInfo200ValueType `json:"type,omitempty"`
		} `json:"value,omitempty"`
	}
	JSON400 *struct {
		Error *struct {
			Field    *string `json:"field,omitempty"`
			Location *string `json:"location,omitempty"`
			Message  *string `json:"message,omitempty"`
			Value    *string `json:"value,omitempty"`
		} `json:"error,omitempty"`
	}
	JSON500 *struct {
		Error *string `json:"error,omitempty"`
	}
}
type GetBridgeTxInfo200ValueType string

// Status returns HTTPResponse.Status
func (r GetBridgeTxInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBridgeTxInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBridgeTxStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Status The status of the transaction
		Status *bool `json:"status,omitempty"`
		ToInfo *struct {
			// USDValue The USD value of the transaction
			USDValue *float32 `json:"USDValue,omitempty"`

			// Address The recipient address
			Address *string `json:"address,omitempty"`

			// ChainID The destination chain ID
			ChainID *int `json:"chainID,omitempty"`

			// FormattedTime The formatted time of the transaction
			FormattedTime *string `json:"formattedTime,omitempty"`

			// FormattedValue The formatted value of the transaction
			FormattedValue *string `json:"formattedValue,omitempty"`

			// TokenSymbol The symbol of the token transferred
			TokenSymbol *string `json:"tokenSymbol,omitempty"`

			// TxnHash The transaction hash on the destination chain
			TxnHash *string `json:"txnHash,omitempty"`
		} `json:"toInfo,omitempty"`
	}
	JSON400 *struct {
		Error *struct {
			Field    *string `json:"field,omitempty"`
			Location *string `json:"location,omitempty"`
			Message  *string `json:"message,omitempty"`
			Value    *string `json:"value,omitempty"`
		} `json:"error,omitempty"`
	}
	JSON500 *struct {
		Error *string `json:"error,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetBridgeTxStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBridgeTxStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutBulkQuotesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PutBulkQuotesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutBulkQuotesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConflictingProofsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// Bridge General transaction fields
		Bridge *map[string]interface{} `json:"Bridge,omitempty"`

		// BridgeClaim Claim information (if available)
		BridgeClaim *map[string]interface{} `json:"BridgeClaim,omitempty"`

		// BridgeDispute Dispute information (if available)
		BridgeDispute *map[string]interface{} `json:"BridgeDispute,omitempty"`

		// BridgeProof Proof information (if available)
		BridgeProof *map[string]interface{} `json:"BridgeProof,omitempty"`

		// BridgeRefund Refund information
		BridgeRefund *map[string]interface{} `json:"BridgeRefund,omitempty"`

		// BridgeRelay Relay information
		BridgeRelay *map[string]interface{} `json:"BridgeRelay,omitempty"`

		// BridgeRequest Deposit information
		BridgeRequest *map[string]interface{} `json:"BridgeRequest,omitempty"`
	}
	JSON404 *struct {
		Message *string `json:"message,omitempty"`
	}
	JSON500 *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetConflictingProofsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConflictingProofsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetContractsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ModelGetContractsResponse
}

// Status returns HTTPResponse.Status
func (r GetContractsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetContractsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDestinationTokensResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// Address The token contract address
		Address *string `json:"address,omitempty"`

		// ChainId The chain ID where the token is available
		ChainId *string `json:"chainId,omitempty"`

		// Symbol The token symbol
		Symbol *string `json:"symbol,omitempty"`
	}
	JSON400 *struct {
		Error *struct {
			Field    *string `json:"field,omitempty"`
			Location *string `json:"location,omitempty"`
			Message  *string `json:"message,omitempty"`
			Value    *string `json:"value,omitempty"`
		} `json:"error,omitempty"`
	}
	JSON500 *struct {
		Error *string `json:"error,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetDestinationTokensResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDestinationTokensResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDestinationTxResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		FromInfo *struct {
			// USDValue The USD value of the transaction
			USDValue *float32 `json:"USDValue,omitempty"`

			// Address The recipient address
			Address *string `json:"address,omitempty"`

			// BlockNumber The block number of the transaction
			BlockNumber *int `json:"blockNumber,omitempty"`

			// ChainID The origin chain ID
			ChainID *int `json:"chainID,omitempty"`

			// FormattedTime The formatted time of the transaction
			FormattedTime *string `json:"formattedTime,omitempty"`

			// FormattedValue The formatted value of the transaction
			FormattedValue *string `json:"formattedValue,omitempty"`

			// TokenSymbol The symbol of the token transferred
			TokenSymbol *string `json:"tokenSymbol,omitempty"`

			// TxnHash The transaction hash on the destination chain
			TxnHash *string `json:"txnHash,omitempty"`
		} `json:"fromInfo,omitempty"`

		// Status The status of the transaction
		Status *string `json:"status,omitempty"`
		ToInfo *struct {
			// USDValue The USD value of the transaction
			USDValue *float32 `json:"USDValue,omitempty"`

			// Address The recipient address
			Address *string `json:"address,omitempty"`

			// BlockNumber The block number of the transaction
			BlockNumber *int `json:"blockNumber,omitempty"`

			// ChainID The destination chain ID
			ChainID *int `json:"chainID,omitempty"`

			// FormattedTime The formatted time of the transaction
			FormattedTime *string `json:"formattedTime,omitempty"`

			// FormattedValue The formatted value of the transaction
			FormattedValue *string `json:"formattedValue,omitempty"`

			// TokenSymbol The symbol of the token transferred
			TokenSymbol *string `json:"tokenSymbol,omitempty"`

			// TxnHash The transaction hash on the destination chain
			TxnHash *string `json:"txnHash,omitempty"`
		} `json:"toInfo,omitempty"`
	}
	JSON400 *struct {
		Error *struct {
			Field    *string `json:"field,omitempty"`
			Location *string `json:"location,omitempty"`
			Message  *string `json:"message,omitempty"`
			Value    *string `json:"value,omitempty"`
		} `json:"error,omitempty"`
	}
	JSON404 *struct {
		FromInfo *map[string]interface{} `json:"fromInfo"`
		Status   *string                 `json:"status,omitempty"`
		ToInfo   *map[string]interface{} `json:"toInfo"`
	}
	JSON500 *struct {
		Error *string `json:"error,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetDestinationTxResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDestinationTxResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDisputesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// Bridge General transaction fields
		Bridge *map[string]interface{} `json:"Bridge,omitempty"`

		// BridgeClaim Claim information (if available)
		BridgeClaim *map[string]interface{} `json:"BridgeClaim,omitempty"`

		// BridgeDispute Dispute information (if available)
		BridgeDispute *map[string]interface{} `json:"BridgeDispute,omitempty"`

		// BridgeProof Proof information (if available)
		BridgeProof *map[string]interface{} `json:"BridgeProof,omitempty"`

		// BridgeRefund Refund information
		BridgeRefund *map[string]interface{} `json:"BridgeRefund,omitempty"`

		// BridgeRelay Relay information
		BridgeRelay *map[string]interface{} `json:"BridgeRelay,omitempty"`

		// BridgeRequest Deposit information
		BridgeRequest *map[string]interface{} `json:"BridgeRequest,omitempty"`
	}
	JSON404 *struct {
		Message *string `json:"message,omitempty"`
	}
	JSON500 *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetDisputesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDisputesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInvalidRelaysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// Bridge General transaction fields
		Bridge *map[string]interface{} `json:"Bridge,omitempty"`

		// BridgeClaim Claim information (if available)
		BridgeClaim *map[string]interface{} `json:"BridgeClaim,omitempty"`

		// BridgeDispute Dispute information (if available)
		BridgeDispute *map[string]interface{} `json:"BridgeDispute,omitempty"`

		// BridgeProof Proof information (if available)
		BridgeProof *map[string]interface{} `json:"BridgeProof,omitempty"`

		// BridgeRefund Refund information
		BridgeRefund *map[string]interface{} `json:"BridgeRefund,omitempty"`

		// BridgeRelay Relay information
		BridgeRelay *map[string]interface{} `json:"BridgeRelay,omitempty"`

		// BridgeRequest Deposit information
		BridgeRequest *map[string]interface{} `json:"BridgeRequest,omitempty"`
	}
	JSON404 *struct {
		Message *string `json:"message,omitempty"`
	}
	JSON500 *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetInvalidRelaysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInvalidRelaysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOpenQuoteRequestsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ModelGetOpenQuoteRequestsResponse
}

// Status returns HTTPResponse.Status
func (r GetOpenQuoteRequestsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOpenQuoteRequestsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPendingTransactionsExceedDeadlineResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		Deposit *map[string]interface{} `json:"deposit,omitempty"`
	}
	JSON404 *struct {
		Message *string `json:"message,omitempty"`
	}
	JSON500 *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPendingTransactionsExceedDeadlineResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPendingTransactionsExceedDeadlineResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPendingTransactionsMissingClaimResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// Bridge General transaction fields
		Bridge *map[string]interface{} `json:"Bridge,omitempty"`

		// BridgeClaim Claim information (if available)
		BridgeClaim *map[string]interface{} `json:"BridgeClaim,omitempty"`

		// BridgeDispute Dispute information (if available)
		BridgeDispute *map[string]interface{} `json:"BridgeDispute,omitempty"`

		// BridgeProof Proof information (if available)
		BridgeProof *map[string]interface{} `json:"BridgeProof,omitempty"`

		// BridgeRefund Refund information
		BridgeRefund *map[string]interface{} `json:"BridgeRefund,omitempty"`

		// BridgeRelay Relay information
		BridgeRelay *map[string]interface{} `json:"BridgeRelay,omitempty"`

		// BridgeRequest Deposit information
		BridgeRequest *map[string]interface{} `json:"BridgeRequest,omitempty"`
	}
	JSON404 *struct {
		Message *string `json:"message,omitempty"`
	}
	JSON500 *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPendingTransactionsMissingClaimResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPendingTransactionsMissingClaimResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPendingTransactionsMissingProofResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		Deposit *map[string]interface{} `json:"deposit,omitempty"`
		Relay   *map[string]interface{} `json:"relay,omitempty"`
	}
	JSON404 *struct {
		Message *string `json:"message,omitempty"`
	}
	JSON500 *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPendingTransactionsMissingProofResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPendingTransactionsMissingProofResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPendingTransactionsMissingRelayResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		Deposit *map[string]interface{} `json:"deposit,omitempty"`
	}
	JSON404 *struct {
		Message *string `json:"message,omitempty"`
	}
	JSON500 *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPendingTransactionsMissingRelayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPendingTransactionsMissingRelayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetQuotesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ModelGetQuoteResponse
}

// Status returns HTTPResponse.Status
func (r GetQuotesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetQuotesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutQuotesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PutQuotesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutQuotesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRefundedAndRelayedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// Bridge General transaction fields
		Bridge *map[string]interface{} `json:"Bridge,omitempty"`

		// BridgeClaim Claim information (if available)
		BridgeClaim *map[string]interface{} `json:"BridgeClaim,omitempty"`

		// BridgeDispute Dispute information (if available)
		BridgeDispute *map[string]interface{} `json:"BridgeDispute,omitempty"`

		// BridgeProof Proof information (if available)
		BridgeProof *map[string]interface{} `json:"BridgeProof,omitempty"`

		// BridgeRefund Refund information
		BridgeRefund *map[string]interface{} `json:"BridgeRefund,omitempty"`

		// BridgeRelay Relay information
		BridgeRelay *map[string]interface{} `json:"BridgeRelay,omitempty"`

		// BridgeRequest Deposit information
		BridgeRequest *map[string]interface{} `json:"BridgeRequest,omitempty"`
	}
	JSON404 *struct {
		Message *string `json:"message,omitempty"`
	}
	JSON500 *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetRefundedAndRelayedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRefundedAndRelayedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutRfqResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ModelPutRFQResponse
}

// Status returns HTTPResponse.Status
func (r PutRfqResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutRfqResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRfqStreamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON101      *string
}

// Status returns HTTPResponse.Status
func (r GetRfqStreamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRfqStreamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSwapResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// MaxAmountOut The maximum amount of tokens that will be received
		MaxAmountOut *string `json:"maxAmountOut,omitempty"`
		Query        *struct {
			Deadline     *BigNumber `json:"deadline,omitempty"`
			MinAmountOut *BigNumber `json:"minAmountOut,omitempty"`

			// RawParams Raw parameters for the swap
			RawParams *string `json:"rawParams,omitempty"`

			// SwapAdapter The address of the swap adapter
			SwapAdapter *string `json:"swapAdapter,omitempty"`

			// TokenOut The address of the token being received
			TokenOut *string `json:"tokenOut,omitempty"`
		} `json:"query,omitempty"`

		// RouterAddress The address of the router contract
		RouterAddress *string `json:"routerAddress,omitempty"`
	}
	JSON400 *struct {
		Error *struct {
			Field    *string `json:"field,omitempty"`
			Location *string `json:"location,omitempty"`
			Message  *string `json:"message,omitempty"`
			Value    *string `json:"value,omitempty"`
		} `json:"error,omitempty"`
	}
	JSON500 *struct {
		Error *string `json:"error,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetSwapResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSwapResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSwapTxInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Encoded transaction data
		Data *string `json:"data,omitempty"`

		// To The address of the contract to interact with
		To *string `json:"to,omitempty"`

		// Value The amount of native currency to send with the transaction
		Value *struct {
			Hex  *string                    `json:"hex,omitempty"`
			Type *GetSwapTxInfo200ValueType `json:"type,omitempty"`
		} `json:"value,omitempty"`
	}
	JSON400 *struct {
		Error *struct {
			Field    *string `json:"field,omitempty"`
			Location *string `json:"location,omitempty"`
			Message  *string `json:"message,omitempty"`
			Value    *string `json:"value,omitempty"`
		} `json:"error,omitempty"`
	}
	JSON500 *struct {
		Error *string `json:"error,omitempty"`
	}
}
type GetSwapTxInfo200ValueType string

// Status returns HTTPResponse.Status
func (r GetSwapTxInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSwapTxInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSynapseTxIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// SynapseTxId The Synapse transaction ID
		SynapseTxId *string `json:"synapseTxId,omitempty"`
	}
	JSON400 *struct {
		Error *struct {
			Field    *string `json:"field,omitempty"`
			Location *string `json:"location,omitempty"`
			Message  *string `json:"message,omitempty"`
			Value    *string `json:"value,omitempty"`
		} `json:"error,omitempty"`
	}
	JSON500 *struct {
		Error *string `json:"error,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetSynapseTxIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSynapseTxIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTokenlistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]struct {
		Addresses    *map[string]string `json:"addresses,omitempty"`
		Color        *string            `json:"color,omitempty"`
		Decimals     *map[string]int    `json:"decimals,omitempty"`
		ImgUrl       *string            `json:"imgUrl,omitempty"`
		Name         *string            `json:"name,omitempty"`
		PriorityRank *int               `json:"priorityRank,omitempty"`
		RouteSymbol  *string            `json:"routeSymbol,omitempty"`
		SwapableType *string            `json:"swapableType,omitempty"`
		Symbol       *string            `json:"symbol,omitempty"`
	}
	JSON500 *struct {
		Error *string `json:"error,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetTokenlistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTokenlistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTransactionIdTransactionIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Bridge General transaction fields
		Bridge *map[string]interface{} `json:"Bridge,omitempty"`

		// BridgeClaim Claim information (if available)
		BridgeClaim *map[string]interface{} `json:"BridgeClaim,omitempty"`

		// BridgeDispute Dispute information (if available)
		BridgeDispute *map[string]interface{} `json:"BridgeDispute,omitempty"`

		// BridgeProof Proof information (if available)
		BridgeProof *map[string]interface{} `json:"BridgeProof,omitempty"`

		// BridgeRefund Refund information
		BridgeRefund *map[string]interface{} `json:"BridgeRefund,omitempty"`

		// BridgeRelay Relay information
		BridgeRelay *map[string]interface{} `json:"BridgeRelay,omitempty"`

		// BridgeRequest Deposit information
		BridgeRequest *map[string]interface{} `json:"BridgeRequest,omitempty"`
	}
	JSON404 *struct {
		Message *string `json:"message,omitempty"`
	}
	JSON500 *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetTransactionIdTransactionIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTransactionIdTransactionIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetWithResponse request returning *GetResponse
func (c *ClientWithResponses) GetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetResponse, error) {
	rsp, err := c.Get(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResponse(rsp)
}

// PutAckWithBodyWithResponse request with arbitrary body returning *PutAckResponse
func (c *ClientWithResponses) PutAckWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutAckResponse, error) {
	rsp, err := c.PutAckWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutAckResponse(rsp)
}

func (c *ClientWithResponses) PutAckWithResponse(ctx context.Context, body PutAckJSONRequestBody, reqEditors ...RequestEditorFn) (*PutAckResponse, error) {
	rsp, err := c.PutAck(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutAckResponse(rsp)
}

// GetBridgeWithResponse request returning *GetBridgeResponse
func (c *ClientWithResponses) GetBridgeWithResponse(ctx context.Context, params *GetBridgeParams, reqEditors ...RequestEditorFn) (*GetBridgeResponse, error) {
	rsp, err := c.GetBridge(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBridgeResponse(rsp)
}

// GetBridgeLimitsWithResponse request returning *GetBridgeLimitsResponse
func (c *ClientWithResponses) GetBridgeLimitsWithResponse(ctx context.Context, params *GetBridgeLimitsParams, reqEditors ...RequestEditorFn) (*GetBridgeLimitsResponse, error) {
	rsp, err := c.GetBridgeLimits(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBridgeLimitsResponse(rsp)
}

// GetBridgeTxInfoWithResponse request returning *GetBridgeTxInfoResponse
func (c *ClientWithResponses) GetBridgeTxInfoWithResponse(ctx context.Context, params *GetBridgeTxInfoParams, reqEditors ...RequestEditorFn) (*GetBridgeTxInfoResponse, error) {
	rsp, err := c.GetBridgeTxInfo(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBridgeTxInfoResponse(rsp)
}

// GetBridgeTxStatusWithResponse request returning *GetBridgeTxStatusResponse
func (c *ClientWithResponses) GetBridgeTxStatusWithResponse(ctx context.Context, params *GetBridgeTxStatusParams, reqEditors ...RequestEditorFn) (*GetBridgeTxStatusResponse, error) {
	rsp, err := c.GetBridgeTxStatus(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBridgeTxStatusResponse(rsp)
}

// PutBulkQuotesWithBodyWithResponse request with arbitrary body returning *PutBulkQuotesResponse
func (c *ClientWithResponses) PutBulkQuotesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutBulkQuotesResponse, error) {
	rsp, err := c.PutBulkQuotesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutBulkQuotesResponse(rsp)
}

func (c *ClientWithResponses) PutBulkQuotesWithResponse(ctx context.Context, body PutBulkQuotesJSONRequestBody, reqEditors ...RequestEditorFn) (*PutBulkQuotesResponse, error) {
	rsp, err := c.PutBulkQuotes(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutBulkQuotesResponse(rsp)
}

// GetConflictingProofsWithResponse request returning *GetConflictingProofsResponse
func (c *ClientWithResponses) GetConflictingProofsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetConflictingProofsResponse, error) {
	rsp, err := c.GetConflictingProofs(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConflictingProofsResponse(rsp)
}

// GetContractsWithResponse request returning *GetContractsResponse
func (c *ClientWithResponses) GetContractsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetContractsResponse, error) {
	rsp, err := c.GetContracts(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetContractsResponse(rsp)
}

// GetDestinationTokensWithResponse request returning *GetDestinationTokensResponse
func (c *ClientWithResponses) GetDestinationTokensWithResponse(ctx context.Context, params *GetDestinationTokensParams, reqEditors ...RequestEditorFn) (*GetDestinationTokensResponse, error) {
	rsp, err := c.GetDestinationTokens(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDestinationTokensResponse(rsp)
}

// GetDestinationTxWithResponse request returning *GetDestinationTxResponse
func (c *ClientWithResponses) GetDestinationTxWithResponse(ctx context.Context, params *GetDestinationTxParams, reqEditors ...RequestEditorFn) (*GetDestinationTxResponse, error) {
	rsp, err := c.GetDestinationTx(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDestinationTxResponse(rsp)
}

// GetDisputesWithResponse request returning *GetDisputesResponse
func (c *ClientWithResponses) GetDisputesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDisputesResponse, error) {
	rsp, err := c.GetDisputes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDisputesResponse(rsp)
}

// GetInvalidRelaysWithResponse request returning *GetInvalidRelaysResponse
func (c *ClientWithResponses) GetInvalidRelaysWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetInvalidRelaysResponse, error) {
	rsp, err := c.GetInvalidRelays(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInvalidRelaysResponse(rsp)
}

// GetOpenQuoteRequestsWithResponse request returning *GetOpenQuoteRequestsResponse
func (c *ClientWithResponses) GetOpenQuoteRequestsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOpenQuoteRequestsResponse, error) {
	rsp, err := c.GetOpenQuoteRequests(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOpenQuoteRequestsResponse(rsp)
}

// GetPendingTransactionsExceedDeadlineWithResponse request returning *GetPendingTransactionsExceedDeadlineResponse
func (c *ClientWithResponses) GetPendingTransactionsExceedDeadlineWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPendingTransactionsExceedDeadlineResponse, error) {
	rsp, err := c.GetPendingTransactionsExceedDeadline(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPendingTransactionsExceedDeadlineResponse(rsp)
}

// GetPendingTransactionsMissingClaimWithResponse request returning *GetPendingTransactionsMissingClaimResponse
func (c *ClientWithResponses) GetPendingTransactionsMissingClaimWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPendingTransactionsMissingClaimResponse, error) {
	rsp, err := c.GetPendingTransactionsMissingClaim(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPendingTransactionsMissingClaimResponse(rsp)
}

// GetPendingTransactionsMissingProofWithResponse request returning *GetPendingTransactionsMissingProofResponse
func (c *ClientWithResponses) GetPendingTransactionsMissingProofWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPendingTransactionsMissingProofResponse, error) {
	rsp, err := c.GetPendingTransactionsMissingProof(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPendingTransactionsMissingProofResponse(rsp)
}

// GetPendingTransactionsMissingRelayWithResponse request returning *GetPendingTransactionsMissingRelayResponse
func (c *ClientWithResponses) GetPendingTransactionsMissingRelayWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPendingTransactionsMissingRelayResponse, error) {
	rsp, err := c.GetPendingTransactionsMissingRelay(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPendingTransactionsMissingRelayResponse(rsp)
}

// GetQuotesWithResponse request returning *GetQuotesResponse
func (c *ClientWithResponses) GetQuotesWithResponse(ctx context.Context, params *GetQuotesParams, reqEditors ...RequestEditorFn) (*GetQuotesResponse, error) {
	rsp, err := c.GetQuotes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetQuotesResponse(rsp)
}

// PutQuotesWithBodyWithResponse request with arbitrary body returning *PutQuotesResponse
func (c *ClientWithResponses) PutQuotesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutQuotesResponse, error) {
	rsp, err := c.PutQuotesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutQuotesResponse(rsp)
}

func (c *ClientWithResponses) PutQuotesWithResponse(ctx context.Context, body PutQuotesJSONRequestBody, reqEditors ...RequestEditorFn) (*PutQuotesResponse, error) {
	rsp, err := c.PutQuotes(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutQuotesResponse(rsp)
}

// GetRefundedAndRelayedWithResponse request returning *GetRefundedAndRelayedResponse
func (c *ClientWithResponses) GetRefundedAndRelayedWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRefundedAndRelayedResponse, error) {
	rsp, err := c.GetRefundedAndRelayed(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRefundedAndRelayedResponse(rsp)
}

// PutRfqWithBodyWithResponse request with arbitrary body returning *PutRfqResponse
func (c *ClientWithResponses) PutRfqWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutRfqResponse, error) {
	rsp, err := c.PutRfqWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutRfqResponse(rsp)
}

func (c *ClientWithResponses) PutRfqWithResponse(ctx context.Context, body PutRfqJSONRequestBody, reqEditors ...RequestEditorFn) (*PutRfqResponse, error) {
	rsp, err := c.PutRfq(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutRfqResponse(rsp)
}

// GetRfqStreamWithResponse request returning *GetRfqStreamResponse
func (c *ClientWithResponses) GetRfqStreamWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRfqStreamResponse, error) {
	rsp, err := c.GetRfqStream(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRfqStreamResponse(rsp)
}

// GetSwapWithResponse request returning *GetSwapResponse
func (c *ClientWithResponses) GetSwapWithResponse(ctx context.Context, params *GetSwapParams, reqEditors ...RequestEditorFn) (*GetSwapResponse, error) {
	rsp, err := c.GetSwap(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSwapResponse(rsp)
}

// GetSwapTxInfoWithResponse request returning *GetSwapTxInfoResponse
func (c *ClientWithResponses) GetSwapTxInfoWithResponse(ctx context.Context, params *GetSwapTxInfoParams, reqEditors ...RequestEditorFn) (*GetSwapTxInfoResponse, error) {
	rsp, err := c.GetSwapTxInfo(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSwapTxInfoResponse(rsp)
}

// GetSynapseTxIdWithResponse request returning *GetSynapseTxIdResponse
func (c *ClientWithResponses) GetSynapseTxIdWithResponse(ctx context.Context, params *GetSynapseTxIdParams, reqEditors ...RequestEditorFn) (*GetSynapseTxIdResponse, error) {
	rsp, err := c.GetSynapseTxId(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSynapseTxIdResponse(rsp)
}

// GetTokenlistWithResponse request returning *GetTokenlistResponse
func (c *ClientWithResponses) GetTokenlistWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTokenlistResponse, error) {
	rsp, err := c.GetTokenlist(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTokenlistResponse(rsp)
}

// GetTransactionIdTransactionIdWithResponse request returning *GetTransactionIdTransactionIdResponse
func (c *ClientWithResponses) GetTransactionIdTransactionIdWithResponse(ctx context.Context, transactionId string, reqEditors ...RequestEditorFn) (*GetTransactionIdTransactionIdResponse, error) {
	rsp, err := c.GetTransactionIdTransactionId(ctx, transactionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTransactionIdTransactionIdResponse(rsp)
}

// ParseGetResponse parses an HTTP response from a GetWithResponse call
func ParseGetResponse(rsp *http.Response) (*GetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AvailableChains List of available blockchain networks
			AvailableChains *[]struct {
				// Id Chain ID of the blockchain network
				Id *int `json:"id,omitempty"`

				// Name Name of the blockchain network
				Name *string `json:"name,omitempty"`
			} `json:"availableChains,omitempty"`

			// AvailableTokens List of available tokens across different chains
			AvailableTokens *[]struct {
				// Chains List of chains where the token is available
				Chains *[]struct {
					// Address Token contract address on the specific chain
					Address *string `json:"address,omitempty"`

					// ChainId Chain ID where the token is available
					ChainId *string `json:"chainId,omitempty"`
				} `json:"chains,omitempty"`

				// Symbol Token symbol
				Symbol *string `json:"symbol,omitempty"`
			} `json:"availableTokens,omitempty"`

			// Message Welcome message for the API
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Error *string `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePutAckResponse parses an HTTP response from a PutAckWithResponse call
func ParsePutAckResponse(rsp *http.Response) (*PutAckResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutAckResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetBridgeResponse parses an HTTP response from a GetBridgeWithResponse call
func ParseGetBridgeResponse(rsp *http.Response) (*GetBridgeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBridgeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			BridgeFeeFormatted *string                 `json:"bridgeFeeFormatted,omitempty"`
			BridgeModuleName   *string                 `json:"bridgeModuleName,omitempty"`
			DestChainId        *int                    `json:"destChainId,omitempty"`
			DestQuery          *map[string]interface{} `json:"destQuery,omitempty"`
			EstimatedTime      *int                    `json:"estimatedTime,omitempty"`
			FeeAmount          *BigNumber              `json:"feeAmount,omitempty"`
			FeeConfig          *struct {
				BridgeFee *int       `json:"bridgeFee,omitempty"`
				MaxFee    *BigNumber `json:"maxFee,omitempty"`
				MinFee    *BigNumber `json:"minFee,omitempty"`
			} `json:"feeConfig,omitempty"`
			GasDropAmount   *BigNumber              `json:"gasDropAmount,omitempty"`
			Id              *string                 `json:"id,omitempty"`
			MaxAmountOut    *BigNumber              `json:"maxAmountOut,omitempty"`
			MaxAmountOutStr *string                 `json:"maxAmountOutStr,omitempty"`
			OriginChainId   *int                    `json:"originChainId,omitempty"`
			OriginQuery     *map[string]interface{} `json:"originQuery,omitempty"`
			RouterAddress   *string                 `json:"routerAddress,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error *struct {
				Field    *string `json:"field,omitempty"`
				Location *string `json:"location,omitempty"`
				Message  *string `json:"message,omitempty"`
				Value    *string `json:"value,omitempty"`
			} `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Error *string `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetBridgeLimitsResponse parses an HTTP response from a GetBridgeLimitsWithResponse call
func ParseGetBridgeLimitsResponse(rsp *http.Response) (*GetBridgeLimitsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBridgeLimitsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// MaxOriginAmount Maximum amount of tokens that can be bridged from the origin chain.
			MaxOriginAmount *string `json:"maxOriginAmount,omitempty"`

			// MinOriginAmount Minimum amount of tokens that can be bridged from the origin chain.
			MinOriginAmount *string `json:"minOriginAmount,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error *struct {
				Field    *string `json:"field,omitempty"`
				Location *string `json:"location,omitempty"`
				Message  *string `json:"message,omitempty"`
				Value    *string `json:"value,omitempty"`
			} `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Error *string `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetBridgeTxInfoResponse parses an HTTP response from a GetBridgeTxInfoWithResponse call
func ParseGetBridgeTxInfoResponse(rsp *http.Response) (*GetBridgeTxInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBridgeTxInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// Data Encoded transaction data
			Data *string `json:"data,omitempty"`

			// To The address of the contract to interact with
			To *string `json:"to,omitempty"`

			// Value The amount of native currency to send with the transaction
			Value *struct {
				Hex  *string                      `json:"hex,omitempty"`
				Type *GetBridgeTxInfo200ValueType `json:"type,omitempty"`
			} `json:"value,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error *struct {
				Field    *string `json:"field,omitempty"`
				Location *string `json:"location,omitempty"`
				Message  *string `json:"message,omitempty"`
				Value    *string `json:"value,omitempty"`
			} `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Error *string `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetBridgeTxStatusResponse parses an HTTP response from a GetBridgeTxStatusWithResponse call
func ParseGetBridgeTxStatusResponse(rsp *http.Response) (*GetBridgeTxStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBridgeTxStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Status The status of the transaction
			Status *bool `json:"status,omitempty"`
			ToInfo *struct {
				// USDValue The USD value of the transaction
				USDValue *float32 `json:"USDValue,omitempty"`

				// Address The recipient address
				Address *string `json:"address,omitempty"`

				// ChainID The destination chain ID
				ChainID *int `json:"chainID,omitempty"`

				// FormattedTime The formatted time of the transaction
				FormattedTime *string `json:"formattedTime,omitempty"`

				// FormattedValue The formatted value of the transaction
				FormattedValue *string `json:"formattedValue,omitempty"`

				// TokenSymbol The symbol of the token transferred
				TokenSymbol *string `json:"tokenSymbol,omitempty"`

				// TxnHash The transaction hash on the destination chain
				TxnHash *string `json:"txnHash,omitempty"`
			} `json:"toInfo,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error *struct {
				Field    *string `json:"field,omitempty"`
				Location *string `json:"location,omitempty"`
				Message  *string `json:"message,omitempty"`
				Value    *string `json:"value,omitempty"`
			} `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Error *string `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePutBulkQuotesResponse parses an HTTP response from a PutBulkQuotesWithResponse call
func ParsePutBulkQuotesResponse(rsp *http.Response) (*PutBulkQuotesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutBulkQuotesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetConflictingProofsResponse parses an HTTP response from a GetConflictingProofsWithResponse call
func ParseGetConflictingProofsResponse(rsp *http.Response) (*GetConflictingProofsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConflictingProofsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// Bridge General transaction fields
			Bridge *map[string]interface{} `json:"Bridge,omitempty"`

			// BridgeClaim Claim information (if available)
			BridgeClaim *map[string]interface{} `json:"BridgeClaim,omitempty"`

			// BridgeDispute Dispute information (if available)
			BridgeDispute *map[string]interface{} `json:"BridgeDispute,omitempty"`

			// BridgeProof Proof information (if available)
			BridgeProof *map[string]interface{} `json:"BridgeProof,omitempty"`

			// BridgeRefund Refund information
			BridgeRefund *map[string]interface{} `json:"BridgeRefund,omitempty"`

			// BridgeRelay Relay information
			BridgeRelay *map[string]interface{} `json:"BridgeRelay,omitempty"`

			// BridgeRequest Deposit information
			BridgeRequest *map[string]interface{} `json:"BridgeRequest,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetContractsResponse parses an HTTP response from a GetContractsWithResponse call
func ParseGetContractsResponse(rsp *http.Response) (*GetContractsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetContractsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ModelGetContractsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetDestinationTokensResponse parses an HTTP response from a GetDestinationTokensWithResponse call
func ParseGetDestinationTokensResponse(rsp *http.Response) (*GetDestinationTokensResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDestinationTokensResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// Address The token contract address
			Address *string `json:"address,omitempty"`

			// ChainId The chain ID where the token is available
			ChainId *string `json:"chainId,omitempty"`

			// Symbol The token symbol
			Symbol *string `json:"symbol,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error *struct {
				Field    *string `json:"field,omitempty"`
				Location *string `json:"location,omitempty"`
				Message  *string `json:"message,omitempty"`
				Value    *string `json:"value,omitempty"`
			} `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Error *string `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDestinationTxResponse parses an HTTP response from a GetDestinationTxWithResponse call
func ParseGetDestinationTxResponse(rsp *http.Response) (*GetDestinationTxResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDestinationTxResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			FromInfo *struct {
				// USDValue The USD value of the transaction
				USDValue *float32 `json:"USDValue,omitempty"`

				// Address The recipient address
				Address *string `json:"address,omitempty"`

				// BlockNumber The block number of the transaction
				BlockNumber *int `json:"blockNumber,omitempty"`

				// ChainID The origin chain ID
				ChainID *int `json:"chainID,omitempty"`

				// FormattedTime The formatted time of the transaction
				FormattedTime *string `json:"formattedTime,omitempty"`

				// FormattedValue The formatted value of the transaction
				FormattedValue *string `json:"formattedValue,omitempty"`

				// TokenSymbol The symbol of the token transferred
				TokenSymbol *string `json:"tokenSymbol,omitempty"`

				// TxnHash The transaction hash on the destination chain
				TxnHash *string `json:"txnHash,omitempty"`
			} `json:"fromInfo,omitempty"`

			// Status The status of the transaction
			Status *string `json:"status,omitempty"`
			ToInfo *struct {
				// USDValue The USD value of the transaction
				USDValue *float32 `json:"USDValue,omitempty"`

				// Address The recipient address
				Address *string `json:"address,omitempty"`

				// BlockNumber The block number of the transaction
				BlockNumber *int `json:"blockNumber,omitempty"`

				// ChainID The destination chain ID
				ChainID *int `json:"chainID,omitempty"`

				// FormattedTime The formatted time of the transaction
				FormattedTime *string `json:"formattedTime,omitempty"`

				// FormattedValue The formatted value of the transaction
				FormattedValue *string `json:"formattedValue,omitempty"`

				// TokenSymbol The symbol of the token transferred
				TokenSymbol *string `json:"tokenSymbol,omitempty"`

				// TxnHash The transaction hash on the destination chain
				TxnHash *string `json:"txnHash,omitempty"`
			} `json:"toInfo,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error *struct {
				Field    *string `json:"field,omitempty"`
				Location *string `json:"location,omitempty"`
				Message  *string `json:"message,omitempty"`
				Value    *string `json:"value,omitempty"`
			} `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			FromInfo *map[string]interface{} `json:"fromInfo"`
			Status   *string                 `json:"status,omitempty"`
			ToInfo   *map[string]interface{} `json:"toInfo"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Error *string `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDisputesResponse parses an HTTP response from a GetDisputesWithResponse call
func ParseGetDisputesResponse(rsp *http.Response) (*GetDisputesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDisputesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// Bridge General transaction fields
			Bridge *map[string]interface{} `json:"Bridge,omitempty"`

			// BridgeClaim Claim information (if available)
			BridgeClaim *map[string]interface{} `json:"BridgeClaim,omitempty"`

			// BridgeDispute Dispute information (if available)
			BridgeDispute *map[string]interface{} `json:"BridgeDispute,omitempty"`

			// BridgeProof Proof information (if available)
			BridgeProof *map[string]interface{} `json:"BridgeProof,omitempty"`

			// BridgeRefund Refund information
			BridgeRefund *map[string]interface{} `json:"BridgeRefund,omitempty"`

			// BridgeRelay Relay information
			BridgeRelay *map[string]interface{} `json:"BridgeRelay,omitempty"`

			// BridgeRequest Deposit information
			BridgeRequest *map[string]interface{} `json:"BridgeRequest,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetInvalidRelaysResponse parses an HTTP response from a GetInvalidRelaysWithResponse call
func ParseGetInvalidRelaysResponse(rsp *http.Response) (*GetInvalidRelaysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInvalidRelaysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// Bridge General transaction fields
			Bridge *map[string]interface{} `json:"Bridge,omitempty"`

			// BridgeClaim Claim information (if available)
			BridgeClaim *map[string]interface{} `json:"BridgeClaim,omitempty"`

			// BridgeDispute Dispute information (if available)
			BridgeDispute *map[string]interface{} `json:"BridgeDispute,omitempty"`

			// BridgeProof Proof information (if available)
			BridgeProof *map[string]interface{} `json:"BridgeProof,omitempty"`

			// BridgeRefund Refund information
			BridgeRefund *map[string]interface{} `json:"BridgeRefund,omitempty"`

			// BridgeRelay Relay information
			BridgeRelay *map[string]interface{} `json:"BridgeRelay,omitempty"`

			// BridgeRequest Deposit information
			BridgeRequest *map[string]interface{} `json:"BridgeRequest,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetOpenQuoteRequestsResponse parses an HTTP response from a GetOpenQuoteRequestsWithResponse call
func ParseGetOpenQuoteRequestsResponse(rsp *http.Response) (*GetOpenQuoteRequestsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOpenQuoteRequestsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ModelGetOpenQuoteRequestsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPendingTransactionsExceedDeadlineResponse parses an HTTP response from a GetPendingTransactionsExceedDeadlineWithResponse call
func ParseGetPendingTransactionsExceedDeadlineResponse(rsp *http.Response) (*GetPendingTransactionsExceedDeadlineResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPendingTransactionsExceedDeadlineResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			Deposit *map[string]interface{} `json:"deposit,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPendingTransactionsMissingClaimResponse parses an HTTP response from a GetPendingTransactionsMissingClaimWithResponse call
func ParseGetPendingTransactionsMissingClaimResponse(rsp *http.Response) (*GetPendingTransactionsMissingClaimResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPendingTransactionsMissingClaimResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// Bridge General transaction fields
			Bridge *map[string]interface{} `json:"Bridge,omitempty"`

			// BridgeClaim Claim information (if available)
			BridgeClaim *map[string]interface{} `json:"BridgeClaim,omitempty"`

			// BridgeDispute Dispute information (if available)
			BridgeDispute *map[string]interface{} `json:"BridgeDispute,omitempty"`

			// BridgeProof Proof information (if available)
			BridgeProof *map[string]interface{} `json:"BridgeProof,omitempty"`

			// BridgeRefund Refund information
			BridgeRefund *map[string]interface{} `json:"BridgeRefund,omitempty"`

			// BridgeRelay Relay information
			BridgeRelay *map[string]interface{} `json:"BridgeRelay,omitempty"`

			// BridgeRequest Deposit information
			BridgeRequest *map[string]interface{} `json:"BridgeRequest,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPendingTransactionsMissingProofResponse parses an HTTP response from a GetPendingTransactionsMissingProofWithResponse call
func ParseGetPendingTransactionsMissingProofResponse(rsp *http.Response) (*GetPendingTransactionsMissingProofResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPendingTransactionsMissingProofResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			Deposit *map[string]interface{} `json:"deposit,omitempty"`
			Relay   *map[string]interface{} `json:"relay,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPendingTransactionsMissingRelayResponse parses an HTTP response from a GetPendingTransactionsMissingRelayWithResponse call
func ParseGetPendingTransactionsMissingRelayResponse(rsp *http.Response) (*GetPendingTransactionsMissingRelayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPendingTransactionsMissingRelayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			Deposit *map[string]interface{} `json:"deposit,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetQuotesResponse parses an HTTP response from a GetQuotesWithResponse call
func ParseGetQuotesResponse(rsp *http.Response) (*GetQuotesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetQuotesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ModelGetQuoteResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePutQuotesResponse parses an HTTP response from a PutQuotesWithResponse call
func ParsePutQuotesResponse(rsp *http.Response) (*PutQuotesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutQuotesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetRefundedAndRelayedResponse parses an HTTP response from a GetRefundedAndRelayedWithResponse call
func ParseGetRefundedAndRelayedResponse(rsp *http.Response) (*GetRefundedAndRelayedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRefundedAndRelayedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// Bridge General transaction fields
			Bridge *map[string]interface{} `json:"Bridge,omitempty"`

			// BridgeClaim Claim information (if available)
			BridgeClaim *map[string]interface{} `json:"BridgeClaim,omitempty"`

			// BridgeDispute Dispute information (if available)
			BridgeDispute *map[string]interface{} `json:"BridgeDispute,omitempty"`

			// BridgeProof Proof information (if available)
			BridgeProof *map[string]interface{} `json:"BridgeProof,omitempty"`

			// BridgeRefund Refund information
			BridgeRefund *map[string]interface{} `json:"BridgeRefund,omitempty"`

			// BridgeRelay Relay information
			BridgeRelay *map[string]interface{} `json:"BridgeRelay,omitempty"`

			// BridgeRequest Deposit information
			BridgeRequest *map[string]interface{} `json:"BridgeRequest,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePutRfqResponse parses an HTTP response from a PutRfqWithResponse call
func ParsePutRfqResponse(rsp *http.Response) (*PutRfqResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutRfqResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ModelPutRFQResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetRfqStreamResponse parses an HTTP response from a GetRfqStreamWithResponse call
func ParseGetRfqStreamResponse(rsp *http.Response) (*GetRfqStreamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRfqStreamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 101:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON101 = &dest

	}

	return response, nil
}

// ParseGetSwapResponse parses an HTTP response from a GetSwapWithResponse call
func ParseGetSwapResponse(rsp *http.Response) (*GetSwapResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSwapResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// MaxAmountOut The maximum amount of tokens that will be received
			MaxAmountOut *string `json:"maxAmountOut,omitempty"`
			Query        *struct {
				Deadline     *BigNumber `json:"deadline,omitempty"`
				MinAmountOut *BigNumber `json:"minAmountOut,omitempty"`

				// RawParams Raw parameters for the swap
				RawParams *string `json:"rawParams,omitempty"`

				// SwapAdapter The address of the swap adapter
				SwapAdapter *string `json:"swapAdapter,omitempty"`

				// TokenOut The address of the token being received
				TokenOut *string `json:"tokenOut,omitempty"`
			} `json:"query,omitempty"`

			// RouterAddress The address of the router contract
			RouterAddress *string `json:"routerAddress,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error *struct {
				Field    *string `json:"field,omitempty"`
				Location *string `json:"location,omitempty"`
				Message  *string `json:"message,omitempty"`
				Value    *string `json:"value,omitempty"`
			} `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Error *string `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSwapTxInfoResponse parses an HTTP response from a GetSwapTxInfoWithResponse call
func ParseGetSwapTxInfoResponse(rsp *http.Response) (*GetSwapTxInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSwapTxInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Encoded transaction data
			Data *string `json:"data,omitempty"`

			// To The address of the contract to interact with
			To *string `json:"to,omitempty"`

			// Value The amount of native currency to send with the transaction
			Value *struct {
				Hex  *string                    `json:"hex,omitempty"`
				Type *GetSwapTxInfo200ValueType `json:"type,omitempty"`
			} `json:"value,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error *struct {
				Field    *string `json:"field,omitempty"`
				Location *string `json:"location,omitempty"`
				Message  *string `json:"message,omitempty"`
				Value    *string `json:"value,omitempty"`
			} `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Error *string `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSynapseTxIdResponse parses an HTTP response from a GetSynapseTxIdWithResponse call
func ParseGetSynapseTxIdResponse(rsp *http.Response) (*GetSynapseTxIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSynapseTxIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// SynapseTxId The Synapse transaction ID
			SynapseTxId *string `json:"synapseTxId,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error *struct {
				Field    *string `json:"field,omitempty"`
				Location *string `json:"location,omitempty"`
				Message  *string `json:"message,omitempty"`
				Value    *string `json:"value,omitempty"`
			} `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Error *string `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTokenlistResponse parses an HTTP response from a GetTokenlistWithResponse call
func ParseGetTokenlistResponse(rsp *http.Response) (*GetTokenlistResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTokenlistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]struct {
			Addresses    *map[string]string `json:"addresses,omitempty"`
			Color        *string            `json:"color,omitempty"`
			Decimals     *map[string]int    `json:"decimals,omitempty"`
			ImgUrl       *string            `json:"imgUrl,omitempty"`
			Name         *string            `json:"name,omitempty"`
			PriorityRank *int               `json:"priorityRank,omitempty"`
			RouteSymbol  *string            `json:"routeSymbol,omitempty"`
			SwapableType *string            `json:"swapableType,omitempty"`
			Symbol       *string            `json:"symbol,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Error *string `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTransactionIdTransactionIdResponse parses an HTTP response from a GetTransactionIdTransactionIdWithResponse call
func ParseGetTransactionIdTransactionIdResponse(rsp *http.Response) (*GetTransactionIdTransactionIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTransactionIdTransactionIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Bridge General transaction fields
			Bridge *map[string]interface{} `json:"Bridge,omitempty"`

			// BridgeClaim Claim information (if available)
			BridgeClaim *map[string]interface{} `json:"BridgeClaim,omitempty"`

			// BridgeDispute Dispute information (if available)
			BridgeDispute *map[string]interface{} `json:"BridgeDispute,omitempty"`

			// BridgeProof Proof information (if available)
			BridgeProof *map[string]interface{} `json:"BridgeProof,omitempty"`

			// BridgeRefund Refund information
			BridgeRefund *map[string]interface{} `json:"BridgeRefund,omitempty"`

			// BridgeRelay Relay information
			BridgeRelay *map[string]interface{} `json:"BridgeRelay,omitempty"`

			// BridgeRequest Deposit information
			BridgeRequest *map[string]interface{} `json:"BridgeRequest,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}
