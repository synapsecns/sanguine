// Code generated by mockery v2.14.0. DO NOT EDIT.

package mocks

import (
	big "math/big"

	bind "github.com/ethereum/go-ethereum/accounts/abi/bind"
	common "github.com/ethereum/go-ethereum/common"

	event "github.com/ethereum/go-ethereum/event"

	inbox "github.com/synapsecns/sanguine/agents/contracts/inbox"

	mock "github.com/stretchr/testify/mock"

	types "github.com/ethereum/go-ethereum/core/types"
)

// IInbox is an autogenerated mock type for the IInbox type
type IInbox struct {
	mock.Mock
}

// Address provides a mock function with given fields:
func (_m *IInbox) Address() common.Address {
	ret := _m.Called()

	var r0 common.Address
	if rf, ok := ret.Get(0).(func() common.Address); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	return r0
}

// AgentManager provides a mock function with given fields: opts
func (_m *IInbox) AgentManager(opts *bind.CallOpts) (common.Address, error) {
	ret := _m.Called(opts)

	var r0 common.Address
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) common.Address); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Destination provides a mock function with given fields: opts
func (_m *IInbox) Destination(opts *bind.CallOpts) (common.Address, error) {
	ret := _m.Called(opts)

	var r0 common.Address
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) common.Address); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterAttestationAccepted provides a mock function with given fields: opts
func (_m *IInbox) FilterAttestationAccepted(opts *bind.FilterOpts) (*inbox.InboxAttestationAcceptedIterator, error) {
	ret := _m.Called(opts)

	var r0 *inbox.InboxAttestationAcceptedIterator
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts) *inbox.InboxAttestationAcceptedIterator); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inbox.InboxAttestationAcceptedIterator)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.FilterOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterInitialized provides a mock function with given fields: opts
func (_m *IInbox) FilterInitialized(opts *bind.FilterOpts) (*inbox.InboxInitializedIterator, error) {
	ret := _m.Called(opts)

	var r0 *inbox.InboxInitializedIterator
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts) *inbox.InboxInitializedIterator); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inbox.InboxInitializedIterator)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.FilterOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterInvalidAttestation provides a mock function with given fields: opts
func (_m *IInbox) FilterInvalidAttestation(opts *bind.FilterOpts) (*inbox.InboxInvalidAttestationIterator, error) {
	ret := _m.Called(opts)

	var r0 *inbox.InboxInvalidAttestationIterator
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts) *inbox.InboxInvalidAttestationIterator); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inbox.InboxInvalidAttestationIterator)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.FilterOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterInvalidAttestationReport provides a mock function with given fields: opts
func (_m *IInbox) FilterInvalidAttestationReport(opts *bind.FilterOpts) (*inbox.InboxInvalidAttestationReportIterator, error) {
	ret := _m.Called(opts)

	var r0 *inbox.InboxInvalidAttestationReportIterator
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts) *inbox.InboxInvalidAttestationReportIterator); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inbox.InboxInvalidAttestationReportIterator)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.FilterOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterInvalidReceipt provides a mock function with given fields: opts
func (_m *IInbox) FilterInvalidReceipt(opts *bind.FilterOpts) (*inbox.InboxInvalidReceiptIterator, error) {
	ret := _m.Called(opts)

	var r0 *inbox.InboxInvalidReceiptIterator
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts) *inbox.InboxInvalidReceiptIterator); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inbox.InboxInvalidReceiptIterator)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.FilterOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterInvalidReceiptReport provides a mock function with given fields: opts
func (_m *IInbox) FilterInvalidReceiptReport(opts *bind.FilterOpts) (*inbox.InboxInvalidReceiptReportIterator, error) {
	ret := _m.Called(opts)

	var r0 *inbox.InboxInvalidReceiptReportIterator
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts) *inbox.InboxInvalidReceiptReportIterator); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inbox.InboxInvalidReceiptReportIterator)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.FilterOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterInvalidStateReport provides a mock function with given fields: opts
func (_m *IInbox) FilterInvalidStateReport(opts *bind.FilterOpts) (*inbox.InboxInvalidStateReportIterator, error) {
	ret := _m.Called(opts)

	var r0 *inbox.InboxInvalidStateReportIterator
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts) *inbox.InboxInvalidStateReportIterator); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inbox.InboxInvalidStateReportIterator)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.FilterOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterInvalidStateWithAttestation provides a mock function with given fields: opts
func (_m *IInbox) FilterInvalidStateWithAttestation(opts *bind.FilterOpts) (*inbox.InboxInvalidStateWithAttestationIterator, error) {
	ret := _m.Called(opts)

	var r0 *inbox.InboxInvalidStateWithAttestationIterator
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts) *inbox.InboxInvalidStateWithAttestationIterator); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inbox.InboxInvalidStateWithAttestationIterator)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.FilterOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterInvalidStateWithSnapshot provides a mock function with given fields: opts
func (_m *IInbox) FilterInvalidStateWithSnapshot(opts *bind.FilterOpts) (*inbox.InboxInvalidStateWithSnapshotIterator, error) {
	ret := _m.Called(opts)

	var r0 *inbox.InboxInvalidStateWithSnapshotIterator
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts) *inbox.InboxInvalidStateWithSnapshotIterator); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inbox.InboxInvalidStateWithSnapshotIterator)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.FilterOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterOwnershipTransferred provides a mock function with given fields: opts, previousOwner, newOwner
func (_m *IInbox) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*inbox.InboxOwnershipTransferredIterator, error) {
	ret := _m.Called(opts, previousOwner, newOwner)

	var r0 *inbox.InboxOwnershipTransferredIterator
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []common.Address, []common.Address) *inbox.InboxOwnershipTransferredIterator); ok {
		r0 = rf(opts, previousOwner, newOwner)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inbox.InboxOwnershipTransferredIterator)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, []common.Address, []common.Address) error); ok {
		r1 = rf(opts, previousOwner, newOwner)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterReceiptAccepted provides a mock function with given fields: opts
func (_m *IInbox) FilterReceiptAccepted(opts *bind.FilterOpts) (*inbox.InboxReceiptAcceptedIterator, error) {
	ret := _m.Called(opts)

	var r0 *inbox.InboxReceiptAcceptedIterator
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts) *inbox.InboxReceiptAcceptedIterator); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inbox.InboxReceiptAcceptedIterator)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.FilterOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterSnapshotAccepted provides a mock function with given fields: opts, domain, agent
func (_m *IInbox) FilterSnapshotAccepted(opts *bind.FilterOpts, domain []uint32, agent []common.Address) (*inbox.InboxSnapshotAcceptedIterator, error) {
	ret := _m.Called(opts, domain, agent)

	var r0 *inbox.InboxSnapshotAcceptedIterator
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []uint32, []common.Address) *inbox.InboxSnapshotAcceptedIterator); ok {
		r0 = rf(opts, domain, agent)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inbox.InboxSnapshotAcceptedIterator)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, []uint32, []common.Address) error); ok {
		r1 = rf(opts, domain, agent)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetGuardReport provides a mock function with given fields: opts, index
func (_m *IInbox) GetGuardReport(opts *bind.CallOpts, index *big.Int) (struct {
	StatementPayload []byte
	ReportSignature  []byte
}, error) {
	ret := _m.Called(opts, index)

	var r0 struct {
		StatementPayload []byte
		ReportSignature  []byte
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, *big.Int) struct {
		StatementPayload []byte
		ReportSignature  []byte
	}); ok {
		r0 = rf(opts, index)
	} else {
		r0 = ret.Get(0).(struct {
			StatementPayload []byte
			ReportSignature  []byte
		})
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts, *big.Int) error); ok {
		r1 = rf(opts, index)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetReportsAmount provides a mock function with given fields: opts
func (_m *IInbox) GetReportsAmount(opts *bind.CallOpts) (*big.Int, error) {
	ret := _m.Called(opts)

	var r0 *big.Int
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) *big.Int); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetStoredSignature provides a mock function with given fields: opts, index
func (_m *IInbox) GetStoredSignature(opts *bind.CallOpts, index *big.Int) ([]byte, error) {
	ret := _m.Called(opts, index)

	var r0 []byte
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, *big.Int) []byte); ok {
		r0 = rf(opts, index)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts, *big.Int) error); ok {
		r1 = rf(opts, index)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Initialize provides a mock function with given fields: opts, agentManager_, origin_, destination_, summit_
func (_m *IInbox) Initialize(opts *bind.TransactOpts, agentManager_ common.Address, origin_ common.Address, destination_ common.Address, summit_ common.Address) (*types.Transaction, error) {
	ret := _m.Called(opts, agentManager_, origin_, destination_, summit_)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, common.Address, common.Address, common.Address, common.Address) *types.Transaction); ok {
		r0 = rf(opts, agentManager_, origin_, destination_, summit_)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, common.Address, common.Address, common.Address, common.Address) error); ok {
		r1 = rf(opts, agentManager_, origin_, destination_, summit_)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LocalDomain provides a mock function with given fields: opts
func (_m *IInbox) LocalDomain(opts *bind.CallOpts) (uint32, error) {
	ret := _m.Called(opts)

	var r0 uint32
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) uint32); ok {
		r0 = rf(opts)
	} else {
		r0 = ret.Get(0).(uint32)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Multicall provides a mock function with given fields: opts, calls
func (_m *IInbox) Multicall(opts *bind.TransactOpts, calls []inbox.MultiCallableCall) (*types.Transaction, error) {
	ret := _m.Called(opts, calls)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, []inbox.MultiCallableCall) *types.Transaction); ok {
		r0 = rf(opts, calls)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, []inbox.MultiCallableCall) error); ok {
		r1 = rf(opts, calls)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Origin provides a mock function with given fields: opts
func (_m *IInbox) Origin(opts *bind.CallOpts) (common.Address, error) {
	ret := _m.Called(opts)

	var r0 common.Address
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) common.Address); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Owner provides a mock function with given fields: opts
func (_m *IInbox) Owner(opts *bind.CallOpts) (common.Address, error) {
	ret := _m.Called(opts)

	var r0 common.Address
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) common.Address); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseAttestationAccepted provides a mock function with given fields: log
func (_m *IInbox) ParseAttestationAccepted(log types.Log) (*inbox.InboxAttestationAccepted, error) {
	ret := _m.Called(log)

	var r0 *inbox.InboxAttestationAccepted
	if rf, ok := ret.Get(0).(func(types.Log) *inbox.InboxAttestationAccepted); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inbox.InboxAttestationAccepted)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseInitialized provides a mock function with given fields: log
func (_m *IInbox) ParseInitialized(log types.Log) (*inbox.InboxInitialized, error) {
	ret := _m.Called(log)

	var r0 *inbox.InboxInitialized
	if rf, ok := ret.Get(0).(func(types.Log) *inbox.InboxInitialized); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inbox.InboxInitialized)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseInvalidAttestation provides a mock function with given fields: log
func (_m *IInbox) ParseInvalidAttestation(log types.Log) (*inbox.InboxInvalidAttestation, error) {
	ret := _m.Called(log)

	var r0 *inbox.InboxInvalidAttestation
	if rf, ok := ret.Get(0).(func(types.Log) *inbox.InboxInvalidAttestation); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inbox.InboxInvalidAttestation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseInvalidAttestationReport provides a mock function with given fields: log
func (_m *IInbox) ParseInvalidAttestationReport(log types.Log) (*inbox.InboxInvalidAttestationReport, error) {
	ret := _m.Called(log)

	var r0 *inbox.InboxInvalidAttestationReport
	if rf, ok := ret.Get(0).(func(types.Log) *inbox.InboxInvalidAttestationReport); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inbox.InboxInvalidAttestationReport)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseInvalidReceipt provides a mock function with given fields: log
func (_m *IInbox) ParseInvalidReceipt(log types.Log) (*inbox.InboxInvalidReceipt, error) {
	ret := _m.Called(log)

	var r0 *inbox.InboxInvalidReceipt
	if rf, ok := ret.Get(0).(func(types.Log) *inbox.InboxInvalidReceipt); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inbox.InboxInvalidReceipt)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseInvalidReceiptReport provides a mock function with given fields: log
func (_m *IInbox) ParseInvalidReceiptReport(log types.Log) (*inbox.InboxInvalidReceiptReport, error) {
	ret := _m.Called(log)

	var r0 *inbox.InboxInvalidReceiptReport
	if rf, ok := ret.Get(0).(func(types.Log) *inbox.InboxInvalidReceiptReport); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inbox.InboxInvalidReceiptReport)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseInvalidStateReport provides a mock function with given fields: log
func (_m *IInbox) ParseInvalidStateReport(log types.Log) (*inbox.InboxInvalidStateReport, error) {
	ret := _m.Called(log)

	var r0 *inbox.InboxInvalidStateReport
	if rf, ok := ret.Get(0).(func(types.Log) *inbox.InboxInvalidStateReport); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inbox.InboxInvalidStateReport)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseInvalidStateWithAttestation provides a mock function with given fields: log
func (_m *IInbox) ParseInvalidStateWithAttestation(log types.Log) (*inbox.InboxInvalidStateWithAttestation, error) {
	ret := _m.Called(log)

	var r0 *inbox.InboxInvalidStateWithAttestation
	if rf, ok := ret.Get(0).(func(types.Log) *inbox.InboxInvalidStateWithAttestation); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inbox.InboxInvalidStateWithAttestation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseInvalidStateWithSnapshot provides a mock function with given fields: log
func (_m *IInbox) ParseInvalidStateWithSnapshot(log types.Log) (*inbox.InboxInvalidStateWithSnapshot, error) {
	ret := _m.Called(log)

	var r0 *inbox.InboxInvalidStateWithSnapshot
	if rf, ok := ret.Get(0).(func(types.Log) *inbox.InboxInvalidStateWithSnapshot); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inbox.InboxInvalidStateWithSnapshot)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseOwnershipTransferred provides a mock function with given fields: log
func (_m *IInbox) ParseOwnershipTransferred(log types.Log) (*inbox.InboxOwnershipTransferred, error) {
	ret := _m.Called(log)

	var r0 *inbox.InboxOwnershipTransferred
	if rf, ok := ret.Get(0).(func(types.Log) *inbox.InboxOwnershipTransferred); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inbox.InboxOwnershipTransferred)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseReceiptAccepted provides a mock function with given fields: log
func (_m *IInbox) ParseReceiptAccepted(log types.Log) (*inbox.InboxReceiptAccepted, error) {
	ret := _m.Called(log)

	var r0 *inbox.InboxReceiptAccepted
	if rf, ok := ret.Get(0).(func(types.Log) *inbox.InboxReceiptAccepted); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inbox.InboxReceiptAccepted)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseSnapshotAccepted provides a mock function with given fields: log
func (_m *IInbox) ParseSnapshotAccepted(log types.Log) (*inbox.InboxSnapshotAccepted, error) {
	ret := _m.Called(log)

	var r0 *inbox.InboxSnapshotAccepted
	if rf, ok := ret.Get(0).(func(types.Log) *inbox.InboxSnapshotAccepted); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*inbox.InboxSnapshotAccepted)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PassReceipt provides a mock function with given fields: opts, attNotaryIndex, attNonce, paddedTips, rcptPayload
func (_m *IInbox) PassReceipt(opts *bind.TransactOpts, attNotaryIndex uint32, attNonce uint32, paddedTips *big.Int, rcptPayload []byte) (*types.Transaction, error) {
	ret := _m.Called(opts, attNotaryIndex, attNonce, paddedTips, rcptPayload)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, uint32, uint32, *big.Int, []byte) *types.Transaction); ok {
		r0 = rf(opts, attNotaryIndex, attNonce, paddedTips, rcptPayload)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, uint32, uint32, *big.Int, []byte) error); ok {
		r1 = rf(opts, attNotaryIndex, attNonce, paddedTips, rcptPayload)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RenounceOwnership provides a mock function with given fields: opts
func (_m *IInbox) RenounceOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	ret := _m.Called(opts)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts) *types.Transaction); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SubmitReceipt provides a mock function with given fields: opts, rcptPayload, rcptSignature, paddedTips, headerHash, bodyHash
func (_m *IInbox) SubmitReceipt(opts *bind.TransactOpts, rcptPayload []byte, rcptSignature []byte, paddedTips *big.Int, headerHash [32]byte, bodyHash [32]byte) (*types.Transaction, error) {
	ret := _m.Called(opts, rcptPayload, rcptSignature, paddedTips, headerHash, bodyHash)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, []byte, []byte, *big.Int, [32]byte, [32]byte) *types.Transaction); ok {
		r0 = rf(opts, rcptPayload, rcptSignature, paddedTips, headerHash, bodyHash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, []byte, []byte, *big.Int, [32]byte, [32]byte) error); ok {
		r1 = rf(opts, rcptPayload, rcptSignature, paddedTips, headerHash, bodyHash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SubmitReceiptReport provides a mock function with given fields: opts, rcptPayload, rcptSignature, rrSignature
func (_m *IInbox) SubmitReceiptReport(opts *bind.TransactOpts, rcptPayload []byte, rcptSignature []byte, rrSignature []byte) (*types.Transaction, error) {
	ret := _m.Called(opts, rcptPayload, rcptSignature, rrSignature)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, []byte, []byte, []byte) *types.Transaction); ok {
		r0 = rf(opts, rcptPayload, rcptSignature, rrSignature)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, []byte, []byte, []byte) error); ok {
		r1 = rf(opts, rcptPayload, rcptSignature, rrSignature)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SubmitSnapshot provides a mock function with given fields: opts, snapPayload, snapSignature
func (_m *IInbox) SubmitSnapshot(opts *bind.TransactOpts, snapPayload []byte, snapSignature []byte) (*types.Transaction, error) {
	ret := _m.Called(opts, snapPayload, snapSignature)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, []byte, []byte) *types.Transaction); ok {
		r0 = rf(opts, snapPayload, snapSignature)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, []byte, []byte) error); ok {
		r1 = rf(opts, snapPayload, snapSignature)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SubmitStateReportWithAttestation provides a mock function with given fields: opts, stateIndex, srSignature, snapPayload, attPayload, attSignature
func (_m *IInbox) SubmitStateReportWithAttestation(opts *bind.TransactOpts, stateIndex *big.Int, srSignature []byte, snapPayload []byte, attPayload []byte, attSignature []byte) (*types.Transaction, error) {
	ret := _m.Called(opts, stateIndex, srSignature, snapPayload, attPayload, attSignature)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, *big.Int, []byte, []byte, []byte, []byte) *types.Transaction); ok {
		r0 = rf(opts, stateIndex, srSignature, snapPayload, attPayload, attSignature)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, *big.Int, []byte, []byte, []byte, []byte) error); ok {
		r1 = rf(opts, stateIndex, srSignature, snapPayload, attPayload, attSignature)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SubmitStateReportWithSnapshot provides a mock function with given fields: opts, stateIndex, srSignature, snapPayload, snapSignature
func (_m *IInbox) SubmitStateReportWithSnapshot(opts *bind.TransactOpts, stateIndex *big.Int, srSignature []byte, snapPayload []byte, snapSignature []byte) (*types.Transaction, error) {
	ret := _m.Called(opts, stateIndex, srSignature, snapPayload, snapSignature)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, *big.Int, []byte, []byte, []byte) *types.Transaction); ok {
		r0 = rf(opts, stateIndex, srSignature, snapPayload, snapSignature)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, *big.Int, []byte, []byte, []byte) error); ok {
		r1 = rf(opts, stateIndex, srSignature, snapPayload, snapSignature)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SubmitStateReportWithSnapshotProof provides a mock function with given fields: opts, stateIndex, statePayload, srSignature, snapProof, attPayload, attSignature
func (_m *IInbox) SubmitStateReportWithSnapshotProof(opts *bind.TransactOpts, stateIndex *big.Int, statePayload []byte, srSignature []byte, snapProof [][32]byte, attPayload []byte, attSignature []byte) (*types.Transaction, error) {
	ret := _m.Called(opts, stateIndex, statePayload, srSignature, snapProof, attPayload, attSignature)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, *big.Int, []byte, []byte, [][32]byte, []byte, []byte) *types.Transaction); ok {
		r0 = rf(opts, stateIndex, statePayload, srSignature, snapProof, attPayload, attSignature)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, *big.Int, []byte, []byte, [][32]byte, []byte, []byte) error); ok {
		r1 = rf(opts, stateIndex, statePayload, srSignature, snapProof, attPayload, attSignature)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Summit provides a mock function with given fields: opts
func (_m *IInbox) Summit(opts *bind.CallOpts) (common.Address, error) {
	ret := _m.Called(opts)

	var r0 common.Address
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) common.Address); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SynapseDomain provides a mock function with given fields: opts
func (_m *IInbox) SynapseDomain(opts *bind.CallOpts) (uint32, error) {
	ret := _m.Called(opts)

	var r0 uint32
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) uint32); ok {
		r0 = rf(opts)
	} else {
		r0 = ret.Get(0).(uint32)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TransferOwnership provides a mock function with given fields: opts, newOwner
func (_m *IInbox) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	ret := _m.Called(opts, newOwner)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, common.Address) *types.Transaction); ok {
		r0 = rf(opts, newOwner)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, common.Address) error); ok {
		r1 = rf(opts, newOwner)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// VerifyAttestation provides a mock function with given fields: opts, attPayload, attSignature
func (_m *IInbox) VerifyAttestation(opts *bind.TransactOpts, attPayload []byte, attSignature []byte) (*types.Transaction, error) {
	ret := _m.Called(opts, attPayload, attSignature)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, []byte, []byte) *types.Transaction); ok {
		r0 = rf(opts, attPayload, attSignature)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, []byte, []byte) error); ok {
		r1 = rf(opts, attPayload, attSignature)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// VerifyAttestationReport provides a mock function with given fields: opts, attPayload, arSignature
func (_m *IInbox) VerifyAttestationReport(opts *bind.TransactOpts, attPayload []byte, arSignature []byte) (*types.Transaction, error) {
	ret := _m.Called(opts, attPayload, arSignature)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, []byte, []byte) *types.Transaction); ok {
		r0 = rf(opts, attPayload, arSignature)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, []byte, []byte) error); ok {
		r1 = rf(opts, attPayload, arSignature)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// VerifyReceipt provides a mock function with given fields: opts, rcptPayload, rcptSignature
func (_m *IInbox) VerifyReceipt(opts *bind.TransactOpts, rcptPayload []byte, rcptSignature []byte) (*types.Transaction, error) {
	ret := _m.Called(opts, rcptPayload, rcptSignature)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, []byte, []byte) *types.Transaction); ok {
		r0 = rf(opts, rcptPayload, rcptSignature)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, []byte, []byte) error); ok {
		r1 = rf(opts, rcptPayload, rcptSignature)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// VerifyReceiptReport provides a mock function with given fields: opts, rcptPayload, rrSignature
func (_m *IInbox) VerifyReceiptReport(opts *bind.TransactOpts, rcptPayload []byte, rrSignature []byte) (*types.Transaction, error) {
	ret := _m.Called(opts, rcptPayload, rrSignature)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, []byte, []byte) *types.Transaction); ok {
		r0 = rf(opts, rcptPayload, rrSignature)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, []byte, []byte) error); ok {
		r1 = rf(opts, rcptPayload, rrSignature)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// VerifyStateReport provides a mock function with given fields: opts, statePayload, srSignature
func (_m *IInbox) VerifyStateReport(opts *bind.TransactOpts, statePayload []byte, srSignature []byte) (*types.Transaction, error) {
	ret := _m.Called(opts, statePayload, srSignature)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, []byte, []byte) *types.Transaction); ok {
		r0 = rf(opts, statePayload, srSignature)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, []byte, []byte) error); ok {
		r1 = rf(opts, statePayload, srSignature)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// VerifyStateWithAttestation provides a mock function with given fields: opts, stateIndex, snapPayload, attPayload, attSignature
func (_m *IInbox) VerifyStateWithAttestation(opts *bind.TransactOpts, stateIndex *big.Int, snapPayload []byte, attPayload []byte, attSignature []byte) (*types.Transaction, error) {
	ret := _m.Called(opts, stateIndex, snapPayload, attPayload, attSignature)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, *big.Int, []byte, []byte, []byte) *types.Transaction); ok {
		r0 = rf(opts, stateIndex, snapPayload, attPayload, attSignature)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, *big.Int, []byte, []byte, []byte) error); ok {
		r1 = rf(opts, stateIndex, snapPayload, attPayload, attSignature)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// VerifyStateWithSnapshot provides a mock function with given fields: opts, stateIndex, snapPayload, snapSignature
func (_m *IInbox) VerifyStateWithSnapshot(opts *bind.TransactOpts, stateIndex *big.Int, snapPayload []byte, snapSignature []byte) (*types.Transaction, error) {
	ret := _m.Called(opts, stateIndex, snapPayload, snapSignature)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, *big.Int, []byte, []byte) *types.Transaction); ok {
		r0 = rf(opts, stateIndex, snapPayload, snapSignature)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, *big.Int, []byte, []byte) error); ok {
		r1 = rf(opts, stateIndex, snapPayload, snapSignature)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// VerifyStateWithSnapshotProof provides a mock function with given fields: opts, stateIndex, statePayload, snapProof, attPayload, attSignature
func (_m *IInbox) VerifyStateWithSnapshotProof(opts *bind.TransactOpts, stateIndex *big.Int, statePayload []byte, snapProof [][32]byte, attPayload []byte, attSignature []byte) (*types.Transaction, error) {
	ret := _m.Called(opts, stateIndex, statePayload, snapProof, attPayload, attSignature)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, *big.Int, []byte, [][32]byte, []byte, []byte) *types.Transaction); ok {
		r0 = rf(opts, stateIndex, statePayload, snapProof, attPayload, attSignature)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, *big.Int, []byte, [][32]byte, []byte, []byte) error); ok {
		r1 = rf(opts, stateIndex, statePayload, snapProof, attPayload, attSignature)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Version provides a mock function with given fields: opts
func (_m *IInbox) Version(opts *bind.CallOpts) (string, error) {
	ret := _m.Called(opts)

	var r0 string
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) string); ok {
		r0 = rf(opts)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchAttestationAccepted provides a mock function with given fields: opts, sink
func (_m *IInbox) WatchAttestationAccepted(opts *bind.WatchOpts, sink chan<- *inbox.InboxAttestationAccepted) (event.Subscription, error) {
	ret := _m.Called(opts, sink)

	var r0 event.Subscription
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *inbox.InboxAttestationAccepted) event.Subscription); ok {
		r0 = rf(opts, sink)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *inbox.InboxAttestationAccepted) error); ok {
		r1 = rf(opts, sink)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchInitialized provides a mock function with given fields: opts, sink
func (_m *IInbox) WatchInitialized(opts *bind.WatchOpts, sink chan<- *inbox.InboxInitialized) (event.Subscription, error) {
	ret := _m.Called(opts, sink)

	var r0 event.Subscription
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *inbox.InboxInitialized) event.Subscription); ok {
		r0 = rf(opts, sink)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *inbox.InboxInitialized) error); ok {
		r1 = rf(opts, sink)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchInvalidAttestation provides a mock function with given fields: opts, sink
func (_m *IInbox) WatchInvalidAttestation(opts *bind.WatchOpts, sink chan<- *inbox.InboxInvalidAttestation) (event.Subscription, error) {
	ret := _m.Called(opts, sink)

	var r0 event.Subscription
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *inbox.InboxInvalidAttestation) event.Subscription); ok {
		r0 = rf(opts, sink)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *inbox.InboxInvalidAttestation) error); ok {
		r1 = rf(opts, sink)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchInvalidAttestationReport provides a mock function with given fields: opts, sink
func (_m *IInbox) WatchInvalidAttestationReport(opts *bind.WatchOpts, sink chan<- *inbox.InboxInvalidAttestationReport) (event.Subscription, error) {
	ret := _m.Called(opts, sink)

	var r0 event.Subscription
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *inbox.InboxInvalidAttestationReport) event.Subscription); ok {
		r0 = rf(opts, sink)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *inbox.InboxInvalidAttestationReport) error); ok {
		r1 = rf(opts, sink)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchInvalidReceipt provides a mock function with given fields: opts, sink
func (_m *IInbox) WatchInvalidReceipt(opts *bind.WatchOpts, sink chan<- *inbox.InboxInvalidReceipt) (event.Subscription, error) {
	ret := _m.Called(opts, sink)

	var r0 event.Subscription
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *inbox.InboxInvalidReceipt) event.Subscription); ok {
		r0 = rf(opts, sink)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *inbox.InboxInvalidReceipt) error); ok {
		r1 = rf(opts, sink)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchInvalidReceiptReport provides a mock function with given fields: opts, sink
func (_m *IInbox) WatchInvalidReceiptReport(opts *bind.WatchOpts, sink chan<- *inbox.InboxInvalidReceiptReport) (event.Subscription, error) {
	ret := _m.Called(opts, sink)

	var r0 event.Subscription
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *inbox.InboxInvalidReceiptReport) event.Subscription); ok {
		r0 = rf(opts, sink)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *inbox.InboxInvalidReceiptReport) error); ok {
		r1 = rf(opts, sink)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchInvalidStateReport provides a mock function with given fields: opts, sink
func (_m *IInbox) WatchInvalidStateReport(opts *bind.WatchOpts, sink chan<- *inbox.InboxInvalidStateReport) (event.Subscription, error) {
	ret := _m.Called(opts, sink)

	var r0 event.Subscription
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *inbox.InboxInvalidStateReport) event.Subscription); ok {
		r0 = rf(opts, sink)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *inbox.InboxInvalidStateReport) error); ok {
		r1 = rf(opts, sink)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchInvalidStateWithAttestation provides a mock function with given fields: opts, sink
func (_m *IInbox) WatchInvalidStateWithAttestation(opts *bind.WatchOpts, sink chan<- *inbox.InboxInvalidStateWithAttestation) (event.Subscription, error) {
	ret := _m.Called(opts, sink)

	var r0 event.Subscription
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *inbox.InboxInvalidStateWithAttestation) event.Subscription); ok {
		r0 = rf(opts, sink)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *inbox.InboxInvalidStateWithAttestation) error); ok {
		r1 = rf(opts, sink)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchInvalidStateWithSnapshot provides a mock function with given fields: opts, sink
func (_m *IInbox) WatchInvalidStateWithSnapshot(opts *bind.WatchOpts, sink chan<- *inbox.InboxInvalidStateWithSnapshot) (event.Subscription, error) {
	ret := _m.Called(opts, sink)

	var r0 event.Subscription
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *inbox.InboxInvalidStateWithSnapshot) event.Subscription); ok {
		r0 = rf(opts, sink)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *inbox.InboxInvalidStateWithSnapshot) error); ok {
		r1 = rf(opts, sink)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchOwnershipTransferred provides a mock function with given fields: opts, sink, previousOwner, newOwner
func (_m *IInbox) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *inbox.InboxOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {
	ret := _m.Called(opts, sink, previousOwner, newOwner)

	var r0 event.Subscription
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *inbox.InboxOwnershipTransferred, []common.Address, []common.Address) event.Subscription); ok {
		r0 = rf(opts, sink, previousOwner, newOwner)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *inbox.InboxOwnershipTransferred, []common.Address, []common.Address) error); ok {
		r1 = rf(opts, sink, previousOwner, newOwner)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchReceiptAccepted provides a mock function with given fields: opts, sink
func (_m *IInbox) WatchReceiptAccepted(opts *bind.WatchOpts, sink chan<- *inbox.InboxReceiptAccepted) (event.Subscription, error) {
	ret := _m.Called(opts, sink)

	var r0 event.Subscription
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *inbox.InboxReceiptAccepted) event.Subscription); ok {
		r0 = rf(opts, sink)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *inbox.InboxReceiptAccepted) error); ok {
		r1 = rf(opts, sink)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchSnapshotAccepted provides a mock function with given fields: opts, sink, domain, agent
func (_m *IInbox) WatchSnapshotAccepted(opts *bind.WatchOpts, sink chan<- *inbox.InboxSnapshotAccepted, domain []uint32, agent []common.Address) (event.Subscription, error) {
	ret := _m.Called(opts, sink, domain, agent)

	var r0 event.Subscription
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *inbox.InboxSnapshotAccepted, []uint32, []common.Address) event.Subscription); ok {
		r0 = rf(opts, sink, domain, agent)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *inbox.InboxSnapshotAccepted, []uint32, []common.Address) error); ok {
		r1 = rf(opts, sink, domain, agent)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type mockConstructorTestingTNewIInbox interface {
	mock.TestingT
	Cleanup(func())
}

// NewIInbox creates a new instance of IInbox. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewIInbox(t mockConstructorTestingTNewIInbox) *IInbox {
	mock := &IInbox{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
