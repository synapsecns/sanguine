// Code generated by mockery v2.14.0. DO NOT EDIT.

package mocks

import (
	big "math/big"

	bind "github.com/ethereum/go-ethereum/accounts/abi/bind"
	common "github.com/ethereum/go-ethereum/common"

	event "github.com/ethereum/go-ethereum/event"

	gasoracle "github.com/synapsecns/sanguine/agents/contracts/gasoracle"

	mock "github.com/stretchr/testify/mock"

	types "github.com/ethereum/go-ethereum/core/types"
)

// IGasOracle is an autogenerated mock type for the IGasOracle type
type IGasOracle struct {
	mock.Mock
}

// Address provides a mock function with given fields:
func (_m *IGasOracle) Address() common.Address {
	ret := _m.Called()

	var r0 common.Address
	if rf, ok := ret.Get(0).(func() common.Address); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	return r0
}

// Destination provides a mock function with given fields: opts
func (_m *IGasOracle) Destination(opts *bind.CallOpts) (common.Address, error) {
	ret := _m.Called(opts)

	var r0 common.Address
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) common.Address); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterGasDataUpdated provides a mock function with given fields: opts
func (_m *IGasOracle) FilterGasDataUpdated(opts *bind.FilterOpts) (*gasoracle.GasOracleGasDataUpdatedIterator, error) {
	ret := _m.Called(opts)

	var r0 *gasoracle.GasOracleGasDataUpdatedIterator
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts) *gasoracle.GasOracleGasDataUpdatedIterator); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gasoracle.GasOracleGasDataUpdatedIterator)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.FilterOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterInitialized provides a mock function with given fields: opts
func (_m *IGasOracle) FilterInitialized(opts *bind.FilterOpts) (*gasoracle.GasOracleInitializedIterator, error) {
	ret := _m.Called(opts)

	var r0 *gasoracle.GasOracleInitializedIterator
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts) *gasoracle.GasOracleInitializedIterator); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gasoracle.GasOracleInitializedIterator)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.FilterOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterOwnershipTransferred provides a mock function with given fields: opts, previousOwner, newOwner
func (_m *IGasOracle) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*gasoracle.GasOracleOwnershipTransferredIterator, error) {
	ret := _m.Called(opts, previousOwner, newOwner)

	var r0 *gasoracle.GasOracleOwnershipTransferredIterator
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []common.Address, []common.Address) *gasoracle.GasOracleOwnershipTransferredIterator); ok {
		r0 = rf(opts, previousOwner, newOwner)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gasoracle.GasOracleOwnershipTransferredIterator)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, []common.Address, []common.Address) error); ok {
		r1 = rf(opts, previousOwner, newOwner)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GASDATADECREASEDOPTIMISTICPERIOD provides a mock function with given fields: opts
func (_m *IGasOracle) GASDATADECREASEDOPTIMISTICPERIOD(opts *bind.CallOpts) (*big.Int, error) {
	ret := _m.Called(opts)

	var r0 *big.Int
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) *big.Int); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GASDATAINCREASEDOPTIMISTICPERIOD provides a mock function with given fields: opts
func (_m *IGasOracle) GASDATAINCREASEDOPTIMISTICPERIOD(opts *bind.CallOpts) (*big.Int, error) {
	ret := _m.Called(opts)

	var r0 *big.Int
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) *big.Int); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDecodedGasData provides a mock function with given fields: opts, domain
func (_m *IGasOracle) GetDecodedGasData(opts *bind.CallOpts, domain uint32) (struct {
	GasPrice     *big.Int
	DataPrice    *big.Int
	ExecBuffer   *big.Int
	AmortAttCost *big.Int
	EtherPrice   *big.Int
	Markup       *big.Int
}, error) {
	ret := _m.Called(opts, domain)

	var r0 struct {
		GasPrice     *big.Int
		DataPrice    *big.Int
		ExecBuffer   *big.Int
		AmortAttCost *big.Int
		EtherPrice   *big.Int
		Markup       *big.Int
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, uint32) struct {
		GasPrice     *big.Int
		DataPrice    *big.Int
		ExecBuffer   *big.Int
		AmortAttCost *big.Int
		EtherPrice   *big.Int
		Markup       *big.Int
	}); ok {
		r0 = rf(opts, domain)
	} else {
		r0 = ret.Get(0).(struct {
			GasPrice     *big.Int
			DataPrice    *big.Int
			ExecBuffer   *big.Int
			AmortAttCost *big.Int
			EtherPrice   *big.Int
			Markup       *big.Int
		})
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts, uint32) error); ok {
		r1 = rf(opts, domain)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetGasData provides a mock function with given fields: opts
func (_m *IGasOracle) GetGasData(opts *bind.CallOpts) (*big.Int, error) {
	ret := _m.Called(opts)

	var r0 *big.Int
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) *big.Int); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMinimumTips provides a mock function with given fields: opts, destination_, paddedRequest, contentLength
func (_m *IGasOracle) GetMinimumTips(opts *bind.CallOpts, destination_ uint32, paddedRequest *big.Int, contentLength *big.Int) (*big.Int, error) {
	ret := _m.Called(opts, destination_, paddedRequest, contentLength)

	var r0 *big.Int
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, uint32, *big.Int, *big.Int) *big.Int); ok {
		r0 = rf(opts, destination_, paddedRequest, contentLength)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts, uint32, *big.Int, *big.Int) error); ok {
		r1 = rf(opts, destination_, paddedRequest, contentLength)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Initialize provides a mock function with given fields: opts
func (_m *IGasOracle) Initialize(opts *bind.TransactOpts) (*types.Transaction, error) {
	ret := _m.Called(opts)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts) *types.Transaction); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LocalDomain provides a mock function with given fields: opts
func (_m *IGasOracle) LocalDomain(opts *bind.CallOpts) (uint32, error) {
	ret := _m.Called(opts)

	var r0 uint32
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) uint32); ok {
		r0 = rf(opts)
	} else {
		r0 = ret.Get(0).(uint32)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Multicall provides a mock function with given fields: opts, calls
func (_m *IGasOracle) Multicall(opts *bind.TransactOpts, calls []gasoracle.MultiCallableCall) (*types.Transaction, error) {
	ret := _m.Called(opts, calls)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, []gasoracle.MultiCallableCall) *types.Transaction); ok {
		r0 = rf(opts, calls)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, []gasoracle.MultiCallableCall) error); ok {
		r1 = rf(opts, calls)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Owner provides a mock function with given fields: opts
func (_m *IGasOracle) Owner(opts *bind.CallOpts) (common.Address, error) {
	ret := _m.Called(opts)

	var r0 common.Address
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) common.Address); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseGasDataUpdated provides a mock function with given fields: log
func (_m *IGasOracle) ParseGasDataUpdated(log types.Log) (*gasoracle.GasOracleGasDataUpdated, error) {
	ret := _m.Called(log)

	var r0 *gasoracle.GasOracleGasDataUpdated
	if rf, ok := ret.Get(0).(func(types.Log) *gasoracle.GasOracleGasDataUpdated); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gasoracle.GasOracleGasDataUpdated)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseInitialized provides a mock function with given fields: log
func (_m *IGasOracle) ParseInitialized(log types.Log) (*gasoracle.GasOracleInitialized, error) {
	ret := _m.Called(log)

	var r0 *gasoracle.GasOracleInitialized
	if rf, ok := ret.Get(0).(func(types.Log) *gasoracle.GasOracleInitialized); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gasoracle.GasOracleInitialized)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseOwnershipTransferred provides a mock function with given fields: log
func (_m *IGasOracle) ParseOwnershipTransferred(log types.Log) (*gasoracle.GasOracleOwnershipTransferred, error) {
	ret := _m.Called(log)

	var r0 *gasoracle.GasOracleOwnershipTransferred
	if rf, ok := ret.Get(0).(func(types.Log) *gasoracle.GasOracleOwnershipTransferred); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gasoracle.GasOracleOwnershipTransferred)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RenounceOwnership provides a mock function with given fields: opts
func (_m *IGasOracle) RenounceOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	ret := _m.Called(opts)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts) *types.Transaction); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetGasData provides a mock function with given fields: opts, domain, gasPrice, dataPrice, execBuffer, amortAttCost, etherPrice, markup
func (_m *IGasOracle) SetGasData(opts *bind.TransactOpts, domain uint32, gasPrice *big.Int, dataPrice *big.Int, execBuffer *big.Int, amortAttCost *big.Int, etherPrice *big.Int, markup *big.Int) (*types.Transaction, error) {
	ret := _m.Called(opts, domain, gasPrice, dataPrice, execBuffer, amortAttCost, etherPrice, markup)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, uint32, *big.Int, *big.Int, *big.Int, *big.Int, *big.Int, *big.Int) *types.Transaction); ok {
		r0 = rf(opts, domain, gasPrice, dataPrice, execBuffer, amortAttCost, etherPrice, markup)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, uint32, *big.Int, *big.Int, *big.Int, *big.Int, *big.Int, *big.Int) error); ok {
		r1 = rf(opts, domain, gasPrice, dataPrice, execBuffer, amortAttCost, etherPrice, markup)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetSummitTip provides a mock function with given fields: opts, summitTipWei
func (_m *IGasOracle) SetSummitTip(opts *bind.TransactOpts, summitTipWei *big.Int) (*types.Transaction, error) {
	ret := _m.Called(opts, summitTipWei)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, *big.Int) *types.Transaction); ok {
		r0 = rf(opts, summitTipWei)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, *big.Int) error); ok {
		r1 = rf(opts, summitTipWei)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TransferOwnership provides a mock function with given fields: opts, newOwner
func (_m *IGasOracle) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	ret := _m.Called(opts, newOwner)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, common.Address) *types.Transaction); ok {
		r0 = rf(opts, newOwner)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, common.Address) error); ok {
		r1 = rf(opts, newOwner)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateGasData provides a mock function with given fields: opts, domain
func (_m *IGasOracle) UpdateGasData(opts *bind.TransactOpts, domain uint32) (*types.Transaction, error) {
	ret := _m.Called(opts, domain)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, uint32) *types.Transaction); ok {
		r0 = rf(opts, domain)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, uint32) error); ok {
		r1 = rf(opts, domain)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Version provides a mock function with given fields: opts
func (_m *IGasOracle) Version(opts *bind.CallOpts) (string, error) {
	ret := _m.Called(opts)

	var r0 string
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) string); ok {
		r0 = rf(opts)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchGasDataUpdated provides a mock function with given fields: opts, sink
func (_m *IGasOracle) WatchGasDataUpdated(opts *bind.WatchOpts, sink chan<- *gasoracle.GasOracleGasDataUpdated) (event.Subscription, error) {
	ret := _m.Called(opts, sink)

	var r0 event.Subscription
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *gasoracle.GasOracleGasDataUpdated) event.Subscription); ok {
		r0 = rf(opts, sink)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *gasoracle.GasOracleGasDataUpdated) error); ok {
		r1 = rf(opts, sink)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchInitialized provides a mock function with given fields: opts, sink
func (_m *IGasOracle) WatchInitialized(opts *bind.WatchOpts, sink chan<- *gasoracle.GasOracleInitialized) (event.Subscription, error) {
	ret := _m.Called(opts, sink)

	var r0 event.Subscription
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *gasoracle.GasOracleInitialized) event.Subscription); ok {
		r0 = rf(opts, sink)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *gasoracle.GasOracleInitialized) error); ok {
		r1 = rf(opts, sink)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchOwnershipTransferred provides a mock function with given fields: opts, sink, previousOwner, newOwner
func (_m *IGasOracle) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *gasoracle.GasOracleOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {
	ret := _m.Called(opts, sink, previousOwner, newOwner)

	var r0 event.Subscription
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *gasoracle.GasOracleOwnershipTransferred, []common.Address, []common.Address) event.Subscription); ok {
		r0 = rf(opts, sink, previousOwner, newOwner)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *gasoracle.GasOracleOwnershipTransferred, []common.Address, []common.Address) error); ok {
		r1 = rf(opts, sink, previousOwner, newOwner)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type mockConstructorTestingTNewIGasOracle interface {
	mock.TestingT
	Cleanup(func())
}

// NewIGasOracle creates a new instance of IGasOracle. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewIGasOracle(t mockConstructorTestingTNewIGasOracle) *IGasOracle {
	mock := &IGasOracle{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
