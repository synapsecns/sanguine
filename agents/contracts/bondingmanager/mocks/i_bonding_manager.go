// Code generated by mockery v2.14.0. DO NOT EDIT.

package mocks

import (
	big "math/big"

	bind "github.com/ethereum/go-ethereum/accounts/abi/bind"
	bondingmanager "github.com/synapsecns/sanguine/agents/contracts/bondingmanager"

	common "github.com/ethereum/go-ethereum/common"

	event "github.com/ethereum/go-ethereum/event"

	mock "github.com/stretchr/testify/mock"

	types "github.com/ethereum/go-ethereum/core/types"
)

// IBondingManager is an autogenerated mock type for the IBondingManager type
type IBondingManager struct {
	mock.Mock
}

// AddAgent provides a mock function with given fields: opts, domain, agent, proof
func (_m *IBondingManager) AddAgent(opts *bind.TransactOpts, domain uint32, agent common.Address, proof [][32]byte) (*types.Transaction, error) {
	ret := _m.Called(opts, domain, agent, proof)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, uint32, common.Address, [][32]byte) *types.Transaction); ok {
		r0 = rf(opts, domain, agent, proof)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, uint32, common.Address, [][32]byte) error); ok {
		r1 = rf(opts, domain, agent, proof)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Address provides a mock function with given fields:
func (_m *IBondingManager) Address() common.Address {
	ret := _m.Called()

	var r0 common.Address
	if rf, ok := ret.Get(0).(func() common.Address); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	return r0
}

// AgentLeaf provides a mock function with given fields: opts, agent
func (_m *IBondingManager) AgentLeaf(opts *bind.CallOpts, agent common.Address) ([32]byte, error) {
	ret := _m.Called(opts, agent)

	var r0 [32]byte
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, common.Address) [32]byte); ok {
		r0 = rf(opts, agent)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([32]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts, common.Address) error); ok {
		r1 = rf(opts, agent)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AgentRoot provides a mock function with given fields: opts
func (_m *IBondingManager) AgentRoot(opts *bind.CallOpts) ([32]byte, error) {
	ret := _m.Called(opts)

	var r0 [32]byte
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) [32]byte); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([32]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AgentStatus provides a mock function with given fields: opts, agent
func (_m *IBondingManager) AgentStatus(opts *bind.CallOpts, agent common.Address) (bondingmanager.AgentStatus, error) {
	ret := _m.Called(opts, agent)

	var r0 bondingmanager.AgentStatus
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, common.Address) bondingmanager.AgentStatus); ok {
		r0 = rf(opts, agent)
	} else {
		r0 = ret.Get(0).(bondingmanager.AgentStatus)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts, common.Address) error); ok {
		r1 = rf(opts, agent)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AllLeafs provides a mock function with given fields: opts
func (_m *IBondingManager) AllLeafs(opts *bind.CallOpts) ([][32]byte, error) {
	ret := _m.Called(opts)

	var r0 [][32]byte
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) [][32]byte); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([][32]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CompleteSlashing provides a mock function with given fields: opts, domain, agent, proof
func (_m *IBondingManager) CompleteSlashing(opts *bind.TransactOpts, domain uint32, agent common.Address, proof [][32]byte) (*types.Transaction, error) {
	ret := _m.Called(opts, domain, agent, proof)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, uint32, common.Address, [][32]byte) *types.Transaction); ok {
		r0 = rf(opts, domain, agent, proof)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, uint32, common.Address, [][32]byte) error); ok {
		r1 = rf(opts, domain, agent, proof)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CompleteUnstaking provides a mock function with given fields: opts, domain, agent, proof
func (_m *IBondingManager) CompleteUnstaking(opts *bind.TransactOpts, domain uint32, agent common.Address, proof [][32]byte) (*types.Transaction, error) {
	ret := _m.Called(opts, domain, agent, proof)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, uint32, common.Address, [][32]byte) *types.Transaction); ok {
		r0 = rf(opts, domain, agent, proof)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, uint32, common.Address, [][32]byte) error); ok {
		r1 = rf(opts, domain, agent, proof)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Destination provides a mock function with given fields: opts
func (_m *IBondingManager) Destination(opts *bind.CallOpts) (common.Address, error) {
	ret := _m.Called(opts)

	var r0 common.Address
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) common.Address); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisputeStatus provides a mock function with given fields: opts, agent
func (_m *IBondingManager) DisputeStatus(opts *bind.CallOpts, agent common.Address) (bondingmanager.Dispute, error) {
	ret := _m.Called(opts, agent)

	var r0 bondingmanager.Dispute
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, common.Address) bondingmanager.Dispute); ok {
		r0 = rf(opts, agent)
	} else {
		r0 = ret.Get(0).(bondingmanager.Dispute)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts, common.Address) error); ok {
		r1 = rf(opts, agent)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterDisputeUpdated provides a mock function with given fields: opts
func (_m *IBondingManager) FilterDisputeUpdated(opts *bind.FilterOpts) (*bondingmanager.BondingManagerDisputeUpdatedIterator, error) {
	ret := _m.Called(opts)

	var r0 *bondingmanager.BondingManagerDisputeUpdatedIterator
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts) *bondingmanager.BondingManagerDisputeUpdatedIterator); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bondingmanager.BondingManagerDisputeUpdatedIterator)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.FilterOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterInitialized provides a mock function with given fields: opts
func (_m *IBondingManager) FilterInitialized(opts *bind.FilterOpts) (*bondingmanager.BondingManagerInitializedIterator, error) {
	ret := _m.Called(opts)

	var r0 *bondingmanager.BondingManagerInitializedIterator
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts) *bondingmanager.BondingManagerInitializedIterator); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bondingmanager.BondingManagerInitializedIterator)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.FilterOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterInvalidAttestation provides a mock function with given fields: opts
func (_m *IBondingManager) FilterInvalidAttestation(opts *bind.FilterOpts) (*bondingmanager.BondingManagerInvalidAttestationIterator, error) {
	ret := _m.Called(opts)

	var r0 *bondingmanager.BondingManagerInvalidAttestationIterator
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts) *bondingmanager.BondingManagerInvalidAttestationIterator); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bondingmanager.BondingManagerInvalidAttestationIterator)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.FilterOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterInvalidAttestationReport provides a mock function with given fields: opts
func (_m *IBondingManager) FilterInvalidAttestationReport(opts *bind.FilterOpts) (*bondingmanager.BondingManagerInvalidAttestationReportIterator, error) {
	ret := _m.Called(opts)

	var r0 *bondingmanager.BondingManagerInvalidAttestationReportIterator
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts) *bondingmanager.BondingManagerInvalidAttestationReportIterator); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bondingmanager.BondingManagerInvalidAttestationReportIterator)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.FilterOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterInvalidReceipt provides a mock function with given fields: opts
func (_m *IBondingManager) FilterInvalidReceipt(opts *bind.FilterOpts) (*bondingmanager.BondingManagerInvalidReceiptIterator, error) {
	ret := _m.Called(opts)

	var r0 *bondingmanager.BondingManagerInvalidReceiptIterator
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts) *bondingmanager.BondingManagerInvalidReceiptIterator); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bondingmanager.BondingManagerInvalidReceiptIterator)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.FilterOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterInvalidStateReport provides a mock function with given fields: opts
func (_m *IBondingManager) FilterInvalidStateReport(opts *bind.FilterOpts) (*bondingmanager.BondingManagerInvalidStateReportIterator, error) {
	ret := _m.Called(opts)

	var r0 *bondingmanager.BondingManagerInvalidStateReportIterator
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts) *bondingmanager.BondingManagerInvalidStateReportIterator); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bondingmanager.BondingManagerInvalidStateReportIterator)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.FilterOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterInvalidStateWithAttestation provides a mock function with given fields: opts
func (_m *IBondingManager) FilterInvalidStateWithAttestation(opts *bind.FilterOpts) (*bondingmanager.BondingManagerInvalidStateWithAttestationIterator, error) {
	ret := _m.Called(opts)

	var r0 *bondingmanager.BondingManagerInvalidStateWithAttestationIterator
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts) *bondingmanager.BondingManagerInvalidStateWithAttestationIterator); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bondingmanager.BondingManagerInvalidStateWithAttestationIterator)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.FilterOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterInvalidStateWithSnapshot provides a mock function with given fields: opts
func (_m *IBondingManager) FilterInvalidStateWithSnapshot(opts *bind.FilterOpts) (*bondingmanager.BondingManagerInvalidStateWithSnapshotIterator, error) {
	ret := _m.Called(opts)

	var r0 *bondingmanager.BondingManagerInvalidStateWithSnapshotIterator
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts) *bondingmanager.BondingManagerInvalidStateWithSnapshotIterator); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bondingmanager.BondingManagerInvalidStateWithSnapshotIterator)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.FilterOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterOwnershipTransferred provides a mock function with given fields: opts, previousOwner, newOwner
func (_m *IBondingManager) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*bondingmanager.BondingManagerOwnershipTransferredIterator, error) {
	ret := _m.Called(opts, previousOwner, newOwner)

	var r0 *bondingmanager.BondingManagerOwnershipTransferredIterator
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []common.Address, []common.Address) *bondingmanager.BondingManagerOwnershipTransferredIterator); ok {
		r0 = rf(opts, previousOwner, newOwner)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bondingmanager.BondingManagerOwnershipTransferredIterator)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, []common.Address, []common.Address) error); ok {
		r1 = rf(opts, previousOwner, newOwner)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterRootUpdated provides a mock function with given fields: opts
func (_m *IBondingManager) FilterRootUpdated(opts *bind.FilterOpts) (*bondingmanager.BondingManagerRootUpdatedIterator, error) {
	ret := _m.Called(opts)

	var r0 *bondingmanager.BondingManagerRootUpdatedIterator
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts) *bondingmanager.BondingManagerRootUpdatedIterator); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bondingmanager.BondingManagerRootUpdatedIterator)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.FilterOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterStatusUpdated provides a mock function with given fields: opts, domain, agent
func (_m *IBondingManager) FilterStatusUpdated(opts *bind.FilterOpts, domain []uint32, agent []common.Address) (*bondingmanager.BondingManagerStatusUpdatedIterator, error) {
	ret := _m.Called(opts, domain, agent)

	var r0 *bondingmanager.BondingManagerStatusUpdatedIterator
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []uint32, []common.Address) *bondingmanager.BondingManagerStatusUpdatedIterator); ok {
		r0 = rf(opts, domain, agent)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bondingmanager.BondingManagerStatusUpdatedIterator)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, []uint32, []common.Address) error); ok {
		r1 = rf(opts, domain, agent)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetActiveAgents provides a mock function with given fields: opts, domain
func (_m *IBondingManager) GetActiveAgents(opts *bind.CallOpts, domain uint32) ([]common.Address, error) {
	ret := _m.Called(opts, domain)

	var r0 []common.Address
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, uint32) []common.Address); ok {
		r0 = rf(opts, domain)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]common.Address)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts, uint32) error); ok {
		r1 = rf(opts, domain)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAgent provides a mock function with given fields: opts, index
func (_m *IBondingManager) GetAgent(opts *bind.CallOpts, index *big.Int) (struct {
	Agent  common.Address
	Status bondingmanager.AgentStatus
}, error) {
	ret := _m.Called(opts, index)

	var r0 struct {
		Agent  common.Address
		Status bondingmanager.AgentStatus
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, *big.Int) struct {
		Agent  common.Address
		Status bondingmanager.AgentStatus
	}); ok {
		r0 = rf(opts, index)
	} else {
		r0 = ret.Get(0).(struct {
			Agent  common.Address
			Status bondingmanager.AgentStatus
		})
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts, *big.Int) error); ok {
		r1 = rf(opts, index)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLeafs provides a mock function with given fields: opts, indexFrom, amount
func (_m *IBondingManager) GetLeafs(opts *bind.CallOpts, indexFrom *big.Int, amount *big.Int) ([][32]byte, error) {
	ret := _m.Called(opts, indexFrom, amount)

	var r0 [][32]byte
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, *big.Int, *big.Int) [][32]byte); ok {
		r0 = rf(opts, indexFrom, amount)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([][32]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts, *big.Int, *big.Int) error); ok {
		r1 = rf(opts, indexFrom, amount)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetProof provides a mock function with given fields: opts, agent
func (_m *IBondingManager) GetProof(opts *bind.CallOpts, agent common.Address) ([][32]byte, error) {
	ret := _m.Called(opts, agent)

	var r0 [][32]byte
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, common.Address) [][32]byte); ok {
		r0 = rf(opts, agent)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([][32]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts, common.Address) error); ok {
		r1 = rf(opts, agent)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Initialize provides a mock function with given fields: opts, origin_, destination_
func (_m *IBondingManager) Initialize(opts *bind.TransactOpts, origin_ common.Address, destination_ common.Address) (*types.Transaction, error) {
	ret := _m.Called(opts, origin_, destination_)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, common.Address, common.Address) *types.Transaction); ok {
		r0 = rf(opts, origin_, destination_)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, common.Address, common.Address) error); ok {
		r1 = rf(opts, origin_, destination_)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InitiateUnstaking provides a mock function with given fields: opts, domain, agent, proof
func (_m *IBondingManager) InitiateUnstaking(opts *bind.TransactOpts, domain uint32, agent common.Address, proof [][32]byte) (*types.Transaction, error) {
	ret := _m.Called(opts, domain, agent, proof)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, uint32, common.Address, [][32]byte) *types.Transaction); ok {
		r0 = rf(opts, domain, agent, proof)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, uint32, common.Address, [][32]byte) error); ok {
		r1 = rf(opts, domain, agent, proof)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LeafsAmount provides a mock function with given fields: opts
func (_m *IBondingManager) LeafsAmount(opts *bind.CallOpts) (*big.Int, error) {
	ret := _m.Called(opts)

	var r0 *big.Int
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) *big.Int); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LocalDomain provides a mock function with given fields: opts
func (_m *IBondingManager) LocalDomain(opts *bind.CallOpts) (uint32, error) {
	ret := _m.Called(opts)

	var r0 uint32
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) uint32); ok {
		r0 = rf(opts)
	} else {
		r0 = ret.Get(0).(uint32)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Origin provides a mock function with given fields: opts
func (_m *IBondingManager) Origin(opts *bind.CallOpts) (common.Address, error) {
	ret := _m.Called(opts)

	var r0 common.Address
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) common.Address); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Owner provides a mock function with given fields: opts
func (_m *IBondingManager) Owner(opts *bind.CallOpts) (common.Address, error) {
	ret := _m.Called(opts)

	var r0 common.Address
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) common.Address); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseDisputeUpdated provides a mock function with given fields: log
func (_m *IBondingManager) ParseDisputeUpdated(log types.Log) (*bondingmanager.BondingManagerDisputeUpdated, error) {
	ret := _m.Called(log)

	var r0 *bondingmanager.BondingManagerDisputeUpdated
	if rf, ok := ret.Get(0).(func(types.Log) *bondingmanager.BondingManagerDisputeUpdated); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bondingmanager.BondingManagerDisputeUpdated)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseInitialized provides a mock function with given fields: log
func (_m *IBondingManager) ParseInitialized(log types.Log) (*bondingmanager.BondingManagerInitialized, error) {
	ret := _m.Called(log)

	var r0 *bondingmanager.BondingManagerInitialized
	if rf, ok := ret.Get(0).(func(types.Log) *bondingmanager.BondingManagerInitialized); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bondingmanager.BondingManagerInitialized)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseInvalidAttestation provides a mock function with given fields: log
func (_m *IBondingManager) ParseInvalidAttestation(log types.Log) (*bondingmanager.BondingManagerInvalidAttestation, error) {
	ret := _m.Called(log)

	var r0 *bondingmanager.BondingManagerInvalidAttestation
	if rf, ok := ret.Get(0).(func(types.Log) *bondingmanager.BondingManagerInvalidAttestation); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bondingmanager.BondingManagerInvalidAttestation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseInvalidAttestationReport provides a mock function with given fields: log
func (_m *IBondingManager) ParseInvalidAttestationReport(log types.Log) (*bondingmanager.BondingManagerInvalidAttestationReport, error) {
	ret := _m.Called(log)

	var r0 *bondingmanager.BondingManagerInvalidAttestationReport
	if rf, ok := ret.Get(0).(func(types.Log) *bondingmanager.BondingManagerInvalidAttestationReport); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bondingmanager.BondingManagerInvalidAttestationReport)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseInvalidReceipt provides a mock function with given fields: log
func (_m *IBondingManager) ParseInvalidReceipt(log types.Log) (*bondingmanager.BondingManagerInvalidReceipt, error) {
	ret := _m.Called(log)

	var r0 *bondingmanager.BondingManagerInvalidReceipt
	if rf, ok := ret.Get(0).(func(types.Log) *bondingmanager.BondingManagerInvalidReceipt); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bondingmanager.BondingManagerInvalidReceipt)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseInvalidStateReport provides a mock function with given fields: log
func (_m *IBondingManager) ParseInvalidStateReport(log types.Log) (*bondingmanager.BondingManagerInvalidStateReport, error) {
	ret := _m.Called(log)

	var r0 *bondingmanager.BondingManagerInvalidStateReport
	if rf, ok := ret.Get(0).(func(types.Log) *bondingmanager.BondingManagerInvalidStateReport); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bondingmanager.BondingManagerInvalidStateReport)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseInvalidStateWithAttestation provides a mock function with given fields: log
func (_m *IBondingManager) ParseInvalidStateWithAttestation(log types.Log) (*bondingmanager.BondingManagerInvalidStateWithAttestation, error) {
	ret := _m.Called(log)

	var r0 *bondingmanager.BondingManagerInvalidStateWithAttestation
	if rf, ok := ret.Get(0).(func(types.Log) *bondingmanager.BondingManagerInvalidStateWithAttestation); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bondingmanager.BondingManagerInvalidStateWithAttestation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseInvalidStateWithSnapshot provides a mock function with given fields: log
func (_m *IBondingManager) ParseInvalidStateWithSnapshot(log types.Log) (*bondingmanager.BondingManagerInvalidStateWithSnapshot, error) {
	ret := _m.Called(log)

	var r0 *bondingmanager.BondingManagerInvalidStateWithSnapshot
	if rf, ok := ret.Get(0).(func(types.Log) *bondingmanager.BondingManagerInvalidStateWithSnapshot); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bondingmanager.BondingManagerInvalidStateWithSnapshot)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseOwnershipTransferred provides a mock function with given fields: log
func (_m *IBondingManager) ParseOwnershipTransferred(log types.Log) (*bondingmanager.BondingManagerOwnershipTransferred, error) {
	ret := _m.Called(log)

	var r0 *bondingmanager.BondingManagerOwnershipTransferred
	if rf, ok := ret.Get(0).(func(types.Log) *bondingmanager.BondingManagerOwnershipTransferred); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bondingmanager.BondingManagerOwnershipTransferred)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseRootUpdated provides a mock function with given fields: log
func (_m *IBondingManager) ParseRootUpdated(log types.Log) (*bondingmanager.BondingManagerRootUpdated, error) {
	ret := _m.Called(log)

	var r0 *bondingmanager.BondingManagerRootUpdated
	if rf, ok := ret.Get(0).(func(types.Log) *bondingmanager.BondingManagerRootUpdated); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bondingmanager.BondingManagerRootUpdated)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseStatusUpdated provides a mock function with given fields: log
func (_m *IBondingManager) ParseStatusUpdated(log types.Log) (*bondingmanager.BondingManagerStatusUpdated, error) {
	ret := _m.Called(log)

	var r0 *bondingmanager.BondingManagerStatusUpdated
	if rf, ok := ret.Get(0).(func(types.Log) *bondingmanager.BondingManagerStatusUpdated); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bondingmanager.BondingManagerStatusUpdated)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoteSlashAgent provides a mock function with given fields: opts, msgOrigin, proofMaturity, domain, agent, prover
func (_m *IBondingManager) RemoteSlashAgent(opts *bind.TransactOpts, msgOrigin uint32, proofMaturity *big.Int, domain uint32, agent common.Address, prover common.Address) (*types.Transaction, error) {
	ret := _m.Called(opts, msgOrigin, proofMaturity, domain, agent, prover)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, uint32, *big.Int, uint32, common.Address, common.Address) *types.Transaction); ok {
		r0 = rf(opts, msgOrigin, proofMaturity, domain, agent, prover)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, uint32, *big.Int, uint32, common.Address, common.Address) error); ok {
		r1 = rf(opts, msgOrigin, proofMaturity, domain, agent, prover)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RenounceOwnership provides a mock function with given fields: opts
func (_m *IBondingManager) RenounceOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	ret := _m.Called(opts)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts) *types.Transaction); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SubmitReceipt provides a mock function with given fields: opts, rcptPayload, rcptSignature
func (_m *IBondingManager) SubmitReceipt(opts *bind.TransactOpts, rcptPayload []byte, rcptSignature []byte) (*types.Transaction, error) {
	ret := _m.Called(opts, rcptPayload, rcptSignature)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, []byte, []byte) *types.Transaction); ok {
		r0 = rf(opts, rcptPayload, rcptSignature)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, []byte, []byte) error); ok {
		r1 = rf(opts, rcptPayload, rcptSignature)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SubmitSnapshot provides a mock function with given fields: opts, snapPayload, snapSignature
func (_m *IBondingManager) SubmitSnapshot(opts *bind.TransactOpts, snapPayload []byte, snapSignature []byte) (*types.Transaction, error) {
	ret := _m.Called(opts, snapPayload, snapSignature)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, []byte, []byte) *types.Transaction); ok {
		r0 = rf(opts, snapPayload, snapSignature)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, []byte, []byte) error); ok {
		r1 = rf(opts, snapPayload, snapSignature)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SubmitStateReportWithAttestation provides a mock function with given fields: opts, stateIndex, srPayload, srSignature, snapPayload, attPayload, attSignature
func (_m *IBondingManager) SubmitStateReportWithAttestation(opts *bind.TransactOpts, stateIndex *big.Int, srPayload []byte, srSignature []byte, snapPayload []byte, attPayload []byte, attSignature []byte) (*types.Transaction, error) {
	ret := _m.Called(opts, stateIndex, srPayload, srSignature, snapPayload, attPayload, attSignature)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, *big.Int, []byte, []byte, []byte, []byte, []byte) *types.Transaction); ok {
		r0 = rf(opts, stateIndex, srPayload, srSignature, snapPayload, attPayload, attSignature)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, *big.Int, []byte, []byte, []byte, []byte, []byte) error); ok {
		r1 = rf(opts, stateIndex, srPayload, srSignature, snapPayload, attPayload, attSignature)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SubmitStateReportWithSnapshot provides a mock function with given fields: opts, stateIndex, srPayload, srSignature, snapPayload, snapSignature
func (_m *IBondingManager) SubmitStateReportWithSnapshot(opts *bind.TransactOpts, stateIndex *big.Int, srPayload []byte, srSignature []byte, snapPayload []byte, snapSignature []byte) (*types.Transaction, error) {
	ret := _m.Called(opts, stateIndex, srPayload, srSignature, snapPayload, snapSignature)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, *big.Int, []byte, []byte, []byte, []byte) *types.Transaction); ok {
		r0 = rf(opts, stateIndex, srPayload, srSignature, snapPayload, snapSignature)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, *big.Int, []byte, []byte, []byte, []byte) error); ok {
		r1 = rf(opts, stateIndex, srPayload, srSignature, snapPayload, snapSignature)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SubmitStateReportWithSnapshotProof provides a mock function with given fields: opts, stateIndex, srPayload, srSignature, snapProof, attPayload, attSignature
func (_m *IBondingManager) SubmitStateReportWithSnapshotProof(opts *bind.TransactOpts, stateIndex *big.Int, srPayload []byte, srSignature []byte, snapProof [][32]byte, attPayload []byte, attSignature []byte) (*types.Transaction, error) {
	ret := _m.Called(opts, stateIndex, srPayload, srSignature, snapProof, attPayload, attSignature)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, *big.Int, []byte, []byte, [][32]byte, []byte, []byte) *types.Transaction); ok {
		r0 = rf(opts, stateIndex, srPayload, srSignature, snapProof, attPayload, attSignature)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, *big.Int, []byte, []byte, [][32]byte, []byte, []byte) error); ok {
		r1 = rf(opts, stateIndex, srPayload, srSignature, snapProof, attPayload, attSignature)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TransferOwnership provides a mock function with given fields: opts, newOwner
func (_m *IBondingManager) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	ret := _m.Called(opts, newOwner)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, common.Address) *types.Transaction); ok {
		r0 = rf(opts, newOwner)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, common.Address) error); ok {
		r1 = rf(opts, newOwner)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// VerifyAttestation provides a mock function with given fields: opts, attPayload, attSignature
func (_m *IBondingManager) VerifyAttestation(opts *bind.TransactOpts, attPayload []byte, attSignature []byte) (*types.Transaction, error) {
	ret := _m.Called(opts, attPayload, attSignature)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, []byte, []byte) *types.Transaction); ok {
		r0 = rf(opts, attPayload, attSignature)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, []byte, []byte) error); ok {
		r1 = rf(opts, attPayload, attSignature)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// VerifyAttestationReport provides a mock function with given fields: opts, arPayload, arSignature
func (_m *IBondingManager) VerifyAttestationReport(opts *bind.TransactOpts, arPayload []byte, arSignature []byte) (*types.Transaction, error) {
	ret := _m.Called(opts, arPayload, arSignature)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, []byte, []byte) *types.Transaction); ok {
		r0 = rf(opts, arPayload, arSignature)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, []byte, []byte) error); ok {
		r1 = rf(opts, arPayload, arSignature)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// VerifyReceipt provides a mock function with given fields: opts, rcptPayload, rcptSignature
func (_m *IBondingManager) VerifyReceipt(opts *bind.TransactOpts, rcptPayload []byte, rcptSignature []byte) (*types.Transaction, error) {
	ret := _m.Called(opts, rcptPayload, rcptSignature)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, []byte, []byte) *types.Transaction); ok {
		r0 = rf(opts, rcptPayload, rcptSignature)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, []byte, []byte) error); ok {
		r1 = rf(opts, rcptPayload, rcptSignature)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// VerifyStateReport provides a mock function with given fields: opts, srPayload, srSignature
func (_m *IBondingManager) VerifyStateReport(opts *bind.TransactOpts, srPayload []byte, srSignature []byte) (*types.Transaction, error) {
	ret := _m.Called(opts, srPayload, srSignature)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, []byte, []byte) *types.Transaction); ok {
		r0 = rf(opts, srPayload, srSignature)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, []byte, []byte) error); ok {
		r1 = rf(opts, srPayload, srSignature)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// VerifyStateWithAttestation provides a mock function with given fields: opts, stateIndex, snapPayload, attPayload, attSignature
func (_m *IBondingManager) VerifyStateWithAttestation(opts *bind.TransactOpts, stateIndex *big.Int, snapPayload []byte, attPayload []byte, attSignature []byte) (*types.Transaction, error) {
	ret := _m.Called(opts, stateIndex, snapPayload, attPayload, attSignature)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, *big.Int, []byte, []byte, []byte) *types.Transaction); ok {
		r0 = rf(opts, stateIndex, snapPayload, attPayload, attSignature)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, *big.Int, []byte, []byte, []byte) error); ok {
		r1 = rf(opts, stateIndex, snapPayload, attPayload, attSignature)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// VerifyStateWithSnapshot provides a mock function with given fields: opts, stateIndex, snapPayload, snapSignature
func (_m *IBondingManager) VerifyStateWithSnapshot(opts *bind.TransactOpts, stateIndex *big.Int, snapPayload []byte, snapSignature []byte) (*types.Transaction, error) {
	ret := _m.Called(opts, stateIndex, snapPayload, snapSignature)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, *big.Int, []byte, []byte) *types.Transaction); ok {
		r0 = rf(opts, stateIndex, snapPayload, snapSignature)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, *big.Int, []byte, []byte) error); ok {
		r1 = rf(opts, stateIndex, snapPayload, snapSignature)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// VerifyStateWithSnapshotProof provides a mock function with given fields: opts, stateIndex, statePayload, snapProof, attPayload, attSignature
func (_m *IBondingManager) VerifyStateWithSnapshotProof(opts *bind.TransactOpts, stateIndex *big.Int, statePayload []byte, snapProof [][32]byte, attPayload []byte, attSignature []byte) (*types.Transaction, error) {
	ret := _m.Called(opts, stateIndex, statePayload, snapProof, attPayload, attSignature)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, *big.Int, []byte, [][32]byte, []byte, []byte) *types.Transaction); ok {
		r0 = rf(opts, stateIndex, statePayload, snapProof, attPayload, attSignature)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, *big.Int, []byte, [][32]byte, []byte, []byte) error); ok {
		r1 = rf(opts, stateIndex, statePayload, snapProof, attPayload, attSignature)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Version provides a mock function with given fields: opts
func (_m *IBondingManager) Version(opts *bind.CallOpts) (string, error) {
	ret := _m.Called(opts)

	var r0 string
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) string); ok {
		r0 = rf(opts)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchDisputeUpdated provides a mock function with given fields: opts, sink
func (_m *IBondingManager) WatchDisputeUpdated(opts *bind.WatchOpts, sink chan<- *bondingmanager.BondingManagerDisputeUpdated) (event.Subscription, error) {
	ret := _m.Called(opts, sink)

	var r0 event.Subscription
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *bondingmanager.BondingManagerDisputeUpdated) event.Subscription); ok {
		r0 = rf(opts, sink)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *bondingmanager.BondingManagerDisputeUpdated) error); ok {
		r1 = rf(opts, sink)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchInitialized provides a mock function with given fields: opts, sink
func (_m *IBondingManager) WatchInitialized(opts *bind.WatchOpts, sink chan<- *bondingmanager.BondingManagerInitialized) (event.Subscription, error) {
	ret := _m.Called(opts, sink)

	var r0 event.Subscription
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *bondingmanager.BondingManagerInitialized) event.Subscription); ok {
		r0 = rf(opts, sink)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *bondingmanager.BondingManagerInitialized) error); ok {
		r1 = rf(opts, sink)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchInvalidAttestation provides a mock function with given fields: opts, sink
func (_m *IBondingManager) WatchInvalidAttestation(opts *bind.WatchOpts, sink chan<- *bondingmanager.BondingManagerInvalidAttestation) (event.Subscription, error) {
	ret := _m.Called(opts, sink)

	var r0 event.Subscription
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *bondingmanager.BondingManagerInvalidAttestation) event.Subscription); ok {
		r0 = rf(opts, sink)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *bondingmanager.BondingManagerInvalidAttestation) error); ok {
		r1 = rf(opts, sink)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchInvalidAttestationReport provides a mock function with given fields: opts, sink
func (_m *IBondingManager) WatchInvalidAttestationReport(opts *bind.WatchOpts, sink chan<- *bondingmanager.BondingManagerInvalidAttestationReport) (event.Subscription, error) {
	ret := _m.Called(opts, sink)

	var r0 event.Subscription
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *bondingmanager.BondingManagerInvalidAttestationReport) event.Subscription); ok {
		r0 = rf(opts, sink)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *bondingmanager.BondingManagerInvalidAttestationReport) error); ok {
		r1 = rf(opts, sink)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchInvalidReceipt provides a mock function with given fields: opts, sink
func (_m *IBondingManager) WatchInvalidReceipt(opts *bind.WatchOpts, sink chan<- *bondingmanager.BondingManagerInvalidReceipt) (event.Subscription, error) {
	ret := _m.Called(opts, sink)

	var r0 event.Subscription
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *bondingmanager.BondingManagerInvalidReceipt) event.Subscription); ok {
		r0 = rf(opts, sink)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *bondingmanager.BondingManagerInvalidReceipt) error); ok {
		r1 = rf(opts, sink)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchInvalidStateReport provides a mock function with given fields: opts, sink
func (_m *IBondingManager) WatchInvalidStateReport(opts *bind.WatchOpts, sink chan<- *bondingmanager.BondingManagerInvalidStateReport) (event.Subscription, error) {
	ret := _m.Called(opts, sink)

	var r0 event.Subscription
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *bondingmanager.BondingManagerInvalidStateReport) event.Subscription); ok {
		r0 = rf(opts, sink)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *bondingmanager.BondingManagerInvalidStateReport) error); ok {
		r1 = rf(opts, sink)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchInvalidStateWithAttestation provides a mock function with given fields: opts, sink
func (_m *IBondingManager) WatchInvalidStateWithAttestation(opts *bind.WatchOpts, sink chan<- *bondingmanager.BondingManagerInvalidStateWithAttestation) (event.Subscription, error) {
	ret := _m.Called(opts, sink)

	var r0 event.Subscription
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *bondingmanager.BondingManagerInvalidStateWithAttestation) event.Subscription); ok {
		r0 = rf(opts, sink)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *bondingmanager.BondingManagerInvalidStateWithAttestation) error); ok {
		r1 = rf(opts, sink)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchInvalidStateWithSnapshot provides a mock function with given fields: opts, sink
func (_m *IBondingManager) WatchInvalidStateWithSnapshot(opts *bind.WatchOpts, sink chan<- *bondingmanager.BondingManagerInvalidStateWithSnapshot) (event.Subscription, error) {
	ret := _m.Called(opts, sink)

	var r0 event.Subscription
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *bondingmanager.BondingManagerInvalidStateWithSnapshot) event.Subscription); ok {
		r0 = rf(opts, sink)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *bondingmanager.BondingManagerInvalidStateWithSnapshot) error); ok {
		r1 = rf(opts, sink)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchOwnershipTransferred provides a mock function with given fields: opts, sink, previousOwner, newOwner
func (_m *IBondingManager) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *bondingmanager.BondingManagerOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {
	ret := _m.Called(opts, sink, previousOwner, newOwner)

	var r0 event.Subscription
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *bondingmanager.BondingManagerOwnershipTransferred, []common.Address, []common.Address) event.Subscription); ok {
		r0 = rf(opts, sink, previousOwner, newOwner)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *bondingmanager.BondingManagerOwnershipTransferred, []common.Address, []common.Address) error); ok {
		r1 = rf(opts, sink, previousOwner, newOwner)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchRootUpdated provides a mock function with given fields: opts, sink
func (_m *IBondingManager) WatchRootUpdated(opts *bind.WatchOpts, sink chan<- *bondingmanager.BondingManagerRootUpdated) (event.Subscription, error) {
	ret := _m.Called(opts, sink)

	var r0 event.Subscription
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *bondingmanager.BondingManagerRootUpdated) event.Subscription); ok {
		r0 = rf(opts, sink)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *bondingmanager.BondingManagerRootUpdated) error); ok {
		r1 = rf(opts, sink)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchStatusUpdated provides a mock function with given fields: opts, sink, domain, agent
func (_m *IBondingManager) WatchStatusUpdated(opts *bind.WatchOpts, sink chan<- *bondingmanager.BondingManagerStatusUpdated, domain []uint32, agent []common.Address) (event.Subscription, error) {
	ret := _m.Called(opts, sink, domain, agent)

	var r0 event.Subscription
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *bondingmanager.BondingManagerStatusUpdated, []uint32, []common.Address) event.Subscription); ok {
		r0 = rf(opts, sink, domain, agent)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *bondingmanager.BondingManagerStatusUpdated, []uint32, []common.Address) error); ok {
		r1 = rf(opts, sink, domain, agent)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WithdrawTips provides a mock function with given fields: opts, recipient, origin_, amount
func (_m *IBondingManager) WithdrawTips(opts *bind.TransactOpts, recipient common.Address, origin_ uint32, amount *big.Int) (*types.Transaction, error) {
	ret := _m.Called(opts, recipient, origin_, amount)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, common.Address, uint32, *big.Int) *types.Transaction); ok {
		r0 = rf(opts, recipient, origin_, amount)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, common.Address, uint32, *big.Int) error); ok {
		r1 = rf(opts, recipient, origin_, amount)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type mockConstructorTestingTNewIBondingManager interface {
	mock.TestingT
	Cleanup(func())
}

// NewIBondingManager creates a new instance of IBondingManager. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewIBondingManager(t mockConstructorTestingTNewIBondingManager) *IBondingManager {
	mock := &IBondingManager{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
