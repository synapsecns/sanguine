{"solidity/MessageHarness.t.sol:ByteString":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220855d14d1a601b70587a6490b99c827e37355fa9ca358962a70e66889b123c00264736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220855d14d1a601b70587a6490b99c827e37355fa9ca358962a70e66889b123c00264736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nlibrary TypedMemView {\n    // Why does this exist?\n    // the solidity `bytes memory` type has a few weaknesses.\n    // 1. You can't index ranges effectively\n    // 2. You can't slice without copying\n    // 3. The underlying data may represent any type\n    // 4. Solidity never deallocates memory, and memory costs grow\n    //    superlinearly\n\n    // By using a memory view instead of a `bytes memory` we get the following\n    // advantages:\n    // 1. Slices are done on the stack, by manipulating the pointer\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\n    // 3. We can insert type info into the pointer, and typecheck at runtime\n\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\n    // algorithms.\n\n    // Why bytes29?\n    // We want to avoid confusion between views, digests, and other common\n    // types so we chose a large and uncommonly used odd number of bytes\n    //\n    // Note that while bytes are left-aligned in a word, integers and addresses\n    // are right-aligned. This means when working in assembly we have to\n    // account for the 3 unused bytes on the righthand side\n    //\n    // First 5 bytes are a type flag.\n    // - ff_ffff_fffe is reserved for unknown type.\n    // - ff_ffff_ffff is reserved for invalid types/errors.\n    // next 12 are memory address\n    // next 12 are len\n    // bottom 3 bytes are empty\n\n    // Assumptions:\n    // - non-modification of memory.\n    // - No Solidity updates\n    // - - wrt free mem point\n    // - - wrt bytes representation in memory\n    // - - wrt memory addressing in general\n\n    // Usage:\n    // - create type constants\n    // - use `assertType` for runtime type assertions\n    // - - unfortunately we can't do this at compile time yet :(\n    // - recommended: implement modifiers that perform type checking\n    // - - e.g.\n    // - - `uint40 constant MY_TYPE = 3;`\n    // - - ` modifier onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n    // - instantiate a typed view from a bytearray using `ref`\n    // - use `index` to inspect the contents of the view\n    // - use `slice` to create smaller views into the same memory\n    // - - `slice` can increase the offset\n    // - - `slice can decrease the length`\n    // - - must specify the output type of `slice`\n    // - - `slice` will return a null view if you try to overrun\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\n    // - use `equal` for typed comparisons.\n\n    // The null view\n    bytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n\n    /**\n     * @dev Memory layout for bytes29\n     * TODO (Chi): with the user defined types storing type is no longer necessary.\n     * Update the library, transforming bytes29 to bytes24 in the process.\n     * [000..005)   type     5 bytes    Type flag for the pointer\n     * [005..017)   loc     12 bytes    Memory address of underlying bytes\n     * [017..029)   len     12 bytes    Length of underlying bytes\n     * [029..032)   empty    3 bytes    Not used\n     */\n    uint256 public constant BITS_TYPE = 40;\n    uint256 public constant BITS_LOC = 96;\n    uint256 public constant BITS_LEN = 96;\n    uint256 public constant BITS_EMPTY = 24;\n\n    // `SHIFT_X` is how much bits to shift for `X` to be in the very bottom bits\n    uint256 public constant SHIFT_LEN = BITS_EMPTY; // 24\n    uint256 public constant SHIFT_LOC = SHIFT_LEN + BITS_LEN; // 24 + 96 = 120\n    uint256 public constant SHIFT_TYPE = SHIFT_LOC + BITS_LOC; // 24 + 96 + 96 = 216\n    // Bitmask for the lowest 96 bits\n    uint256 public constant LOW_96_BITS_MASK = type(uint96).max;\n\n    // For nibble encoding\n    bytes private constant NIBBLE_LOOKUP = \"0123456789abcdef\";\n\n    /**\n     * @notice Returns the encoded hex character that represents the lower 4 bits of the argument.\n     * @param _byte     The byte\n     * @return _char    The encoded hex character\n     */\n    function nibbleHex(uint8 _byte) internal pure returns (uint8 _char) {\n        uint8 _nibble = _byte \u0026 0x0f; // keep bottom 4 bits, zero out top 4 bits\n        _char = uint8(NIBBLE_LOOKUP[_nibble]);\n    }\n\n    /**\n     * @notice      Returns a uint16 containing the hex-encoded byte.\n     * @param _b    The byte\n     * @return      encoded - The hex-encoded byte\n     */\n    function byteHex(uint8 _b) internal pure returns (uint16 encoded) {\n        encoded |= nibbleHex(_b \u003e\u003e 4); // top 4 bits\n        encoded \u003c\u003c= 8;\n        encoded |= nibbleHex(_b); // lower 4 bits\n    }\n\n    /**\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\n     *              `second` contains the encoded lower 16 bytes.\n     *\n     * @param _b    The 32 bytes as uint256\n     * @return      first - The top 16 bytes\n     * @return      second - The bottom 16 bytes\n     */\n    function encodeHex(uint256 _b) internal pure returns (uint256 first, uint256 second) {\n        for (uint8 i = 31; i \u003e 15; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            first |= byteHex(_byte);\n            if (i != 16) {\n                first \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n\n        // abusing underflow here =_=\n        for (uint8 i = 15; i \u003c 255; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            second |= byteHex(_byte);\n            if (i != 0) {\n                second \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n    }\n\n    /**\n     * @notice          Changes the endianness of a uint256.\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n     * @param _b        The unsigned integer to reverse\n     * @return          v - The reversed value\n     */\n    function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\n        v = _b;\n\n        // swap bytes\n        v =\n            ((v \u003e\u003e 8) \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\n            ((v \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) \u003c\u003c 8);\n        // swap 2-byte long pairs\n        v =\n            ((v \u003e\u003e 16) \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\n            ((v \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) \u003c\u003c 16);\n        // swap 4-byte long pairs\n        v =\n            ((v \u003e\u003e 32) \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\n            ((v \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) \u003c\u003c 32);\n        // swap 8-byte long pairs\n        v =\n            ((v \u003e\u003e 64) \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\n            ((v \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) \u003c\u003c 64);\n        // swap 16-byte long pairs\n        v = (v \u003e\u003e 128) | (v \u003c\u003c 128);\n    }\n\n    /**\n     * @notice      Create a mask with the highest `_len` bits set.\n     * @param _len  The length\n     * @return      mask - The mask\n     */\n    function leftMask(uint8 _len) private pure returns (uint256 mask) {\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(\n                sub(_len, 1),\n                0x8000000000000000000000000000000000000000000000000000000000000000\n            )\n        }\n    }\n\n    /**\n     * @notice      Return the null view.\n     * @return      bytes29 - The null view\n     */\n    // solhint-disable-next-line ordering\n    function nullView() internal pure returns (bytes29) {\n        return NULL;\n    }\n\n    /**\n     * @notice      Check if the view is null.\n     * @return      bool - True if the view is null\n     */\n    function isNull(bytes29 memView) internal pure returns (bool) {\n        return memView == NULL;\n    }\n\n    /**\n     * @notice      Check if the view is not null.\n     * @return      bool - True if the view is not null\n     */\n    function notNull(bytes29 memView) internal pure returns (bool) {\n        return !isNull(memView);\n    }\n\n    /**\n     * @notice          Check if the view is of a valid type and points to a valid location\n     *                  in memory.\n     * @dev             We perform this check by examining solidity's unallocated memory\n     *                  pointer and ensuring that the view's upper bound is less than that.\n     * @param memView   The view\n     * @return          ret - True if the view is valid\n     */\n    function isValid(bytes29 memView) internal pure returns (bool ret) {\n        if (typeOf(memView) == 0xffffffffff) {\n            return false;\n        }\n        uint256 _end = end(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // View is valid if (\"upper bound\" \u003c= \"unallocated memory pointer\")\n            // Upper bound is exclusive, hence \"\u003c=\"\n            ret := not(gt(_end, mload(0x40)))\n        }\n    }\n\n    /**\n     * @notice          Require that a typed memory view be valid.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @return          bytes29 - The validated view\n     */\n    function assertValid(bytes29 memView) internal pure returns (bytes29) {\n        require(isValid(memView), \"Validity assertion failed\");\n        return memView;\n    }\n\n    /**\n     * @notice          Return true if the memview is of the expected type. Otherwise false.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bool - True if the memview is of the expected type\n     */\n    function isType(bytes29 memView, uint40 _expected) internal pure returns (bool) {\n        return typeOf(memView) == _expected;\n    }\n\n    /**\n     * @notice          Require that a typed memory view has a specific type.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bytes29 - The view with validated type\n     */\n    function assertType(bytes29 memView, uint40 _expected) internal pure returns (bytes29) {\n        if (!isType(memView, _expected)) {\n            (, uint256 g) = encodeHex(uint256(typeOf(memView)));\n            (, uint256 e) = encodeHex(uint256(_expected));\n            string memory err = string(\n                abi.encodePacked(\n                    \"Type assertion failed. Got 0x\",\n                    uint80(g),\n                    \". Expected 0x\",\n                    uint80(e)\n                )\n            );\n            revert(err);\n        }\n        return memView;\n    }\n\n    /**\n     * @notice          Return an identical view with a different type.\n     * @param memView   The view\n     * @param _newType  The new type\n     * @return          newView - The new view with the specified type\n     */\n    function castTo(bytes29 memView, uint40 _newType) internal pure returns (bytes29 newView) {\n        // How many bits are the \"type bits\" occupying\n        uint256 _bitsType = BITS_TYPE;\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 _shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // shift off the \"type bits\" (shift left, then sift right)\n            newView := or(newView, shr(_bitsType, shl(_bitsType, memView)))\n            // set the new \"type bits\" (shift left, then OR)\n            newView := or(newView, shl(_shiftType, _newType))\n        }\n    }\n\n    /**\n     * @notice          Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function unsafeBuildUnchecked(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) private pure returns (bytes29 newView) {\n        uint256 _bitsLoc = BITS_LOC;\n        uint256 _bitsLen = BITS_LEN;\n        uint256 _bitsEmpty = BITS_EMPTY;\n        // Ref memory layout\n        // [000..005) 5 bytes of type\n        // [005..017) 12 bytes of location\n        // [017..029) 12 bytes of length\n        // last 3 bits are blank and dropped in typecast\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // insert `type`, shift to prepare empty bits for `loc`\n            newView := shl(_bitsLoc, or(newView, _type))\n            // insert `loc`, shift to prepare empty bits for `len`\n            newView := shl(_bitsLen, or(newView, _loc))\n            // insert `len`, shift to insert 3 blank lowest bits\n            newView := shl(_bitsEmpty, or(newView, _len))\n        }\n    }\n\n    /**\n     * @notice          Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function build(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) internal pure returns (bytes29 newView) {\n        uint256 _end = _loc + _len;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(_end, mload(0x40)) {\n                _end := 0\n            }\n        }\n        if (_end == 0) {\n            return NULL;\n        }\n        newView = unsafeBuildUnchecked(_type, _loc, _len);\n    }\n\n    /**\n     * @notice          Instantiate a memory view from a byte array.\n     * @dev             Note that due to Solidity memory representation, it is not possible to\n     *                  implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr       The byte array\n     * @param newType   The type\n     * @return          bytes29 - The memory view\n     */\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\n        uint256 _len = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 _loc;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            _loc := add(arr, 0x20)\n        }\n\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Return the associated type information.\n     * @param memView   The memory view\n     * @return          _type - The type associated with the view\n     */\n    function typeOf(bytes29 memView) internal pure returns (uint40 _type) {\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 _shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"type bits\". \"type bits\" are occupying\n            // the highest bits, so all that's left is \"type bits\", OR is not required.\n            _type := shr(_shiftType, memView)\n        }\n    }\n\n    /**\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the 5-byte type flag is equal\n     */\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\n        // Check that the highest 5 bytes are equal: xor and shift out lower 27 bytes\n        return (left ^ right) \u003e\u003e SHIFT_TYPE == 0;\n    }\n\n    /**\n     * @notice          Return the memory address of the underlying bytes.\n     * @param memView   The view\n     * @return          _loc - The memory address\n     */\n    function loc(bytes29 memView) internal pure returns (uint96 _loc) {\n        // How many bits are the \"loc bits\" shifted from the bottom\n        uint256 _shiftLoc = SHIFT_LOC;\n        // Mask for the bottom 96 bits\n        uint256 _uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"loc bits\".\n            // Then use the lowest 96 bits to determine `loc` by applying the bit-mask.\n            _loc := and(shr(_shiftLoc, memView), _uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          The number of memory words this memory view occupies, rounded up.\n     * @param memView   The view\n     * @return          uint256 - The number of memory words\n     */\n    function words(bytes29 memView) internal pure returns (uint256) {\n        // returning ceil(length / 32.0)\n        return (uint256(len(memView)) + 31) / 32;\n    }\n\n    /**\n     * @notice          The in-memory footprint of a fresh copy of the view.\n     * @param memView   The view\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(bytes29 memView) internal pure returns (uint256) {\n        return words(memView) * 32;\n    }\n\n    /**\n     * @notice          The number of bytes of the view.\n     * @param memView   The view\n     * @return          _len - The length of the view\n     */\n    function len(bytes29 memView) internal pure returns (uint96 _len) {\n        // How many bits are the \"len bits\" shifted from the bottom\n        uint256 _shiftLen = SHIFT_LEN;\n        // Mask for the bottom 96 bits\n        uint256 _uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"len bits\".\n            // Then use the lowest 96 bits to determine `len` by applying the bit-mask.\n            _len := and(shr(_shiftLen, memView), _uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          Returns the endpoint of `memView`.\n     * @param memView   The view\n     * @return          uint256 - The endpoint of `memView`\n     */\n    function end(bytes29 memView) internal pure returns (uint256) {\n        unchecked {\n            return loc(memView) + len(memView);\n        }\n    }\n\n    /**\n     * @notice          Safe slicing without memory modification.\n     * @param memView   The view\n     * @param _index    The start index\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function slice(\n        bytes29 memView,\n        uint256 _index,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        uint256 _loc = loc(memView);\n\n        // Ensure it doesn't overrun the view\n        if (_loc + _index + _len \u003e end(memView)) {\n            return NULL;\n        }\n\n        _loc = _loc + _index;\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing\n     *                  bytes from `_index` to end(memView).\n     * @param memView   The view\n     * @param _index    The start index\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function sliceFrom(\n        bytes29 memView,\n        uint256 _index,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, _index, len(memView) - _index, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the first `_len` bytes.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function prefix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, 0, _len, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the last `_len` byte.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function postfix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, uint256(len(memView)) - _len, _len, newType);\n    }\n\n    /**\n     * @notice          Construct an error message for an indexing overrun.\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @param _index    The index\n     * @param _slice    The slice where the overrun occurred\n     * @return          err - The err\n     */\n    function indexErrOverrun(\n        uint256 _loc,\n        uint256 _len,\n        uint256 _index,\n        uint256 _slice\n    ) internal pure returns (string memory err) {\n        (, uint256 a) = encodeHex(_loc);\n        (, uint256 b) = encodeHex(_len);\n        (, uint256 c) = encodeHex(_index);\n        (, uint256 d) = encodeHex(_slice);\n        err = string(\n            abi.encodePacked(\n                \"TypedMemView/index - Overran the view. Slice is at 0x\",\n                uint48(a),\n                \" with length 0x\",\n                uint48(b),\n                \". Attempted to index at offset 0x\",\n                uint48(c),\n                \" with length 0x\",\n                uint48(d),\n                \".\"\n            )\n        );\n    }\n\n    /**\n     * @notice          Load up to 32 bytes from the view onto the stack.\n     * @dev             Returns a bytes32 with only the `_bytes` highest bytes set.\n     *                  This can be immediately cast to a smaller fixed-length byte array.\n     *                  To automatically cast to an integer, use `indexUint`.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The 32 byte result\n     */\n    function index(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (bytes32 result) {\n        if (_bytes == 0) {\n            return bytes32(0);\n        }\n        if (_index + _bytes \u003e len(memView)) {\n            revert(indexErrOverrun(loc(memView), len(memView), _index, uint256(_bytes)));\n        }\n        require(_bytes \u003c= 32, \"Index: more than 32 bytes\");\n\n        uint8 bitLength;\n        unchecked {\n            bitLength = _bytes * 8;\n        }\n        uint256 _loc = loc(memView);\n        // Get a mask with `bitLength` highest bits set\n        uint256 _mask = leftMask(bitLength);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(_loc, _index)), _mask)\n        }\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from the view at `_index`.\n     * @dev             Requires that the view have \u003e= `_bytes` bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        // `index()` returns left-aligned `_bytes`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word\n        return uint256(index(memView, _index, _bytes)) \u003e\u003e ((32 - _bytes) * 8);\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from LE bytes.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexLEUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return reverseUint256(uint256(index(memView, _index, _bytes)));\n    }\n\n    /**\n     * @notice          Parse an address from the view at `_index`.\n     *                  Requires that the view have \u003e= 20 bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @return          address - The address\n     */\n    function indexAddress(bytes29 memView, uint256 _index) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(indexUint(memView, _index, 20)));\n    }\n\n    /**\n     * @notice          Return the keccak256 hash of the underlying memory\n     * @param memView   The view\n     * @return          digest - The keccak256 hash of the underlying memory\n     */\n    function keccak(bytes29 memView) internal pure returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(_loc, _len)\n        }\n    }\n\n    /**\n     * @notice          Return the sha2 digest of the underlying memory.\n     * @dev             We explicitly deallocate memory afterwards.\n     * @param memView   The view\n     * @return          digest - The sha2 hash of the underlying memory\n     */\n    function sha2(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            digest := mload(ptr)\n        }\n        require(res, \"sha2: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n     * @param memView   The pre-image\n     * @return          digest - the Digest\n     */\n    function hash160(bytes29 memView) internal view returns (bytes20 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            // rmd160 precompile is 0x03\n            res := and(res, staticcall(gas(), 0x03, ptr, 0x20, ptr, 0x20))\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\n        }\n        require(res, \"hash160: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash256 (double sha2)\n     * @param memView   A view of the preimage\n     * @return          digest - the Digest\n     */\n    function hash256(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            res := and(res, staticcall(gas(), 0x02, ptr, 0x20, ptr, 0x20))\n            digest := mload(ptr)\n        }\n        require(res, \"hash256: out of gas\");\n    }\n\n    /**\n     * @notice          Return true if the underlying memory is equal. Else false.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the underlying memory is equal\n     */\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return\n            (loc(left) == loc(right) \u0026\u0026 len(left) == len(right)) || keccak(left) == keccak(right);\n    }\n\n    /**\n     * @notice          Return false if the underlying memory is equal. Else true.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - False if the underlying memory is equal\n     */\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !untypedEqual(left, right);\n    }\n\n    /**\n     * @notice          Compares type equality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are the same\n     */\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return left == right || (typeOf(left) == typeOf(right) \u0026\u0026 keccak(left) == keccak(right));\n    }\n\n    /**\n     * @notice          Compares type inequality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are not the same\n     */\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !equal(left, right);\n    }\n\n    /**\n     * @notice          Copy the view to a location, return an unsafe memory reference\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memView   The view\n     * @param _newLoc   The new location\n     * @return          written - the unsafe memory reference\n     */\n    function unsafeCopyTo(bytes29 memView, uint256 _newLoc) private view returns (bytes29 written) {\n        require(notNull(memView), \"copyTo: Null pointer deref\");\n        require(isValid(memView), \"copyTo: Invalid pointer deref\");\n        uint256 _len = len(memView);\n        uint256 _oldLoc = loc(memView);\n\n        uint256 ptr;\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _newLoc) {\n                revert(0x60, 0x20) // empty revert message\n            }\n\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, _oldLoc, _len, _newLoc, _len)\n        }\n        require(res, \"identity: out of gas\");\n\n        written = unsafeBuildUnchecked(typeOf(memView), _newLoc, _len);\n    }\n\n    /**\n     * @notice          Copies the referenced memory to a new loc in memory,\n     *                  returning a `bytes` pointing to the new memory.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param memView   The view\n     * @return          ret - The view pointing to the new memory\n     */\n    function clone(bytes29 memView) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n            ret := ptr\n        }\n        unchecked {\n            unsafeCopyTo(memView, ptr + 0x20);\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mstore(0x40, add(add(ptr, _len), 0x20)) // write new unused pointer\n            mstore(ptr, _len) // write len of new array (in bytes)\n        }\n    }\n\n    /**\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memViews  The views\n     * @return          unsafeView - The conjoined view pointing to the new memory\n     */\n    function unsafeJoin(bytes29[] memory memViews, uint256 _location)\n        private\n        view\n        returns (bytes29 unsafeView)\n    {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _location) {\n                revert(0x60, 0x20) // empty revert message\n            }\n        }\n\n        uint256 _offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length; i++) {\n            bytes29 memView = memViews[i];\n            unchecked {\n                unsafeCopyTo(memView, _location + _offset);\n                _offset += len(memView);\n            }\n        }\n        unsafeView = unsafeBuildUnchecked(0, _location, _offset);\n    }\n\n    /**\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The keccak256 digest\n     */\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return keccak(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The sha256 digest\n     */\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return sha2(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          copies all views, joins them into a new bytearray.\n     * @param memViews  The views\n     * @return          ret - The new byte array\n     */\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n\n        bytes29 _newView;\n        unchecked {\n            _newView = unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 _written = len(_newView);\n        uint256 _footprint = footprint(_newView);\n\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // store the length\n            mstore(ptr, _written)\n            // new pointer is old + 0x20 + the footprint of the body\n            mstore(0x40, add(add(ptr, _footprint), 0x20))\n            ret := ptr\n        }\n    }\n}\n\n/// @dev CallData is a memory view over the payload to be used for an external call, i.e.\n/// recipient.call(callData). Its length is always (4 + 32 * N) bytes:\n/// - First 4 bytes represent the function selector.\n/// - 32 * N bytes represent N words that function arguments occupy.\ntype CallData is bytes29;\n/// @dev Signature is a memory view over a \"65 bytes\" array representing a ECDSA signature.\ntype Signature is bytes29;\n\nlibrary ByteString {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev non-compact ECDSA signatures are enforced as of OZ 4.7.3\n     *\n     *      Signature payload memory layout\n     * [000 .. 032) r   bytes32 32 bytes\n     * [032 .. 064) s   bytes32 32 bytes\n     * [064 .. 065) v   uint8    1 byte\n     */\n    uint256 internal constant SIGNATURE_LENGTH = 65;\n    uint256 internal constant OFFSET_R = 0;\n    uint256 internal constant OFFSET_S = 32;\n    uint256 internal constant OFFSET_V = 64;\n\n    /**\n     * @dev Calldata memory layout\n     * [000 .. 004) selector    bytes4  4 bytes\n     *      Optional: N function arguments\n     * [004 .. 036) arg1        bytes32 32 bytes\n     *      ..\n     * [AAA .. END) argN        bytes32 32 bytes\n     */\n    uint256 internal constant SELECTOR_LENGTH = 4;\n    uint256 internal constant OFFSET_SELECTOR = 0;\n    uint256 internal constant OFFSET_ARGUMENTS = SELECTOR_LENGTH;\n\n    /**\n     * @notice Returns a memory view over the given payload, treating it as raw bytes.\n     * @dev Shortcut for .ref(0) - to be deprecated once \"uint40 type\" is removed from bytes29.\n     */\n    function castToRawBytes(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref({ newType: 0 });\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              SIGNATURE                               ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Constructs the signature payload from the given values.\n     * @dev Using ByteString.formatSignature({r: r, s: s, v: v}) will make sure\n     * that params are given in the right order.\n     */\n    function formatSignature(\n        bytes32 r,\n        bytes32 s,\n        uint8 v\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(r, s, v);\n    }\n\n    /**\n     * @notice Returns a Signature view over for the given payload.\n     * @dev Will revert if the payload is not a signature.\n     */\n    function castToSignature(bytes memory _payload) internal pure returns (Signature) {\n        return castToSignature(castToRawBytes(_payload));\n    }\n\n    /**\n     * @notice Casts a memory view to a Signature view.\n     * @dev Will revert if the memory view is not over a signature.\n     */\n    function castToSignature(bytes29 _view) internal pure returns (Signature) {\n        require(isSignature(_view), \"Not a signature\");\n        return Signature.wrap(_view);\n    }\n\n    /**\n     * @notice Checks that a byte string is a signature\n     */\n    function isSignature(bytes29 _view) internal pure returns (bool) {\n        return _view.len() == SIGNATURE_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Signature _signature) internal pure returns (bytes29) {\n        return Signature.unwrap(_signature);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                          SIGNATURE SLICING                           ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /// @notice Unpacks signature payload into (r, s, v) parameters.\n    /// @dev Make sure to verify signature length with isSignature() beforehand.\n    function toRSV(Signature _signature)\n        internal\n        pure\n        returns (\n            bytes32 r,\n            bytes32 s,\n            uint8 v\n        )\n    {\n        // Get the underlying memory view\n        bytes29 _view = unwrap(_signature);\n        r = _view.index({ _index: OFFSET_R, _bytes: 32 });\n        s = _view.index({ _index: OFFSET_S, _bytes: 32 });\n        v = uint8(_view.indexUint({ _index: OFFSET_V, _bytes: 1 }));\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                               CALLDATA                               ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns a CallData view over for the given payload.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(bytes memory _payload) internal pure returns (CallData) {\n        return castToCallData(castToRawBytes(_payload));\n    }\n\n    /**\n     * @notice Casts a memory view to a CallData view.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(bytes29 _view) internal pure returns (CallData) {\n        require(isCallData(_view), \"Not a calldata\");\n        return CallData.wrap(_view);\n    }\n\n    /**\n     * @notice Checks that a byte string is a valid calldata, i.e.\n     * a function selector, followed by arbitrary amount of arguments.\n     */\n    function isCallData(bytes29 _view) internal pure returns (bool) {\n        uint256 length = _view.len();\n        // Calldata should at least have a function selector\n        if (length \u003c SELECTOR_LENGTH) return false;\n        // The remainder of the calldata should be exactly N words (N \u003e= 0), i.e.\n        // (length - SELECTOR_LENGTH) % 32 == 0\n        // We're using logical AND here to speed it up a bit\n        return (length - SELECTOR_LENGTH) \u0026 31 == 0;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(CallData _callData) internal pure returns (bytes29) {\n        return CallData.unwrap(_callData);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           CALLDATA SLICING                           ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns amount of memory words (32 byte chunks) the function arguments\n     * occupy in the calldata.\n     * @dev This might differ from amount of arguments supplied, if any of the arguments\n     * occupies more than one memory slot. It is true, however, that argument part of the payload\n     * occupies exactly N words, even for dynamic types like `bytes`\n     */\n    function argumentWords(CallData _callData) internal pure returns (uint256) {\n        // Get the underlying memory view\n        bytes29 _view = unwrap(_callData);\n        // Equivalent of (length - SELECTOR_LENGTH) / 32\n        return (_view.len() - SELECTOR_LENGTH) \u003e\u003e 5;\n    }\n\n    /// @notice Returns selector for the provided calldata.\n    function callSelector(CallData _callData) internal pure returns (bytes29) {\n        // Get the underlying memory view\n        bytes29 _view = unwrap(_callData);\n        return _view.slice({ _index: OFFSET_SELECTOR, _len: SELECTOR_LENGTH, newType: 0 });\n    }\n\n    /// @notice Returns abi encoded arguments for the provided calldata.\n    function arguments(CallData _callData) internal pure returns (bytes29) {\n        // Get the underlying memory view\n        bytes29 _view = unwrap(_callData);\n        return _view.sliceFrom({ _index: OFFSET_ARGUMENTS, newType: 0 });\n    }\n}\n\nlibrary TypeCasts {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    function coerceBytes32(string memory _s) internal pure returns (bytes32 _b) {\n        _b = bytes(_s).ref(0).index(0, uint8(bytes(_s).length));\n    }\n\n    // treat it as a null-terminated string of max 32 bytes\n    function coerceString(bytes32 _buf) internal pure returns (string memory _newStr) {\n        uint8 _slen = 0;\n        while (_slen \u003c 32 \u0026\u0026 _buf[_slen] != 0) {\n            _slen++;\n        }\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            _newStr := mload(0x40)\n            mstore(0x40, add(_newStr, 0x40)) // may end up with extra\n            mstore(_newStr, _slen)\n            mstore(add(_newStr, 0x20), _buf)\n        }\n    }\n\n    // alignment preserving cast\n    function addressToBytes32(address _addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(_addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 _buf) internal pure returns (address) {\n        return address(uint160(uint256(_buf)));\n    }\n}\n\n/// @dev Header is a memory over over a formatted message header payload.\ntype Header is bytes29;\n/// @dev Attach library functions to Header\nusing {\n    HeaderLib.unwrap,\n    HeaderLib.version,\n    HeaderLib.origin,\n    HeaderLib.sender,\n    HeaderLib.nonce,\n    HeaderLib.destination,\n    HeaderLib.recipient,\n    HeaderLib.optimisticSeconds,\n    HeaderLib.recipientAddress\n} for Header global;\n\n/**\n * @notice Library for versioned formatting [the header part]\n * of [the messages used by Origin and Destination].\n */\nlibrary HeaderLib {\n    using ByteString for bytes;\n    using TypedMemView for bytes29;\n\n    uint16 internal constant HEADER_VERSION = 1;\n\n    /**\n     * @dev Header memory layout\n     * [000 .. 002): version            uint16   2 bytes\n     * [002 .. 006): origin             uint32   4 bytes\n     * [006 .. 038): sender             bytes32 32 bytes\n     * [038 .. 042): nonce              uint32   4 bytes\n     * [042 .. 046): destination        uint32   4 bytes\n     * [046 .. 078): recipient          bytes32 32 bytes\n     * [078 .. 082): optimisticSeconds  uint32   4 bytes\n     */\n\n    uint256 internal constant OFFSET_VERSION = 0;\n    uint256 internal constant OFFSET_ORIGIN = 2;\n    uint256 internal constant OFFSET_SENDER = 6;\n    uint256 internal constant OFFSET_NONCE = 38;\n    uint256 internal constant OFFSET_DESTINATION = 42;\n    uint256 internal constant OFFSET_RECIPIENT = 46;\n    uint256 internal constant OFFSET_OPTIMISTIC_SECONDS = 78;\n\n    uint256 internal constant HEADER_LENGTH = 82;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns a formatted Header payload with provided fields\n     * @param _origin               Domain of origin chain\n     * @param _sender               Address that sent the message\n     * @param _nonce                Message nonce on origin chain\n     * @param _destination          Domain of destination chain\n     * @param _recipient            Address that will receive the message\n     * @param _optimisticSeconds    Optimistic period for message execution\n     * @return Formatted header\n     **/\n    function formatHeader(\n        uint32 _origin,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destination,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodePacked(\n                HEADER_VERSION,\n                _origin,\n                _sender,\n                _nonce,\n                _destination,\n                _recipient,\n                _optimisticSeconds\n            );\n    }\n\n    /**\n     * @notice Returns a Header view over for the given payload.\n     * @dev Will revert if the payload is not a header payload.\n     */\n    function castToHeader(bytes memory _payload) internal pure returns (Header) {\n        return castToHeader(_payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a Header view.\n     * @dev Will revert if the memory view is not over a header payload.\n     */\n    function castToHeader(bytes29 _view) internal pure returns (Header) {\n        require(isHeader(_view), \"Not a header payload\");\n        return Header.wrap(_view);\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Header.\n     */\n    function isHeader(bytes29 _view) internal pure returns (bool) {\n        uint256 length = _view.len();\n        // Check if version exists in the payload\n        if (length \u003c 2) return false;\n        // Check that header version and its length matches\n        return _getVersion(_view) == HEADER_VERSION \u0026\u0026 length == HEADER_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Header _header) internal pure returns (bytes29) {\n        return Header.unwrap(_header);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                            HEADER SLICING                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /// @notice Returns header's version field.\n    function version(Header _header) internal pure returns (uint16) {\n        // Get the underlying memory view\n        bytes29 _view = unwrap(_header);\n        return _getVersion(_view);\n    }\n\n    /// @notice Returns header's origin field\n    function origin(Header _header) internal pure returns (uint32) {\n        bytes29 _view = unwrap(_header);\n        return uint32(_view.indexUint(OFFSET_ORIGIN, 4));\n    }\n\n    /// @notice Returns header's sender field\n    function sender(Header _header) internal pure returns (bytes32) {\n        bytes29 _view = unwrap(_header);\n        return _view.index(OFFSET_SENDER, 32);\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(Header _header) internal pure returns (uint32) {\n        bytes29 _view = unwrap(_header);\n        return uint32(_view.indexUint(OFFSET_NONCE, 4));\n    }\n\n    /// @notice Returns header's destination field\n    function destination(Header _header) internal pure returns (uint32) {\n        bytes29 _view = unwrap(_header);\n        return uint32(_view.indexUint(OFFSET_DESTINATION, 4));\n    }\n\n    /// @notice Returns header's recipient field as bytes32\n    function recipient(Header _header) internal pure returns (bytes32) {\n        bytes29 _view = unwrap(_header);\n        return _view.index(OFFSET_RECIPIENT, 32);\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticSeconds(Header _header) internal pure returns (uint32) {\n        bytes29 _view = unwrap(_header);\n        return uint32(_view.indexUint(OFFSET_OPTIMISTIC_SECONDS, 4));\n    }\n\n    /// @notice Returns header's recipient field as an address\n    function recipientAddress(Header _header) internal pure returns (address) {\n        return TypeCasts.bytes32ToAddress(recipient(_header));\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           PRIVATE HELPERS                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /// @notice Returns a version field without checking if payload is properly formatted.\n    function _getVersion(bytes29 _view) internal pure returns (uint16) {\n        return uint16(_view.indexUint(OFFSET_VERSION, 2));\n    }\n}\n\n/// @dev Tips is a memory over over a formatted message tips payload.\ntype Tips is bytes29;\n/// @dev Attach library functions to Tips\nusing {\n    TipsLib.unwrap,\n    TipsLib.version,\n    TipsLib.notaryTip,\n    TipsLib.broadcasterTip,\n    TipsLib.proverTip,\n    TipsLib.executorTip,\n    TipsLib.totalTips\n} for Tips global;\n\n/**\n * @notice Library for versioned formatting [the tips part]\n * of [the messages used by Origin and Destination].\n */\nlibrary TipsLib {\n    using ByteString for bytes;\n    using TypedMemView for bytes29;\n\n    uint16 internal constant TIPS_VERSION = 1;\n\n    // TODO: determine if we need to pack the tips values,\n    // or if using uint256 instead will suffice.\n\n    /**\n     * @dev Tips memory layout\n     * [000 .. 002): version            uint16\t 2 bytes\n     * [002 .. 014): notaryTip          uint96\t12 bytes\n     * [014 .. 026): broadcasterTip     uint96\t12 bytes\n     * [026 .. 038): proverTip          uint96\t12 bytes\n     * [038 .. 050): executorTip        uint96\t12 bytes\n     */\n\n    uint256 internal constant OFFSET_VERSION = 0;\n    uint256 internal constant OFFSET_NOTARY = 2;\n    uint256 internal constant OFFSET_BROADCASTER = 14;\n    uint256 internal constant OFFSET_PROVER = 26;\n    uint256 internal constant OFFSET_EXECUTOR = 38;\n\n    uint256 internal constant TIPS_LENGTH = 50;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                                 TIPS                                 ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns a formatted Tips payload with provided fields\n     * @param _notaryTip        Tip for the Notary\n     * @param _broadcasterTip   Tip for the Broadcaster\n     * @param _proverTip        Tip for the Prover\n     * @param _executorTip      Tip for the Executor\n     * @return Formatted tips\n     **/\n    function formatTips(\n        uint96 _notaryTip,\n        uint96 _broadcasterTip,\n        uint96 _proverTip,\n        uint96 _executorTip\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodePacked(TIPS_VERSION, _notaryTip, _broadcasterTip, _proverTip, _executorTip);\n    }\n\n    /**\n     * @notice Returns a formatted Tips payload specifying empty tips.\n     * @return Formatted tips\n     **/\n    function emptyTips() internal pure returns (bytes memory) {\n        return formatTips(0, 0, 0, 0);\n    }\n\n    /**\n     * @notice Returns a Tips view over for the given payload.\n     * @dev Will revert if the payload is not a tips payload.\n     */\n    function castToTips(bytes memory _payload) internal pure returns (Tips) {\n        return castToTips(_payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a Tips view.\n     * @dev Will revert if the memory view is not over a tips payload.\n     */\n    function castToTips(bytes29 _view) internal pure returns (Tips) {\n        require(isTips(_view), \"Not a tips payload\");\n        return Tips.wrap(_view);\n    }\n\n    /// @notice Checks that a payload is a formatted Tips payload.\n    function isTips(bytes29 _view) internal pure returns (bool) {\n        uint256 length = _view.len();\n        // Check if version exists in the payload\n        if (length \u003c OFFSET_NOTARY) return false;\n        // Check that tips version and its length matches\n        return _getVersion(_view) == TIPS_VERSION \u0026\u0026 length == TIPS_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Tips _tips) internal pure returns (bytes29) {\n        return Tips.unwrap(_tips);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                             TIPS SLICING                             ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /// @notice Returns version of formatted tips\n    function version(Tips _tips) internal pure returns (uint16) {\n        // Get the underlying memory view\n        bytes29 _view = _tips.unwrap();\n        return _getVersion(_view);\n    }\n\n    /// @notice Returns notaryTip field\n    function notaryTip(Tips _tips) internal pure returns (uint96) {\n        bytes29 _view = _tips.unwrap();\n        return uint96(_view.indexUint(OFFSET_NOTARY, 12));\n    }\n\n    /// @notice Returns broadcasterTip field\n    function broadcasterTip(Tips _tips) internal pure returns (uint96) {\n        bytes29 _view = _tips.unwrap();\n        return uint96(_view.indexUint(OFFSET_BROADCASTER, 12));\n    }\n\n    /// @notice Returns proverTip field\n    function proverTip(Tips _tips) internal pure returns (uint96) {\n        bytes29 _view = _tips.unwrap();\n        return uint96(_view.indexUint(OFFSET_PROVER, 12));\n    }\n\n    /// @notice Returns executorTip field\n    function executorTip(Tips _tips) internal pure returns (uint96) {\n        bytes29 _view = _tips.unwrap();\n        return uint96(_view.indexUint(OFFSET_EXECUTOR, 12));\n    }\n\n    /// @notice Returns total tip amount.\n    function totalTips(Tips _tips) internal pure returns (uint96) {\n        // In practice there's no chance that the total tips value would not fit into uint96.\n        // TODO: determine if we want to use uint256 here instead anyway.\n        return notaryTip(_tips) + broadcasterTip(_tips) + proverTip(_tips) + executorTip(_tips);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           PRIVATE HELPERS                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /// @notice Returns a version field without checking if payload is properly formatted.\n    function _getVersion(bytes29 _view) private pure returns (uint16) {\n        return uint16(_view.indexUint(OFFSET_VERSION, 2));\n    }\n}\n\n/// @dev Message is a memory over over a formatted message payload.\ntype Message is bytes29;\n/// @dev Attach library functions to Message\nusing {\n    MessageLib.unwrap,\n    MessageLib.version,\n    MessageLib.header,\n    MessageLib.tips,\n    MessageLib.body,\n    MessageLib.leaf\n} for Message global;\n\n/**\n * @notice  Library for versioned formatting the messages used by Origin and Destination.\n */\nlibrary MessageLib {\n    using HeaderLib for bytes29;\n    using TipsLib for bytes29;\n    using ByteString for bytes;\n    using TypedMemView for bytes29;\n\n    enum Parts {\n        Version,\n        Header,\n        Tips,\n        Body\n    }\n\n    /**\n     * @dev This is only updated if the whole message structure is changed,\n     *      i.e. if a new part is added.\n     *      If already existing part is changed, the message version does not get bumped.\n     */\n    uint16 internal constant MESSAGE_VERSION = 1;\n\n    /**\n     * @dev Message memory layout\n     * [000 .. 002): version            uint16  2 bytes\n     * [002 .. 004): header length      uint16  2 bytes (length == AAA - 6)\n     * [004 .. 006): tips length        uint16  2 bytes (length == BBB - AAA)\n     * [006 .. AAA): header             bytes   ? bytes\n     * [AAA .. BBB): tips               bytes   ? bytes\n     * [BBB .. CCC): body               bytes   ? bytes (length could be zero)\n     */\n\n    uint256 internal constant OFFSET_VERSION = 0;\n\n    /// @dev How much bytes is used for storing the version, or a single offset value\n    uint8 internal constant TWO_BYTES = 2;\n    /// @dev This value reflects the header offset in the latest message version\n    uint16 internal constant OFFSET_HEADER = TWO_BYTES * uint8(type(Parts).max);\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns formatted message with provided fields\n     * @param _header       Formatted header payload\n     * @param _tips         Formatted tips payload\n     * @param _messageBody  Raw bytes of message body\n     * @return Formatted message\n     **/\n    function formatMessage(\n        bytes memory _header,\n        bytes memory _tips,\n        bytes memory _messageBody\n    ) internal pure returns (bytes memory) {\n        // Header and Tips are supposed to fit within 65535 bytes\n        return\n            abi.encodePacked(\n                MESSAGE_VERSION,\n                uint16(_header.length),\n                uint16(_tips.length),\n                _header,\n                _tips,\n                _messageBody\n            );\n    }\n\n    /**\n     * @notice Returns formatted message with provided fields\n     * @param _origin               Domain of origin chain\n     * @param _sender               Address that sent the message\n     * @param _nonce                Message nonce on origin chain\n     * @param _destination          Domain of destination chain\n     * @param _recipient            Address that will receive the message\n     * @param _optimisticSeconds    Optimistic period for message execution\n     * @param _tips                 Formatted tips payload\n     * @param _messageBody          Raw bytes of message body\n     * @return Formatted message\n     **/\n    function formatMessage(\n        uint32 _origin,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destination,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds,\n        bytes memory _tips,\n        bytes memory _messageBody\n    ) internal pure returns (bytes memory) {\n        return\n            formatMessage(\n                HeaderLib.formatHeader(\n                    _origin,\n                    _sender,\n                    _nonce,\n                    _destination,\n                    _recipient,\n                    _optimisticSeconds\n                ),\n                _tips,\n                _messageBody\n            );\n    }\n\n    /**\n     * @notice Returns a Message view over for the given payload.\n     * @dev Will revert if the payload is not a message payload.\n     */\n    function castToMessage(bytes memory _payload) internal pure returns (Message) {\n        return castToMessage(_payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a Message view.\n     * @dev Will revert if the memory view is not over a message payload.\n     */\n    function castToMessage(bytes29 _view) internal pure returns (Message) {\n        require(isMessage(_view), \"Not a message payload\");\n        return Message.wrap(_view);\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Message.\n     */\n    function isMessage(bytes29 _view) internal pure returns (bool) {\n        uint256 length = _view.len();\n        // Check if version and lengths exist in the payload\n        if (length \u003c OFFSET_HEADER) return false;\n        // Check message version\n        if (_getVersion(_view) != MESSAGE_VERSION) return false;\n\n        uint256 headerLength = _getLen(_view, Parts.Header);\n        uint256 tipsLength = _getLen(_view, Parts.Tips);\n        // Header and Tips need to exist\n        // Body could be empty, thus \u003e\n        if (OFFSET_HEADER + headerLength + tipsLength \u003e length) return false;\n\n        // Check header for being a formatted header payload\n        // Check tips for being a formatted tips payload\n        if (!_getHeader(_view).isHeader() || !_getTips(_view).isTips()) return false;\n        return true;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Message _msg) internal pure returns (bytes29) {\n        return Message.unwrap(_msg);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           MESSAGE SLICING                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /// @notice Returns message's version field.\n    function version(Message _msg) internal pure returns (uint16) {\n        // Get the underlying memory view\n        bytes29 _view = _msg.unwrap();\n        return _getVersion(_view);\n    }\n\n    /// @notice Returns message's header field as a Header view.\n    function header(Message _msg) internal pure returns (Header) {\n        bytes29 _view = _msg.unwrap();\n        return _getHeader(_view).castToHeader();\n    }\n\n    /// @notice Returns message's tips field as a Tips view.\n    function tips(Message _msg) internal pure returns (Tips) {\n        bytes29 _view = _msg.unwrap();\n        return _getTips(_view).castToTips();\n    }\n\n    /// @notice Returns message's body field as a generic memory view.\n    function body(Message _msg) internal pure returns (bytes29) {\n        bytes29 _view = _msg.unwrap();\n        // Determine index where message body payload starts\n        uint256 index = OFFSET_HEADER + _getLen(_view, Parts.Header) + _getLen(_view, Parts.Tips);\n        return _view.sliceFrom({ _index: index, newType: 0 });\n    }\n\n    /// @notice Returns message's hash: a leaf to be inserted in the Merkle tree.\n    function leaf(Message _msg) internal pure returns (bytes32) {\n        bytes29 _view = _msg.unwrap();\n        return _view.keccak();\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           PRIVATE HELPERS                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /// @dev Returns length for a given part of the message\n    /// without checking if the payload is properly formatted.\n    function _getLen(bytes29 _view, Parts _part) private pure returns (uint256) {\n        return _view.indexUint(uint256(_part) * TWO_BYTES, TWO_BYTES);\n    }\n\n    /// @dev Returns a version field without checking if the payload is properly formatted.\n    function _getVersion(bytes29 _view) private pure returns (uint16) {\n        return uint16(_view.indexUint(OFFSET_VERSION, 2));\n    }\n\n    /// @dev Returns a generic memory view over the header field without checking\n    /// if the whole payload or the header are properly formatted.\n    function _getHeader(bytes29 _view) private pure returns (bytes29) {\n        uint256 length = _getLen(_view, Parts.Header);\n        return _view.slice({ _index: OFFSET_HEADER, _len: length, newType: 0 });\n    }\n\n    /// @dev Returns a generic memory view over the tips field without checking\n    /// if the whole payload or the tips are properly formatted.\n    function _getTips(bytes29 _view) private pure returns (bytes29) {\n        // Determine index where tips payload starts\n        uint256 indexFrom = OFFSET_HEADER + _getLen(_view, Parts.Header);\n        uint256 length = _getLen(_view, Parts.Tips);\n        return _view.slice({ _index: indexFrom, _len: length, newType: 0 });\n    }\n}\n\n/**\n * @notice Exposes Message methods for testing against golang.\n */\ncontract MessageHarness {\n    using MessageLib for bytes;\n    using MessageLib for bytes29;\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                               GETTERS                                ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    function castToMessage(bytes memory _payload) public view returns (bytes memory) {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        Message _msg = MessageLib.castToMessage(_payload);\n        return _msg.unwrap().clone();\n    }\n\n    function header(bytes memory _payload) public view returns (bytes memory) {\n        return _payload.castToMessage().header().unwrap().clone();\n    }\n\n    function tips(bytes memory _payload) public view returns (bytes memory) {\n        return _payload.castToMessage().tips().unwrap().clone();\n    }\n\n    function body(bytes memory _payload) public view returns (bytes memory) {\n        return _payload.castToMessage().body().clone();\n    }\n\n    function version(bytes memory _payload) public pure returns (uint16) {\n        return _payload.castToMessage().version();\n    }\n\n    function leaf(bytes memory _payload) public pure returns (bytes32) {\n        return _payload.castToMessage().leaf();\n    }\n\n    function isMessage(bytes memory _payload) public pure returns (bool) {\n        return _payload.ref(0).isMessage();\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    function formatMessage(\n        uint32 _origin,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destination,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds,\n        // tips params\n        uint96 _notaryTip,\n        uint96 _broadcasterTip,\n        uint96 _proverTip,\n        uint96 _executorTip,\n        bytes memory _messageBody\n    ) public pure returns (bytes memory) {\n        bytes memory _tips = TipsLib.formatTips(\n            _notaryTip,\n            _broadcasterTip,\n            _proverTip,\n            _executorTip\n        );\n\n        bytes memory _header = HeaderLib.formatHeader(\n            _origin,\n            _sender,\n            _nonce,\n            _destination,\n            _recipient,\n            _optimisticSeconds\n        );\n        return formatMessage(_header, _tips, _messageBody);\n    }\n\n    function formatMessage(\n        uint32 _origin,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destination,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds,\n        bytes memory _tips,\n        bytes memory _messageBody\n    ) public pure returns (bytes memory) {\n        return\n            MessageLib.formatMessage(\n                _origin,\n                _sender,\n                _nonce,\n                _destination,\n                _recipient,\n                _optimisticSeconds,\n                _tips,\n                _messageBody\n            );\n    }\n\n    function formatMessage(\n        bytes memory _header,\n        bytes memory _tips,\n        bytes memory _messageBody\n    ) public pure returns (bytes memory) {\n        return MessageLib.formatMessage(_header, _tips, _messageBody);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           CONSTANT GETTERS                           ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    function messageVersion() public pure returns (uint16) {\n        return MessageLib.MESSAGE_VERSION;\n    }\n\n    function offsetVersion() public pure returns (uint256) {\n        return MessageLib.OFFSET_VERSION;\n    }\n\n    function offsetHeader() public pure returns (uint256) {\n        return MessageLib.OFFSET_HEADER;\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"36156:8192:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;36156:8192:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"36156:8192:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"stateVariables":{"SELECTOR_LENGTH":{"details":"Calldata memory layout [000 .. 004) selector    bytes4  4 bytes      Optional: N function arguments [004 .. 036) arg1        bytes32 32 bytes      .. [AAA .. END) argN        bytes32 32 bytes"},"SIGNATURE_LENGTH":{"details":"non-compact ECDSA signatures are enforced as of OZ 4.7.3      Signature payload memory layout [000 .. 032) r   bytes32 32 bytes [032 .. 064) s   bytes32 32 bytes [064 .. 065) v   uint8    1 byte"}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"stateVariables\":{\"SELECTOR_LENGTH\":{\"details\":\"Calldata memory layout [000 .. 004) selector    bytes4  4 bytes      Optional: N function arguments [004 .. 036) arg1        bytes32 32 bytes      .. [AAA .. END) argN        bytes32 32 bytes\"},\"SIGNATURE_LENGTH\":{\"details\":\"non-compact ECDSA signatures are enforced as of OZ 4.7.3      Signature payload memory layout [000 .. 032) r   bytes32 32 bytes [032 .. 064) s   bytes32 32 bytes [064 .. 065) v   uint8    1 byte\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/MessageHarness.t.sol\":\"ByteString\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/MessageHarness.t.sol\":{\"keccak256\":\"0x3904cba9f384c6433257789b24cdb15655a5775a36df2c4c297958af081b2acc\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://eff1071fd96ffa0ae24c5a5d8de738a1545769b12ccc3c5ec469a9d7e16b21db\",\"dweb:/ipfs/QmYyQsoEqF9QJ5aHaVw5545ePNt9Z7GqXfVyCFGrEh4y84\"]}},\"version\":1}"},"hashes":{}},"solidity/MessageHarness.t.sol:HeaderLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212201d0a2b32586370ab66b210e31e294e3325f426a9dadcf1f7f699772269cfaa3264736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212201d0a2b32586370ab66b210e31e294e3325f426a9dadcf1f7f699772269cfaa3264736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nlibrary TypedMemView {\n    // Why does this exist?\n    // the solidity `bytes memory` type has a few weaknesses.\n    // 1. You can't index ranges effectively\n    // 2. You can't slice without copying\n    // 3. The underlying data may represent any type\n    // 4. Solidity never deallocates memory, and memory costs grow\n    //    superlinearly\n\n    // By using a memory view instead of a `bytes memory` we get the following\n    // advantages:\n    // 1. Slices are done on the stack, by manipulating the pointer\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\n    // 3. We can insert type info into the pointer, and typecheck at runtime\n\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\n    // algorithms.\n\n    // Why bytes29?\n    // We want to avoid confusion between views, digests, and other common\n    // types so we chose a large and uncommonly used odd number of bytes\n    //\n    // Note that while bytes are left-aligned in a word, integers and addresses\n    // are right-aligned. This means when working in assembly we have to\n    // account for the 3 unused bytes on the righthand side\n    //\n    // First 5 bytes are a type flag.\n    // - ff_ffff_fffe is reserved for unknown type.\n    // - ff_ffff_ffff is reserved for invalid types/errors.\n    // next 12 are memory address\n    // next 12 are len\n    // bottom 3 bytes are empty\n\n    // Assumptions:\n    // - non-modification of memory.\n    // - No Solidity updates\n    // - - wrt free mem point\n    // - - wrt bytes representation in memory\n    // - - wrt memory addressing in general\n\n    // Usage:\n    // - create type constants\n    // - use `assertType` for runtime type assertions\n    // - - unfortunately we can't do this at compile time yet :(\n    // - recommended: implement modifiers that perform type checking\n    // - - e.g.\n    // - - `uint40 constant MY_TYPE = 3;`\n    // - - ` modifier onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n    // - instantiate a typed view from a bytearray using `ref`\n    // - use `index` to inspect the contents of the view\n    // - use `slice` to create smaller views into the same memory\n    // - - `slice` can increase the offset\n    // - - `slice can decrease the length`\n    // - - must specify the output type of `slice`\n    // - - `slice` will return a null view if you try to overrun\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\n    // - use `equal` for typed comparisons.\n\n    // The null view\n    bytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n\n    /**\n     * @dev Memory layout for bytes29\n     * TODO (Chi): with the user defined types storing type is no longer necessary.\n     * Update the library, transforming bytes29 to bytes24 in the process.\n     * [000..005)   type     5 bytes    Type flag for the pointer\n     * [005..017)   loc     12 bytes    Memory address of underlying bytes\n     * [017..029)   len     12 bytes    Length of underlying bytes\n     * [029..032)   empty    3 bytes    Not used\n     */\n    uint256 public constant BITS_TYPE = 40;\n    uint256 public constant BITS_LOC = 96;\n    uint256 public constant BITS_LEN = 96;\n    uint256 public constant BITS_EMPTY = 24;\n\n    // `SHIFT_X` is how much bits to shift for `X` to be in the very bottom bits\n    uint256 public constant SHIFT_LEN = BITS_EMPTY; // 24\n    uint256 public constant SHIFT_LOC = SHIFT_LEN + BITS_LEN; // 24 + 96 = 120\n    uint256 public constant SHIFT_TYPE = SHIFT_LOC + BITS_LOC; // 24 + 96 + 96 = 216\n    // Bitmask for the lowest 96 bits\n    uint256 public constant LOW_96_BITS_MASK = type(uint96).max;\n\n    // For nibble encoding\n    bytes private constant NIBBLE_LOOKUP = \"0123456789abcdef\";\n\n    /**\n     * @notice Returns the encoded hex character that represents the lower 4 bits of the argument.\n     * @param _byte     The byte\n     * @return _char    The encoded hex character\n     */\n    function nibbleHex(uint8 _byte) internal pure returns (uint8 _char) {\n        uint8 _nibble = _byte \u0026 0x0f; // keep bottom 4 bits, zero out top 4 bits\n        _char = uint8(NIBBLE_LOOKUP[_nibble]);\n    }\n\n    /**\n     * @notice      Returns a uint16 containing the hex-encoded byte.\n     * @param _b    The byte\n     * @return      encoded - The hex-encoded byte\n     */\n    function byteHex(uint8 _b) internal pure returns (uint16 encoded) {\n        encoded |= nibbleHex(_b \u003e\u003e 4); // top 4 bits\n        encoded \u003c\u003c= 8;\n        encoded |= nibbleHex(_b); // lower 4 bits\n    }\n\n    /**\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\n     *              `second` contains the encoded lower 16 bytes.\n     *\n     * @param _b    The 32 bytes as uint256\n     * @return      first - The top 16 bytes\n     * @return      second - The bottom 16 bytes\n     */\n    function encodeHex(uint256 _b) internal pure returns (uint256 first, uint256 second) {\n        for (uint8 i = 31; i \u003e 15; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            first |= byteHex(_byte);\n            if (i != 16) {\n                first \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n\n        // abusing underflow here =_=\n        for (uint8 i = 15; i \u003c 255; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            second |= byteHex(_byte);\n            if (i != 0) {\n                second \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n    }\n\n    /**\n     * @notice          Changes the endianness of a uint256.\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n     * @param _b        The unsigned integer to reverse\n     * @return          v - The reversed value\n     */\n    function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\n        v = _b;\n\n        // swap bytes\n        v =\n            ((v \u003e\u003e 8) \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\n            ((v \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) \u003c\u003c 8);\n        // swap 2-byte long pairs\n        v =\n            ((v \u003e\u003e 16) \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\n            ((v \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) \u003c\u003c 16);\n        // swap 4-byte long pairs\n        v =\n            ((v \u003e\u003e 32) \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\n            ((v \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) \u003c\u003c 32);\n        // swap 8-byte long pairs\n        v =\n            ((v \u003e\u003e 64) \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\n            ((v \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) \u003c\u003c 64);\n        // swap 16-byte long pairs\n        v = (v \u003e\u003e 128) | (v \u003c\u003c 128);\n    }\n\n    /**\n     * @notice      Create a mask with the highest `_len` bits set.\n     * @param _len  The length\n     * @return      mask - The mask\n     */\n    function leftMask(uint8 _len) private pure returns (uint256 mask) {\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(\n                sub(_len, 1),\n                0x8000000000000000000000000000000000000000000000000000000000000000\n            )\n        }\n    }\n\n    /**\n     * @notice      Return the null view.\n     * @return      bytes29 - The null view\n     */\n    // solhint-disable-next-line ordering\n    function nullView() internal pure returns (bytes29) {\n        return NULL;\n    }\n\n    /**\n     * @notice      Check if the view is null.\n     * @return      bool - True if the view is null\n     */\n    function isNull(bytes29 memView) internal pure returns (bool) {\n        return memView == NULL;\n    }\n\n    /**\n     * @notice      Check if the view is not null.\n     * @return      bool - True if the view is not null\n     */\n    function notNull(bytes29 memView) internal pure returns (bool) {\n        return !isNull(memView);\n    }\n\n    /**\n     * @notice          Check if the view is of a valid type and points to a valid location\n     *                  in memory.\n     * @dev             We perform this check by examining solidity's unallocated memory\n     *                  pointer and ensuring that the view's upper bound is less than that.\n     * @param memView   The view\n     * @return          ret - True if the view is valid\n     */\n    function isValid(bytes29 memView) internal pure returns (bool ret) {\n        if (typeOf(memView) == 0xffffffffff) {\n            return false;\n        }\n        uint256 _end = end(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // View is valid if (\"upper bound\" \u003c= \"unallocated memory pointer\")\n            // Upper bound is exclusive, hence \"\u003c=\"\n            ret := not(gt(_end, mload(0x40)))\n        }\n    }\n\n    /**\n     * @notice          Require that a typed memory view be valid.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @return          bytes29 - The validated view\n     */\n    function assertValid(bytes29 memView) internal pure returns (bytes29) {\n        require(isValid(memView), \"Validity assertion failed\");\n        return memView;\n    }\n\n    /**\n     * @notice          Return true if the memview is of the expected type. Otherwise false.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bool - True if the memview is of the expected type\n     */\n    function isType(bytes29 memView, uint40 _expected) internal pure returns (bool) {\n        return typeOf(memView) == _expected;\n    }\n\n    /**\n     * @notice          Require that a typed memory view has a specific type.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bytes29 - The view with validated type\n     */\n    function assertType(bytes29 memView, uint40 _expected) internal pure returns (bytes29) {\n        if (!isType(memView, _expected)) {\n            (, uint256 g) = encodeHex(uint256(typeOf(memView)));\n            (, uint256 e) = encodeHex(uint256(_expected));\n            string memory err = string(\n                abi.encodePacked(\n                    \"Type assertion failed. Got 0x\",\n                    uint80(g),\n                    \". Expected 0x\",\n                    uint80(e)\n                )\n            );\n            revert(err);\n        }\n        return memView;\n    }\n\n    /**\n     * @notice          Return an identical view with a different type.\n     * @param memView   The view\n     * @param _newType  The new type\n     * @return          newView - The new view with the specified type\n     */\n    function castTo(bytes29 memView, uint40 _newType) internal pure returns (bytes29 newView) {\n        // How many bits are the \"type bits\" occupying\n        uint256 _bitsType = BITS_TYPE;\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 _shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // shift off the \"type bits\" (shift left, then sift right)\n            newView := or(newView, shr(_bitsType, shl(_bitsType, memView)))\n            // set the new \"type bits\" (shift left, then OR)\n            newView := or(newView, shl(_shiftType, _newType))\n        }\n    }\n\n    /**\n     * @notice          Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function unsafeBuildUnchecked(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) private pure returns (bytes29 newView) {\n        uint256 _bitsLoc = BITS_LOC;\n        uint256 _bitsLen = BITS_LEN;\n        uint256 _bitsEmpty = BITS_EMPTY;\n        // Ref memory layout\n        // [000..005) 5 bytes of type\n        // [005..017) 12 bytes of location\n        // [017..029) 12 bytes of length\n        // last 3 bits are blank and dropped in typecast\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // insert `type`, shift to prepare empty bits for `loc`\n            newView := shl(_bitsLoc, or(newView, _type))\n            // insert `loc`, shift to prepare empty bits for `len`\n            newView := shl(_bitsLen, or(newView, _loc))\n            // insert `len`, shift to insert 3 blank lowest bits\n            newView := shl(_bitsEmpty, or(newView, _len))\n        }\n    }\n\n    /**\n     * @notice          Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function build(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) internal pure returns (bytes29 newView) {\n        uint256 _end = _loc + _len;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(_end, mload(0x40)) {\n                _end := 0\n            }\n        }\n        if (_end == 0) {\n            return NULL;\n        }\n        newView = unsafeBuildUnchecked(_type, _loc, _len);\n    }\n\n    /**\n     * @notice          Instantiate a memory view from a byte array.\n     * @dev             Note that due to Solidity memory representation, it is not possible to\n     *                  implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr       The byte array\n     * @param newType   The type\n     * @return          bytes29 - The memory view\n     */\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\n        uint256 _len = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 _loc;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            _loc := add(arr, 0x20)\n        }\n\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Return the associated type information.\n     * @param memView   The memory view\n     * @return          _type - The type associated with the view\n     */\n    function typeOf(bytes29 memView) internal pure returns (uint40 _type) {\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 _shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"type bits\". \"type bits\" are occupying\n            // the highest bits, so all that's left is \"type bits\", OR is not required.\n            _type := shr(_shiftType, memView)\n        }\n    }\n\n    /**\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the 5-byte type flag is equal\n     */\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\n        // Check that the highest 5 bytes are equal: xor and shift out lower 27 bytes\n        return (left ^ right) \u003e\u003e SHIFT_TYPE == 0;\n    }\n\n    /**\n     * @notice          Return the memory address of the underlying bytes.\n     * @param memView   The view\n     * @return          _loc - The memory address\n     */\n    function loc(bytes29 memView) internal pure returns (uint96 _loc) {\n        // How many bits are the \"loc bits\" shifted from the bottom\n        uint256 _shiftLoc = SHIFT_LOC;\n        // Mask for the bottom 96 bits\n        uint256 _uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"loc bits\".\n            // Then use the lowest 96 bits to determine `loc` by applying the bit-mask.\n            _loc := and(shr(_shiftLoc, memView), _uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          The number of memory words this memory view occupies, rounded up.\n     * @param memView   The view\n     * @return          uint256 - The number of memory words\n     */\n    function words(bytes29 memView) internal pure returns (uint256) {\n        // returning ceil(length / 32.0)\n        return (uint256(len(memView)) + 31) / 32;\n    }\n\n    /**\n     * @notice          The in-memory footprint of a fresh copy of the view.\n     * @param memView   The view\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(bytes29 memView) internal pure returns (uint256) {\n        return words(memView) * 32;\n    }\n\n    /**\n     * @notice          The number of bytes of the view.\n     * @param memView   The view\n     * @return          _len - The length of the view\n     */\n    function len(bytes29 memView) internal pure returns (uint96 _len) {\n        // How many bits are the \"len bits\" shifted from the bottom\n        uint256 _shiftLen = SHIFT_LEN;\n        // Mask for the bottom 96 bits\n        uint256 _uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"len bits\".\n            // Then use the lowest 96 bits to determine `len` by applying the bit-mask.\n            _len := and(shr(_shiftLen, memView), _uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          Returns the endpoint of `memView`.\n     * @param memView   The view\n     * @return          uint256 - The endpoint of `memView`\n     */\n    function end(bytes29 memView) internal pure returns (uint256) {\n        unchecked {\n            return loc(memView) + len(memView);\n        }\n    }\n\n    /**\n     * @notice          Safe slicing without memory modification.\n     * @param memView   The view\n     * @param _index    The start index\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function slice(\n        bytes29 memView,\n        uint256 _index,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        uint256 _loc = loc(memView);\n\n        // Ensure it doesn't overrun the view\n        if (_loc + _index + _len \u003e end(memView)) {\n            return NULL;\n        }\n\n        _loc = _loc + _index;\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing\n     *                  bytes from `_index` to end(memView).\n     * @param memView   The view\n     * @param _index    The start index\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function sliceFrom(\n        bytes29 memView,\n        uint256 _index,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, _index, len(memView) - _index, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the first `_len` bytes.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function prefix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, 0, _len, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the last `_len` byte.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function postfix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, uint256(len(memView)) - _len, _len, newType);\n    }\n\n    /**\n     * @notice          Construct an error message for an indexing overrun.\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @param _index    The index\n     * @param _slice    The slice where the overrun occurred\n     * @return          err - The err\n     */\n    function indexErrOverrun(\n        uint256 _loc,\n        uint256 _len,\n        uint256 _index,\n        uint256 _slice\n    ) internal pure returns (string memory err) {\n        (, uint256 a) = encodeHex(_loc);\n        (, uint256 b) = encodeHex(_len);\n        (, uint256 c) = encodeHex(_index);\n        (, uint256 d) = encodeHex(_slice);\n        err = string(\n            abi.encodePacked(\n                \"TypedMemView/index - Overran the view. Slice is at 0x\",\n                uint48(a),\n                \" with length 0x\",\n                uint48(b),\n                \". Attempted to index at offset 0x\",\n                uint48(c),\n                \" with length 0x\",\n                uint48(d),\n                \".\"\n            )\n        );\n    }\n\n    /**\n     * @notice          Load up to 32 bytes from the view onto the stack.\n     * @dev             Returns a bytes32 with only the `_bytes` highest bytes set.\n     *                  This can be immediately cast to a smaller fixed-length byte array.\n     *                  To automatically cast to an integer, use `indexUint`.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The 32 byte result\n     */\n    function index(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (bytes32 result) {\n        if (_bytes == 0) {\n            return bytes32(0);\n        }\n        if (_index + _bytes \u003e len(memView)) {\n            revert(indexErrOverrun(loc(memView), len(memView), _index, uint256(_bytes)));\n        }\n        require(_bytes \u003c= 32, \"Index: more than 32 bytes\");\n\n        uint8 bitLength;\n        unchecked {\n            bitLength = _bytes * 8;\n        }\n        uint256 _loc = loc(memView);\n        // Get a mask with `bitLength` highest bits set\n        uint256 _mask = leftMask(bitLength);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(_loc, _index)), _mask)\n        }\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from the view at `_index`.\n     * @dev             Requires that the view have \u003e= `_bytes` bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        // `index()` returns left-aligned `_bytes`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word\n        return uint256(index(memView, _index, _bytes)) \u003e\u003e ((32 - _bytes) * 8);\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from LE bytes.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexLEUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return reverseUint256(uint256(index(memView, _index, _bytes)));\n    }\n\n    /**\n     * @notice          Parse an address from the view at `_index`.\n     *                  Requires that the view have \u003e= 20 bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @return          address - The address\n     */\n    function indexAddress(bytes29 memView, uint256 _index) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(indexUint(memView, _index, 20)));\n    }\n\n    /**\n     * @notice          Return the keccak256 hash of the underlying memory\n     * @param memView   The view\n     * @return          digest - The keccak256 hash of the underlying memory\n     */\n    function keccak(bytes29 memView) internal pure returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(_loc, _len)\n        }\n    }\n\n    /**\n     * @notice          Return the sha2 digest of the underlying memory.\n     * @dev             We explicitly deallocate memory afterwards.\n     * @param memView   The view\n     * @return          digest - The sha2 hash of the underlying memory\n     */\n    function sha2(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            digest := mload(ptr)\n        }\n        require(res, \"sha2: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n     * @param memView   The pre-image\n     * @return          digest - the Digest\n     */\n    function hash160(bytes29 memView) internal view returns (bytes20 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            // rmd160 precompile is 0x03\n            res := and(res, staticcall(gas(), 0x03, ptr, 0x20, ptr, 0x20))\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\n        }\n        require(res, \"hash160: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash256 (double sha2)\n     * @param memView   A view of the preimage\n     * @return          digest - the Digest\n     */\n    function hash256(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            res := and(res, staticcall(gas(), 0x02, ptr, 0x20, ptr, 0x20))\n            digest := mload(ptr)\n        }\n        require(res, \"hash256: out of gas\");\n    }\n\n    /**\n     * @notice          Return true if the underlying memory is equal. Else false.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the underlying memory is equal\n     */\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return\n            (loc(left) == loc(right) \u0026\u0026 len(left) == len(right)) || keccak(left) == keccak(right);\n    }\n\n    /**\n     * @notice          Return false if the underlying memory is equal. Else true.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - False if the underlying memory is equal\n     */\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !untypedEqual(left, right);\n    }\n\n    /**\n     * @notice          Compares type equality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are the same\n     */\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return left == right || (typeOf(left) == typeOf(right) \u0026\u0026 keccak(left) == keccak(right));\n    }\n\n    /**\n     * @notice          Compares type inequality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are not the same\n     */\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !equal(left, right);\n    }\n\n    /**\n     * @notice          Copy the view to a location, return an unsafe memory reference\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memView   The view\n     * @param _newLoc   The new location\n     * @return          written - the unsafe memory reference\n     */\n    function unsafeCopyTo(bytes29 memView, uint256 _newLoc) private view returns (bytes29 written) {\n        require(notNull(memView), \"copyTo: Null pointer deref\");\n        require(isValid(memView), \"copyTo: Invalid pointer deref\");\n        uint256 _len = len(memView);\n        uint256 _oldLoc = loc(memView);\n\n        uint256 ptr;\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _newLoc) {\n                revert(0x60, 0x20) // empty revert message\n            }\n\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, _oldLoc, _len, _newLoc, _len)\n        }\n        require(res, \"identity: out of gas\");\n\n        written = unsafeBuildUnchecked(typeOf(memView), _newLoc, _len);\n    }\n\n    /**\n     * @notice          Copies the referenced memory to a new loc in memory,\n     *                  returning a `bytes` pointing to the new memory.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param memView   The view\n     * @return          ret - The view pointing to the new memory\n     */\n    function clone(bytes29 memView) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n            ret := ptr\n        }\n        unchecked {\n            unsafeCopyTo(memView, ptr + 0x20);\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mstore(0x40, add(add(ptr, _len), 0x20)) // write new unused pointer\n            mstore(ptr, _len) // write len of new array (in bytes)\n        }\n    }\n\n    /**\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memViews  The views\n     * @return          unsafeView - The conjoined view pointing to the new memory\n     */\n    function unsafeJoin(bytes29[] memory memViews, uint256 _location)\n        private\n        view\n        returns (bytes29 unsafeView)\n    {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _location) {\n                revert(0x60, 0x20) // empty revert message\n            }\n        }\n\n        uint256 _offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length; i++) {\n            bytes29 memView = memViews[i];\n            unchecked {\n                unsafeCopyTo(memView, _location + _offset);\n                _offset += len(memView);\n            }\n        }\n        unsafeView = unsafeBuildUnchecked(0, _location, _offset);\n    }\n\n    /**\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The keccak256 digest\n     */\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return keccak(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The sha256 digest\n     */\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return sha2(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          copies all views, joins them into a new bytearray.\n     * @param memViews  The views\n     * @return          ret - The new byte array\n     */\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n\n        bytes29 _newView;\n        unchecked {\n            _newView = unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 _written = len(_newView);\n        uint256 _footprint = footprint(_newView);\n\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // store the length\n            mstore(ptr, _written)\n            // new pointer is old + 0x20 + the footprint of the body\n            mstore(0x40, add(add(ptr, _footprint), 0x20))\n            ret := ptr\n        }\n    }\n}\n\n/// @dev CallData is a memory view over the payload to be used for an external call, i.e.\n/// recipient.call(callData). Its length is always (4 + 32 * N) bytes:\n/// - First 4 bytes represent the function selector.\n/// - 32 * N bytes represent N words that function arguments occupy.\ntype CallData is bytes29;\n/// @dev Signature is a memory view over a \"65 bytes\" array representing a ECDSA signature.\ntype Signature is bytes29;\n\nlibrary ByteString {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev non-compact ECDSA signatures are enforced as of OZ 4.7.3\n     *\n     *      Signature payload memory layout\n     * [000 .. 032) r   bytes32 32 bytes\n     * [032 .. 064) s   bytes32 32 bytes\n     * [064 .. 065) v   uint8    1 byte\n     */\n    uint256 internal constant SIGNATURE_LENGTH = 65;\n    uint256 internal constant OFFSET_R = 0;\n    uint256 internal constant OFFSET_S = 32;\n    uint256 internal constant OFFSET_V = 64;\n\n    /**\n     * @dev Calldata memory layout\n     * [000 .. 004) selector    bytes4  4 bytes\n     *      Optional: N function arguments\n     * [004 .. 036) arg1        bytes32 32 bytes\n     *      ..\n     * [AAA .. END) argN        bytes32 32 bytes\n     */\n    uint256 internal constant SELECTOR_LENGTH = 4;\n    uint256 internal constant OFFSET_SELECTOR = 0;\n    uint256 internal constant OFFSET_ARGUMENTS = SELECTOR_LENGTH;\n\n    /**\n     * @notice Returns a memory view over the given payload, treating it as raw bytes.\n     * @dev Shortcut for .ref(0) - to be deprecated once \"uint40 type\" is removed from bytes29.\n     */\n    function castToRawBytes(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref({ newType: 0 });\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              SIGNATURE                               ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Constructs the signature payload from the given values.\n     * @dev Using ByteString.formatSignature({r: r, s: s, v: v}) will make sure\n     * that params are given in the right order.\n     */\n    function formatSignature(\n        bytes32 r,\n        bytes32 s,\n        uint8 v\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(r, s, v);\n    }\n\n    /**\n     * @notice Returns a Signature view over for the given payload.\n     * @dev Will revert if the payload is not a signature.\n     */\n    function castToSignature(bytes memory _payload) internal pure returns (Signature) {\n        return castToSignature(castToRawBytes(_payload));\n    }\n\n    /**\n     * @notice Casts a memory view to a Signature view.\n     * @dev Will revert if the memory view is not over a signature.\n     */\n    function castToSignature(bytes29 _view) internal pure returns (Signature) {\n        require(isSignature(_view), \"Not a signature\");\n        return Signature.wrap(_view);\n    }\n\n    /**\n     * @notice Checks that a byte string is a signature\n     */\n    function isSignature(bytes29 _view) internal pure returns (bool) {\n        return _view.len() == SIGNATURE_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Signature _signature) internal pure returns (bytes29) {\n        return Signature.unwrap(_signature);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                          SIGNATURE SLICING                           ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /// @notice Unpacks signature payload into (r, s, v) parameters.\n    /// @dev Make sure to verify signature length with isSignature() beforehand.\n    function toRSV(Signature _signature)\n        internal\n        pure\n        returns (\n            bytes32 r,\n            bytes32 s,\n            uint8 v\n        )\n    {\n        // Get the underlying memory view\n        bytes29 _view = unwrap(_signature);\n        r = _view.index({ _index: OFFSET_R, _bytes: 32 });\n        s = _view.index({ _index: OFFSET_S, _bytes: 32 });\n        v = uint8(_view.indexUint({ _index: OFFSET_V, _bytes: 1 }));\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                               CALLDATA                               ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns a CallData view over for the given payload.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(bytes memory _payload) internal pure returns (CallData) {\n        return castToCallData(castToRawBytes(_payload));\n    }\n\n    /**\n     * @notice Casts a memory view to a CallData view.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(bytes29 _view) internal pure returns (CallData) {\n        require(isCallData(_view), \"Not a calldata\");\n        return CallData.wrap(_view);\n    }\n\n    /**\n     * @notice Checks that a byte string is a valid calldata, i.e.\n     * a function selector, followed by arbitrary amount of arguments.\n     */\n    function isCallData(bytes29 _view) internal pure returns (bool) {\n        uint256 length = _view.len();\n        // Calldata should at least have a function selector\n        if (length \u003c SELECTOR_LENGTH) return false;\n        // The remainder of the calldata should be exactly N words (N \u003e= 0), i.e.\n        // (length - SELECTOR_LENGTH) % 32 == 0\n        // We're using logical AND here to speed it up a bit\n        return (length - SELECTOR_LENGTH) \u0026 31 == 0;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(CallData _callData) internal pure returns (bytes29) {\n        return CallData.unwrap(_callData);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           CALLDATA SLICING                           ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns amount of memory words (32 byte chunks) the function arguments\n     * occupy in the calldata.\n     * @dev This might differ from amount of arguments supplied, if any of the arguments\n     * occupies more than one memory slot. It is true, however, that argument part of the payload\n     * occupies exactly N words, even for dynamic types like `bytes`\n     */\n    function argumentWords(CallData _callData) internal pure returns (uint256) {\n        // Get the underlying memory view\n        bytes29 _view = unwrap(_callData);\n        // Equivalent of (length - SELECTOR_LENGTH) / 32\n        return (_view.len() - SELECTOR_LENGTH) \u003e\u003e 5;\n    }\n\n    /// @notice Returns selector for the provided calldata.\n    function callSelector(CallData _callData) internal pure returns (bytes29) {\n        // Get the underlying memory view\n        bytes29 _view = unwrap(_callData);\n        return _view.slice({ _index: OFFSET_SELECTOR, _len: SELECTOR_LENGTH, newType: 0 });\n    }\n\n    /// @notice Returns abi encoded arguments for the provided calldata.\n    function arguments(CallData _callData) internal pure returns (bytes29) {\n        // Get the underlying memory view\n        bytes29 _view = unwrap(_callData);\n        return _view.sliceFrom({ _index: OFFSET_ARGUMENTS, newType: 0 });\n    }\n}\n\nlibrary TypeCasts {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    function coerceBytes32(string memory _s) internal pure returns (bytes32 _b) {\n        _b = bytes(_s).ref(0).index(0, uint8(bytes(_s).length));\n    }\n\n    // treat it as a null-terminated string of max 32 bytes\n    function coerceString(bytes32 _buf) internal pure returns (string memory _newStr) {\n        uint8 _slen = 0;\n        while (_slen \u003c 32 \u0026\u0026 _buf[_slen] != 0) {\n            _slen++;\n        }\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            _newStr := mload(0x40)\n            mstore(0x40, add(_newStr, 0x40)) // may end up with extra\n            mstore(_newStr, _slen)\n            mstore(add(_newStr, 0x20), _buf)\n        }\n    }\n\n    // alignment preserving cast\n    function addressToBytes32(address _addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(_addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 _buf) internal pure returns (address) {\n        return address(uint160(uint256(_buf)));\n    }\n}\n\n/// @dev Header is a memory over over a formatted message header payload.\ntype Header is bytes29;\n/// @dev Attach library functions to Header\nusing {\n    HeaderLib.unwrap,\n    HeaderLib.version,\n    HeaderLib.origin,\n    HeaderLib.sender,\n    HeaderLib.nonce,\n    HeaderLib.destination,\n    HeaderLib.recipient,\n    HeaderLib.optimisticSeconds,\n    HeaderLib.recipientAddress\n} for Header global;\n\n/**\n * @notice Library for versioned formatting [the header part]\n * of [the messages used by Origin and Destination].\n */\nlibrary HeaderLib {\n    using ByteString for bytes;\n    using TypedMemView for bytes29;\n\n    uint16 internal constant HEADER_VERSION = 1;\n\n    /**\n     * @dev Header memory layout\n     * [000 .. 002): version            uint16   2 bytes\n     * [002 .. 006): origin             uint32   4 bytes\n     * [006 .. 038): sender             bytes32 32 bytes\n     * [038 .. 042): nonce              uint32   4 bytes\n     * [042 .. 046): destination        uint32   4 bytes\n     * [046 .. 078): recipient          bytes32 32 bytes\n     * [078 .. 082): optimisticSeconds  uint32   4 bytes\n     */\n\n    uint256 internal constant OFFSET_VERSION = 0;\n    uint256 internal constant OFFSET_ORIGIN = 2;\n    uint256 internal constant OFFSET_SENDER = 6;\n    uint256 internal constant OFFSET_NONCE = 38;\n    uint256 internal constant OFFSET_DESTINATION = 42;\n    uint256 internal constant OFFSET_RECIPIENT = 46;\n    uint256 internal constant OFFSET_OPTIMISTIC_SECONDS = 78;\n\n    uint256 internal constant HEADER_LENGTH = 82;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns a formatted Header payload with provided fields\n     * @param _origin               Domain of origin chain\n     * @param _sender               Address that sent the message\n     * @param _nonce                Message nonce on origin chain\n     * @param _destination          Domain of destination chain\n     * @param _recipient            Address that will receive the message\n     * @param _optimisticSeconds    Optimistic period for message execution\n     * @return Formatted header\n     **/\n    function formatHeader(\n        uint32 _origin,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destination,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodePacked(\n                HEADER_VERSION,\n                _origin,\n                _sender,\n                _nonce,\n                _destination,\n                _recipient,\n                _optimisticSeconds\n            );\n    }\n\n    /**\n     * @notice Returns a Header view over for the given payload.\n     * @dev Will revert if the payload is not a header payload.\n     */\n    function castToHeader(bytes memory _payload) internal pure returns (Header) {\n        return castToHeader(_payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a Header view.\n     * @dev Will revert if the memory view is not over a header payload.\n     */\n    function castToHeader(bytes29 _view) internal pure returns (Header) {\n        require(isHeader(_view), \"Not a header payload\");\n        return Header.wrap(_view);\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Header.\n     */\n    function isHeader(bytes29 _view) internal pure returns (bool) {\n        uint256 length = _view.len();\n        // Check if version exists in the payload\n        if (length \u003c 2) return false;\n        // Check that header version and its length matches\n        return _getVersion(_view) == HEADER_VERSION \u0026\u0026 length == HEADER_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Header _header) internal pure returns (bytes29) {\n        return Header.unwrap(_header);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                            HEADER SLICING                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /// @notice Returns header's version field.\n    function version(Header _header) internal pure returns (uint16) {\n        // Get the underlying memory view\n        bytes29 _view = unwrap(_header);\n        return _getVersion(_view);\n    }\n\n    /// @notice Returns header's origin field\n    function origin(Header _header) internal pure returns (uint32) {\n        bytes29 _view = unwrap(_header);\n        return uint32(_view.indexUint(OFFSET_ORIGIN, 4));\n    }\n\n    /// @notice Returns header's sender field\n    function sender(Header _header) internal pure returns (bytes32) {\n        bytes29 _view = unwrap(_header);\n        return _view.index(OFFSET_SENDER, 32);\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(Header _header) internal pure returns (uint32) {\n        bytes29 _view = unwrap(_header);\n        return uint32(_view.indexUint(OFFSET_NONCE, 4));\n    }\n\n    /// @notice Returns header's destination field\n    function destination(Header _header) internal pure returns (uint32) {\n        bytes29 _view = unwrap(_header);\n        return uint32(_view.indexUint(OFFSET_DESTINATION, 4));\n    }\n\n    /// @notice Returns header's recipient field as bytes32\n    function recipient(Header _header) internal pure returns (bytes32) {\n        bytes29 _view = unwrap(_header);\n        return _view.index(OFFSET_RECIPIENT, 32);\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticSeconds(Header _header) internal pure returns (uint32) {\n        bytes29 _view = unwrap(_header);\n        return uint32(_view.indexUint(OFFSET_OPTIMISTIC_SECONDS, 4));\n    }\n\n    /// @notice Returns header's recipient field as an address\n    function recipientAddress(Header _header) internal pure returns (address) {\n        return TypeCasts.bytes32ToAddress(recipient(_header));\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           PRIVATE HELPERS                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /// @notice Returns a version field without checking if payload is properly formatted.\n    function _getVersion(bytes29 _view) internal pure returns (uint16) {\n        return uint16(_view.indexUint(OFFSET_VERSION, 2));\n    }\n}\n\n/// @dev Tips is a memory over over a formatted message tips payload.\ntype Tips is bytes29;\n/// @dev Attach library functions to Tips\nusing {\n    TipsLib.unwrap,\n    TipsLib.version,\n    TipsLib.notaryTip,\n    TipsLib.broadcasterTip,\n    TipsLib.proverTip,\n    TipsLib.executorTip,\n    TipsLib.totalTips\n} for Tips global;\n\n/**\n * @notice Library for versioned formatting [the tips part]\n * of [the messages used by Origin and Destination].\n */\nlibrary TipsLib {\n    using ByteString for bytes;\n    using TypedMemView for bytes29;\n\n    uint16 internal constant TIPS_VERSION = 1;\n\n    // TODO: determine if we need to pack the tips values,\n    // or if using uint256 instead will suffice.\n\n    /**\n     * @dev Tips memory layout\n     * [000 .. 002): version            uint16\t 2 bytes\n     * [002 .. 014): notaryTip          uint96\t12 bytes\n     * [014 .. 026): broadcasterTip     uint96\t12 bytes\n     * [026 .. 038): proverTip          uint96\t12 bytes\n     * [038 .. 050): executorTip        uint96\t12 bytes\n     */\n\n    uint256 internal constant OFFSET_VERSION = 0;\n    uint256 internal constant OFFSET_NOTARY = 2;\n    uint256 internal constant OFFSET_BROADCASTER = 14;\n    uint256 internal constant OFFSET_PROVER = 26;\n    uint256 internal constant OFFSET_EXECUTOR = 38;\n\n    uint256 internal constant TIPS_LENGTH = 50;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                                 TIPS                                 ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns a formatted Tips payload with provided fields\n     * @param _notaryTip        Tip for the Notary\n     * @param _broadcasterTip   Tip for the Broadcaster\n     * @param _proverTip        Tip for the Prover\n     * @param _executorTip      Tip for the Executor\n     * @return Formatted tips\n     **/\n    function formatTips(\n        uint96 _notaryTip,\n        uint96 _broadcasterTip,\n        uint96 _proverTip,\n        uint96 _executorTip\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodePacked(TIPS_VERSION, _notaryTip, _broadcasterTip, _proverTip, _executorTip);\n    }\n\n    /**\n     * @notice Returns a formatted Tips payload specifying empty tips.\n     * @return Formatted tips\n     **/\n    function emptyTips() internal pure returns (bytes memory) {\n        return formatTips(0, 0, 0, 0);\n    }\n\n    /**\n     * @notice Returns a Tips view over for the given payload.\n     * @dev Will revert if the payload is not a tips payload.\n     */\n    function castToTips(bytes memory _payload) internal pure returns (Tips) {\n        return castToTips(_payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a Tips view.\n     * @dev Will revert if the memory view is not over a tips payload.\n     */\n    function castToTips(bytes29 _view) internal pure returns (Tips) {\n        require(isTips(_view), \"Not a tips payload\");\n        return Tips.wrap(_view);\n    }\n\n    /// @notice Checks that a payload is a formatted Tips payload.\n    function isTips(bytes29 _view) internal pure returns (bool) {\n        uint256 length = _view.len();\n        // Check if version exists in the payload\n        if (length \u003c OFFSET_NOTARY) return false;\n        // Check that tips version and its length matches\n        return _getVersion(_view) == TIPS_VERSION \u0026\u0026 length == TIPS_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Tips _tips) internal pure returns (bytes29) {\n        return Tips.unwrap(_tips);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                             TIPS SLICING                             ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /// @notice Returns version of formatted tips\n    function version(Tips _tips) internal pure returns (uint16) {\n        // Get the underlying memory view\n        bytes29 _view = _tips.unwrap();\n        return _getVersion(_view);\n    }\n\n    /// @notice Returns notaryTip field\n    function notaryTip(Tips _tips) internal pure returns (uint96) {\n        bytes29 _view = _tips.unwrap();\n        return uint96(_view.indexUint(OFFSET_NOTARY, 12));\n    }\n\n    /// @notice Returns broadcasterTip field\n    function broadcasterTip(Tips _tips) internal pure returns (uint96) {\n        bytes29 _view = _tips.unwrap();\n        return uint96(_view.indexUint(OFFSET_BROADCASTER, 12));\n    }\n\n    /// @notice Returns proverTip field\n    function proverTip(Tips _tips) internal pure returns (uint96) {\n        bytes29 _view = _tips.unwrap();\n        return uint96(_view.indexUint(OFFSET_PROVER, 12));\n    }\n\n    /// @notice Returns executorTip field\n    function executorTip(Tips _tips) internal pure returns (uint96) {\n        bytes29 _view = _tips.unwrap();\n        return uint96(_view.indexUint(OFFSET_EXECUTOR, 12));\n    }\n\n    /// @notice Returns total tip amount.\n    function totalTips(Tips _tips) internal pure returns (uint96) {\n        // In practice there's no chance that the total tips value would not fit into uint96.\n        // TODO: determine if we want to use uint256 here instead anyway.\n        return notaryTip(_tips) + broadcasterTip(_tips) + proverTip(_tips) + executorTip(_tips);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           PRIVATE HELPERS                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /// @notice Returns a version field without checking if payload is properly formatted.\n    function _getVersion(bytes29 _view) private pure returns (uint16) {\n        return uint16(_view.indexUint(OFFSET_VERSION, 2));\n    }\n}\n\n/// @dev Message is a memory over over a formatted message payload.\ntype Message is bytes29;\n/// @dev Attach library functions to Message\nusing {\n    MessageLib.unwrap,\n    MessageLib.version,\n    MessageLib.header,\n    MessageLib.tips,\n    MessageLib.body,\n    MessageLib.leaf\n} for Message global;\n\n/**\n * @notice  Library for versioned formatting the messages used by Origin and Destination.\n */\nlibrary MessageLib {\n    using HeaderLib for bytes29;\n    using TipsLib for bytes29;\n    using ByteString for bytes;\n    using TypedMemView for bytes29;\n\n    enum Parts {\n        Version,\n        Header,\n        Tips,\n        Body\n    }\n\n    /**\n     * @dev This is only updated if the whole message structure is changed,\n     *      i.e. if a new part is added.\n     *      If already existing part is changed, the message version does not get bumped.\n     */\n    uint16 internal constant MESSAGE_VERSION = 1;\n\n    /**\n     * @dev Message memory layout\n     * [000 .. 002): version            uint16  2 bytes\n     * [002 .. 004): header length      uint16  2 bytes (length == AAA - 6)\n     * [004 .. 006): tips length        uint16  2 bytes (length == BBB - AAA)\n     * [006 .. AAA): header             bytes   ? bytes\n     * [AAA .. BBB): tips               bytes   ? bytes\n     * [BBB .. CCC): body               bytes   ? bytes (length could be zero)\n     */\n\n    uint256 internal constant OFFSET_VERSION = 0;\n\n    /// @dev How much bytes is used for storing the version, or a single offset value\n    uint8 internal constant TWO_BYTES = 2;\n    /// @dev This value reflects the header offset in the latest message version\n    uint16 internal constant OFFSET_HEADER = TWO_BYTES * uint8(type(Parts).max);\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns formatted message with provided fields\n     * @param _header       Formatted header payload\n     * @param _tips         Formatted tips payload\n     * @param _messageBody  Raw bytes of message body\n     * @return Formatted message\n     **/\n    function formatMessage(\n        bytes memory _header,\n        bytes memory _tips,\n        bytes memory _messageBody\n    ) internal pure returns (bytes memory) {\n        // Header and Tips are supposed to fit within 65535 bytes\n        return\n            abi.encodePacked(\n                MESSAGE_VERSION,\n                uint16(_header.length),\n                uint16(_tips.length),\n                _header,\n                _tips,\n                _messageBody\n            );\n    }\n\n    /**\n     * @notice Returns formatted message with provided fields\n     * @param _origin               Domain of origin chain\n     * @param _sender               Address that sent the message\n     * @param _nonce                Message nonce on origin chain\n     * @param _destination          Domain of destination chain\n     * @param _recipient            Address that will receive the message\n     * @param _optimisticSeconds    Optimistic period for message execution\n     * @param _tips                 Formatted tips payload\n     * @param _messageBody          Raw bytes of message body\n     * @return Formatted message\n     **/\n    function formatMessage(\n        uint32 _origin,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destination,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds,\n        bytes memory _tips,\n        bytes memory _messageBody\n    ) internal pure returns (bytes memory) {\n        return\n            formatMessage(\n                HeaderLib.formatHeader(\n                    _origin,\n                    _sender,\n                    _nonce,\n                    _destination,\n                    _recipient,\n                    _optimisticSeconds\n                ),\n                _tips,\n                _messageBody\n            );\n    }\n\n    /**\n     * @notice Returns a Message view over for the given payload.\n     * @dev Will revert if the payload is not a message payload.\n     */\n    function castToMessage(bytes memory _payload) internal pure returns (Message) {\n        return castToMessage(_payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a Message view.\n     * @dev Will revert if the memory view is not over a message payload.\n     */\n    function castToMessage(bytes29 _view) internal pure returns (Message) {\n        require(isMessage(_view), \"Not a message payload\");\n        return Message.wrap(_view);\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Message.\n     */\n    function isMessage(bytes29 _view) internal pure returns (bool) {\n        uint256 length = _view.len();\n        // Check if version and lengths exist in the payload\n        if (length \u003c OFFSET_HEADER) return false;\n        // Check message version\n        if (_getVersion(_view) != MESSAGE_VERSION) return false;\n\n        uint256 headerLength = _getLen(_view, Parts.Header);\n        uint256 tipsLength = _getLen(_view, Parts.Tips);\n        // Header and Tips need to exist\n        // Body could be empty, thus \u003e\n        if (OFFSET_HEADER + headerLength + tipsLength \u003e length) return false;\n\n        // Check header for being a formatted header payload\n        // Check tips for being a formatted tips payload\n        if (!_getHeader(_view).isHeader() || !_getTips(_view).isTips()) return false;\n        return true;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Message _msg) internal pure returns (bytes29) {\n        return Message.unwrap(_msg);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           MESSAGE SLICING                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /// @notice Returns message's version field.\n    function version(Message _msg) internal pure returns (uint16) {\n        // Get the underlying memory view\n        bytes29 _view = _msg.unwrap();\n        return _getVersion(_view);\n    }\n\n    /// @notice Returns message's header field as a Header view.\n    function header(Message _msg) internal pure returns (Header) {\n        bytes29 _view = _msg.unwrap();\n        return _getHeader(_view).castToHeader();\n    }\n\n    /// @notice Returns message's tips field as a Tips view.\n    function tips(Message _msg) internal pure returns (Tips) {\n        bytes29 _view = _msg.unwrap();\n        return _getTips(_view).castToTips();\n    }\n\n    /// @notice Returns message's body field as a generic memory view.\n    function body(Message _msg) internal pure returns (bytes29) {\n        bytes29 _view = _msg.unwrap();\n        // Determine index where message body payload starts\n        uint256 index = OFFSET_HEADER + _getLen(_view, Parts.Header) + _getLen(_view, Parts.Tips);\n        return _view.sliceFrom({ _index: index, newType: 0 });\n    }\n\n    /// @notice Returns message's hash: a leaf to be inserted in the Merkle tree.\n    function leaf(Message _msg) internal pure returns (bytes32) {\n        bytes29 _view = _msg.unwrap();\n        return _view.keccak();\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           PRIVATE HELPERS                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /// @dev Returns length for a given part of the message\n    /// without checking if the payload is properly formatted.\n    function _getLen(bytes29 _view, Parts _part) private pure returns (uint256) {\n        return _view.indexUint(uint256(_part) * TWO_BYTES, TWO_BYTES);\n    }\n\n    /// @dev Returns a version field without checking if the payload is properly formatted.\n    function _getVersion(bytes29 _view) private pure returns (uint16) {\n        return uint16(_view.indexUint(OFFSET_VERSION, 2));\n    }\n\n    /// @dev Returns a generic memory view over the header field without checking\n    /// if the whole payload or the header are properly formatted.\n    function _getHeader(bytes29 _view) private pure returns (bytes29) {\n        uint256 length = _getLen(_view, Parts.Header);\n        return _view.slice({ _index: OFFSET_HEADER, _len: length, newType: 0 });\n    }\n\n    /// @dev Returns a generic memory view over the tips field without checking\n    /// if the whole payload or the tips are properly formatted.\n    function _getTips(bytes29 _view) private pure returns (bytes29) {\n        // Determine index where tips payload starts\n        uint256 indexFrom = OFFSET_HEADER + _getLen(_view, Parts.Header);\n        uint256 length = _getLen(_view, Parts.Tips);\n        return _view.slice({ _index: indexFrom, _len: length, newType: 0 });\n    }\n}\n\n/**\n * @notice Exposes Message methods for testing against golang.\n */\ncontract MessageHarness {\n    using MessageLib for bytes;\n    using MessageLib for bytes29;\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                               GETTERS                                ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    function castToMessage(bytes memory _payload) public view returns (bytes memory) {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        Message _msg = MessageLib.castToMessage(_payload);\n        return _msg.unwrap().clone();\n    }\n\n    function header(bytes memory _payload) public view returns (bytes memory) {\n        return _payload.castToMessage().header().unwrap().clone();\n    }\n\n    function tips(bytes memory _payload) public view returns (bytes memory) {\n        return _payload.castToMessage().tips().unwrap().clone();\n    }\n\n    function body(bytes memory _payload) public view returns (bytes memory) {\n        return _payload.castToMessage().body().clone();\n    }\n\n    function version(bytes memory _payload) public pure returns (uint16) {\n        return _payload.castToMessage().version();\n    }\n\n    function leaf(bytes memory _payload) public pure returns (bytes32) {\n        return _payload.castToMessage().leaf();\n    }\n\n    function isMessage(bytes memory _payload) public pure returns (bool) {\n        return _payload.ref(0).isMessage();\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    function formatMessage(\n        uint32 _origin,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destination,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds,\n        // tips params\n        uint96 _notaryTip,\n        uint96 _broadcasterTip,\n        uint96 _proverTip,\n        uint96 _executorTip,\n        bytes memory _messageBody\n    ) public pure returns (bytes memory) {\n        bytes memory _tips = TipsLib.formatTips(\n            _notaryTip,\n            _broadcasterTip,\n            _proverTip,\n            _executorTip\n        );\n\n        bytes memory _header = HeaderLib.formatHeader(\n            _origin,\n            _sender,\n            _nonce,\n            _destination,\n            _recipient,\n            _optimisticSeconds\n        );\n        return formatMessage(_header, _tips, _messageBody);\n    }\n\n    function formatMessage(\n        uint32 _origin,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destination,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds,\n        bytes memory _tips,\n        bytes memory _messageBody\n    ) public pure returns (bytes memory) {\n        return\n            MessageLib.formatMessage(\n                _origin,\n                _sender,\n                _nonce,\n                _destination,\n                _recipient,\n                _optimisticSeconds,\n                _tips,\n                _messageBody\n            );\n    }\n\n    function formatMessage(\n        bytes memory _header,\n        bytes memory _tips,\n        bytes memory _messageBody\n    ) public pure returns (bytes memory) {\n        return MessageLib.formatMessage(_header, _tips, _messageBody);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           CONSTANT GETTERS                           ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    function messageVersion() public pure returns (uint16) {\n        return MessageLib.MESSAGE_VERSION;\n    }\n\n    function offsetVersion() public pure returns (uint256) {\n        return MessageLib.OFFSET_VERSION;\n    }\n\n    function offsetHeader() public pure returns (uint256) {\n        return MessageLib.OFFSET_HEADER;\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"45983:6911:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;45983:6911:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"45983:6911:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"notice":"Library for versioned formatting [the header part] of [the messages used by Origin and Destination].","version":1},"developerDoc":{"kind":"dev","methods":{},"stateVariables":{"OFFSET_VERSION":{"details":"Header memory layout [000 .. 002): version            uint16   2 bytes [002 .. 006): origin             uint32   4 bytes [006 .. 038): sender             bytes32 32 bytes [038 .. 042): nonce              uint32   4 bytes [042 .. 046): destination        uint32   4 bytes [046 .. 078): recipient          bytes32 32 bytes [078 .. 082): optimisticSeconds  uint32   4 bytes"}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"stateVariables\":{\"OFFSET_VERSION\":{\"details\":\"Header memory layout [000 .. 002): version            uint16   2 bytes [002 .. 006): origin             uint32   4 bytes [006 .. 038): sender             bytes32 32 bytes [038 .. 042): nonce              uint32   4 bytes [042 .. 046): destination        uint32   4 bytes [046 .. 078): recipient          bytes32 32 bytes [078 .. 082): optimisticSeconds  uint32   4 bytes\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"Library for versioned formatting [the header part] of [the messages used by Origin and Destination].\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/MessageHarness.t.sol\":\"HeaderLib\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/MessageHarness.t.sol\":{\"keccak256\":\"0x3904cba9f384c6433257789b24cdb15655a5775a36df2c4c297958af081b2acc\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://eff1071fd96ffa0ae24c5a5d8de738a1545769b12ccc3c5ec469a9d7e16b21db\",\"dweb:/ipfs/QmYyQsoEqF9QJ5aHaVw5545ePNt9Z7GqXfVyCFGrEh4y84\"]}},\"version\":1}"},"hashes":{}},"solidity/MessageHarness.t.sol:MessageHarness":{"code":"0x608060405234801561001057600080fd5b506118db806100206000396000f3fe608060405234801561001057600080fd5b50600436106100df5760003560e01c80637d67c5a71161008c578063c311d35911610066578063c311d3591461019b578063c97c703a146101ae578063d7a7a72c146101c1578063f9893ddd146101d457600080fd5b80637d67c5a714610162578063801fdbfc1461017557806381d030ef1461018857600080fd5b80631515f90c116100bd5780631515f90c1461013157806352617f3c146101395780637c5178251461014f57600080fd5b8063045c6c0b146100e45780630b9255e91461010d5780630c096e8d14610120575b600080fd5b6100f76100f2366004611407565b6101f7565b60405161010491906114aa565b60405180910390f35b6100f761011b3660046114bd565b610230565b60005b604051908152602001610104565b610123610247565b60015b60405161ffff9091168152602001610104565b6100f761015d36600461155e565b61025d565b61013c610170366004611407565b61027c565b6100f7610183366004611407565b610295565b6100f7610196366004611634565b6102b4565b6100f76101a9366004611407565b61038b565b6100f76101bc366004611407565b6103a9565b6101236101cf366004611407565b6103c5565b6101e76101e2366004611407565b6103de565b6040519015158152602001610104565b606061022a61021f61021661020b856103f8565b62ffffff191661040b565b62ffffff191690565b62ffffff191661042b565b92915050565b606061023d84848461047e565b90505b9392505050565b60006102556003600261176b565b60ff16919050565b606061026f89898989898989896104b5565b9998505050505050505050565b600061022a61028a836103f8565b62ffffff1916610556565b606061022a61021f6102166102a9856103f8565b62ffffff1916610568565b606060006102c487878787610588565b9050600061036c8e8e8e8e8e8e604080517e01000000000000000000000000000000000000000000000000000000000000602082015260e097881b7fffffffff000000000000000000000000000000000000000000000000000000009081166022830152602682019790975294871b8616604686015292861b8516604a850152604e84019190915290931b909116606e82015281516052818303018152607290910190915290565b9050610379818386610230565b9e9d5050505050505050505050505050565b60606000610398836103f8565b905061024062ffffff19821661021f565b606061022a61021f6103ba846103f8565b62ffffff191661061a565b600061022a6103d3836103f8565b62ffffff1916610671565b600061022a6103ed8383610683565b62ffffff19166106a7565b600061022a6104068361079f565b6107ab565b600062ffffff19821661024061042082610825565b62ffffff1916610870565b60606000806104488460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff169050604051915081925061046d84836020016108e1565b508181016020016040529052919050565b8251825160405160609261049d9260019288908890889060200161178e565b60405160208183030381529060405290509392505050565b604080517e0100000000000000000000000000000000000000000000000000000000000060208201527fffffffff0000000000000000000000000000000000000000000000000000000060e08b811b82166022840152602683018b905289811b8216604684015288811b8216604a840152604e830188905286901b16606e82015281518082036052018152607290910190915260609061026f90848461047e565b600062ffffff19821661024081610ac8565b600062ffffff19821661024061057d82610adc565b62ffffff1916610b0e565b6040517e0100000000000000000000000000000000000000000000000000000000000060208201527fffffffffffffffffffffffff000000000000000000000000000000000000000060a086811b8216602284015285811b8216602e84015284811b8216603a84015283901b16604682015260609060520160405160208183030381529060405290505b949350505050565b600062ffffff1982168161062f826002610b7f565b61063a836001610b7f565b6106466003600261176b565b610653919060ff16611820565b61065d9190611820565b905061061262ffffff198316826000610bb1565b600062ffffff19821661024081610bef565b81516000906020840161069e64ffffffffff85168284610c3d565b95945050505050565b6000601882901c6bffffffffffffffffffffffff166106c86003600261176b565b60ff168110156106db5750600092915050565b60016106e684610ac8565b61ffff16146106f85750600092915050565b6000610705846001610b7f565b90506000610714856002610b7f565b90508281836107256003600261176b565b610732919060ff16611820565b61073c9190611820565b111561074d57506000949350505050565b61076461075986610adc565b62ffffff1916610c84565b1580610784575061078261077786610825565b62ffffff1916610ccb565b155b1561079457506000949350505050565b506001949350505050565b600061022a8282610683565b60006107b6826106a7565b610821576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601560248201527f4e6f742061206d657373616765207061796c6f6164000000000000000000000060448201526064015b60405180910390fd5b5090565b600080610833836001610b7f565b61083f6003600261176b565b61084c919060ff16611820565b9050600061085b846002610b7f565b905061061262ffffff19851683836000610d12565b600061087b82610ccb565b610821576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601260248201527f4e6f7420612074697073207061796c6f616400000000000000000000000000006044820152606401610818565b600062ffffff1980841603610952576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601a60248201527f636f7079546f3a204e756c6c20706f696e7465722064657265660000000000006044820152606401610818565b61095b83610d87565b6109c1576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f636f7079546f3a20496e76616c696420706f696e7465722064657265660000006044820152606401610818565b60006109db8460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff16905060006109f685610dc3565b6bffffffffffffffffffffffff169050600080604051915085821115610a1c5760206060fd5b8386858560045afa905080610a8d576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f6964656e746974793a206f7574206f66206761730000000000000000000000006044820152606401610818565b610abd610a9988610dea565b70ffffffffff000000000000000000000000606091821b168817901b851760181b90565b979650505050505050565b600061022a62ffffff198316826002610e0e565b600080610aea836001610b7f565b9050610240610afb6003600261176b565b62ffffff1985169060ff16836000610d12565b6000610b1982610c84565b610821576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f4e6f74206120686561646572207061796c6f61640000000000000000000000006044820152606401610818565b60006102406002836003811115610b9857610b9861170d565b610ba29190611833565b62ffffff198516906002610e0e565b600061023d848485610bd18860181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff16610be9919061184a565b85610d12565b600080610bfb83610dc3565b6bffffffffffffffffffffffff1690506000610c258460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff169091209392505050565b600080610c4a8385611820565b9050604051811115610c5a575060005b80600003610c6f5762ffffff19915050610240565b5050606092831b9190911790911b1760181b90565b6000601882901c6bffffffffffffffffffffffff166002811015610cab5750600092915050565b6001610cb684610ac8565b61ffff16148015610240575060521492915050565b6000601882901c6bffffffffffffffffffffffff166002811015610cf25750600092915050565b6001610cfd84610ac8565b61ffff16148015610240575060321492915050565b600080610d1e86610dc3565b6bffffffffffffffffffffffff169050610d3786610e3e565b84610d428784611820565b610d4c9190611820565b1115610d5f5762ffffff19915050610612565b610d698582611820565b9050610d7d8364ffffffffff168286610c3d565b9695505050505050565b6000610d9282610dea565b64ffffffffff1664ffffffffff03610dac57506000919050565b6000610db783610e3e565b60405110199392505050565b600080610dd260606018611820565b9290921c6bffffffffffffffffffffffff1692915050565b6000806060610dfa816018611820565b610e049190611820565b9290921c92915050565b6000610e1b82602061185d565b610e2690600861176b565b60ff16610e34858585610e77565b901c949350505050565b6000610e588260181c6bffffffffffffffffffffffff1690565b610e6183610dc3565b016bffffffffffffffffffffffff169050919050565b60008160ff16600003610e8c57506000610240565b610ea48460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff16610ebf60ff841685611820565b1115610f4257610f0f610ed185610dc3565b6bffffffffffffffffffffffff16610ef78660181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff16858560ff16611025565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161081891906114aa565b60208260ff161115610fb0576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601960248201527f496e6465783a206d6f7265207468616e203332206279746573000000000000006044820152606401610818565b600882026000610fbf86610dc3565b6bffffffffffffffffffffffff16905060007f80000000000000000000000000000000000000000000000000000000000000007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff84011d91909501511695945050505050565b60606000611032866111b5565b9150506000611040866111b5565b915050600061104e866111b5565b915050600061105c866111b5565b604080517f54797065644d656d566965772f696e646578202d204f76657272616e2074686560208201527f20766965772e20536c6963652069732061742030780000000000000000000000818301527fffffffffffff000000000000000000000000000000000000000000000000000060d098891b811660558301527f2077697468206c656e6774682030780000000000000000000000000000000000605b830181905297891b8116606a8301527f2e20417474656d7074656420746f20696e646578206174206f6666736574203060708301527f7800000000000000000000000000000000000000000000000000000000000000609083015295881b861660918201526097810196909652951b90921660a684015250507f2e0000000000000000000000000000000000000000000000000000000000000060ac8201528151808203608d01815260ad90910190915295945050505050565b600080601f5b600f8160ff1611156112285760006111d482600861176b565b60ff1685901c90506111e58161129f565b61ffff16841793508160ff1660101461120057601084901b93505b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff016111bb565b50600f5b60ff8160ff16101561129957600061124582600861176b565b60ff1685901c90506112568161129f565b61ffff16831792508160ff1660001461127157601083901b92505b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0161122c565b50915091565b60006112b160048360ff16901c6112d1565b60ff1661ffff919091161760081b6112c8826112d1565b60ff1617919050565b6040805180820190915260108082527f30313233343536373839616263646566000000000000000000000000000000006020830152600091600f8416918290811061131e5761131e611876565b016020015160f81c9392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600082601f83011261136d57600080fd5b813567ffffffffffffffff808211156113885761138861132d565b604051601f83017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f011681019082821181831017156113ce576113ce61132d565b816040528381528660208588010111156113e757600080fd5b836020870160208301376000602085830101528094505050505092915050565b60006020828403121561141957600080fd5b813567ffffffffffffffff81111561143057600080fd5b6106128482850161135c565b60005b8381101561145757818101518382015260200161143f565b50506000910152565b6000815180845261147881602086016020860161143c565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b6020815260006102406020830184611460565b6000806000606084860312156114d257600080fd5b833567ffffffffffffffff808211156114ea57600080fd5b6114f68783880161135c565b9450602086013591508082111561150c57600080fd5b6115188783880161135c565b9350604086013591508082111561152e57600080fd5b5061153b8682870161135c565b9150509250925092565b803563ffffffff8116811461155957600080fd5b919050565b600080600080600080600080610100898b03121561157b57600080fd5b61158489611545565b97506020890135965061159960408a01611545565b95506115a760608a01611545565b9450608089013593506115bc60a08a01611545565b925060c089013567ffffffffffffffff808211156115d957600080fd5b6115e58c838d0161135c565b935060e08b01359150808211156115fb57600080fd5b506116088b828c0161135c565b9150509295985092959890939650565b80356bffffffffffffffffffffffff8116811461155957600080fd5b60008060008060008060008060008060006101608c8e03121561165657600080fd5b61165f8c611545565b9a5060208c0135995061167460408d01611545565b985061168260608d01611545565b975060808c0135965061169760a08d01611545565b95506116a560c08d01611618565b94506116b360e08d01611618565b93506116c26101008d01611618565b92506116d16101208d01611618565b91506101408c013567ffffffffffffffff8111156116ee57600080fd5b6116fa8e828f0161135c565b9150509295989b509295989b9093969950565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60ff81811683821602908116908181146117875761178761173c565b5092915050565b60007fffff000000000000000000000000000000000000000000000000000000000000808960f01b168352808860f01b166002840152808760f01b1660048401525084516117e381600685016020890161143c565b8451908301906117fa81600684016020890161143c565b845191019061181081600684016020880161143c565b0160060198975050505050505050565b8082018082111561022a5761022a61173c565b808202811582820484141761022a5761022a61173c565b8181038181111561022a5761022a61173c565b60ff828116828216039081111561022a5761022a61173c565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fdfea2646970667358221220765283d3dc304fe697db2cdb95dec159277ff249fdbce5c129014ccc604e863b64736f6c63430008110033","runtime-code":"0x608060405234801561001057600080fd5b50600436106100df5760003560e01c80637d67c5a71161008c578063c311d35911610066578063c311d3591461019b578063c97c703a146101ae578063d7a7a72c146101c1578063f9893ddd146101d457600080fd5b80637d67c5a714610162578063801fdbfc1461017557806381d030ef1461018857600080fd5b80631515f90c116100bd5780631515f90c1461013157806352617f3c146101395780637c5178251461014f57600080fd5b8063045c6c0b146100e45780630b9255e91461010d5780630c096e8d14610120575b600080fd5b6100f76100f2366004611407565b6101f7565b60405161010491906114aa565b60405180910390f35b6100f761011b3660046114bd565b610230565b60005b604051908152602001610104565b610123610247565b60015b60405161ffff9091168152602001610104565b6100f761015d36600461155e565b61025d565b61013c610170366004611407565b61027c565b6100f7610183366004611407565b610295565b6100f7610196366004611634565b6102b4565b6100f76101a9366004611407565b61038b565b6100f76101bc366004611407565b6103a9565b6101236101cf366004611407565b6103c5565b6101e76101e2366004611407565b6103de565b6040519015158152602001610104565b606061022a61021f61021661020b856103f8565b62ffffff191661040b565b62ffffff191690565b62ffffff191661042b565b92915050565b606061023d84848461047e565b90505b9392505050565b60006102556003600261176b565b60ff16919050565b606061026f89898989898989896104b5565b9998505050505050505050565b600061022a61028a836103f8565b62ffffff1916610556565b606061022a61021f6102166102a9856103f8565b62ffffff1916610568565b606060006102c487878787610588565b9050600061036c8e8e8e8e8e8e604080517e01000000000000000000000000000000000000000000000000000000000000602082015260e097881b7fffffffff000000000000000000000000000000000000000000000000000000009081166022830152602682019790975294871b8616604686015292861b8516604a850152604e84019190915290931b909116606e82015281516052818303018152607290910190915290565b9050610379818386610230565b9e9d5050505050505050505050505050565b60606000610398836103f8565b905061024062ffffff19821661021f565b606061022a61021f6103ba846103f8565b62ffffff191661061a565b600061022a6103d3836103f8565b62ffffff1916610671565b600061022a6103ed8383610683565b62ffffff19166106a7565b600061022a6104068361079f565b6107ab565b600062ffffff19821661024061042082610825565b62ffffff1916610870565b60606000806104488460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff169050604051915081925061046d84836020016108e1565b508181016020016040529052919050565b8251825160405160609261049d9260019288908890889060200161178e565b60405160208183030381529060405290509392505050565b604080517e0100000000000000000000000000000000000000000000000000000000000060208201527fffffffff0000000000000000000000000000000000000000000000000000000060e08b811b82166022840152602683018b905289811b8216604684015288811b8216604a840152604e830188905286901b16606e82015281518082036052018152607290910190915260609061026f90848461047e565b600062ffffff19821661024081610ac8565b600062ffffff19821661024061057d82610adc565b62ffffff1916610b0e565b6040517e0100000000000000000000000000000000000000000000000000000000000060208201527fffffffffffffffffffffffff000000000000000000000000000000000000000060a086811b8216602284015285811b8216602e84015284811b8216603a84015283901b16604682015260609060520160405160208183030381529060405290505b949350505050565b600062ffffff1982168161062f826002610b7f565b61063a836001610b7f565b6106466003600261176b565b610653919060ff16611820565b61065d9190611820565b905061061262ffffff198316826000610bb1565b600062ffffff19821661024081610bef565b81516000906020840161069e64ffffffffff85168284610c3d565b95945050505050565b6000601882901c6bffffffffffffffffffffffff166106c86003600261176b565b60ff168110156106db5750600092915050565b60016106e684610ac8565b61ffff16146106f85750600092915050565b6000610705846001610b7f565b90506000610714856002610b7f565b90508281836107256003600261176b565b610732919060ff16611820565b61073c9190611820565b111561074d57506000949350505050565b61076461075986610adc565b62ffffff1916610c84565b1580610784575061078261077786610825565b62ffffff1916610ccb565b155b1561079457506000949350505050565b506001949350505050565b600061022a8282610683565b60006107b6826106a7565b610821576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601560248201527f4e6f742061206d657373616765207061796c6f6164000000000000000000000060448201526064015b60405180910390fd5b5090565b600080610833836001610b7f565b61083f6003600261176b565b61084c919060ff16611820565b9050600061085b846002610b7f565b905061061262ffffff19851683836000610d12565b600061087b82610ccb565b610821576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601260248201527f4e6f7420612074697073207061796c6f616400000000000000000000000000006044820152606401610818565b600062ffffff1980841603610952576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601a60248201527f636f7079546f3a204e756c6c20706f696e7465722064657265660000000000006044820152606401610818565b61095b83610d87565b6109c1576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f636f7079546f3a20496e76616c696420706f696e7465722064657265660000006044820152606401610818565b60006109db8460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff16905060006109f685610dc3565b6bffffffffffffffffffffffff169050600080604051915085821115610a1c5760206060fd5b8386858560045afa905080610a8d576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f6964656e746974793a206f7574206f66206761730000000000000000000000006044820152606401610818565b610abd610a9988610dea565b70ffffffffff000000000000000000000000606091821b168817901b851760181b90565b979650505050505050565b600061022a62ffffff198316826002610e0e565b600080610aea836001610b7f565b9050610240610afb6003600261176b565b62ffffff1985169060ff16836000610d12565b6000610b1982610c84565b610821576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f4e6f74206120686561646572207061796c6f61640000000000000000000000006044820152606401610818565b60006102406002836003811115610b9857610b9861170d565b610ba29190611833565b62ffffff198516906002610e0e565b600061023d848485610bd18860181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff16610be9919061184a565b85610d12565b600080610bfb83610dc3565b6bffffffffffffffffffffffff1690506000610c258460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff169091209392505050565b600080610c4a8385611820565b9050604051811115610c5a575060005b80600003610c6f5762ffffff19915050610240565b5050606092831b9190911790911b1760181b90565b6000601882901c6bffffffffffffffffffffffff166002811015610cab5750600092915050565b6001610cb684610ac8565b61ffff16148015610240575060521492915050565b6000601882901c6bffffffffffffffffffffffff166002811015610cf25750600092915050565b6001610cfd84610ac8565b61ffff16148015610240575060321492915050565b600080610d1e86610dc3565b6bffffffffffffffffffffffff169050610d3786610e3e565b84610d428784611820565b610d4c9190611820565b1115610d5f5762ffffff19915050610612565b610d698582611820565b9050610d7d8364ffffffffff168286610c3d565b9695505050505050565b6000610d9282610dea565b64ffffffffff1664ffffffffff03610dac57506000919050565b6000610db783610e3e565b60405110199392505050565b600080610dd260606018611820565b9290921c6bffffffffffffffffffffffff1692915050565b6000806060610dfa816018611820565b610e049190611820565b9290921c92915050565b6000610e1b82602061185d565b610e2690600861176b565b60ff16610e34858585610e77565b901c949350505050565b6000610e588260181c6bffffffffffffffffffffffff1690565b610e6183610dc3565b016bffffffffffffffffffffffff169050919050565b60008160ff16600003610e8c57506000610240565b610ea48460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff16610ebf60ff841685611820565b1115610f4257610f0f610ed185610dc3565b6bffffffffffffffffffffffff16610ef78660181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff16858560ff16611025565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161081891906114aa565b60208260ff161115610fb0576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601960248201527f496e6465783a206d6f7265207468616e203332206279746573000000000000006044820152606401610818565b600882026000610fbf86610dc3565b6bffffffffffffffffffffffff16905060007f80000000000000000000000000000000000000000000000000000000000000007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff84011d91909501511695945050505050565b60606000611032866111b5565b9150506000611040866111b5565b915050600061104e866111b5565b915050600061105c866111b5565b604080517f54797065644d656d566965772f696e646578202d204f76657272616e2074686560208201527f20766965772e20536c6963652069732061742030780000000000000000000000818301527fffffffffffff000000000000000000000000000000000000000000000000000060d098891b811660558301527f2077697468206c656e6774682030780000000000000000000000000000000000605b830181905297891b8116606a8301527f2e20417474656d7074656420746f20696e646578206174206f6666736574203060708301527f7800000000000000000000000000000000000000000000000000000000000000609083015295881b861660918201526097810196909652951b90921660a684015250507f2e0000000000000000000000000000000000000000000000000000000000000060ac8201528151808203608d01815260ad90910190915295945050505050565b600080601f5b600f8160ff1611156112285760006111d482600861176b565b60ff1685901c90506111e58161129f565b61ffff16841793508160ff1660101461120057601084901b93505b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff016111bb565b50600f5b60ff8160ff16101561129957600061124582600861176b565b60ff1685901c90506112568161129f565b61ffff16831792508160ff1660001461127157601083901b92505b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0161122c565b50915091565b60006112b160048360ff16901c6112d1565b60ff1661ffff919091161760081b6112c8826112d1565b60ff1617919050565b6040805180820190915260108082527f30313233343536373839616263646566000000000000000000000000000000006020830152600091600f8416918290811061131e5761131e611876565b016020015160f81c9392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600082601f83011261136d57600080fd5b813567ffffffffffffffff808211156113885761138861132d565b604051601f83017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f011681019082821181831017156113ce576113ce61132d565b816040528381528660208588010111156113e757600080fd5b836020870160208301376000602085830101528094505050505092915050565b60006020828403121561141957600080fd5b813567ffffffffffffffff81111561143057600080fd5b6106128482850161135c565b60005b8381101561145757818101518382015260200161143f565b50506000910152565b6000815180845261147881602086016020860161143c565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b6020815260006102406020830184611460565b6000806000606084860312156114d257600080fd5b833567ffffffffffffffff808211156114ea57600080fd5b6114f68783880161135c565b9450602086013591508082111561150c57600080fd5b6115188783880161135c565b9350604086013591508082111561152e57600080fd5b5061153b8682870161135c565b9150509250925092565b803563ffffffff8116811461155957600080fd5b919050565b600080600080600080600080610100898b03121561157b57600080fd5b61158489611545565b97506020890135965061159960408a01611545565b95506115a760608a01611545565b9450608089013593506115bc60a08a01611545565b925060c089013567ffffffffffffffff808211156115d957600080fd5b6115e58c838d0161135c565b935060e08b01359150808211156115fb57600080fd5b506116088b828c0161135c565b9150509295985092959890939650565b80356bffffffffffffffffffffffff8116811461155957600080fd5b60008060008060008060008060008060006101608c8e03121561165657600080fd5b61165f8c611545565b9a5060208c0135995061167460408d01611545565b985061168260608d01611545565b975060808c0135965061169760a08d01611545565b95506116a560c08d01611618565b94506116b360e08d01611618565b93506116c26101008d01611618565b92506116d16101208d01611618565b91506101408c013567ffffffffffffffff8111156116ee57600080fd5b6116fa8e828f0161135c565b9150509295989b509295989b9093969950565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60ff81811683821602908116908181146117875761178761173c565b5092915050565b60007fffff000000000000000000000000000000000000000000000000000000000000808960f01b168352808860f01b166002840152808760f01b1660048401525084516117e381600685016020890161143c565b8451908301906117fa81600684016020890161143c565b845191019061181081600684016020880161143c565b0160060198975050505050505050565b8082018082111561022a5761022a61173c565b808202811582820484141761022a5761022a61173c565b8181038181111561022a5761022a61173c565b60ff828116828216039081111561022a5761022a61173c565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fdfea2646970667358221220765283d3dc304fe697db2cdb95dec159277ff249fdbce5c129014ccc604e863b64736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nlibrary TypedMemView {\n    // Why does this exist?\n    // the solidity `bytes memory` type has a few weaknesses.\n    // 1. You can't index ranges effectively\n    // 2. You can't slice without copying\n    // 3. The underlying data may represent any type\n    // 4. Solidity never deallocates memory, and memory costs grow\n    //    superlinearly\n\n    // By using a memory view instead of a `bytes memory` we get the following\n    // advantages:\n    // 1. Slices are done on the stack, by manipulating the pointer\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\n    // 3. We can insert type info into the pointer, and typecheck at runtime\n\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\n    // algorithms.\n\n    // Why bytes29?\n    // We want to avoid confusion between views, digests, and other common\n    // types so we chose a large and uncommonly used odd number of bytes\n    //\n    // Note that while bytes are left-aligned in a word, integers and addresses\n    // are right-aligned. This means when working in assembly we have to\n    // account for the 3 unused bytes on the righthand side\n    //\n    // First 5 bytes are a type flag.\n    // - ff_ffff_fffe is reserved for unknown type.\n    // - ff_ffff_ffff is reserved for invalid types/errors.\n    // next 12 are memory address\n    // next 12 are len\n    // bottom 3 bytes are empty\n\n    // Assumptions:\n    // - non-modification of memory.\n    // - No Solidity updates\n    // - - wrt free mem point\n    // - - wrt bytes representation in memory\n    // - - wrt memory addressing in general\n\n    // Usage:\n    // - create type constants\n    // - use `assertType` for runtime type assertions\n    // - - unfortunately we can't do this at compile time yet :(\n    // - recommended: implement modifiers that perform type checking\n    // - - e.g.\n    // - - `uint40 constant MY_TYPE = 3;`\n    // - - ` modifier onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n    // - instantiate a typed view from a bytearray using `ref`\n    // - use `index` to inspect the contents of the view\n    // - use `slice` to create smaller views into the same memory\n    // - - `slice` can increase the offset\n    // - - `slice can decrease the length`\n    // - - must specify the output type of `slice`\n    // - - `slice` will return a null view if you try to overrun\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\n    // - use `equal` for typed comparisons.\n\n    // The null view\n    bytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n\n    /**\n     * @dev Memory layout for bytes29\n     * TODO (Chi): with the user defined types storing type is no longer necessary.\n     * Update the library, transforming bytes29 to bytes24 in the process.\n     * [000..005)   type     5 bytes    Type flag for the pointer\n     * [005..017)   loc     12 bytes    Memory address of underlying bytes\n     * [017..029)   len     12 bytes    Length of underlying bytes\n     * [029..032)   empty    3 bytes    Not used\n     */\n    uint256 public constant BITS_TYPE = 40;\n    uint256 public constant BITS_LOC = 96;\n    uint256 public constant BITS_LEN = 96;\n    uint256 public constant BITS_EMPTY = 24;\n\n    // `SHIFT_X` is how much bits to shift for `X` to be in the very bottom bits\n    uint256 public constant SHIFT_LEN = BITS_EMPTY; // 24\n    uint256 public constant SHIFT_LOC = SHIFT_LEN + BITS_LEN; // 24 + 96 = 120\n    uint256 public constant SHIFT_TYPE = SHIFT_LOC + BITS_LOC; // 24 + 96 + 96 = 216\n    // Bitmask for the lowest 96 bits\n    uint256 public constant LOW_96_BITS_MASK = type(uint96).max;\n\n    // For nibble encoding\n    bytes private constant NIBBLE_LOOKUP = \"0123456789abcdef\";\n\n    /**\n     * @notice Returns the encoded hex character that represents the lower 4 bits of the argument.\n     * @param _byte     The byte\n     * @return _char    The encoded hex character\n     */\n    function nibbleHex(uint8 _byte) internal pure returns (uint8 _char) {\n        uint8 _nibble = _byte \u0026 0x0f; // keep bottom 4 bits, zero out top 4 bits\n        _char = uint8(NIBBLE_LOOKUP[_nibble]);\n    }\n\n    /**\n     * @notice      Returns a uint16 containing the hex-encoded byte.\n     * @param _b    The byte\n     * @return      encoded - The hex-encoded byte\n     */\n    function byteHex(uint8 _b) internal pure returns (uint16 encoded) {\n        encoded |= nibbleHex(_b \u003e\u003e 4); // top 4 bits\n        encoded \u003c\u003c= 8;\n        encoded |= nibbleHex(_b); // lower 4 bits\n    }\n\n    /**\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\n     *              `second` contains the encoded lower 16 bytes.\n     *\n     * @param _b    The 32 bytes as uint256\n     * @return      first - The top 16 bytes\n     * @return      second - The bottom 16 bytes\n     */\n    function encodeHex(uint256 _b) internal pure returns (uint256 first, uint256 second) {\n        for (uint8 i = 31; i \u003e 15; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            first |= byteHex(_byte);\n            if (i != 16) {\n                first \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n\n        // abusing underflow here =_=\n        for (uint8 i = 15; i \u003c 255; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            second |= byteHex(_byte);\n            if (i != 0) {\n                second \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n    }\n\n    /**\n     * @notice          Changes the endianness of a uint256.\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n     * @param _b        The unsigned integer to reverse\n     * @return          v - The reversed value\n     */\n    function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\n        v = _b;\n\n        // swap bytes\n        v =\n            ((v \u003e\u003e 8) \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\n            ((v \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) \u003c\u003c 8);\n        // swap 2-byte long pairs\n        v =\n            ((v \u003e\u003e 16) \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\n            ((v \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) \u003c\u003c 16);\n        // swap 4-byte long pairs\n        v =\n            ((v \u003e\u003e 32) \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\n            ((v \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) \u003c\u003c 32);\n        // swap 8-byte long pairs\n        v =\n            ((v \u003e\u003e 64) \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\n            ((v \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) \u003c\u003c 64);\n        // swap 16-byte long pairs\n        v = (v \u003e\u003e 128) | (v \u003c\u003c 128);\n    }\n\n    /**\n     * @notice      Create a mask with the highest `_len` bits set.\n     * @param _len  The length\n     * @return      mask - The mask\n     */\n    function leftMask(uint8 _len) private pure returns (uint256 mask) {\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(\n                sub(_len, 1),\n                0x8000000000000000000000000000000000000000000000000000000000000000\n            )\n        }\n    }\n\n    /**\n     * @notice      Return the null view.\n     * @return      bytes29 - The null view\n     */\n    // solhint-disable-next-line ordering\n    function nullView() internal pure returns (bytes29) {\n        return NULL;\n    }\n\n    /**\n     * @notice      Check if the view is null.\n     * @return      bool - True if the view is null\n     */\n    function isNull(bytes29 memView) internal pure returns (bool) {\n        return memView == NULL;\n    }\n\n    /**\n     * @notice      Check if the view is not null.\n     * @return      bool - True if the view is not null\n     */\n    function notNull(bytes29 memView) internal pure returns (bool) {\n        return !isNull(memView);\n    }\n\n    /**\n     * @notice          Check if the view is of a valid type and points to a valid location\n     *                  in memory.\n     * @dev             We perform this check by examining solidity's unallocated memory\n     *                  pointer and ensuring that the view's upper bound is less than that.\n     * @param memView   The view\n     * @return          ret - True if the view is valid\n     */\n    function isValid(bytes29 memView) internal pure returns (bool ret) {\n        if (typeOf(memView) == 0xffffffffff) {\n            return false;\n        }\n        uint256 _end = end(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // View is valid if (\"upper bound\" \u003c= \"unallocated memory pointer\")\n            // Upper bound is exclusive, hence \"\u003c=\"\n            ret := not(gt(_end, mload(0x40)))\n        }\n    }\n\n    /**\n     * @notice          Require that a typed memory view be valid.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @return          bytes29 - The validated view\n     */\n    function assertValid(bytes29 memView) internal pure returns (bytes29) {\n        require(isValid(memView), \"Validity assertion failed\");\n        return memView;\n    }\n\n    /**\n     * @notice          Return true if the memview is of the expected type. Otherwise false.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bool - True if the memview is of the expected type\n     */\n    function isType(bytes29 memView, uint40 _expected) internal pure returns (bool) {\n        return typeOf(memView) == _expected;\n    }\n\n    /**\n     * @notice          Require that a typed memory view has a specific type.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bytes29 - The view with validated type\n     */\n    function assertType(bytes29 memView, uint40 _expected) internal pure returns (bytes29) {\n        if (!isType(memView, _expected)) {\n            (, uint256 g) = encodeHex(uint256(typeOf(memView)));\n            (, uint256 e) = encodeHex(uint256(_expected));\n            string memory err = string(\n                abi.encodePacked(\n                    \"Type assertion failed. Got 0x\",\n                    uint80(g),\n                    \". Expected 0x\",\n                    uint80(e)\n                )\n            );\n            revert(err);\n        }\n        return memView;\n    }\n\n    /**\n     * @notice          Return an identical view with a different type.\n     * @param memView   The view\n     * @param _newType  The new type\n     * @return          newView - The new view with the specified type\n     */\n    function castTo(bytes29 memView, uint40 _newType) internal pure returns (bytes29 newView) {\n        // How many bits are the \"type bits\" occupying\n        uint256 _bitsType = BITS_TYPE;\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 _shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // shift off the \"type bits\" (shift left, then sift right)\n            newView := or(newView, shr(_bitsType, shl(_bitsType, memView)))\n            // set the new \"type bits\" (shift left, then OR)\n            newView := or(newView, shl(_shiftType, _newType))\n        }\n    }\n\n    /**\n     * @notice          Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function unsafeBuildUnchecked(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) private pure returns (bytes29 newView) {\n        uint256 _bitsLoc = BITS_LOC;\n        uint256 _bitsLen = BITS_LEN;\n        uint256 _bitsEmpty = BITS_EMPTY;\n        // Ref memory layout\n        // [000..005) 5 bytes of type\n        // [005..017) 12 bytes of location\n        // [017..029) 12 bytes of length\n        // last 3 bits are blank and dropped in typecast\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // insert `type`, shift to prepare empty bits for `loc`\n            newView := shl(_bitsLoc, or(newView, _type))\n            // insert `loc`, shift to prepare empty bits for `len`\n            newView := shl(_bitsLen, or(newView, _loc))\n            // insert `len`, shift to insert 3 blank lowest bits\n            newView := shl(_bitsEmpty, or(newView, _len))\n        }\n    }\n\n    /**\n     * @notice          Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function build(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) internal pure returns (bytes29 newView) {\n        uint256 _end = _loc + _len;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(_end, mload(0x40)) {\n                _end := 0\n            }\n        }\n        if (_end == 0) {\n            return NULL;\n        }\n        newView = unsafeBuildUnchecked(_type, _loc, _len);\n    }\n\n    /**\n     * @notice          Instantiate a memory view from a byte array.\n     * @dev             Note that due to Solidity memory representation, it is not possible to\n     *                  implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr       The byte array\n     * @param newType   The type\n     * @return          bytes29 - The memory view\n     */\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\n        uint256 _len = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 _loc;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            _loc := add(arr, 0x20)\n        }\n\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Return the associated type information.\n     * @param memView   The memory view\n     * @return          _type - The type associated with the view\n     */\n    function typeOf(bytes29 memView) internal pure returns (uint40 _type) {\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 _shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"type bits\". \"type bits\" are occupying\n            // the highest bits, so all that's left is \"type bits\", OR is not required.\n            _type := shr(_shiftType, memView)\n        }\n    }\n\n    /**\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the 5-byte type flag is equal\n     */\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\n        // Check that the highest 5 bytes are equal: xor and shift out lower 27 bytes\n        return (left ^ right) \u003e\u003e SHIFT_TYPE == 0;\n    }\n\n    /**\n     * @notice          Return the memory address of the underlying bytes.\n     * @param memView   The view\n     * @return          _loc - The memory address\n     */\n    function loc(bytes29 memView) internal pure returns (uint96 _loc) {\n        // How many bits are the \"loc bits\" shifted from the bottom\n        uint256 _shiftLoc = SHIFT_LOC;\n        // Mask for the bottom 96 bits\n        uint256 _uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"loc bits\".\n            // Then use the lowest 96 bits to determine `loc` by applying the bit-mask.\n            _loc := and(shr(_shiftLoc, memView), _uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          The number of memory words this memory view occupies, rounded up.\n     * @param memView   The view\n     * @return          uint256 - The number of memory words\n     */\n    function words(bytes29 memView) internal pure returns (uint256) {\n        // returning ceil(length / 32.0)\n        return (uint256(len(memView)) + 31) / 32;\n    }\n\n    /**\n     * @notice          The in-memory footprint of a fresh copy of the view.\n     * @param memView   The view\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(bytes29 memView) internal pure returns (uint256) {\n        return words(memView) * 32;\n    }\n\n    /**\n     * @notice          The number of bytes of the view.\n     * @param memView   The view\n     * @return          _len - The length of the view\n     */\n    function len(bytes29 memView) internal pure returns (uint96 _len) {\n        // How many bits are the \"len bits\" shifted from the bottom\n        uint256 _shiftLen = SHIFT_LEN;\n        // Mask for the bottom 96 bits\n        uint256 _uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"len bits\".\n            // Then use the lowest 96 bits to determine `len` by applying the bit-mask.\n            _len := and(shr(_shiftLen, memView), _uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          Returns the endpoint of `memView`.\n     * @param memView   The view\n     * @return          uint256 - The endpoint of `memView`\n     */\n    function end(bytes29 memView) internal pure returns (uint256) {\n        unchecked {\n            return loc(memView) + len(memView);\n        }\n    }\n\n    /**\n     * @notice          Safe slicing without memory modification.\n     * @param memView   The view\n     * @param _index    The start index\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function slice(\n        bytes29 memView,\n        uint256 _index,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        uint256 _loc = loc(memView);\n\n        // Ensure it doesn't overrun the view\n        if (_loc + _index + _len \u003e end(memView)) {\n            return NULL;\n        }\n\n        _loc = _loc + _index;\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing\n     *                  bytes from `_index` to end(memView).\n     * @param memView   The view\n     * @param _index    The start index\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function sliceFrom(\n        bytes29 memView,\n        uint256 _index,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, _index, len(memView) - _index, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the first `_len` bytes.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function prefix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, 0, _len, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the last `_len` byte.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function postfix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, uint256(len(memView)) - _len, _len, newType);\n    }\n\n    /**\n     * @notice          Construct an error message for an indexing overrun.\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @param _index    The index\n     * @param _slice    The slice where the overrun occurred\n     * @return          err - The err\n     */\n    function indexErrOverrun(\n        uint256 _loc,\n        uint256 _len,\n        uint256 _index,\n        uint256 _slice\n    ) internal pure returns (string memory err) {\n        (, uint256 a) = encodeHex(_loc);\n        (, uint256 b) = encodeHex(_len);\n        (, uint256 c) = encodeHex(_index);\n        (, uint256 d) = encodeHex(_slice);\n        err = string(\n            abi.encodePacked(\n                \"TypedMemView/index - Overran the view. Slice is at 0x\",\n                uint48(a),\n                \" with length 0x\",\n                uint48(b),\n                \". Attempted to index at offset 0x\",\n                uint48(c),\n                \" with length 0x\",\n                uint48(d),\n                \".\"\n            )\n        );\n    }\n\n    /**\n     * @notice          Load up to 32 bytes from the view onto the stack.\n     * @dev             Returns a bytes32 with only the `_bytes` highest bytes set.\n     *                  This can be immediately cast to a smaller fixed-length byte array.\n     *                  To automatically cast to an integer, use `indexUint`.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The 32 byte result\n     */\n    function index(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (bytes32 result) {\n        if (_bytes == 0) {\n            return bytes32(0);\n        }\n        if (_index + _bytes \u003e len(memView)) {\n            revert(indexErrOverrun(loc(memView), len(memView), _index, uint256(_bytes)));\n        }\n        require(_bytes \u003c= 32, \"Index: more than 32 bytes\");\n\n        uint8 bitLength;\n        unchecked {\n            bitLength = _bytes * 8;\n        }\n        uint256 _loc = loc(memView);\n        // Get a mask with `bitLength` highest bits set\n        uint256 _mask = leftMask(bitLength);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(_loc, _index)), _mask)\n        }\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from the view at `_index`.\n     * @dev             Requires that the view have \u003e= `_bytes` bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        // `index()` returns left-aligned `_bytes`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word\n        return uint256(index(memView, _index, _bytes)) \u003e\u003e ((32 - _bytes) * 8);\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from LE bytes.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexLEUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return reverseUint256(uint256(index(memView, _index, _bytes)));\n    }\n\n    /**\n     * @notice          Parse an address from the view at `_index`.\n     *                  Requires that the view have \u003e= 20 bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @return          address - The address\n     */\n    function indexAddress(bytes29 memView, uint256 _index) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(indexUint(memView, _index, 20)));\n    }\n\n    /**\n     * @notice          Return the keccak256 hash of the underlying memory\n     * @param memView   The view\n     * @return          digest - The keccak256 hash of the underlying memory\n     */\n    function keccak(bytes29 memView) internal pure returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(_loc, _len)\n        }\n    }\n\n    /**\n     * @notice          Return the sha2 digest of the underlying memory.\n     * @dev             We explicitly deallocate memory afterwards.\n     * @param memView   The view\n     * @return          digest - The sha2 hash of the underlying memory\n     */\n    function sha2(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            digest := mload(ptr)\n        }\n        require(res, \"sha2: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n     * @param memView   The pre-image\n     * @return          digest - the Digest\n     */\n    function hash160(bytes29 memView) internal view returns (bytes20 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            // rmd160 precompile is 0x03\n            res := and(res, staticcall(gas(), 0x03, ptr, 0x20, ptr, 0x20))\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\n        }\n        require(res, \"hash160: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash256 (double sha2)\n     * @param memView   A view of the preimage\n     * @return          digest - the Digest\n     */\n    function hash256(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            res := and(res, staticcall(gas(), 0x02, ptr, 0x20, ptr, 0x20))\n            digest := mload(ptr)\n        }\n        require(res, \"hash256: out of gas\");\n    }\n\n    /**\n     * @notice          Return true if the underlying memory is equal. Else false.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the underlying memory is equal\n     */\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return\n            (loc(left) == loc(right) \u0026\u0026 len(left) == len(right)) || keccak(left) == keccak(right);\n    }\n\n    /**\n     * @notice          Return false if the underlying memory is equal. Else true.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - False if the underlying memory is equal\n     */\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !untypedEqual(left, right);\n    }\n\n    /**\n     * @notice          Compares type equality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are the same\n     */\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return left == right || (typeOf(left) == typeOf(right) \u0026\u0026 keccak(left) == keccak(right));\n    }\n\n    /**\n     * @notice          Compares type inequality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are not the same\n     */\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !equal(left, right);\n    }\n\n    /**\n     * @notice          Copy the view to a location, return an unsafe memory reference\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memView   The view\n     * @param _newLoc   The new location\n     * @return          written - the unsafe memory reference\n     */\n    function unsafeCopyTo(bytes29 memView, uint256 _newLoc) private view returns (bytes29 written) {\n        require(notNull(memView), \"copyTo: Null pointer deref\");\n        require(isValid(memView), \"copyTo: Invalid pointer deref\");\n        uint256 _len = len(memView);\n        uint256 _oldLoc = loc(memView);\n\n        uint256 ptr;\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _newLoc) {\n                revert(0x60, 0x20) // empty revert message\n            }\n\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, _oldLoc, _len, _newLoc, _len)\n        }\n        require(res, \"identity: out of gas\");\n\n        written = unsafeBuildUnchecked(typeOf(memView), _newLoc, _len);\n    }\n\n    /**\n     * @notice          Copies the referenced memory to a new loc in memory,\n     *                  returning a `bytes` pointing to the new memory.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param memView   The view\n     * @return          ret - The view pointing to the new memory\n     */\n    function clone(bytes29 memView) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n            ret := ptr\n        }\n        unchecked {\n            unsafeCopyTo(memView, ptr + 0x20);\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mstore(0x40, add(add(ptr, _len), 0x20)) // write new unused pointer\n            mstore(ptr, _len) // write len of new array (in bytes)\n        }\n    }\n\n    /**\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memViews  The views\n     * @return          unsafeView - The conjoined view pointing to the new memory\n     */\n    function unsafeJoin(bytes29[] memory memViews, uint256 _location)\n        private\n        view\n        returns (bytes29 unsafeView)\n    {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _location) {\n                revert(0x60, 0x20) // empty revert message\n            }\n        }\n\n        uint256 _offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length; i++) {\n            bytes29 memView = memViews[i];\n            unchecked {\n                unsafeCopyTo(memView, _location + _offset);\n                _offset += len(memView);\n            }\n        }\n        unsafeView = unsafeBuildUnchecked(0, _location, _offset);\n    }\n\n    /**\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The keccak256 digest\n     */\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return keccak(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The sha256 digest\n     */\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return sha2(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          copies all views, joins them into a new bytearray.\n     * @param memViews  The views\n     * @return          ret - The new byte array\n     */\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n\n        bytes29 _newView;\n        unchecked {\n            _newView = unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 _written = len(_newView);\n        uint256 _footprint = footprint(_newView);\n\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // store the length\n            mstore(ptr, _written)\n            // new pointer is old + 0x20 + the footprint of the body\n            mstore(0x40, add(add(ptr, _footprint), 0x20))\n            ret := ptr\n        }\n    }\n}\n\n/// @dev CallData is a memory view over the payload to be used for an external call, i.e.\n/// recipient.call(callData). Its length is always (4 + 32 * N) bytes:\n/// - First 4 bytes represent the function selector.\n/// - 32 * N bytes represent N words that function arguments occupy.\ntype CallData is bytes29;\n/// @dev Signature is a memory view over a \"65 bytes\" array representing a ECDSA signature.\ntype Signature is bytes29;\n\nlibrary ByteString {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev non-compact ECDSA signatures are enforced as of OZ 4.7.3\n     *\n     *      Signature payload memory layout\n     * [000 .. 032) r   bytes32 32 bytes\n     * [032 .. 064) s   bytes32 32 bytes\n     * [064 .. 065) v   uint8    1 byte\n     */\n    uint256 internal constant SIGNATURE_LENGTH = 65;\n    uint256 internal constant OFFSET_R = 0;\n    uint256 internal constant OFFSET_S = 32;\n    uint256 internal constant OFFSET_V = 64;\n\n    /**\n     * @dev Calldata memory layout\n     * [000 .. 004) selector    bytes4  4 bytes\n     *      Optional: N function arguments\n     * [004 .. 036) arg1        bytes32 32 bytes\n     *      ..\n     * [AAA .. END) argN        bytes32 32 bytes\n     */\n    uint256 internal constant SELECTOR_LENGTH = 4;\n    uint256 internal constant OFFSET_SELECTOR = 0;\n    uint256 internal constant OFFSET_ARGUMENTS = SELECTOR_LENGTH;\n\n    /**\n     * @notice Returns a memory view over the given payload, treating it as raw bytes.\n     * @dev Shortcut for .ref(0) - to be deprecated once \"uint40 type\" is removed from bytes29.\n     */\n    function castToRawBytes(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref({ newType: 0 });\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              SIGNATURE                               ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Constructs the signature payload from the given values.\n     * @dev Using ByteString.formatSignature({r: r, s: s, v: v}) will make sure\n     * that params are given in the right order.\n     */\n    function formatSignature(\n        bytes32 r,\n        bytes32 s,\n        uint8 v\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(r, s, v);\n    }\n\n    /**\n     * @notice Returns a Signature view over for the given payload.\n     * @dev Will revert if the payload is not a signature.\n     */\n    function castToSignature(bytes memory _payload) internal pure returns (Signature) {\n        return castToSignature(castToRawBytes(_payload));\n    }\n\n    /**\n     * @notice Casts a memory view to a Signature view.\n     * @dev Will revert if the memory view is not over a signature.\n     */\n    function castToSignature(bytes29 _view) internal pure returns (Signature) {\n        require(isSignature(_view), \"Not a signature\");\n        return Signature.wrap(_view);\n    }\n\n    /**\n     * @notice Checks that a byte string is a signature\n     */\n    function isSignature(bytes29 _view) internal pure returns (bool) {\n        return _view.len() == SIGNATURE_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Signature _signature) internal pure returns (bytes29) {\n        return Signature.unwrap(_signature);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                          SIGNATURE SLICING                           ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /// @notice Unpacks signature payload into (r, s, v) parameters.\n    /// @dev Make sure to verify signature length with isSignature() beforehand.\n    function toRSV(Signature _signature)\n        internal\n        pure\n        returns (\n            bytes32 r,\n            bytes32 s,\n            uint8 v\n        )\n    {\n        // Get the underlying memory view\n        bytes29 _view = unwrap(_signature);\n        r = _view.index({ _index: OFFSET_R, _bytes: 32 });\n        s = _view.index({ _index: OFFSET_S, _bytes: 32 });\n        v = uint8(_view.indexUint({ _index: OFFSET_V, _bytes: 1 }));\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                               CALLDATA                               ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns a CallData view over for the given payload.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(bytes memory _payload) internal pure returns (CallData) {\n        return castToCallData(castToRawBytes(_payload));\n    }\n\n    /**\n     * @notice Casts a memory view to a CallData view.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(bytes29 _view) internal pure returns (CallData) {\n        require(isCallData(_view), \"Not a calldata\");\n        return CallData.wrap(_view);\n    }\n\n    /**\n     * @notice Checks that a byte string is a valid calldata, i.e.\n     * a function selector, followed by arbitrary amount of arguments.\n     */\n    function isCallData(bytes29 _view) internal pure returns (bool) {\n        uint256 length = _view.len();\n        // Calldata should at least have a function selector\n        if (length \u003c SELECTOR_LENGTH) return false;\n        // The remainder of the calldata should be exactly N words (N \u003e= 0), i.e.\n        // (length - SELECTOR_LENGTH) % 32 == 0\n        // We're using logical AND here to speed it up a bit\n        return (length - SELECTOR_LENGTH) \u0026 31 == 0;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(CallData _callData) internal pure returns (bytes29) {\n        return CallData.unwrap(_callData);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           CALLDATA SLICING                           ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns amount of memory words (32 byte chunks) the function arguments\n     * occupy in the calldata.\n     * @dev This might differ from amount of arguments supplied, if any of the arguments\n     * occupies more than one memory slot. It is true, however, that argument part of the payload\n     * occupies exactly N words, even for dynamic types like `bytes`\n     */\n    function argumentWords(CallData _callData) internal pure returns (uint256) {\n        // Get the underlying memory view\n        bytes29 _view = unwrap(_callData);\n        // Equivalent of (length - SELECTOR_LENGTH) / 32\n        return (_view.len() - SELECTOR_LENGTH) \u003e\u003e 5;\n    }\n\n    /// @notice Returns selector for the provided calldata.\n    function callSelector(CallData _callData) internal pure returns (bytes29) {\n        // Get the underlying memory view\n        bytes29 _view = unwrap(_callData);\n        return _view.slice({ _index: OFFSET_SELECTOR, _len: SELECTOR_LENGTH, newType: 0 });\n    }\n\n    /// @notice Returns abi encoded arguments for the provided calldata.\n    function arguments(CallData _callData) internal pure returns (bytes29) {\n        // Get the underlying memory view\n        bytes29 _view = unwrap(_callData);\n        return _view.sliceFrom({ _index: OFFSET_ARGUMENTS, newType: 0 });\n    }\n}\n\nlibrary TypeCasts {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    function coerceBytes32(string memory _s) internal pure returns (bytes32 _b) {\n        _b = bytes(_s).ref(0).index(0, uint8(bytes(_s).length));\n    }\n\n    // treat it as a null-terminated string of max 32 bytes\n    function coerceString(bytes32 _buf) internal pure returns (string memory _newStr) {\n        uint8 _slen = 0;\n        while (_slen \u003c 32 \u0026\u0026 _buf[_slen] != 0) {\n            _slen++;\n        }\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            _newStr := mload(0x40)\n            mstore(0x40, add(_newStr, 0x40)) // may end up with extra\n            mstore(_newStr, _slen)\n            mstore(add(_newStr, 0x20), _buf)\n        }\n    }\n\n    // alignment preserving cast\n    function addressToBytes32(address _addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(_addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 _buf) internal pure returns (address) {\n        return address(uint160(uint256(_buf)));\n    }\n}\n\n/// @dev Header is a memory over over a formatted message header payload.\ntype Header is bytes29;\n/// @dev Attach library functions to Header\nusing {\n    HeaderLib.unwrap,\n    HeaderLib.version,\n    HeaderLib.origin,\n    HeaderLib.sender,\n    HeaderLib.nonce,\n    HeaderLib.destination,\n    HeaderLib.recipient,\n    HeaderLib.optimisticSeconds,\n    HeaderLib.recipientAddress\n} for Header global;\n\n/**\n * @notice Library for versioned formatting [the header part]\n * of [the messages used by Origin and Destination].\n */\nlibrary HeaderLib {\n    using ByteString for bytes;\n    using TypedMemView for bytes29;\n\n    uint16 internal constant HEADER_VERSION = 1;\n\n    /**\n     * @dev Header memory layout\n     * [000 .. 002): version            uint16   2 bytes\n     * [002 .. 006): origin             uint32   4 bytes\n     * [006 .. 038): sender             bytes32 32 bytes\n     * [038 .. 042): nonce              uint32   4 bytes\n     * [042 .. 046): destination        uint32   4 bytes\n     * [046 .. 078): recipient          bytes32 32 bytes\n     * [078 .. 082): optimisticSeconds  uint32   4 bytes\n     */\n\n    uint256 internal constant OFFSET_VERSION = 0;\n    uint256 internal constant OFFSET_ORIGIN = 2;\n    uint256 internal constant OFFSET_SENDER = 6;\n    uint256 internal constant OFFSET_NONCE = 38;\n    uint256 internal constant OFFSET_DESTINATION = 42;\n    uint256 internal constant OFFSET_RECIPIENT = 46;\n    uint256 internal constant OFFSET_OPTIMISTIC_SECONDS = 78;\n\n    uint256 internal constant HEADER_LENGTH = 82;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns a formatted Header payload with provided fields\n     * @param _origin               Domain of origin chain\n     * @param _sender               Address that sent the message\n     * @param _nonce                Message nonce on origin chain\n     * @param _destination          Domain of destination chain\n     * @param _recipient            Address that will receive the message\n     * @param _optimisticSeconds    Optimistic period for message execution\n     * @return Formatted header\n     **/\n    function formatHeader(\n        uint32 _origin,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destination,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodePacked(\n                HEADER_VERSION,\n                _origin,\n                _sender,\n                _nonce,\n                _destination,\n                _recipient,\n                _optimisticSeconds\n            );\n    }\n\n    /**\n     * @notice Returns a Header view over for the given payload.\n     * @dev Will revert if the payload is not a header payload.\n     */\n    function castToHeader(bytes memory _payload) internal pure returns (Header) {\n        return castToHeader(_payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a Header view.\n     * @dev Will revert if the memory view is not over a header payload.\n     */\n    function castToHeader(bytes29 _view) internal pure returns (Header) {\n        require(isHeader(_view), \"Not a header payload\");\n        return Header.wrap(_view);\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Header.\n     */\n    function isHeader(bytes29 _view) internal pure returns (bool) {\n        uint256 length = _view.len();\n        // Check if version exists in the payload\n        if (length \u003c 2) return false;\n        // Check that header version and its length matches\n        return _getVersion(_view) == HEADER_VERSION \u0026\u0026 length == HEADER_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Header _header) internal pure returns (bytes29) {\n        return Header.unwrap(_header);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                            HEADER SLICING                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /// @notice Returns header's version field.\n    function version(Header _header) internal pure returns (uint16) {\n        // Get the underlying memory view\n        bytes29 _view = unwrap(_header);\n        return _getVersion(_view);\n    }\n\n    /// @notice Returns header's origin field\n    function origin(Header _header) internal pure returns (uint32) {\n        bytes29 _view = unwrap(_header);\n        return uint32(_view.indexUint(OFFSET_ORIGIN, 4));\n    }\n\n    /// @notice Returns header's sender field\n    function sender(Header _header) internal pure returns (bytes32) {\n        bytes29 _view = unwrap(_header);\n        return _view.index(OFFSET_SENDER, 32);\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(Header _header) internal pure returns (uint32) {\n        bytes29 _view = unwrap(_header);\n        return uint32(_view.indexUint(OFFSET_NONCE, 4));\n    }\n\n    /// @notice Returns header's destination field\n    function destination(Header _header) internal pure returns (uint32) {\n        bytes29 _view = unwrap(_header);\n        return uint32(_view.indexUint(OFFSET_DESTINATION, 4));\n    }\n\n    /// @notice Returns header's recipient field as bytes32\n    function recipient(Header _header) internal pure returns (bytes32) {\n        bytes29 _view = unwrap(_header);\n        return _view.index(OFFSET_RECIPIENT, 32);\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticSeconds(Header _header) internal pure returns (uint32) {\n        bytes29 _view = unwrap(_header);\n        return uint32(_view.indexUint(OFFSET_OPTIMISTIC_SECONDS, 4));\n    }\n\n    /// @notice Returns header's recipient field as an address\n    function recipientAddress(Header _header) internal pure returns (address) {\n        return TypeCasts.bytes32ToAddress(recipient(_header));\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           PRIVATE HELPERS                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /// @notice Returns a version field without checking if payload is properly formatted.\n    function _getVersion(bytes29 _view) internal pure returns (uint16) {\n        return uint16(_view.indexUint(OFFSET_VERSION, 2));\n    }\n}\n\n/// @dev Tips is a memory over over a formatted message tips payload.\ntype Tips is bytes29;\n/// @dev Attach library functions to Tips\nusing {\n    TipsLib.unwrap,\n    TipsLib.version,\n    TipsLib.notaryTip,\n    TipsLib.broadcasterTip,\n    TipsLib.proverTip,\n    TipsLib.executorTip,\n    TipsLib.totalTips\n} for Tips global;\n\n/**\n * @notice Library for versioned formatting [the tips part]\n * of [the messages used by Origin and Destination].\n */\nlibrary TipsLib {\n    using ByteString for bytes;\n    using TypedMemView for bytes29;\n\n    uint16 internal constant TIPS_VERSION = 1;\n\n    // TODO: determine if we need to pack the tips values,\n    // or if using uint256 instead will suffice.\n\n    /**\n     * @dev Tips memory layout\n     * [000 .. 002): version            uint16\t 2 bytes\n     * [002 .. 014): notaryTip          uint96\t12 bytes\n     * [014 .. 026): broadcasterTip     uint96\t12 bytes\n     * [026 .. 038): proverTip          uint96\t12 bytes\n     * [038 .. 050): executorTip        uint96\t12 bytes\n     */\n\n    uint256 internal constant OFFSET_VERSION = 0;\n    uint256 internal constant OFFSET_NOTARY = 2;\n    uint256 internal constant OFFSET_BROADCASTER = 14;\n    uint256 internal constant OFFSET_PROVER = 26;\n    uint256 internal constant OFFSET_EXECUTOR = 38;\n\n    uint256 internal constant TIPS_LENGTH = 50;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                                 TIPS                                 ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns a formatted Tips payload with provided fields\n     * @param _notaryTip        Tip for the Notary\n     * @param _broadcasterTip   Tip for the Broadcaster\n     * @param _proverTip        Tip for the Prover\n     * @param _executorTip      Tip for the Executor\n     * @return Formatted tips\n     **/\n    function formatTips(\n        uint96 _notaryTip,\n        uint96 _broadcasterTip,\n        uint96 _proverTip,\n        uint96 _executorTip\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodePacked(TIPS_VERSION, _notaryTip, _broadcasterTip, _proverTip, _executorTip);\n    }\n\n    /**\n     * @notice Returns a formatted Tips payload specifying empty tips.\n     * @return Formatted tips\n     **/\n    function emptyTips() internal pure returns (bytes memory) {\n        return formatTips(0, 0, 0, 0);\n    }\n\n    /**\n     * @notice Returns a Tips view over for the given payload.\n     * @dev Will revert if the payload is not a tips payload.\n     */\n    function castToTips(bytes memory _payload) internal pure returns (Tips) {\n        return castToTips(_payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a Tips view.\n     * @dev Will revert if the memory view is not over a tips payload.\n     */\n    function castToTips(bytes29 _view) internal pure returns (Tips) {\n        require(isTips(_view), \"Not a tips payload\");\n        return Tips.wrap(_view);\n    }\n\n    /// @notice Checks that a payload is a formatted Tips payload.\n    function isTips(bytes29 _view) internal pure returns (bool) {\n        uint256 length = _view.len();\n        // Check if version exists in the payload\n        if (length \u003c OFFSET_NOTARY) return false;\n        // Check that tips version and its length matches\n        return _getVersion(_view) == TIPS_VERSION \u0026\u0026 length == TIPS_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Tips _tips) internal pure returns (bytes29) {\n        return Tips.unwrap(_tips);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                             TIPS SLICING                             ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /// @notice Returns version of formatted tips\n    function version(Tips _tips) internal pure returns (uint16) {\n        // Get the underlying memory view\n        bytes29 _view = _tips.unwrap();\n        return _getVersion(_view);\n    }\n\n    /// @notice Returns notaryTip field\n    function notaryTip(Tips _tips) internal pure returns (uint96) {\n        bytes29 _view = _tips.unwrap();\n        return uint96(_view.indexUint(OFFSET_NOTARY, 12));\n    }\n\n    /// @notice Returns broadcasterTip field\n    function broadcasterTip(Tips _tips) internal pure returns (uint96) {\n        bytes29 _view = _tips.unwrap();\n        return uint96(_view.indexUint(OFFSET_BROADCASTER, 12));\n    }\n\n    /// @notice Returns proverTip field\n    function proverTip(Tips _tips) internal pure returns (uint96) {\n        bytes29 _view = _tips.unwrap();\n        return uint96(_view.indexUint(OFFSET_PROVER, 12));\n    }\n\n    /// @notice Returns executorTip field\n    function executorTip(Tips _tips) internal pure returns (uint96) {\n        bytes29 _view = _tips.unwrap();\n        return uint96(_view.indexUint(OFFSET_EXECUTOR, 12));\n    }\n\n    /// @notice Returns total tip amount.\n    function totalTips(Tips _tips) internal pure returns (uint96) {\n        // In practice there's no chance that the total tips value would not fit into uint96.\n        // TODO: determine if we want to use uint256 here instead anyway.\n        return notaryTip(_tips) + broadcasterTip(_tips) + proverTip(_tips) + executorTip(_tips);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           PRIVATE HELPERS                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /// @notice Returns a version field without checking if payload is properly formatted.\n    function _getVersion(bytes29 _view) private pure returns (uint16) {\n        return uint16(_view.indexUint(OFFSET_VERSION, 2));\n    }\n}\n\n/// @dev Message is a memory over over a formatted message payload.\ntype Message is bytes29;\n/// @dev Attach library functions to Message\nusing {\n    MessageLib.unwrap,\n    MessageLib.version,\n    MessageLib.header,\n    MessageLib.tips,\n    MessageLib.body,\n    MessageLib.leaf\n} for Message global;\n\n/**\n * @notice  Library for versioned formatting the messages used by Origin and Destination.\n */\nlibrary MessageLib {\n    using HeaderLib for bytes29;\n    using TipsLib for bytes29;\n    using ByteString for bytes;\n    using TypedMemView for bytes29;\n\n    enum Parts {\n        Version,\n        Header,\n        Tips,\n        Body\n    }\n\n    /**\n     * @dev This is only updated if the whole message structure is changed,\n     *      i.e. if a new part is added.\n     *      If already existing part is changed, the message version does not get bumped.\n     */\n    uint16 internal constant MESSAGE_VERSION = 1;\n\n    /**\n     * @dev Message memory layout\n     * [000 .. 002): version            uint16  2 bytes\n     * [002 .. 004): header length      uint16  2 bytes (length == AAA - 6)\n     * [004 .. 006): tips length        uint16  2 bytes (length == BBB - AAA)\n     * [006 .. AAA): header             bytes   ? bytes\n     * [AAA .. BBB): tips               bytes   ? bytes\n     * [BBB .. CCC): body               bytes   ? bytes (length could be zero)\n     */\n\n    uint256 internal constant OFFSET_VERSION = 0;\n\n    /// @dev How much bytes is used for storing the version, or a single offset value\n    uint8 internal constant TWO_BYTES = 2;\n    /// @dev This value reflects the header offset in the latest message version\n    uint16 internal constant OFFSET_HEADER = TWO_BYTES * uint8(type(Parts).max);\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns formatted message with provided fields\n     * @param _header       Formatted header payload\n     * @param _tips         Formatted tips payload\n     * @param _messageBody  Raw bytes of message body\n     * @return Formatted message\n     **/\n    function formatMessage(\n        bytes memory _header,\n        bytes memory _tips,\n        bytes memory _messageBody\n    ) internal pure returns (bytes memory) {\n        // Header and Tips are supposed to fit within 65535 bytes\n        return\n            abi.encodePacked(\n                MESSAGE_VERSION,\n                uint16(_header.length),\n                uint16(_tips.length),\n                _header,\n                _tips,\n                _messageBody\n            );\n    }\n\n    /**\n     * @notice Returns formatted message with provided fields\n     * @param _origin               Domain of origin chain\n     * @param _sender               Address that sent the message\n     * @param _nonce                Message nonce on origin chain\n     * @param _destination          Domain of destination chain\n     * @param _recipient            Address that will receive the message\n     * @param _optimisticSeconds    Optimistic period for message execution\n     * @param _tips                 Formatted tips payload\n     * @param _messageBody          Raw bytes of message body\n     * @return Formatted message\n     **/\n    function formatMessage(\n        uint32 _origin,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destination,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds,\n        bytes memory _tips,\n        bytes memory _messageBody\n    ) internal pure returns (bytes memory) {\n        return\n            formatMessage(\n                HeaderLib.formatHeader(\n                    _origin,\n                    _sender,\n                    _nonce,\n                    _destination,\n                    _recipient,\n                    _optimisticSeconds\n                ),\n                _tips,\n                _messageBody\n            );\n    }\n\n    /**\n     * @notice Returns a Message view over for the given payload.\n     * @dev Will revert if the payload is not a message payload.\n     */\n    function castToMessage(bytes memory _payload) internal pure returns (Message) {\n        return castToMessage(_payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a Message view.\n     * @dev Will revert if the memory view is not over a message payload.\n     */\n    function castToMessage(bytes29 _view) internal pure returns (Message) {\n        require(isMessage(_view), \"Not a message payload\");\n        return Message.wrap(_view);\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Message.\n     */\n    function isMessage(bytes29 _view) internal pure returns (bool) {\n        uint256 length = _view.len();\n        // Check if version and lengths exist in the payload\n        if (length \u003c OFFSET_HEADER) return false;\n        // Check message version\n        if (_getVersion(_view) != MESSAGE_VERSION) return false;\n\n        uint256 headerLength = _getLen(_view, Parts.Header);\n        uint256 tipsLength = _getLen(_view, Parts.Tips);\n        // Header and Tips need to exist\n        // Body could be empty, thus \u003e\n        if (OFFSET_HEADER + headerLength + tipsLength \u003e length) return false;\n\n        // Check header for being a formatted header payload\n        // Check tips for being a formatted tips payload\n        if (!_getHeader(_view).isHeader() || !_getTips(_view).isTips()) return false;\n        return true;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Message _msg) internal pure returns (bytes29) {\n        return Message.unwrap(_msg);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           MESSAGE SLICING                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /// @notice Returns message's version field.\n    function version(Message _msg) internal pure returns (uint16) {\n        // Get the underlying memory view\n        bytes29 _view = _msg.unwrap();\n        return _getVersion(_view);\n    }\n\n    /// @notice Returns message's header field as a Header view.\n    function header(Message _msg) internal pure returns (Header) {\n        bytes29 _view = _msg.unwrap();\n        return _getHeader(_view).castToHeader();\n    }\n\n    /// @notice Returns message's tips field as a Tips view.\n    function tips(Message _msg) internal pure returns (Tips) {\n        bytes29 _view = _msg.unwrap();\n        return _getTips(_view).castToTips();\n    }\n\n    /// @notice Returns message's body field as a generic memory view.\n    function body(Message _msg) internal pure returns (bytes29) {\n        bytes29 _view = _msg.unwrap();\n        // Determine index where message body payload starts\n        uint256 index = OFFSET_HEADER + _getLen(_view, Parts.Header) + _getLen(_view, Parts.Tips);\n        return _view.sliceFrom({ _index: index, newType: 0 });\n    }\n\n    /// @notice Returns message's hash: a leaf to be inserted in the Merkle tree.\n    function leaf(Message _msg) internal pure returns (bytes32) {\n        bytes29 _view = _msg.unwrap();\n        return _view.keccak();\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           PRIVATE HELPERS                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /// @dev Returns length for a given part of the message\n    /// without checking if the payload is properly formatted.\n    function _getLen(bytes29 _view, Parts _part) private pure returns (uint256) {\n        return _view.indexUint(uint256(_part) * TWO_BYTES, TWO_BYTES);\n    }\n\n    /// @dev Returns a version field without checking if the payload is properly formatted.\n    function _getVersion(bytes29 _view) private pure returns (uint16) {\n        return uint16(_view.indexUint(OFFSET_VERSION, 2));\n    }\n\n    /// @dev Returns a generic memory view over the header field without checking\n    /// if the whole payload or the header are properly formatted.\n    function _getHeader(bytes29 _view) private pure returns (bytes29) {\n        uint256 length = _getLen(_view, Parts.Header);\n        return _view.slice({ _index: OFFSET_HEADER, _len: length, newType: 0 });\n    }\n\n    /// @dev Returns a generic memory view over the tips field without checking\n    /// if the whole payload or the tips are properly formatted.\n    function _getTips(bytes29 _view) private pure returns (bytes29) {\n        // Determine index where tips payload starts\n        uint256 indexFrom = OFFSET_HEADER + _getLen(_view, Parts.Header);\n        uint256 length = _getLen(_view, Parts.Tips);\n        return _view.slice({ _index: indexFrom, _len: length, newType: 0 });\n    }\n}\n\n/**\n * @notice Exposes Message methods for testing against golang.\n */\ncontract MessageHarness {\n    using MessageLib for bytes;\n    using MessageLib for bytes29;\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                               GETTERS                                ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    function castToMessage(bytes memory _payload) public view returns (bytes memory) {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        Message _msg = MessageLib.castToMessage(_payload);\n        return _msg.unwrap().clone();\n    }\n\n    function header(bytes memory _payload) public view returns (bytes memory) {\n        return _payload.castToMessage().header().unwrap().clone();\n    }\n\n    function tips(bytes memory _payload) public view returns (bytes memory) {\n        return _payload.castToMessage().tips().unwrap().clone();\n    }\n\n    function body(bytes memory _payload) public view returns (bytes memory) {\n        return _payload.castToMessage().body().clone();\n    }\n\n    function version(bytes memory _payload) public pure returns (uint16) {\n        return _payload.castToMessage().version();\n    }\n\n    function leaf(bytes memory _payload) public pure returns (bytes32) {\n        return _payload.castToMessage().leaf();\n    }\n\n    function isMessage(bytes memory _payload) public pure returns (bool) {\n        return _payload.ref(0).isMessage();\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    function formatMessage(\n        uint32 _origin,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destination,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds,\n        // tips params\n        uint96 _notaryTip,\n        uint96 _broadcasterTip,\n        uint96 _proverTip,\n        uint96 _executorTip,\n        bytes memory _messageBody\n    ) public pure returns (bytes memory) {\n        bytes memory _tips = TipsLib.formatTips(\n            _notaryTip,\n            _broadcasterTip,\n            _proverTip,\n            _executorTip\n        );\n\n        bytes memory _header = HeaderLib.formatHeader(\n            _origin,\n            _sender,\n            _nonce,\n            _destination,\n            _recipient,\n            _optimisticSeconds\n        );\n        return formatMessage(_header, _tips, _messageBody);\n    }\n\n    function formatMessage(\n        uint32 _origin,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destination,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds,\n        bytes memory _tips,\n        bytes memory _messageBody\n    ) public pure returns (bytes memory) {\n        return\n            MessageLib.formatMessage(\n                _origin,\n                _sender,\n                _nonce,\n                _destination,\n                _recipient,\n                _optimisticSeconds,\n                _tips,\n                _messageBody\n            );\n    }\n\n    function formatMessage(\n        bytes memory _header,\n        bytes memory _tips,\n        bytes memory _messageBody\n    ) public pure returns (bytes memory) {\n        return MessageLib.formatMessage(_header, _tips, _messageBody);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           CONSTANT GETTERS                           ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    function messageVersion() public pure returns (uint16) {\n        return MessageLib.MESSAGE_VERSION;\n    }\n\n    function offsetVersion() public pure returns (uint256) {\n        return MessageLib.OFFSET_VERSION;\n    }\n\n    function offsetHeader() public pure returns (uint256) {\n        return MessageLib.OFFSET_HEADER;\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"69411:4971:0:-:0;;;;;;;;;;;;;;;;;;;","srcMapRuntime":"69411:4971:0:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;70620:144;;;;;;:::i;:::-;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;73276:235;;;;;;:::i;:::-;;:::i;74168:104::-;74214:7;74168:104;;;3009:25:1;;;2997:2;2982:18;74168:104:0;2863:177:1;74278:102:0;;;:::i;74057:105::-;60498:1;74057:105;;;3219:6:1;3207:19;;;3189:38;;3177:2;3162:18;74057:105:0;3045:188:1;72684:586:0;;;;;;:::i;:::-;;:::i;70911:127::-;;;;;;:::i;:::-;;:::i;70466:148::-;;;;;;:::i;:::-;;:::i;71838:840::-;;;;;;:::i;:::-;;:::i;70118:342::-;;;;;;:::i;:::-;;:::i;70770:135::-;;;;;;:::i;:::-;;:::i;71044:122::-;;;;;;:::i;:::-;;:::i;71172:120::-;;;;;;:::i;:::-;;:::i;:::-;;;5957:14:1;;5950:22;5932:41;;5920:2;5905:18;71172:120:0;5792:187:1;70620:144:0;70678:12;70709:48;:40;:31;:24;:8;:22;:24::i;:::-;-1:-1:-1;;70709:29:0;;:31::i;:::-;-1:-1:-1;;70709:38:0;56766:5;56677:102;70709:40;-1:-1:-1;;70709:46:0;;:48::i;:::-;70702:55;70620:144;-1:-1:-1;;70620:144:0:o;73276:235::-;73419:12;73450:54;73475:7;73484:5;73491:12;73450:24;:54::i;:::-;73443:61;;73276:235;;;;;;:::o;74278:102::-;74323:7;61260:34;61278:15;61131:1;61260:34;:::i;:::-;74349:24;;;74278:102;-1:-1:-1;74278:102:0:o;72684:586::-;72961:12;73004:259;73046:7;73071;73096:6;73120:12;73150:10;73178:18;73214:5;73237:12;73004:24;:259::i;:::-;72985:278;72684:586;-1:-1:-1;;;;;;;;;72684:586:0:o;70911:127::-;70972:6;70997:34;:24;:8;:22;:24::i;:::-;-1:-1:-1;;70997:32:0;;:34::i;70466:148::-;70526:12;70557:50;:42;:33;:24;:8;:22;:24::i;:::-;-1:-1:-1;;70557:31:0;;:33::i;71838:840::-;72225:12;72249:18;72270:131;72302:10;72326:15;72355:10;72379:12;72270:18;:131::i;:::-;72249:152;;72412:20;72435:176;72471:7;72492;72513:6;72533:12;72559:10;72583:18;48317:230;;;8611:16:1;48317:230:0;;;8595:102:1;8819:3;8815:16;;;8716:66;8811:25;;;8798:11;;;8791:46;8853:11;;;8846:27;;;;8907:16;;;8903:25;;8889:12;;;8882:47;8963:16;;;8959:25;;8945:12;;;8938:47;9001:12;;;8994:28;;;;9056:16;;;9052:25;;;9038:12;;;9031:47;48317:230:0;;;;;;;;;9094:12:1;;;;48317:230:0;;;;48059:495;72435:176;72412:199;;72628:43;72642:7;72651:5;72658:12;72628:13;:43::i;:::-;72621:50;71838:840;-1:-1:-1;;;;;;;;;;;;;;71838:840:0:o;70118:342::-;70185:12;70366;70381:34;70406:8;70381:24;:34::i;:::-;70366:49;-1:-1:-1;70432:21:0;-1:-1:-1;;70432:11:0;;:13;56677:102;70770:135;70828:12;70859:39;:31;:24;:8;:22;:24::i;:::-;-1:-1:-1;;70859:29:0;;:31::i;71044:122::-;71102:7;71128:31;:24;:8;:22;:24::i;:::-;-1:-1:-1;;71128:29:0;;:31::i;71172:120::-;71235:4;71258:27;:15;:8;71235:4;71258:12;:15::i;:::-;-1:-1:-1;;71258:25:0;;:27::i;64047:142::-;64116:7;64142:40;64156:25;:8;:23;:25::i;:::-;64142:13;:40::i;66661:148::-;66712:4;-1:-1:-1;;66744:11:0;;66774:28;:15;66744:11;66774:8;:15::i;:::-;-1:-1:-1;;66774:26:0;;:28::i;31765:632::-;31820:16;31848:11;31869:12;31884;31888:7;3310:2;18746:23;3703:16;18742:41;;18226:573;31884:12;31869:27;;;;32006:4;32000:11;31993:18;;32061:3;32054:10;;32107:33;32120:7;32129:3;32135:4;32129:10;32107:12;:33::i;:::-;-1:-1:-1;32264:14:0;;;32280:4;32260:25;32254:4;32247:39;32327:17;;31765:632;;-1:-1:-1;31765:632:0:o;62111:480::-;62439:14;;62479:12;;62365:219;;62256:12;;62365:219;;60498:1;;62439:7;;62479:5;;62558:12;;62365:219;;;:::i;:::-;;;;;;;;;;;;;62346:238;;62111:480;;;;;:::o;63235:659::-;48317:230;;;8611:16:1;48317:230:0;;;8595:102:1;8716:66;8819:3;8815:16;;;8811:25;;8798:11;;;8791:46;8853:11;;;8846:27;;;8907:16;;;8903:25;;8889:12;;;8882:47;8963:16;;;8959:25;;8945:12;;;8938:47;9001:12;;;8994:28;;;9056:16;;;9052:25;9038:12;;;9031:47;48317:230:0;;;;;;;;;9094:12:1;;;;48317:230:0;;;63514:12;;63557:330;;63838:5;63861:12;63557:13;:330::i;66182:185::-;66236:6;-1:-1:-1;;66312:11:0;;66342:18;66312:11;66342;:18::i;66438:156::-;66491:6;-1:-1:-1;;66525:11:0;;66555:32;:17;66525:11;66555:10;:17::i;:::-;-1:-1:-1;;66555:30:0;;:32::i;55090:299::-;55297:85;;7875:16:1;55297:85:0;;;7859:102:1;7980:66;8083:3;8079:16;;;8075:25;;8062:11;;;8055:46;8135:16;;;8131:25;;8117:12;;;8110:47;8191:16;;;8187:25;;8173:12;;;8166:47;8247:16;;;8243:25;8229:12;;;8222:47;55254:12:0;;8285::1;;55297:85:0;;;;;;;;;;;;55278:104;;55090:299;;;;;;;:::o;66886:329::-;66937:7;-1:-1:-1;;66972:11:0;;66937:7;67119:26;66972:11;67134:10;67119:7;:26::i;:::-;67088:28;67096:5;67103:12;67088:7;:28::i;:::-;61260:34;61278:15;61131:1;61260:34;:::i;:::-;67072:44;;;:13;;:44;:::i;:::-;:73;;;;:::i;:::-;67056:89;-1:-1:-1;67162:46:0;-1:-1:-1;;67162:15:0;;67056:89;67204:1;67162:15;:46::i;67303:137::-;67354:7;-1:-1:-1;;67389:11:0;;67419:14;67389:11;67419:12;:14::i;14835:595::-;14939:10;;14905:7;;15365:4;15356:14;;15397:26;;;;15356:14;14939:10;15397:5;:26::i;:::-;15390:33;14835:595;-1:-1:-1;;;;;14835:595:0:o;64595:820::-;64652:4;3310:2;18746:23;;;3703:16;18742:41;61260:34;61278:15;61131:1;61260:34;:::i;:::-;64780:13;;64771:22;;64767:40;;;-1:-1:-1;64802:5:0;;64595:820;-1:-1:-1;;64595:820:0:o;64767:40::-;60498:1;64854:18;64866:5;64854:11;:18::i;:::-;:37;;;64850:55;;-1:-1:-1;64900:5:0;;64595:820;-1:-1:-1;;64595:820:0:o;64850:55::-;64916:20;64939:28;64947:5;64954:12;64939:7;:28::i;:::-;64916:51;;64977:18;64998:26;65006:5;65013:10;64998:7;:26::i;:::-;64977:47;-1:-1:-1;65162:6:0;64977:47;65134:12;61260:34;61278:15;61131:1;61260:34;:::i;:::-;65118:28;;;:13;;:28;:::i;:::-;:41;;;;:::i;:::-;:50;65114:68;;;-1:-1:-1;65177:5:0;;64595:820;-1:-1:-1;;;;64595:820:0:o;65114:68::-;65316:28;:17;65327:5;65316:10;:17::i;:::-;-1:-1:-1;;65316:26:0;;:28::i;:::-;65315:29;:58;;;;65349:24;:15;65358:5;65349:8;:15::i;:::-;-1:-1:-1;;65349:22:0;;:24::i;:::-;65348:25;65315:58;65311:76;;;-1:-1:-1;65382:5:0;;64595:820;-1:-1:-1;;;;64595:820:0:o;65311:76::-;-1:-1:-1;65404:4:0;;64595:820;-1:-1:-1;;;;64595:820:0:o;37321:131::-;37391:7;37417:28;:8;37391:7;37417:12;:28::i;64339:173::-;64400:7;64427:16;64437:5;64427:9;:16::i;:::-;64419:50;;;;;;;9449:2:1;64419:50:0;;;9431:21:1;9488:2;9468:18;;;9461:30;9527:23;9507:18;;;9500:51;9568:18;;64419:50:0;;;;;;;;;-1:-1:-1;64499:5:0;64339:173::o;69008:328::-;69063:7;69135:17;69171:28;69179:5;69186:12;69171:7;:28::i;:::-;61260:34;61278:15;61131:1;61260:34;:::i;:::-;69155:44;;;:13;;:44;:::i;:::-;69135:64;;69209:14;69226:26;69234:5;69241:10;69226:7;:26::i;:::-;69209:43;-1:-1:-1;69269:60:0;-1:-1:-1;;69269:11:0;;69291:9;69209:43;69325:1;69269:11;:60::i;56041:158::-;56099:4;56123:13;56130:5;56123:6;:13::i;:::-;56115:44;;;;;;;9799:2:1;56115:44:0;;;9781:21:1;9838:2;9818:18;;;9811:30;9877:20;9857:18;;;9850:48;9915:18;;56115:44:0;9597:342:1;30502:892:0;30580:15;-1:-1:-1;;8095:15:0;;;;30607:55;;;;;;;10146:2:1;30607:55:0;;;10128:21:1;10185:2;10165:18;;;10158:30;10224:28;10204:18;;;10197:56;10270:18;;30607:55:0;9944:350:1;30607:55:0;30680:16;30688:7;30680;:16::i;:::-;30672:58;;;;;;;10501:2:1;30672:58:0;;;10483:21:1;10540:2;10520:18;;;10513:30;10579:31;10559:18;;;10552:59;10628:18;;30672:58:0;10299:353:1;30672:58:0;30740:12;30755;30759:7;3310:2;18746:23;3703:16;18742:41;;18226:573;30755:12;30740:27;;;;30777:15;30795:12;30799:7;30795:3;:12::i;:::-;30777:30;;;;30818:11;30839:8;30957:4;30951:11;30944:18;;31044:7;31039:3;31036:16;31033:94;;;31084:4;31078;31071:18;31033:94;31254:4;31245:7;31239:4;31230:7;31224:4;31217:5;31206:53;31199:60;;31286:3;31278:36;;;;;;;10859:2:1;31278:36:0;;;10841:21:1;10898:2;10878:18;;;10871:30;10937:22;10917:18;;;10910:50;10977:18;;31278:36:0;10657:344:1;31278:36:0;31335:52;31356:15;31363:7;31356:6;:15::i;:::-;12989:33;3222:2;12989:33;;;;13127:17;;13113:32;;13250:17;;3310:2;13234:34;;12348:936;31335:52;31325:62;30502:892;-1:-1:-1;;;;;;;30502:892:0:o;68361:132::-;68419:6;68451:34;-1:-1:-1;;68451:15:0;;68419:6;68483:1;68451:15;:34::i;68648:209::-;68705:7;68724:14;68741:28;68749:5;68756:12;68741:7;:28::i;:::-;68724:45;-1:-1:-1;68786:64:0;61260:34;61278:15;61131:1;61260:34;:::i;:::-;-1:-1:-1;;68786:11:0;;;68808:13;;68829:6;68846:1;68786:11;:64::i;48992:168::-;49052:6;49078:15;49087:5;49078:8;:15::i;:::-;49070:48;;;;;;;11208:2:1;49070:48:0;;;11190:21:1;11247:2;11227:18;;;11220:30;11286:22;11266:18;;;11259:50;11326:18;;49070:48:0;11006:344:1;68109:154:0;68176:7;68202:54;61131:1;68226:5;68218:14;;;;;;;;:::i;:::-;:26;;;;:::i;:::-;-1:-1:-1;;68202:15:0;;;61131:1;68202:15;:54::i;20109:208::-;20230:7;20256:54;20262:7;20271:6;20294;20279:12;20283:7;3310:2;18746:23;3703:16;18742:41;;18226:573;20279:12;:21;;;;;;:::i;:::-;20302:7;20256:5;:54::i;25583:290::-;25639:14;25665:12;25680;25684:7;25680:3;:12::i;:::-;25665:27;;;;25702:12;25717;25721:7;3310:2;18746:23;3703:16;18742:41;;18226:573;25717:12;25702:27;;25836:21;;;;25583:290;-1:-1:-1;;;25583:290:0:o;13823:615::-;13934:15;;13976:11;13983:4;13976;:11;:::i;:::-;13961:26;;14255:4;14249:11;14243:4;14240:21;14237:66;;;-1:-1:-1;14288:1:0;14237:66;14326:4;14334:1;14326:9;14322:51;;-1:-1:-1;;14351:11:0;;;;;14322:51;-1:-1:-1;;3222:2:0;12989:33;;;13127:17;;;;13113:32;;;13250:17;3310:2;13234:34;;13823:615::o;49242:335::-;49298:4;3310:2;18746:23;;;3703:16;18742:41;49415:1;49406:10;;49402:28;;;-1:-1:-1;49425:5:0;;49242:335;-1:-1:-1;;49242:335:0:o;49402:28::-;46118:1;49507:18;49519:5;49507:11;:18::i;:::-;:36;;;:63;;;;-1:-1:-1;46985:2:0;49547:23;;49500:70;-1:-1:-1;;49242:335:0:o;56272:339::-;56326:4;3310:2;18746:23;;;3703:16;18742:41;54009:1;56434:22;;56430:40;;;-1:-1:-1;56465:5:0;;56272:339;-1:-1:-1;;56272:339:0:o;56430:40::-;53472:1;56545:18;56557:5;56545:11;:18::i;:::-;:34;;;:59;;;;-1:-1:-1;54214:2:0;56583:21;;56538:66;-1:-1:-1;;56272:339:0:o;19400:399::-;19539:7;19558:12;19573;19577:7;19573:3;:12::i;:::-;19558:27;;;;19669:12;19673:7;19669:3;:12::i;:::-;19662:4;19646:13;19653:6;19646:4;:13;:::i;:::-;:20;;;;:::i;:::-;:35;19642:77;;;-1:-1:-1;;19697:11:0;;;;;19642:77;19736:13;19743:6;19736:4;:13;:::i;:::-;19729:20;;19766:26;19772:7;19766:26;;19781:4;19787;19766:5;:26::i;:::-;19759:33;19400:399;-1:-1:-1;;;;;;19400:399:0:o;8768:465::-;8825:8;8849:15;8856:7;8849:6;:15::i;:::-;:31;;8868:12;8849:31;8845:74;;-1:-1:-1;8903:5:0;;8768:465;-1:-1:-1;8768:465:0:o;8845:74::-;8928:12;8943;8947:7;8943:3;:12::i;:::-;9210:4;9204:11;-1:-1:-1;9191:26:0;;8768:465;-1:-1:-1;;;8768:465:0:o;16789:573::-;16842:11;;3494:20;3265:2;3310;3494:20;:::i;:::-;17309:23;;;;3703:16;17305:41;;16789:573;-1:-1:-1;;16789:573:0:o;15622:504::-;15678:12;;3222:2;3494:20;3222:2;3310;3494:20;:::i;:::-;3574;;;;:::i;:::-;16086:24;;;;;15622:504;-1:-1:-1;;15622:504:0:o;24029:374::-;24148:14;24379:11;24384:6;24379:2;:11;:::i;:::-;24378:17;;24394:1;24378:17;:::i;:::-;24334:62;;24342:30;24348:7;24357:6;24365;24342:5;:30::i;:::-;24334:62;;;24029:374;-1:-1:-1;;;;24029:374:0:o;18973:147::-;19026:7;19091:12;19095:7;3310:2;18746:23;3703:16;18742:41;;18226:573;19091:12;19076;19080:7;19076:3;:12::i;:::-;:27;19069:34;;;;18973:147;;;:::o;22793:890::-;22908:14;22938:6;:11;;22948:1;22938:11;22934:59;;-1:-1:-1;22980:1:0;22965:17;;22934:59;23024:12;23028:7;3310:2;18746:23;3703:16;18742:41;;18226:573;23024:12;23006:30;;:15;;;;:6;:15;:::i;:::-;:30;23002:137;;;23059:68;23075:12;23079:7;23075:3;:12::i;:::-;23059:68;;23089:12;23093:7;3310:2;18746:23;3703:16;18742:41;;18226:573;23089:12;23059:68;;23103:6;23119;23111:15;;23059;:68::i;:::-;23052:76;;;;;;;;;;;:::i;23002:137::-;23166:2;23156:6;:12;;;;23148:50;;;;;;;12243:2:1;23148:50:0;;;12225:21:1;12282:2;12262:18;;;12255:30;12321:27;12301:18;;;12294:55;12366:18;;23148:50:0;12041:349:1;23148:50:0;23279:1;23270:10;;23209:15;23315:12;23319:7;23315:3;:12::i;:::-;23300:27;;;-1:-1:-1;23393:13:0;7569:66;7539:12;;;7518:131;23641:17;;;;23635:24;23631:36;;;-1:-1:-1;;;;;22793:890:0:o;21550:741::-;21696:17;21728:9;21741:15;21751:4;21741:9;:15::i;:::-;21725:31;;;21769:9;21782:15;21792:4;21782:9;:15::i;:::-;21766:31;;;21810:9;21823:17;21833:6;21823:9;:17::i;:::-;21807:33;;;21853:9;21866:17;21876:6;21866:9;:17::i;:::-;21919:355;;;13236:34:1;21919:355:0;;;13224:47:1;13301:23;13287:12;;;13280:45;13344:66;13448:3;13444:16;;;13440:25;;13426:12;;;13419:47;13485:17;13518:12;;;13511:24;;;13569:16;;;13565:25;;13551:12;;;13544:47;13621:34;13607:12;;;13600:56;13687:3;13672:13;;;13665:26;13726:16;;;13722:25;;13707:13;;;13700:48;13764:13;;;13757:25;;;;13817:16;;13813:25;;;13798:13;;;13791:48;-1:-1:-1;;12472:3:1;13885:13;;;12460:16;21919:355:0;;;;;;;;;12492:11:1;;;;21919:355:0;;;;;-1:-1:-1;;;;;21550:741:0:o;4913:667::-;4967:13;;5023:2;5008:258;5031:2;5027:1;:6;;;5008:258;;;5051:11;5078:5;:1;5082;5078:5;:::i;:::-;5071:13;;:2;:13;;5051:34;;5108:14;5116:5;5108:7;:14::i;:::-;5099:23;;;;;;5140:1;:7;;5145:2;5140:7;5136:58;;5177:2;5167:12;;;;;5136:58;-1:-1:-1;5235:6:0;;5008:258;;;-1:-1:-1;5329:2:0;5314:260;5337:3;5333:1;:7;;;5314:260;;;5358:11;5385:5;:1;5389;5385:5;:::i;:::-;5378:13;;:2;:13;;5358:34;;5416:14;5424:5;5416:7;:14::i;:::-;5406:24;;;;;;5448:1;:6;;5453:1;5448:6;5444:58;;5485:2;5474:13;;;;;5444:58;-1:-1:-1;5543:6:0;;5314:260;;;;4913:667;;;:::o;4390:199::-;4440:14;4477:18;4493:1;4487:2;:7;;;;4477:9;:18::i;:::-;4466:29;;4519:13;;;;;;4531:1;4519:13;4553;4563:2;4553:9;:13::i;:::-;4542:24;;;;4390:199;-1:-1:-1;4390:199:0:o;4015:203::-;4188:13;;;;;;;;;;;;;;;;;;4070:11;;4117:4;4109:12;;;;;4188:22;;;;;;:::i;:::-;;;;;;;;4015:203;-1:-1:-1;;;4015:203:0:o;14:184:1:-;66:77;63:1;56:88;163:4;160:1;153:15;187:4;184:1;177:15;203:777;245:5;298:3;291:4;283:6;279:17;275:27;265:55;;316:1;313;306:12;265:55;352:6;339:20;378:18;415:2;411;408:10;405:36;;;421:18;;:::i;:::-;555:2;549:9;617:4;609:13;;460:66;605:22;;;629:2;601:31;597:40;585:53;;;653:18;;;673:22;;;650:46;647:72;;;699:18;;:::i;:::-;739:10;735:2;728:22;774:2;766:6;759:18;820:3;813:4;808:2;800:6;796:15;792:26;789:35;786:55;;;837:1;834;827:12;786:55;901:2;894:4;886:6;882:17;875:4;867:6;863:17;850:54;948:1;941:4;936:2;928:6;924:15;920:26;913:37;968:6;959:15;;;;;;203:777;;;;:::o;985:320::-;1053:6;1106:2;1094:9;1085:7;1081:23;1077:32;1074:52;;;1122:1;1119;1112:12;1074:52;1162:9;1149:23;1195:18;1187:6;1184:30;1181:50;;;1227:1;1224;1217:12;1181:50;1250:49;1291:7;1282:6;1271:9;1267:22;1250:49;:::i;1310:250::-;1395:1;1405:113;1419:6;1416:1;1413:13;1405:113;;;1495:11;;;1489:18;1476:11;;;1469:39;1441:2;1434:10;1405:113;;;-1:-1:-1;;1552:1:1;1534:16;;1527:27;1310:250::o;1565:329::-;1606:3;1644:5;1638:12;1671:6;1666:3;1659:19;1687:76;1756:6;1749:4;1744:3;1740:14;1733:4;1726:5;1722:16;1687:76;:::i;:::-;1808:2;1796:15;1813:66;1792:88;1783:98;;;;1883:4;1779:109;;1565:329;-1:-1:-1;;1565:329:1:o;1899:217::-;2046:2;2035:9;2028:21;2009:4;2066:44;2106:2;2095:9;2091:18;2083:6;2066:44;:::i;2121:737::-;2225:6;2233;2241;2294:2;2282:9;2273:7;2269:23;2265:32;2262:52;;;2310:1;2307;2300:12;2262:52;2350:9;2337:23;2379:18;2420:2;2412:6;2409:14;2406:34;;;2436:1;2433;2426:12;2406:34;2459:49;2500:7;2491:6;2480:9;2476:22;2459:49;:::i;:::-;2449:59;;2561:2;2550:9;2546:18;2533:32;2517:48;;2590:2;2580:8;2577:16;2574:36;;;2606:1;2603;2596:12;2574:36;2629:51;2672:7;2661:8;2650:9;2646:24;2629:51;:::i;:::-;2619:61;;2733:2;2722:9;2718:18;2705:32;2689:48;;2762:2;2752:8;2749:16;2746:36;;;2778:1;2775;2768:12;2746:36;;2801:51;2844:7;2833:8;2822:9;2818:24;2801:51;:::i;:::-;2791:61;;;2121:737;;;;;:::o;3238:163::-;3305:20;;3365:10;3354:22;;3344:33;;3334:61;;3391:1;3388;3381:12;3334:61;3238:163;;;:::o;3406:968::-;3542:6;3550;3558;3566;3574;3582;3590;3598;3651:3;3639:9;3630:7;3626:23;3622:33;3619:53;;;3668:1;3665;3658:12;3619:53;3691:28;3709:9;3691:28;:::i;:::-;3681:38;;3766:2;3755:9;3751:18;3738:32;3728:42;;3789:37;3822:2;3811:9;3807:18;3789:37;:::i;:::-;3779:47;;3845:37;3878:2;3867:9;3863:18;3845:37;:::i;:::-;3835:47;;3929:3;3918:9;3914:19;3901:33;3891:43;;3953:38;3986:3;3975:9;3971:19;3953:38;:::i;:::-;3943:48;;4042:3;4031:9;4027:19;4014:33;4066:18;4107:2;4099:6;4096:14;4093:34;;;4123:1;4120;4113:12;4093:34;4146:49;4187:7;4178:6;4167:9;4163:22;4146:49;:::i;:::-;4136:59;;4248:3;4237:9;4233:19;4220:33;4204:49;;4278:2;4268:8;4265:16;4262:36;;;4294:1;4291;4284:12;4262:36;;4317:51;4360:7;4349:8;4338:9;4334:24;4317:51;:::i;:::-;4307:61;;;3406:968;;;;;;;;;;;:::o;4379:179::-;4446:20;;4506:26;4495:38;;4485:49;;4475:77;;4548:1;4545;4538:12;4563:1042;4713:6;4721;4729;4737;4745;4753;4761;4769;4777;4785;4793:7;4847:3;4835:9;4826:7;4822:23;4818:33;4815:53;;;4864:1;4861;4854:12;4815:53;4887:28;4905:9;4887:28;:::i;:::-;4877:38;;4962:2;4951:9;4947:18;4934:32;4924:42;;4985:37;5018:2;5007:9;5003:18;4985:37;:::i;:::-;4975:47;;5041:37;5074:2;5063:9;5059:18;5041:37;:::i;:::-;5031:47;;5125:3;5114:9;5110:19;5097:33;5087:43;;5149:38;5182:3;5171:9;5167:19;5149:38;:::i;:::-;5139:48;;5206:38;5239:3;5228:9;5224:19;5206:38;:::i;:::-;5196:48;;5263:38;5296:3;5285:9;5281:19;5263:38;:::i;:::-;5253:48;;5320:38;5353:3;5342:9;5338:19;5320:38;:::i;:::-;5310:48;;5377:38;5410:3;5399:9;5395:19;5377:38;:::i;:::-;5367:48;;5466:3;5455:9;5451:19;5438:33;5494:18;5486:6;5483:30;5480:50;;;5526:1;5523;5516:12;5480:50;5550:49;5591:7;5582:6;5571:9;5567:22;5550:49;:::i;:::-;5539:60;;;4563:1042;;;;;;;;;;;;;;:::o;5984:184::-;6036:77;6033:1;6026:88;6133:4;6130:1;6123:15;6157:4;6154:1;6147:15;6173:184;6225:77;6222:1;6215:88;6322:4;6319:1;6312:15;6346:4;6343:1;6336:15;6362:225;6466:4;6445:12;;;6459;;;6441:31;6492:22;;;;6533:24;;;6523:58;;6561:18;;:::i;:::-;6523:58;6362:225;;;;:::o;6592:1031::-;6891:3;6919:66;7028:2;7019:6;7014:3;7010:16;7006:25;7001:3;6994:38;7083:2;7074:6;7069:3;7065:16;7061:25;7057:1;7052:3;7048:11;7041:46;7138:2;7129:6;7124:3;7120:16;7116:25;7112:1;7107:3;7103:11;7096:46;;7171:6;7165:13;7187:74;7254:6;7250:1;7245:3;7241:11;7234:4;7226:6;7222:17;7187:74;:::i;:::-;7321:13;;7280:16;;;;7343:75;7321:13;7405:1;7397:10;;7390:4;7378:17;;7343:75;:::i;:::-;7479:13;;7437:17;;;7501:75;7479:13;7563:1;7555:10;;7548:4;7536:17;;7501:75;:::i;:::-;7596:17;7615:1;7592:25;;6592:1031;-1:-1:-1;;;;;;;;6592:1031:1:o;9117:125::-;9182:9;;;9203:10;;;9200:36;;;9216:18;;:::i;11355:168::-;11428:9;;;11459;;11476:15;;;11470:22;;11456:37;11446:71;;11497:18;;:::i;11528:128::-;11595:9;;;11616:11;;;11613:37;;;11630:18;;:::i;11661:151::-;11751:4;11744:12;;;11730;;;11726:31;;11769:14;;11766:40;;;11786:18;;:::i;13910:184::-;13962:77;13959:1;13952:88;14059:4;14056:1;14049:15;14083:4;14080:1;14073:15","abiDefinition":[{"inputs":[{"internalType":"bytes","name":"_payload","type":"bytes"}],"name":"body","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes","name":"_payload","type":"bytes"}],"name":"castToMessage","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes","name":"_header","type":"bytes"},{"internalType":"bytes","name":"_tips","type":"bytes"},{"internalType":"bytes","name":"_messageBody","type":"bytes"}],"name":"formatMessage","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint32","name":"_origin","type":"uint32"},{"internalType":"bytes32","name":"_sender","type":"bytes32"},{"internalType":"uint32","name":"_nonce","type":"uint32"},{"internalType":"uint32","name":"_destination","type":"uint32"},{"internalType":"bytes32","name":"_recipient","type":"bytes32"},{"internalType":"uint32","name":"_optimisticSeconds","type":"uint32"},{"internalType":"bytes","name":"_tips","type":"bytes"},{"internalType":"bytes","name":"_messageBody","type":"bytes"}],"name":"formatMessage","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint32","name":"_origin","type":"uint32"},{"internalType":"bytes32","name":"_sender","type":"bytes32"},{"internalType":"uint32","name":"_nonce","type":"uint32"},{"internalType":"uint32","name":"_destination","type":"uint32"},{"internalType":"bytes32","name":"_recipient","type":"bytes32"},{"internalType":"uint32","name":"_optimisticSeconds","type":"uint32"},{"internalType":"uint96","name":"_notaryTip","type":"uint96"},{"internalType":"uint96","name":"_broadcasterTip","type":"uint96"},{"internalType":"uint96","name":"_proverTip","type":"uint96"},{"internalType":"uint96","name":"_executorTip","type":"uint96"},{"internalType":"bytes","name":"_messageBody","type":"bytes"}],"name":"formatMessage","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"_payload","type":"bytes"}],"name":"header","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes","name":"_payload","type":"bytes"}],"name":"isMessage","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"_payload","type":"bytes"}],"name":"leaf","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"messageVersion","outputs":[{"internalType":"uint16","name":"","type":"uint16"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"offsetHeader","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"offsetVersion","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"_payload","type":"bytes"}],"name":"tips","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes","name":"_payload","type":"bytes"}],"name":"version","outputs":[{"internalType":"uint16","name":"","type":"uint16"}],"stateMutability":"pure","type":"function"}],"userDoc":{"kind":"user","methods":{},"notice":"Exposes Message methods for testing against golang.","version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"body\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"castToMessage\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_header\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_tips\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_messageBody\",\"type\":\"bytes\"}],\"name\":\"formatMessage\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_origin\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"_sender\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"_nonce\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_destination\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"_recipient\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"_optimisticSeconds\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"_tips\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_messageBody\",\"type\":\"bytes\"}],\"name\":\"formatMessage\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_origin\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"_sender\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"_nonce\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_destination\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"_recipient\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"_optimisticSeconds\",\"type\":\"uint32\"},{\"internalType\":\"uint96\",\"name\":\"_notaryTip\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"_broadcasterTip\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"_proverTip\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"_executorTip\",\"type\":\"uint96\"},{\"internalType\":\"bytes\",\"name\":\"_messageBody\",\"type\":\"bytes\"}],\"name\":\"formatMessage\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"header\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"isMessage\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"leaf\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"messageVersion\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"offsetHeader\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"offsetVersion\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"tips\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"version\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"Exposes Message methods for testing against golang.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/MessageHarness.t.sol\":\"MessageHarness\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/MessageHarness.t.sol\":{\"keccak256\":\"0x3904cba9f384c6433257789b24cdb15655a5775a36df2c4c297958af081b2acc\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://eff1071fd96ffa0ae24c5a5d8de738a1545769b12ccc3c5ec469a9d7e16b21db\",\"dweb:/ipfs/QmYyQsoEqF9QJ5aHaVw5545ePNt9Z7GqXfVyCFGrEh4y84\"]}},\"version\":1}"},"hashes":{"body(bytes)":"c97c703a","castToMessage(bytes)":"c311d359","formatMessage(bytes,bytes,bytes)":"0b9255e9","formatMessage(uint32,bytes32,uint32,uint32,bytes32,uint32,bytes,bytes)":"7c517825","formatMessage(uint32,bytes32,uint32,uint32,bytes32,uint32,uint96,uint96,uint96,uint96,bytes)":"81d030ef","header(bytes)":"801fdbfc","isMessage(bytes)":"f9893ddd","leaf(bytes)":"d7a7a72c","messageVersion()":"52617f3c","offsetHeader()":"1515f90c","offsetVersion()":"0c096e8d","tips(bytes)":"045c6c0b","version(bytes)":"7d67c5a7"}},"solidity/MessageHarness.t.sol:MessageLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220913f4b3ae91b0510a66de856f41fc1944d019990582315fe3d31e1991b87cf9664736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220913f4b3ae91b0510a66de856f41fc1944d019990582315fe3d31e1991b87cf9664736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nlibrary TypedMemView {\n    // Why does this exist?\n    // the solidity `bytes memory` type has a few weaknesses.\n    // 1. You can't index ranges effectively\n    // 2. You can't slice without copying\n    // 3. The underlying data may represent any type\n    // 4. Solidity never deallocates memory, and memory costs grow\n    //    superlinearly\n\n    // By using a memory view instead of a `bytes memory` we get the following\n    // advantages:\n    // 1. Slices are done on the stack, by manipulating the pointer\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\n    // 3. We can insert type info into the pointer, and typecheck at runtime\n\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\n    // algorithms.\n\n    // Why bytes29?\n    // We want to avoid confusion between views, digests, and other common\n    // types so we chose a large and uncommonly used odd number of bytes\n    //\n    // Note that while bytes are left-aligned in a word, integers and addresses\n    // are right-aligned. This means when working in assembly we have to\n    // account for the 3 unused bytes on the righthand side\n    //\n    // First 5 bytes are a type flag.\n    // - ff_ffff_fffe is reserved for unknown type.\n    // - ff_ffff_ffff is reserved for invalid types/errors.\n    // next 12 are memory address\n    // next 12 are len\n    // bottom 3 bytes are empty\n\n    // Assumptions:\n    // - non-modification of memory.\n    // - No Solidity updates\n    // - - wrt free mem point\n    // - - wrt bytes representation in memory\n    // - - wrt memory addressing in general\n\n    // Usage:\n    // - create type constants\n    // - use `assertType` for runtime type assertions\n    // - - unfortunately we can't do this at compile time yet :(\n    // - recommended: implement modifiers that perform type checking\n    // - - e.g.\n    // - - `uint40 constant MY_TYPE = 3;`\n    // - - ` modifier onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n    // - instantiate a typed view from a bytearray using `ref`\n    // - use `index` to inspect the contents of the view\n    // - use `slice` to create smaller views into the same memory\n    // - - `slice` can increase the offset\n    // - - `slice can decrease the length`\n    // - - must specify the output type of `slice`\n    // - - `slice` will return a null view if you try to overrun\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\n    // - use `equal` for typed comparisons.\n\n    // The null view\n    bytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n\n    /**\n     * @dev Memory layout for bytes29\n     * TODO (Chi): with the user defined types storing type is no longer necessary.\n     * Update the library, transforming bytes29 to bytes24 in the process.\n     * [000..005)   type     5 bytes    Type flag for the pointer\n     * [005..017)   loc     12 bytes    Memory address of underlying bytes\n     * [017..029)   len     12 bytes    Length of underlying bytes\n     * [029..032)   empty    3 bytes    Not used\n     */\n    uint256 public constant BITS_TYPE = 40;\n    uint256 public constant BITS_LOC = 96;\n    uint256 public constant BITS_LEN = 96;\n    uint256 public constant BITS_EMPTY = 24;\n\n    // `SHIFT_X` is how much bits to shift for `X` to be in the very bottom bits\n    uint256 public constant SHIFT_LEN = BITS_EMPTY; // 24\n    uint256 public constant SHIFT_LOC = SHIFT_LEN + BITS_LEN; // 24 + 96 = 120\n    uint256 public constant SHIFT_TYPE = SHIFT_LOC + BITS_LOC; // 24 + 96 + 96 = 216\n    // Bitmask for the lowest 96 bits\n    uint256 public constant LOW_96_BITS_MASK = type(uint96).max;\n\n    // For nibble encoding\n    bytes private constant NIBBLE_LOOKUP = \"0123456789abcdef\";\n\n    /**\n     * @notice Returns the encoded hex character that represents the lower 4 bits of the argument.\n     * @param _byte     The byte\n     * @return _char    The encoded hex character\n     */\n    function nibbleHex(uint8 _byte) internal pure returns (uint8 _char) {\n        uint8 _nibble = _byte \u0026 0x0f; // keep bottom 4 bits, zero out top 4 bits\n        _char = uint8(NIBBLE_LOOKUP[_nibble]);\n    }\n\n    /**\n     * @notice      Returns a uint16 containing the hex-encoded byte.\n     * @param _b    The byte\n     * @return      encoded - The hex-encoded byte\n     */\n    function byteHex(uint8 _b) internal pure returns (uint16 encoded) {\n        encoded |= nibbleHex(_b \u003e\u003e 4); // top 4 bits\n        encoded \u003c\u003c= 8;\n        encoded |= nibbleHex(_b); // lower 4 bits\n    }\n\n    /**\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\n     *              `second` contains the encoded lower 16 bytes.\n     *\n     * @param _b    The 32 bytes as uint256\n     * @return      first - The top 16 bytes\n     * @return      second - The bottom 16 bytes\n     */\n    function encodeHex(uint256 _b) internal pure returns (uint256 first, uint256 second) {\n        for (uint8 i = 31; i \u003e 15; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            first |= byteHex(_byte);\n            if (i != 16) {\n                first \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n\n        // abusing underflow here =_=\n        for (uint8 i = 15; i \u003c 255; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            second |= byteHex(_byte);\n            if (i != 0) {\n                second \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n    }\n\n    /**\n     * @notice          Changes the endianness of a uint256.\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n     * @param _b        The unsigned integer to reverse\n     * @return          v - The reversed value\n     */\n    function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\n        v = _b;\n\n        // swap bytes\n        v =\n            ((v \u003e\u003e 8) \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\n            ((v \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) \u003c\u003c 8);\n        // swap 2-byte long pairs\n        v =\n            ((v \u003e\u003e 16) \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\n            ((v \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) \u003c\u003c 16);\n        // swap 4-byte long pairs\n        v =\n            ((v \u003e\u003e 32) \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\n            ((v \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) \u003c\u003c 32);\n        // swap 8-byte long pairs\n        v =\n            ((v \u003e\u003e 64) \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\n            ((v \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) \u003c\u003c 64);\n        // swap 16-byte long pairs\n        v = (v \u003e\u003e 128) | (v \u003c\u003c 128);\n    }\n\n    /**\n     * @notice      Create a mask with the highest `_len` bits set.\n     * @param _len  The length\n     * @return      mask - The mask\n     */\n    function leftMask(uint8 _len) private pure returns (uint256 mask) {\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(\n                sub(_len, 1),\n                0x8000000000000000000000000000000000000000000000000000000000000000\n            )\n        }\n    }\n\n    /**\n     * @notice      Return the null view.\n     * @return      bytes29 - The null view\n     */\n    // solhint-disable-next-line ordering\n    function nullView() internal pure returns (bytes29) {\n        return NULL;\n    }\n\n    /**\n     * @notice      Check if the view is null.\n     * @return      bool - True if the view is null\n     */\n    function isNull(bytes29 memView) internal pure returns (bool) {\n        return memView == NULL;\n    }\n\n    /**\n     * @notice      Check if the view is not null.\n     * @return      bool - True if the view is not null\n     */\n    function notNull(bytes29 memView) internal pure returns (bool) {\n        return !isNull(memView);\n    }\n\n    /**\n     * @notice          Check if the view is of a valid type and points to a valid location\n     *                  in memory.\n     * @dev             We perform this check by examining solidity's unallocated memory\n     *                  pointer and ensuring that the view's upper bound is less than that.\n     * @param memView   The view\n     * @return          ret - True if the view is valid\n     */\n    function isValid(bytes29 memView) internal pure returns (bool ret) {\n        if (typeOf(memView) == 0xffffffffff) {\n            return false;\n        }\n        uint256 _end = end(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // View is valid if (\"upper bound\" \u003c= \"unallocated memory pointer\")\n            // Upper bound is exclusive, hence \"\u003c=\"\n            ret := not(gt(_end, mload(0x40)))\n        }\n    }\n\n    /**\n     * @notice          Require that a typed memory view be valid.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @return          bytes29 - The validated view\n     */\n    function assertValid(bytes29 memView) internal pure returns (bytes29) {\n        require(isValid(memView), \"Validity assertion failed\");\n        return memView;\n    }\n\n    /**\n     * @notice          Return true if the memview is of the expected type. Otherwise false.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bool - True if the memview is of the expected type\n     */\n    function isType(bytes29 memView, uint40 _expected) internal pure returns (bool) {\n        return typeOf(memView) == _expected;\n    }\n\n    /**\n     * @notice          Require that a typed memory view has a specific type.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bytes29 - The view with validated type\n     */\n    function assertType(bytes29 memView, uint40 _expected) internal pure returns (bytes29) {\n        if (!isType(memView, _expected)) {\n            (, uint256 g) = encodeHex(uint256(typeOf(memView)));\n            (, uint256 e) = encodeHex(uint256(_expected));\n            string memory err = string(\n                abi.encodePacked(\n                    \"Type assertion failed. Got 0x\",\n                    uint80(g),\n                    \". Expected 0x\",\n                    uint80(e)\n                )\n            );\n            revert(err);\n        }\n        return memView;\n    }\n\n    /**\n     * @notice          Return an identical view with a different type.\n     * @param memView   The view\n     * @param _newType  The new type\n     * @return          newView - The new view with the specified type\n     */\n    function castTo(bytes29 memView, uint40 _newType) internal pure returns (bytes29 newView) {\n        // How many bits are the \"type bits\" occupying\n        uint256 _bitsType = BITS_TYPE;\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 _shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // shift off the \"type bits\" (shift left, then sift right)\n            newView := or(newView, shr(_bitsType, shl(_bitsType, memView)))\n            // set the new \"type bits\" (shift left, then OR)\n            newView := or(newView, shl(_shiftType, _newType))\n        }\n    }\n\n    /**\n     * @notice          Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function unsafeBuildUnchecked(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) private pure returns (bytes29 newView) {\n        uint256 _bitsLoc = BITS_LOC;\n        uint256 _bitsLen = BITS_LEN;\n        uint256 _bitsEmpty = BITS_EMPTY;\n        // Ref memory layout\n        // [000..005) 5 bytes of type\n        // [005..017) 12 bytes of location\n        // [017..029) 12 bytes of length\n        // last 3 bits are blank and dropped in typecast\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // insert `type`, shift to prepare empty bits for `loc`\n            newView := shl(_bitsLoc, or(newView, _type))\n            // insert `loc`, shift to prepare empty bits for `len`\n            newView := shl(_bitsLen, or(newView, _loc))\n            // insert `len`, shift to insert 3 blank lowest bits\n            newView := shl(_bitsEmpty, or(newView, _len))\n        }\n    }\n\n    /**\n     * @notice          Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function build(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) internal pure returns (bytes29 newView) {\n        uint256 _end = _loc + _len;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(_end, mload(0x40)) {\n                _end := 0\n            }\n        }\n        if (_end == 0) {\n            return NULL;\n        }\n        newView = unsafeBuildUnchecked(_type, _loc, _len);\n    }\n\n    /**\n     * @notice          Instantiate a memory view from a byte array.\n     * @dev             Note that due to Solidity memory representation, it is not possible to\n     *                  implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr       The byte array\n     * @param newType   The type\n     * @return          bytes29 - The memory view\n     */\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\n        uint256 _len = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 _loc;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            _loc := add(arr, 0x20)\n        }\n\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Return the associated type information.\n     * @param memView   The memory view\n     * @return          _type - The type associated with the view\n     */\n    function typeOf(bytes29 memView) internal pure returns (uint40 _type) {\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 _shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"type bits\". \"type bits\" are occupying\n            // the highest bits, so all that's left is \"type bits\", OR is not required.\n            _type := shr(_shiftType, memView)\n        }\n    }\n\n    /**\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the 5-byte type flag is equal\n     */\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\n        // Check that the highest 5 bytes are equal: xor and shift out lower 27 bytes\n        return (left ^ right) \u003e\u003e SHIFT_TYPE == 0;\n    }\n\n    /**\n     * @notice          Return the memory address of the underlying bytes.\n     * @param memView   The view\n     * @return          _loc - The memory address\n     */\n    function loc(bytes29 memView) internal pure returns (uint96 _loc) {\n        // How many bits are the \"loc bits\" shifted from the bottom\n        uint256 _shiftLoc = SHIFT_LOC;\n        // Mask for the bottom 96 bits\n        uint256 _uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"loc bits\".\n            // Then use the lowest 96 bits to determine `loc` by applying the bit-mask.\n            _loc := and(shr(_shiftLoc, memView), _uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          The number of memory words this memory view occupies, rounded up.\n     * @param memView   The view\n     * @return          uint256 - The number of memory words\n     */\n    function words(bytes29 memView) internal pure returns (uint256) {\n        // returning ceil(length / 32.0)\n        return (uint256(len(memView)) + 31) / 32;\n    }\n\n    /**\n     * @notice          The in-memory footprint of a fresh copy of the view.\n     * @param memView   The view\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(bytes29 memView) internal pure returns (uint256) {\n        return words(memView) * 32;\n    }\n\n    /**\n     * @notice          The number of bytes of the view.\n     * @param memView   The view\n     * @return          _len - The length of the view\n     */\n    function len(bytes29 memView) internal pure returns (uint96 _len) {\n        // How many bits are the \"len bits\" shifted from the bottom\n        uint256 _shiftLen = SHIFT_LEN;\n        // Mask for the bottom 96 bits\n        uint256 _uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"len bits\".\n            // Then use the lowest 96 bits to determine `len` by applying the bit-mask.\n            _len := and(shr(_shiftLen, memView), _uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          Returns the endpoint of `memView`.\n     * @param memView   The view\n     * @return          uint256 - The endpoint of `memView`\n     */\n    function end(bytes29 memView) internal pure returns (uint256) {\n        unchecked {\n            return loc(memView) + len(memView);\n        }\n    }\n\n    /**\n     * @notice          Safe slicing without memory modification.\n     * @param memView   The view\n     * @param _index    The start index\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function slice(\n        bytes29 memView,\n        uint256 _index,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        uint256 _loc = loc(memView);\n\n        // Ensure it doesn't overrun the view\n        if (_loc + _index + _len \u003e end(memView)) {\n            return NULL;\n        }\n\n        _loc = _loc + _index;\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing\n     *                  bytes from `_index` to end(memView).\n     * @param memView   The view\n     * @param _index    The start index\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function sliceFrom(\n        bytes29 memView,\n        uint256 _index,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, _index, len(memView) - _index, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the first `_len` bytes.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function prefix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, 0, _len, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the last `_len` byte.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function postfix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, uint256(len(memView)) - _len, _len, newType);\n    }\n\n    /**\n     * @notice          Construct an error message for an indexing overrun.\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @param _index    The index\n     * @param _slice    The slice where the overrun occurred\n     * @return          err - The err\n     */\n    function indexErrOverrun(\n        uint256 _loc,\n        uint256 _len,\n        uint256 _index,\n        uint256 _slice\n    ) internal pure returns (string memory err) {\n        (, uint256 a) = encodeHex(_loc);\n        (, uint256 b) = encodeHex(_len);\n        (, uint256 c) = encodeHex(_index);\n        (, uint256 d) = encodeHex(_slice);\n        err = string(\n            abi.encodePacked(\n                \"TypedMemView/index - Overran the view. Slice is at 0x\",\n                uint48(a),\n                \" with length 0x\",\n                uint48(b),\n                \". Attempted to index at offset 0x\",\n                uint48(c),\n                \" with length 0x\",\n                uint48(d),\n                \".\"\n            )\n        );\n    }\n\n    /**\n     * @notice          Load up to 32 bytes from the view onto the stack.\n     * @dev             Returns a bytes32 with only the `_bytes` highest bytes set.\n     *                  This can be immediately cast to a smaller fixed-length byte array.\n     *                  To automatically cast to an integer, use `indexUint`.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The 32 byte result\n     */\n    function index(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (bytes32 result) {\n        if (_bytes == 0) {\n            return bytes32(0);\n        }\n        if (_index + _bytes \u003e len(memView)) {\n            revert(indexErrOverrun(loc(memView), len(memView), _index, uint256(_bytes)));\n        }\n        require(_bytes \u003c= 32, \"Index: more than 32 bytes\");\n\n        uint8 bitLength;\n        unchecked {\n            bitLength = _bytes * 8;\n        }\n        uint256 _loc = loc(memView);\n        // Get a mask with `bitLength` highest bits set\n        uint256 _mask = leftMask(bitLength);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(_loc, _index)), _mask)\n        }\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from the view at `_index`.\n     * @dev             Requires that the view have \u003e= `_bytes` bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        // `index()` returns left-aligned `_bytes`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word\n        return uint256(index(memView, _index, _bytes)) \u003e\u003e ((32 - _bytes) * 8);\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from LE bytes.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexLEUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return reverseUint256(uint256(index(memView, _index, _bytes)));\n    }\n\n    /**\n     * @notice          Parse an address from the view at `_index`.\n     *                  Requires that the view have \u003e= 20 bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @return          address - The address\n     */\n    function indexAddress(bytes29 memView, uint256 _index) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(indexUint(memView, _index, 20)));\n    }\n\n    /**\n     * @notice          Return the keccak256 hash of the underlying memory\n     * @param memView   The view\n     * @return          digest - The keccak256 hash of the underlying memory\n     */\n    function keccak(bytes29 memView) internal pure returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(_loc, _len)\n        }\n    }\n\n    /**\n     * @notice          Return the sha2 digest of the underlying memory.\n     * @dev             We explicitly deallocate memory afterwards.\n     * @param memView   The view\n     * @return          digest - The sha2 hash of the underlying memory\n     */\n    function sha2(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            digest := mload(ptr)\n        }\n        require(res, \"sha2: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n     * @param memView   The pre-image\n     * @return          digest - the Digest\n     */\n    function hash160(bytes29 memView) internal view returns (bytes20 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            // rmd160 precompile is 0x03\n            res := and(res, staticcall(gas(), 0x03, ptr, 0x20, ptr, 0x20))\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\n        }\n        require(res, \"hash160: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash256 (double sha2)\n     * @param memView   A view of the preimage\n     * @return          digest - the Digest\n     */\n    function hash256(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            res := and(res, staticcall(gas(), 0x02, ptr, 0x20, ptr, 0x20))\n            digest := mload(ptr)\n        }\n        require(res, \"hash256: out of gas\");\n    }\n\n    /**\n     * @notice          Return true if the underlying memory is equal. Else false.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the underlying memory is equal\n     */\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return\n            (loc(left) == loc(right) \u0026\u0026 len(left) == len(right)) || keccak(left) == keccak(right);\n    }\n\n    /**\n     * @notice          Return false if the underlying memory is equal. Else true.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - False if the underlying memory is equal\n     */\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !untypedEqual(left, right);\n    }\n\n    /**\n     * @notice          Compares type equality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are the same\n     */\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return left == right || (typeOf(left) == typeOf(right) \u0026\u0026 keccak(left) == keccak(right));\n    }\n\n    /**\n     * @notice          Compares type inequality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are not the same\n     */\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !equal(left, right);\n    }\n\n    /**\n     * @notice          Copy the view to a location, return an unsafe memory reference\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memView   The view\n     * @param _newLoc   The new location\n     * @return          written - the unsafe memory reference\n     */\n    function unsafeCopyTo(bytes29 memView, uint256 _newLoc) private view returns (bytes29 written) {\n        require(notNull(memView), \"copyTo: Null pointer deref\");\n        require(isValid(memView), \"copyTo: Invalid pointer deref\");\n        uint256 _len = len(memView);\n        uint256 _oldLoc = loc(memView);\n\n        uint256 ptr;\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _newLoc) {\n                revert(0x60, 0x20) // empty revert message\n            }\n\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, _oldLoc, _len, _newLoc, _len)\n        }\n        require(res, \"identity: out of gas\");\n\n        written = unsafeBuildUnchecked(typeOf(memView), _newLoc, _len);\n    }\n\n    /**\n     * @notice          Copies the referenced memory to a new loc in memory,\n     *                  returning a `bytes` pointing to the new memory.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param memView   The view\n     * @return          ret - The view pointing to the new memory\n     */\n    function clone(bytes29 memView) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n            ret := ptr\n        }\n        unchecked {\n            unsafeCopyTo(memView, ptr + 0x20);\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mstore(0x40, add(add(ptr, _len), 0x20)) // write new unused pointer\n            mstore(ptr, _len) // write len of new array (in bytes)\n        }\n    }\n\n    /**\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memViews  The views\n     * @return          unsafeView - The conjoined view pointing to the new memory\n     */\n    function unsafeJoin(bytes29[] memory memViews, uint256 _location)\n        private\n        view\n        returns (bytes29 unsafeView)\n    {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _location) {\n                revert(0x60, 0x20) // empty revert message\n            }\n        }\n\n        uint256 _offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length; i++) {\n            bytes29 memView = memViews[i];\n            unchecked {\n                unsafeCopyTo(memView, _location + _offset);\n                _offset += len(memView);\n            }\n        }\n        unsafeView = unsafeBuildUnchecked(0, _location, _offset);\n    }\n\n    /**\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The keccak256 digest\n     */\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return keccak(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The sha256 digest\n     */\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return sha2(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          copies all views, joins them into a new bytearray.\n     * @param memViews  The views\n     * @return          ret - The new byte array\n     */\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n\n        bytes29 _newView;\n        unchecked {\n            _newView = unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 _written = len(_newView);\n        uint256 _footprint = footprint(_newView);\n\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // store the length\n            mstore(ptr, _written)\n            // new pointer is old + 0x20 + the footprint of the body\n            mstore(0x40, add(add(ptr, _footprint), 0x20))\n            ret := ptr\n        }\n    }\n}\n\n/// @dev CallData is a memory view over the payload to be used for an external call, i.e.\n/// recipient.call(callData). Its length is always (4 + 32 * N) bytes:\n/// - First 4 bytes represent the function selector.\n/// - 32 * N bytes represent N words that function arguments occupy.\ntype CallData is bytes29;\n/// @dev Signature is a memory view over a \"65 bytes\" array representing a ECDSA signature.\ntype Signature is bytes29;\n\nlibrary ByteString {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev non-compact ECDSA signatures are enforced as of OZ 4.7.3\n     *\n     *      Signature payload memory layout\n     * [000 .. 032) r   bytes32 32 bytes\n     * [032 .. 064) s   bytes32 32 bytes\n     * [064 .. 065) v   uint8    1 byte\n     */\n    uint256 internal constant SIGNATURE_LENGTH = 65;\n    uint256 internal constant OFFSET_R = 0;\n    uint256 internal constant OFFSET_S = 32;\n    uint256 internal constant OFFSET_V = 64;\n\n    /**\n     * @dev Calldata memory layout\n     * [000 .. 004) selector    bytes4  4 bytes\n     *      Optional: N function arguments\n     * [004 .. 036) arg1        bytes32 32 bytes\n     *      ..\n     * [AAA .. END) argN        bytes32 32 bytes\n     */\n    uint256 internal constant SELECTOR_LENGTH = 4;\n    uint256 internal constant OFFSET_SELECTOR = 0;\n    uint256 internal constant OFFSET_ARGUMENTS = SELECTOR_LENGTH;\n\n    /**\n     * @notice Returns a memory view over the given payload, treating it as raw bytes.\n     * @dev Shortcut for .ref(0) - to be deprecated once \"uint40 type\" is removed from bytes29.\n     */\n    function castToRawBytes(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref({ newType: 0 });\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              SIGNATURE                               ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Constructs the signature payload from the given values.\n     * @dev Using ByteString.formatSignature({r: r, s: s, v: v}) will make sure\n     * that params are given in the right order.\n     */\n    function formatSignature(\n        bytes32 r,\n        bytes32 s,\n        uint8 v\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(r, s, v);\n    }\n\n    /**\n     * @notice Returns a Signature view over for the given payload.\n     * @dev Will revert if the payload is not a signature.\n     */\n    function castToSignature(bytes memory _payload) internal pure returns (Signature) {\n        return castToSignature(castToRawBytes(_payload));\n    }\n\n    /**\n     * @notice Casts a memory view to a Signature view.\n     * @dev Will revert if the memory view is not over a signature.\n     */\n    function castToSignature(bytes29 _view) internal pure returns (Signature) {\n        require(isSignature(_view), \"Not a signature\");\n        return Signature.wrap(_view);\n    }\n\n    /**\n     * @notice Checks that a byte string is a signature\n     */\n    function isSignature(bytes29 _view) internal pure returns (bool) {\n        return _view.len() == SIGNATURE_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Signature _signature) internal pure returns (bytes29) {\n        return Signature.unwrap(_signature);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                          SIGNATURE SLICING                           ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /// @notice Unpacks signature payload into (r, s, v) parameters.\n    /// @dev Make sure to verify signature length with isSignature() beforehand.\n    function toRSV(Signature _signature)\n        internal\n        pure\n        returns (\n            bytes32 r,\n            bytes32 s,\n            uint8 v\n        )\n    {\n        // Get the underlying memory view\n        bytes29 _view = unwrap(_signature);\n        r = _view.index({ _index: OFFSET_R, _bytes: 32 });\n        s = _view.index({ _index: OFFSET_S, _bytes: 32 });\n        v = uint8(_view.indexUint({ _index: OFFSET_V, _bytes: 1 }));\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                               CALLDATA                               ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns a CallData view over for the given payload.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(bytes memory _payload) internal pure returns (CallData) {\n        return castToCallData(castToRawBytes(_payload));\n    }\n\n    /**\n     * @notice Casts a memory view to a CallData view.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(bytes29 _view) internal pure returns (CallData) {\n        require(isCallData(_view), \"Not a calldata\");\n        return CallData.wrap(_view);\n    }\n\n    /**\n     * @notice Checks that a byte string is a valid calldata, i.e.\n     * a function selector, followed by arbitrary amount of arguments.\n     */\n    function isCallData(bytes29 _view) internal pure returns (bool) {\n        uint256 length = _view.len();\n        // Calldata should at least have a function selector\n        if (length \u003c SELECTOR_LENGTH) return false;\n        // The remainder of the calldata should be exactly N words (N \u003e= 0), i.e.\n        // (length - SELECTOR_LENGTH) % 32 == 0\n        // We're using logical AND here to speed it up a bit\n        return (length - SELECTOR_LENGTH) \u0026 31 == 0;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(CallData _callData) internal pure returns (bytes29) {\n        return CallData.unwrap(_callData);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           CALLDATA SLICING                           ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns amount of memory words (32 byte chunks) the function arguments\n     * occupy in the calldata.\n     * @dev This might differ from amount of arguments supplied, if any of the arguments\n     * occupies more than one memory slot. It is true, however, that argument part of the payload\n     * occupies exactly N words, even for dynamic types like `bytes`\n     */\n    function argumentWords(CallData _callData) internal pure returns (uint256) {\n        // Get the underlying memory view\n        bytes29 _view = unwrap(_callData);\n        // Equivalent of (length - SELECTOR_LENGTH) / 32\n        return (_view.len() - SELECTOR_LENGTH) \u003e\u003e 5;\n    }\n\n    /// @notice Returns selector for the provided calldata.\n    function callSelector(CallData _callData) internal pure returns (bytes29) {\n        // Get the underlying memory view\n        bytes29 _view = unwrap(_callData);\n        return _view.slice({ _index: OFFSET_SELECTOR, _len: SELECTOR_LENGTH, newType: 0 });\n    }\n\n    /// @notice Returns abi encoded arguments for the provided calldata.\n    function arguments(CallData _callData) internal pure returns (bytes29) {\n        // Get the underlying memory view\n        bytes29 _view = unwrap(_callData);\n        return _view.sliceFrom({ _index: OFFSET_ARGUMENTS, newType: 0 });\n    }\n}\n\nlibrary TypeCasts {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    function coerceBytes32(string memory _s) internal pure returns (bytes32 _b) {\n        _b = bytes(_s).ref(0).index(0, uint8(bytes(_s).length));\n    }\n\n    // treat it as a null-terminated string of max 32 bytes\n    function coerceString(bytes32 _buf) internal pure returns (string memory _newStr) {\n        uint8 _slen = 0;\n        while (_slen \u003c 32 \u0026\u0026 _buf[_slen] != 0) {\n            _slen++;\n        }\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            _newStr := mload(0x40)\n            mstore(0x40, add(_newStr, 0x40)) // may end up with extra\n            mstore(_newStr, _slen)\n            mstore(add(_newStr, 0x20), _buf)\n        }\n    }\n\n    // alignment preserving cast\n    function addressToBytes32(address _addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(_addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 _buf) internal pure returns (address) {\n        return address(uint160(uint256(_buf)));\n    }\n}\n\n/// @dev Header is a memory over over a formatted message header payload.\ntype Header is bytes29;\n/// @dev Attach library functions to Header\nusing {\n    HeaderLib.unwrap,\n    HeaderLib.version,\n    HeaderLib.origin,\n    HeaderLib.sender,\n    HeaderLib.nonce,\n    HeaderLib.destination,\n    HeaderLib.recipient,\n    HeaderLib.optimisticSeconds,\n    HeaderLib.recipientAddress\n} for Header global;\n\n/**\n * @notice Library for versioned formatting [the header part]\n * of [the messages used by Origin and Destination].\n */\nlibrary HeaderLib {\n    using ByteString for bytes;\n    using TypedMemView for bytes29;\n\n    uint16 internal constant HEADER_VERSION = 1;\n\n    /**\n     * @dev Header memory layout\n     * [000 .. 002): version            uint16   2 bytes\n     * [002 .. 006): origin             uint32   4 bytes\n     * [006 .. 038): sender             bytes32 32 bytes\n     * [038 .. 042): nonce              uint32   4 bytes\n     * [042 .. 046): destination        uint32   4 bytes\n     * [046 .. 078): recipient          bytes32 32 bytes\n     * [078 .. 082): optimisticSeconds  uint32   4 bytes\n     */\n\n    uint256 internal constant OFFSET_VERSION = 0;\n    uint256 internal constant OFFSET_ORIGIN = 2;\n    uint256 internal constant OFFSET_SENDER = 6;\n    uint256 internal constant OFFSET_NONCE = 38;\n    uint256 internal constant OFFSET_DESTINATION = 42;\n    uint256 internal constant OFFSET_RECIPIENT = 46;\n    uint256 internal constant OFFSET_OPTIMISTIC_SECONDS = 78;\n\n    uint256 internal constant HEADER_LENGTH = 82;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns a formatted Header payload with provided fields\n     * @param _origin               Domain of origin chain\n     * @param _sender               Address that sent the message\n     * @param _nonce                Message nonce on origin chain\n     * @param _destination          Domain of destination chain\n     * @param _recipient            Address that will receive the message\n     * @param _optimisticSeconds    Optimistic period for message execution\n     * @return Formatted header\n     **/\n    function formatHeader(\n        uint32 _origin,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destination,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodePacked(\n                HEADER_VERSION,\n                _origin,\n                _sender,\n                _nonce,\n                _destination,\n                _recipient,\n                _optimisticSeconds\n            );\n    }\n\n    /**\n     * @notice Returns a Header view over for the given payload.\n     * @dev Will revert if the payload is not a header payload.\n     */\n    function castToHeader(bytes memory _payload) internal pure returns (Header) {\n        return castToHeader(_payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a Header view.\n     * @dev Will revert if the memory view is not over a header payload.\n     */\n    function castToHeader(bytes29 _view) internal pure returns (Header) {\n        require(isHeader(_view), \"Not a header payload\");\n        return Header.wrap(_view);\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Header.\n     */\n    function isHeader(bytes29 _view) internal pure returns (bool) {\n        uint256 length = _view.len();\n        // Check if version exists in the payload\n        if (length \u003c 2) return false;\n        // Check that header version and its length matches\n        return _getVersion(_view) == HEADER_VERSION \u0026\u0026 length == HEADER_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Header _header) internal pure returns (bytes29) {\n        return Header.unwrap(_header);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                            HEADER SLICING                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /// @notice Returns header's version field.\n    function version(Header _header) internal pure returns (uint16) {\n        // Get the underlying memory view\n        bytes29 _view = unwrap(_header);\n        return _getVersion(_view);\n    }\n\n    /// @notice Returns header's origin field\n    function origin(Header _header) internal pure returns (uint32) {\n        bytes29 _view = unwrap(_header);\n        return uint32(_view.indexUint(OFFSET_ORIGIN, 4));\n    }\n\n    /// @notice Returns header's sender field\n    function sender(Header _header) internal pure returns (bytes32) {\n        bytes29 _view = unwrap(_header);\n        return _view.index(OFFSET_SENDER, 32);\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(Header _header) internal pure returns (uint32) {\n        bytes29 _view = unwrap(_header);\n        return uint32(_view.indexUint(OFFSET_NONCE, 4));\n    }\n\n    /// @notice Returns header's destination field\n    function destination(Header _header) internal pure returns (uint32) {\n        bytes29 _view = unwrap(_header);\n        return uint32(_view.indexUint(OFFSET_DESTINATION, 4));\n    }\n\n    /// @notice Returns header's recipient field as bytes32\n    function recipient(Header _header) internal pure returns (bytes32) {\n        bytes29 _view = unwrap(_header);\n        return _view.index(OFFSET_RECIPIENT, 32);\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticSeconds(Header _header) internal pure returns (uint32) {\n        bytes29 _view = unwrap(_header);\n        return uint32(_view.indexUint(OFFSET_OPTIMISTIC_SECONDS, 4));\n    }\n\n    /// @notice Returns header's recipient field as an address\n    function recipientAddress(Header _header) internal pure returns (address) {\n        return TypeCasts.bytes32ToAddress(recipient(_header));\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           PRIVATE HELPERS                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /// @notice Returns a version field without checking if payload is properly formatted.\n    function _getVersion(bytes29 _view) internal pure returns (uint16) {\n        return uint16(_view.indexUint(OFFSET_VERSION, 2));\n    }\n}\n\n/// @dev Tips is a memory over over a formatted message tips payload.\ntype Tips is bytes29;\n/// @dev Attach library functions to Tips\nusing {\n    TipsLib.unwrap,\n    TipsLib.version,\n    TipsLib.notaryTip,\n    TipsLib.broadcasterTip,\n    TipsLib.proverTip,\n    TipsLib.executorTip,\n    TipsLib.totalTips\n} for Tips global;\n\n/**\n * @notice Library for versioned formatting [the tips part]\n * of [the messages used by Origin and Destination].\n */\nlibrary TipsLib {\n    using ByteString for bytes;\n    using TypedMemView for bytes29;\n\n    uint16 internal constant TIPS_VERSION = 1;\n\n    // TODO: determine if we need to pack the tips values,\n    // or if using uint256 instead will suffice.\n\n    /**\n     * @dev Tips memory layout\n     * [000 .. 002): version            uint16\t 2 bytes\n     * [002 .. 014): notaryTip          uint96\t12 bytes\n     * [014 .. 026): broadcasterTip     uint96\t12 bytes\n     * [026 .. 038): proverTip          uint96\t12 bytes\n     * [038 .. 050): executorTip        uint96\t12 bytes\n     */\n\n    uint256 internal constant OFFSET_VERSION = 0;\n    uint256 internal constant OFFSET_NOTARY = 2;\n    uint256 internal constant OFFSET_BROADCASTER = 14;\n    uint256 internal constant OFFSET_PROVER = 26;\n    uint256 internal constant OFFSET_EXECUTOR = 38;\n\n    uint256 internal constant TIPS_LENGTH = 50;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                                 TIPS                                 ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns a formatted Tips payload with provided fields\n     * @param _notaryTip        Tip for the Notary\n     * @param _broadcasterTip   Tip for the Broadcaster\n     * @param _proverTip        Tip for the Prover\n     * @param _executorTip      Tip for the Executor\n     * @return Formatted tips\n     **/\n    function formatTips(\n        uint96 _notaryTip,\n        uint96 _broadcasterTip,\n        uint96 _proverTip,\n        uint96 _executorTip\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodePacked(TIPS_VERSION, _notaryTip, _broadcasterTip, _proverTip, _executorTip);\n    }\n\n    /**\n     * @notice Returns a formatted Tips payload specifying empty tips.\n     * @return Formatted tips\n     **/\n    function emptyTips() internal pure returns (bytes memory) {\n        return formatTips(0, 0, 0, 0);\n    }\n\n    /**\n     * @notice Returns a Tips view over for the given payload.\n     * @dev Will revert if the payload is not a tips payload.\n     */\n    function castToTips(bytes memory _payload) internal pure returns (Tips) {\n        return castToTips(_payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a Tips view.\n     * @dev Will revert if the memory view is not over a tips payload.\n     */\n    function castToTips(bytes29 _view) internal pure returns (Tips) {\n        require(isTips(_view), \"Not a tips payload\");\n        return Tips.wrap(_view);\n    }\n\n    /// @notice Checks that a payload is a formatted Tips payload.\n    function isTips(bytes29 _view) internal pure returns (bool) {\n        uint256 length = _view.len();\n        // Check if version exists in the payload\n        if (length \u003c OFFSET_NOTARY) return false;\n        // Check that tips version and its length matches\n        return _getVersion(_view) == TIPS_VERSION \u0026\u0026 length == TIPS_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Tips _tips) internal pure returns (bytes29) {\n        return Tips.unwrap(_tips);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                             TIPS SLICING                             ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /// @notice Returns version of formatted tips\n    function version(Tips _tips) internal pure returns (uint16) {\n        // Get the underlying memory view\n        bytes29 _view = _tips.unwrap();\n        return _getVersion(_view);\n    }\n\n    /// @notice Returns notaryTip field\n    function notaryTip(Tips _tips) internal pure returns (uint96) {\n        bytes29 _view = _tips.unwrap();\n        return uint96(_view.indexUint(OFFSET_NOTARY, 12));\n    }\n\n    /// @notice Returns broadcasterTip field\n    function broadcasterTip(Tips _tips) internal pure returns (uint96) {\n        bytes29 _view = _tips.unwrap();\n        return uint96(_view.indexUint(OFFSET_BROADCASTER, 12));\n    }\n\n    /// @notice Returns proverTip field\n    function proverTip(Tips _tips) internal pure returns (uint96) {\n        bytes29 _view = _tips.unwrap();\n        return uint96(_view.indexUint(OFFSET_PROVER, 12));\n    }\n\n    /// @notice Returns executorTip field\n    function executorTip(Tips _tips) internal pure returns (uint96) {\n        bytes29 _view = _tips.unwrap();\n        return uint96(_view.indexUint(OFFSET_EXECUTOR, 12));\n    }\n\n    /// @notice Returns total tip amount.\n    function totalTips(Tips _tips) internal pure returns (uint96) {\n        // In practice there's no chance that the total tips value would not fit into uint96.\n        // TODO: determine if we want to use uint256 here instead anyway.\n        return notaryTip(_tips) + broadcasterTip(_tips) + proverTip(_tips) + executorTip(_tips);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           PRIVATE HELPERS                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /// @notice Returns a version field without checking if payload is properly formatted.\n    function _getVersion(bytes29 _view) private pure returns (uint16) {\n        return uint16(_view.indexUint(OFFSET_VERSION, 2));\n    }\n}\n\n/// @dev Message is a memory over over a formatted message payload.\ntype Message is bytes29;\n/// @dev Attach library functions to Message\nusing {\n    MessageLib.unwrap,\n    MessageLib.version,\n    MessageLib.header,\n    MessageLib.tips,\n    MessageLib.body,\n    MessageLib.leaf\n} for Message global;\n\n/**\n * @notice  Library for versioned formatting the messages used by Origin and Destination.\n */\nlibrary MessageLib {\n    using HeaderLib for bytes29;\n    using TipsLib for bytes29;\n    using ByteString for bytes;\n    using TypedMemView for bytes29;\n\n    enum Parts {\n        Version,\n        Header,\n        Tips,\n        Body\n    }\n\n    /**\n     * @dev This is only updated if the whole message structure is changed,\n     *      i.e. if a new part is added.\n     *      If already existing part is changed, the message version does not get bumped.\n     */\n    uint16 internal constant MESSAGE_VERSION = 1;\n\n    /**\n     * @dev Message memory layout\n     * [000 .. 002): version            uint16  2 bytes\n     * [002 .. 004): header length      uint16  2 bytes (length == AAA - 6)\n     * [004 .. 006): tips length        uint16  2 bytes (length == BBB - AAA)\n     * [006 .. AAA): header             bytes   ? bytes\n     * [AAA .. BBB): tips               bytes   ? bytes\n     * [BBB .. CCC): body               bytes   ? bytes (length could be zero)\n     */\n\n    uint256 internal constant OFFSET_VERSION = 0;\n\n    /// @dev How much bytes is used for storing the version, or a single offset value\n    uint8 internal constant TWO_BYTES = 2;\n    /// @dev This value reflects the header offset in the latest message version\n    uint16 internal constant OFFSET_HEADER = TWO_BYTES * uint8(type(Parts).max);\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns formatted message with provided fields\n     * @param _header       Formatted header payload\n     * @param _tips         Formatted tips payload\n     * @param _messageBody  Raw bytes of message body\n     * @return Formatted message\n     **/\n    function formatMessage(\n        bytes memory _header,\n        bytes memory _tips,\n        bytes memory _messageBody\n    ) internal pure returns (bytes memory) {\n        // Header and Tips are supposed to fit within 65535 bytes\n        return\n            abi.encodePacked(\n                MESSAGE_VERSION,\n                uint16(_header.length),\n                uint16(_tips.length),\n                _header,\n                _tips,\n                _messageBody\n            );\n    }\n\n    /**\n     * @notice Returns formatted message with provided fields\n     * @param _origin               Domain of origin chain\n     * @param _sender               Address that sent the message\n     * @param _nonce                Message nonce on origin chain\n     * @param _destination          Domain of destination chain\n     * @param _recipient            Address that will receive the message\n     * @param _optimisticSeconds    Optimistic period for message execution\n     * @param _tips                 Formatted tips payload\n     * @param _messageBody          Raw bytes of message body\n     * @return Formatted message\n     **/\n    function formatMessage(\n        uint32 _origin,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destination,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds,\n        bytes memory _tips,\n        bytes memory _messageBody\n    ) internal pure returns (bytes memory) {\n        return\n            formatMessage(\n                HeaderLib.formatHeader(\n                    _origin,\n                    _sender,\n                    _nonce,\n                    _destination,\n                    _recipient,\n                    _optimisticSeconds\n                ),\n                _tips,\n                _messageBody\n            );\n    }\n\n    /**\n     * @notice Returns a Message view over for the given payload.\n     * @dev Will revert if the payload is not a message payload.\n     */\n    function castToMessage(bytes memory _payload) internal pure returns (Message) {\n        return castToMessage(_payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a Message view.\n     * @dev Will revert if the memory view is not over a message payload.\n     */\n    function castToMessage(bytes29 _view) internal pure returns (Message) {\n        require(isMessage(_view), \"Not a message payload\");\n        return Message.wrap(_view);\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Message.\n     */\n    function isMessage(bytes29 _view) internal pure returns (bool) {\n        uint256 length = _view.len();\n        // Check if version and lengths exist in the payload\n        if (length \u003c OFFSET_HEADER) return false;\n        // Check message version\n        if (_getVersion(_view) != MESSAGE_VERSION) return false;\n\n        uint256 headerLength = _getLen(_view, Parts.Header);\n        uint256 tipsLength = _getLen(_view, Parts.Tips);\n        // Header and Tips need to exist\n        // Body could be empty, thus \u003e\n        if (OFFSET_HEADER + headerLength + tipsLength \u003e length) return false;\n\n        // Check header for being a formatted header payload\n        // Check tips for being a formatted tips payload\n        if (!_getHeader(_view).isHeader() || !_getTips(_view).isTips()) return false;\n        return true;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Message _msg) internal pure returns (bytes29) {\n        return Message.unwrap(_msg);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           MESSAGE SLICING                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /// @notice Returns message's version field.\n    function version(Message _msg) internal pure returns (uint16) {\n        // Get the underlying memory view\n        bytes29 _view = _msg.unwrap();\n        return _getVersion(_view);\n    }\n\n    /// @notice Returns message's header field as a Header view.\n    function header(Message _msg) internal pure returns (Header) {\n        bytes29 _view = _msg.unwrap();\n        return _getHeader(_view).castToHeader();\n    }\n\n    /// @notice Returns message's tips field as a Tips view.\n    function tips(Message _msg) internal pure returns (Tips) {\n        bytes29 _view = _msg.unwrap();\n        return _getTips(_view).castToTips();\n    }\n\n    /// @notice Returns message's body field as a generic memory view.\n    function body(Message _msg) internal pure returns (bytes29) {\n        bytes29 _view = _msg.unwrap();\n        // Determine index where message body payload starts\n        uint256 index = OFFSET_HEADER + _getLen(_view, Parts.Header) + _getLen(_view, Parts.Tips);\n        return _view.sliceFrom({ _index: index, newType: 0 });\n    }\n\n    /// @notice Returns message's hash: a leaf to be inserted in the Merkle tree.\n    function leaf(Message _msg) internal pure returns (bytes32) {\n        bytes29 _view = _msg.unwrap();\n        return _view.keccak();\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           PRIVATE HELPERS                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /// @dev Returns length for a given part of the message\n    /// without checking if the payload is properly formatted.\n    function _getLen(bytes29 _view, Parts _part) private pure returns (uint256) {\n        return _view.indexUint(uint256(_part) * TWO_BYTES, TWO_BYTES);\n    }\n\n    /// @dev Returns a version field without checking if the payload is properly formatted.\n    function _getVersion(bytes29 _view) private pure returns (uint16) {\n        return uint16(_view.indexUint(OFFSET_VERSION, 2));\n    }\n\n    /// @dev Returns a generic memory view over the header field without checking\n    /// if the whole payload or the header are properly formatted.\n    function _getHeader(bytes29 _view) private pure returns (bytes29) {\n        uint256 length = _getLen(_view, Parts.Header);\n        return _view.slice({ _index: OFFSET_HEADER, _len: length, newType: 0 });\n    }\n\n    /// @dev Returns a generic memory view over the tips field without checking\n    /// if the whole payload or the tips are properly formatted.\n    function _getTips(bytes29 _view) private pure returns (bytes29) {\n        // Determine index where tips payload starts\n        uint256 indexFrom = OFFSET_HEADER + _getLen(_view, Parts.Header);\n        uint256 length = _getLen(_view, Parts.Tips);\n        return _view.slice({ _index: indexFrom, _len: length, newType: 0 });\n    }\n}\n\n/**\n * @notice Exposes Message methods for testing against golang.\n */\ncontract MessageHarness {\n    using MessageLib for bytes;\n    using MessageLib for bytes29;\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                               GETTERS                                ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    function castToMessage(bytes memory _payload) public view returns (bytes memory) {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        Message _msg = MessageLib.castToMessage(_payload);\n        return _msg.unwrap().clone();\n    }\n\n    function header(bytes memory _payload) public view returns (bytes memory) {\n        return _payload.castToMessage().header().unwrap().clone();\n    }\n\n    function tips(bytes memory _payload) public view returns (bytes memory) {\n        return _payload.castToMessage().tips().unwrap().clone();\n    }\n\n    function body(bytes memory _payload) public view returns (bytes memory) {\n        return _payload.castToMessage().body().clone();\n    }\n\n    function version(bytes memory _payload) public pure returns (uint16) {\n        return _payload.castToMessage().version();\n    }\n\n    function leaf(bytes memory _payload) public pure returns (bytes32) {\n        return _payload.castToMessage().leaf();\n    }\n\n    function isMessage(bytes memory _payload) public pure returns (bool) {\n        return _payload.ref(0).isMessage();\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    function formatMessage(\n        uint32 _origin,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destination,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds,\n        // tips params\n        uint96 _notaryTip,\n        uint96 _broadcasterTip,\n        uint96 _proverTip,\n        uint96 _executorTip,\n        bytes memory _messageBody\n    ) public pure returns (bytes memory) {\n        bytes memory _tips = TipsLib.formatTips(\n            _notaryTip,\n            _broadcasterTip,\n            _proverTip,\n            _executorTip\n        );\n\n        bytes memory _header = HeaderLib.formatHeader(\n            _origin,\n            _sender,\n            _nonce,\n            _destination,\n            _recipient,\n            _optimisticSeconds\n        );\n        return formatMessage(_header, _tips, _messageBody);\n    }\n\n    function formatMessage(\n        uint32 _origin,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destination,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds,\n        bytes memory _tips,\n        bytes memory _messageBody\n    ) public pure returns (bytes memory) {\n        return\n            MessageLib.formatMessage(\n                _origin,\n                _sender,\n                _nonce,\n                _destination,\n                _recipient,\n                _optimisticSeconds,\n                _tips,\n                _messageBody\n            );\n    }\n\n    function formatMessage(\n        bytes memory _header,\n        bytes memory _tips,\n        bytes memory _messageBody\n    ) public pure returns (bytes memory) {\n        return MessageLib.formatMessage(_header, _tips, _messageBody);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           CONSTANT GETTERS                           ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    function messageVersion() public pure returns (uint16) {\n        return MessageLib.MESSAGE_VERSION;\n    }\n\n    function offsetVersion() public pure returns (uint256) {\n        return MessageLib.OFFSET_VERSION;\n    }\n\n    function offsetHeader() public pure returns (uint256) {\n        return MessageLib.OFFSET_HEADER;\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"59990:9348:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;59990:9348:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"59990:9348:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"notice":"Library for versioned formatting the messages used by Origin and Destination.","version":1},"developerDoc":{"kind":"dev","methods":{},"stateVariables":{"MESSAGE_VERSION":{"details":"This is only updated if the whole message structure is changed,      i.e. if a new part is added.      If already existing part is changed, the message version does not get bumped."},"OFFSET_HEADER":{"details":"This value reflects the header offset in the latest message version"},"OFFSET_VERSION":{"details":"Message memory layout [000 .. 002): version            uint16  2 bytes [002 .. 004): header length      uint16  2 bytes (length == AAA - 6) [004 .. 006): tips length        uint16  2 bytes (length == BBB - AAA) [006 .. AAA): header             bytes   ? bytes [AAA .. BBB): tips               bytes   ? bytes [BBB .. CCC): body               bytes   ? bytes (length could be zero)"},"TWO_BYTES":{"details":"How much bytes is used for storing the version, or a single offset value"}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"stateVariables\":{\"MESSAGE_VERSION\":{\"details\":\"This is only updated if the whole message structure is changed,      i.e. if a new part is added.      If already existing part is changed, the message version does not get bumped.\"},\"OFFSET_HEADER\":{\"details\":\"This value reflects the header offset in the latest message version\"},\"OFFSET_VERSION\":{\"details\":\"Message memory layout [000 .. 002): version            uint16  2 bytes [002 .. 004): header length      uint16  2 bytes (length == AAA - 6) [004 .. 006): tips length        uint16  2 bytes (length == BBB - AAA) [006 .. AAA): header             bytes   ? bytes [AAA .. BBB): tips               bytes   ? bytes [BBB .. CCC): body               bytes   ? bytes (length could be zero)\"},\"TWO_BYTES\":{\"details\":\"How much bytes is used for storing the version, or a single offset value\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"Library for versioned formatting the messages used by Origin and Destination.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/MessageHarness.t.sol\":\"MessageLib\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/MessageHarness.t.sol\":{\"keccak256\":\"0x3904cba9f384c6433257789b24cdb15655a5775a36df2c4c297958af081b2acc\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://eff1071fd96ffa0ae24c5a5d8de738a1545769b12ccc3c5ec469a9d7e16b21db\",\"dweb:/ipfs/QmYyQsoEqF9QJ5aHaVw5545ePNt9Z7GqXfVyCFGrEh4y84\"]}},\"version\":1}"},"hashes":{}},"solidity/MessageHarness.t.sol:TipsLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220742770cdf17070c06571a252072f21fa5ca686208a4551dfa80a34188928ba7864736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220742770cdf17070c06571a252072f21fa5ca686208a4551dfa80a34188928ba7864736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nlibrary TypedMemView {\n    // Why does this exist?\n    // the solidity `bytes memory` type has a few weaknesses.\n    // 1. You can't index ranges effectively\n    // 2. You can't slice without copying\n    // 3. The underlying data may represent any type\n    // 4. Solidity never deallocates memory, and memory costs grow\n    //    superlinearly\n\n    // By using a memory view instead of a `bytes memory` we get the following\n    // advantages:\n    // 1. Slices are done on the stack, by manipulating the pointer\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\n    // 3. We can insert type info into the pointer, and typecheck at runtime\n\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\n    // algorithms.\n\n    // Why bytes29?\n    // We want to avoid confusion between views, digests, and other common\n    // types so we chose a large and uncommonly used odd number of bytes\n    //\n    // Note that while bytes are left-aligned in a word, integers and addresses\n    // are right-aligned. This means when working in assembly we have to\n    // account for the 3 unused bytes on the righthand side\n    //\n    // First 5 bytes are a type flag.\n    // - ff_ffff_fffe is reserved for unknown type.\n    // - ff_ffff_ffff is reserved for invalid types/errors.\n    // next 12 are memory address\n    // next 12 are len\n    // bottom 3 bytes are empty\n\n    // Assumptions:\n    // - non-modification of memory.\n    // - No Solidity updates\n    // - - wrt free mem point\n    // - - wrt bytes representation in memory\n    // - - wrt memory addressing in general\n\n    // Usage:\n    // - create type constants\n    // - use `assertType` for runtime type assertions\n    // - - unfortunately we can't do this at compile time yet :(\n    // - recommended: implement modifiers that perform type checking\n    // - - e.g.\n    // - - `uint40 constant MY_TYPE = 3;`\n    // - - ` modifier onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n    // - instantiate a typed view from a bytearray using `ref`\n    // - use `index` to inspect the contents of the view\n    // - use `slice` to create smaller views into the same memory\n    // - - `slice` can increase the offset\n    // - - `slice can decrease the length`\n    // - - must specify the output type of `slice`\n    // - - `slice` will return a null view if you try to overrun\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\n    // - use `equal` for typed comparisons.\n\n    // The null view\n    bytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n\n    /**\n     * @dev Memory layout for bytes29\n     * TODO (Chi): with the user defined types storing type is no longer necessary.\n     * Update the library, transforming bytes29 to bytes24 in the process.\n     * [000..005)   type     5 bytes    Type flag for the pointer\n     * [005..017)   loc     12 bytes    Memory address of underlying bytes\n     * [017..029)   len     12 bytes    Length of underlying bytes\n     * [029..032)   empty    3 bytes    Not used\n     */\n    uint256 public constant BITS_TYPE = 40;\n    uint256 public constant BITS_LOC = 96;\n    uint256 public constant BITS_LEN = 96;\n    uint256 public constant BITS_EMPTY = 24;\n\n    // `SHIFT_X` is how much bits to shift for `X` to be in the very bottom bits\n    uint256 public constant SHIFT_LEN = BITS_EMPTY; // 24\n    uint256 public constant SHIFT_LOC = SHIFT_LEN + BITS_LEN; // 24 + 96 = 120\n    uint256 public constant SHIFT_TYPE = SHIFT_LOC + BITS_LOC; // 24 + 96 + 96 = 216\n    // Bitmask for the lowest 96 bits\n    uint256 public constant LOW_96_BITS_MASK = type(uint96).max;\n\n    // For nibble encoding\n    bytes private constant NIBBLE_LOOKUP = \"0123456789abcdef\";\n\n    /**\n     * @notice Returns the encoded hex character that represents the lower 4 bits of the argument.\n     * @param _byte     The byte\n     * @return _char    The encoded hex character\n     */\n    function nibbleHex(uint8 _byte) internal pure returns (uint8 _char) {\n        uint8 _nibble = _byte \u0026 0x0f; // keep bottom 4 bits, zero out top 4 bits\n        _char = uint8(NIBBLE_LOOKUP[_nibble]);\n    }\n\n    /**\n     * @notice      Returns a uint16 containing the hex-encoded byte.\n     * @param _b    The byte\n     * @return      encoded - The hex-encoded byte\n     */\n    function byteHex(uint8 _b) internal pure returns (uint16 encoded) {\n        encoded |= nibbleHex(_b \u003e\u003e 4); // top 4 bits\n        encoded \u003c\u003c= 8;\n        encoded |= nibbleHex(_b); // lower 4 bits\n    }\n\n    /**\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\n     *              `second` contains the encoded lower 16 bytes.\n     *\n     * @param _b    The 32 bytes as uint256\n     * @return      first - The top 16 bytes\n     * @return      second - The bottom 16 bytes\n     */\n    function encodeHex(uint256 _b) internal pure returns (uint256 first, uint256 second) {\n        for (uint8 i = 31; i \u003e 15; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            first |= byteHex(_byte);\n            if (i != 16) {\n                first \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n\n        // abusing underflow here =_=\n        for (uint8 i = 15; i \u003c 255; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            second |= byteHex(_byte);\n            if (i != 0) {\n                second \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n    }\n\n    /**\n     * @notice          Changes the endianness of a uint256.\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n     * @param _b        The unsigned integer to reverse\n     * @return          v - The reversed value\n     */\n    function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\n        v = _b;\n\n        // swap bytes\n        v =\n            ((v \u003e\u003e 8) \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\n            ((v \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) \u003c\u003c 8);\n        // swap 2-byte long pairs\n        v =\n            ((v \u003e\u003e 16) \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\n            ((v \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) \u003c\u003c 16);\n        // swap 4-byte long pairs\n        v =\n            ((v \u003e\u003e 32) \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\n            ((v \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) \u003c\u003c 32);\n        // swap 8-byte long pairs\n        v =\n            ((v \u003e\u003e 64) \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\n            ((v \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) \u003c\u003c 64);\n        // swap 16-byte long pairs\n        v = (v \u003e\u003e 128) | (v \u003c\u003c 128);\n    }\n\n    /**\n     * @notice      Create a mask with the highest `_len` bits set.\n     * @param _len  The length\n     * @return      mask - The mask\n     */\n    function leftMask(uint8 _len) private pure returns (uint256 mask) {\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(\n                sub(_len, 1),\n                0x8000000000000000000000000000000000000000000000000000000000000000\n            )\n        }\n    }\n\n    /**\n     * @notice      Return the null view.\n     * @return      bytes29 - The null view\n     */\n    // solhint-disable-next-line ordering\n    function nullView() internal pure returns (bytes29) {\n        return NULL;\n    }\n\n    /**\n     * @notice      Check if the view is null.\n     * @return      bool - True if the view is null\n     */\n    function isNull(bytes29 memView) internal pure returns (bool) {\n        return memView == NULL;\n    }\n\n    /**\n     * @notice      Check if the view is not null.\n     * @return      bool - True if the view is not null\n     */\n    function notNull(bytes29 memView) internal pure returns (bool) {\n        return !isNull(memView);\n    }\n\n    /**\n     * @notice          Check if the view is of a valid type and points to a valid location\n     *                  in memory.\n     * @dev             We perform this check by examining solidity's unallocated memory\n     *                  pointer and ensuring that the view's upper bound is less than that.\n     * @param memView   The view\n     * @return          ret - True if the view is valid\n     */\n    function isValid(bytes29 memView) internal pure returns (bool ret) {\n        if (typeOf(memView) == 0xffffffffff) {\n            return false;\n        }\n        uint256 _end = end(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // View is valid if (\"upper bound\" \u003c= \"unallocated memory pointer\")\n            // Upper bound is exclusive, hence \"\u003c=\"\n            ret := not(gt(_end, mload(0x40)))\n        }\n    }\n\n    /**\n     * @notice          Require that a typed memory view be valid.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @return          bytes29 - The validated view\n     */\n    function assertValid(bytes29 memView) internal pure returns (bytes29) {\n        require(isValid(memView), \"Validity assertion failed\");\n        return memView;\n    }\n\n    /**\n     * @notice          Return true if the memview is of the expected type. Otherwise false.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bool - True if the memview is of the expected type\n     */\n    function isType(bytes29 memView, uint40 _expected) internal pure returns (bool) {\n        return typeOf(memView) == _expected;\n    }\n\n    /**\n     * @notice          Require that a typed memory view has a specific type.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bytes29 - The view with validated type\n     */\n    function assertType(bytes29 memView, uint40 _expected) internal pure returns (bytes29) {\n        if (!isType(memView, _expected)) {\n            (, uint256 g) = encodeHex(uint256(typeOf(memView)));\n            (, uint256 e) = encodeHex(uint256(_expected));\n            string memory err = string(\n                abi.encodePacked(\n                    \"Type assertion failed. Got 0x\",\n                    uint80(g),\n                    \". Expected 0x\",\n                    uint80(e)\n                )\n            );\n            revert(err);\n        }\n        return memView;\n    }\n\n    /**\n     * @notice          Return an identical view with a different type.\n     * @param memView   The view\n     * @param _newType  The new type\n     * @return          newView - The new view with the specified type\n     */\n    function castTo(bytes29 memView, uint40 _newType) internal pure returns (bytes29 newView) {\n        // How many bits are the \"type bits\" occupying\n        uint256 _bitsType = BITS_TYPE;\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 _shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // shift off the \"type bits\" (shift left, then sift right)\n            newView := or(newView, shr(_bitsType, shl(_bitsType, memView)))\n            // set the new \"type bits\" (shift left, then OR)\n            newView := or(newView, shl(_shiftType, _newType))\n        }\n    }\n\n    /**\n     * @notice          Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function unsafeBuildUnchecked(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) private pure returns (bytes29 newView) {\n        uint256 _bitsLoc = BITS_LOC;\n        uint256 _bitsLen = BITS_LEN;\n        uint256 _bitsEmpty = BITS_EMPTY;\n        // Ref memory layout\n        // [000..005) 5 bytes of type\n        // [005..017) 12 bytes of location\n        // [017..029) 12 bytes of length\n        // last 3 bits are blank and dropped in typecast\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // insert `type`, shift to prepare empty bits for `loc`\n            newView := shl(_bitsLoc, or(newView, _type))\n            // insert `loc`, shift to prepare empty bits for `len`\n            newView := shl(_bitsLen, or(newView, _loc))\n            // insert `len`, shift to insert 3 blank lowest bits\n            newView := shl(_bitsEmpty, or(newView, _len))\n        }\n    }\n\n    /**\n     * @notice          Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function build(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) internal pure returns (bytes29 newView) {\n        uint256 _end = _loc + _len;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(_end, mload(0x40)) {\n                _end := 0\n            }\n        }\n        if (_end == 0) {\n            return NULL;\n        }\n        newView = unsafeBuildUnchecked(_type, _loc, _len);\n    }\n\n    /**\n     * @notice          Instantiate a memory view from a byte array.\n     * @dev             Note that due to Solidity memory representation, it is not possible to\n     *                  implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr       The byte array\n     * @param newType   The type\n     * @return          bytes29 - The memory view\n     */\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\n        uint256 _len = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 _loc;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            _loc := add(arr, 0x20)\n        }\n\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Return the associated type information.\n     * @param memView   The memory view\n     * @return          _type - The type associated with the view\n     */\n    function typeOf(bytes29 memView) internal pure returns (uint40 _type) {\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 _shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"type bits\". \"type bits\" are occupying\n            // the highest bits, so all that's left is \"type bits\", OR is not required.\n            _type := shr(_shiftType, memView)\n        }\n    }\n\n    /**\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the 5-byte type flag is equal\n     */\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\n        // Check that the highest 5 bytes are equal: xor and shift out lower 27 bytes\n        return (left ^ right) \u003e\u003e SHIFT_TYPE == 0;\n    }\n\n    /**\n     * @notice          Return the memory address of the underlying bytes.\n     * @param memView   The view\n     * @return          _loc - The memory address\n     */\n    function loc(bytes29 memView) internal pure returns (uint96 _loc) {\n        // How many bits are the \"loc bits\" shifted from the bottom\n        uint256 _shiftLoc = SHIFT_LOC;\n        // Mask for the bottom 96 bits\n        uint256 _uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"loc bits\".\n            // Then use the lowest 96 bits to determine `loc` by applying the bit-mask.\n            _loc := and(shr(_shiftLoc, memView), _uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          The number of memory words this memory view occupies, rounded up.\n     * @param memView   The view\n     * @return          uint256 - The number of memory words\n     */\n    function words(bytes29 memView) internal pure returns (uint256) {\n        // returning ceil(length / 32.0)\n        return (uint256(len(memView)) + 31) / 32;\n    }\n\n    /**\n     * @notice          The in-memory footprint of a fresh copy of the view.\n     * @param memView   The view\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(bytes29 memView) internal pure returns (uint256) {\n        return words(memView) * 32;\n    }\n\n    /**\n     * @notice          The number of bytes of the view.\n     * @param memView   The view\n     * @return          _len - The length of the view\n     */\n    function len(bytes29 memView) internal pure returns (uint96 _len) {\n        // How many bits are the \"len bits\" shifted from the bottom\n        uint256 _shiftLen = SHIFT_LEN;\n        // Mask for the bottom 96 bits\n        uint256 _uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"len bits\".\n            // Then use the lowest 96 bits to determine `len` by applying the bit-mask.\n            _len := and(shr(_shiftLen, memView), _uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          Returns the endpoint of `memView`.\n     * @param memView   The view\n     * @return          uint256 - The endpoint of `memView`\n     */\n    function end(bytes29 memView) internal pure returns (uint256) {\n        unchecked {\n            return loc(memView) + len(memView);\n        }\n    }\n\n    /**\n     * @notice          Safe slicing without memory modification.\n     * @param memView   The view\n     * @param _index    The start index\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function slice(\n        bytes29 memView,\n        uint256 _index,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        uint256 _loc = loc(memView);\n\n        // Ensure it doesn't overrun the view\n        if (_loc + _index + _len \u003e end(memView)) {\n            return NULL;\n        }\n\n        _loc = _loc + _index;\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing\n     *                  bytes from `_index` to end(memView).\n     * @param memView   The view\n     * @param _index    The start index\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function sliceFrom(\n        bytes29 memView,\n        uint256 _index,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, _index, len(memView) - _index, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the first `_len` bytes.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function prefix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, 0, _len, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the last `_len` byte.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function postfix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, uint256(len(memView)) - _len, _len, newType);\n    }\n\n    /**\n     * @notice          Construct an error message for an indexing overrun.\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @param _index    The index\n     * @param _slice    The slice where the overrun occurred\n     * @return          err - The err\n     */\n    function indexErrOverrun(\n        uint256 _loc,\n        uint256 _len,\n        uint256 _index,\n        uint256 _slice\n    ) internal pure returns (string memory err) {\n        (, uint256 a) = encodeHex(_loc);\n        (, uint256 b) = encodeHex(_len);\n        (, uint256 c) = encodeHex(_index);\n        (, uint256 d) = encodeHex(_slice);\n        err = string(\n            abi.encodePacked(\n                \"TypedMemView/index - Overran the view. Slice is at 0x\",\n                uint48(a),\n                \" with length 0x\",\n                uint48(b),\n                \". Attempted to index at offset 0x\",\n                uint48(c),\n                \" with length 0x\",\n                uint48(d),\n                \".\"\n            )\n        );\n    }\n\n    /**\n     * @notice          Load up to 32 bytes from the view onto the stack.\n     * @dev             Returns a bytes32 with only the `_bytes` highest bytes set.\n     *                  This can be immediately cast to a smaller fixed-length byte array.\n     *                  To automatically cast to an integer, use `indexUint`.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The 32 byte result\n     */\n    function index(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (bytes32 result) {\n        if (_bytes == 0) {\n            return bytes32(0);\n        }\n        if (_index + _bytes \u003e len(memView)) {\n            revert(indexErrOverrun(loc(memView), len(memView), _index, uint256(_bytes)));\n        }\n        require(_bytes \u003c= 32, \"Index: more than 32 bytes\");\n\n        uint8 bitLength;\n        unchecked {\n            bitLength = _bytes * 8;\n        }\n        uint256 _loc = loc(memView);\n        // Get a mask with `bitLength` highest bits set\n        uint256 _mask = leftMask(bitLength);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(_loc, _index)), _mask)\n        }\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from the view at `_index`.\n     * @dev             Requires that the view have \u003e= `_bytes` bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        // `index()` returns left-aligned `_bytes`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word\n        return uint256(index(memView, _index, _bytes)) \u003e\u003e ((32 - _bytes) * 8);\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from LE bytes.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexLEUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return reverseUint256(uint256(index(memView, _index, _bytes)));\n    }\n\n    /**\n     * @notice          Parse an address from the view at `_index`.\n     *                  Requires that the view have \u003e= 20 bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @return          address - The address\n     */\n    function indexAddress(bytes29 memView, uint256 _index) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(indexUint(memView, _index, 20)));\n    }\n\n    /**\n     * @notice          Return the keccak256 hash of the underlying memory\n     * @param memView   The view\n     * @return          digest - The keccak256 hash of the underlying memory\n     */\n    function keccak(bytes29 memView) internal pure returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(_loc, _len)\n        }\n    }\n\n    /**\n     * @notice          Return the sha2 digest of the underlying memory.\n     * @dev             We explicitly deallocate memory afterwards.\n     * @param memView   The view\n     * @return          digest - The sha2 hash of the underlying memory\n     */\n    function sha2(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            digest := mload(ptr)\n        }\n        require(res, \"sha2: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n     * @param memView   The pre-image\n     * @return          digest - the Digest\n     */\n    function hash160(bytes29 memView) internal view returns (bytes20 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            // rmd160 precompile is 0x03\n            res := and(res, staticcall(gas(), 0x03, ptr, 0x20, ptr, 0x20))\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\n        }\n        require(res, \"hash160: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash256 (double sha2)\n     * @param memView   A view of the preimage\n     * @return          digest - the Digest\n     */\n    function hash256(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            res := and(res, staticcall(gas(), 0x02, ptr, 0x20, ptr, 0x20))\n            digest := mload(ptr)\n        }\n        require(res, \"hash256: out of gas\");\n    }\n\n    /**\n     * @notice          Return true if the underlying memory is equal. Else false.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the underlying memory is equal\n     */\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return\n            (loc(left) == loc(right) \u0026\u0026 len(left) == len(right)) || keccak(left) == keccak(right);\n    }\n\n    /**\n     * @notice          Return false if the underlying memory is equal. Else true.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - False if the underlying memory is equal\n     */\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !untypedEqual(left, right);\n    }\n\n    /**\n     * @notice          Compares type equality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are the same\n     */\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return left == right || (typeOf(left) == typeOf(right) \u0026\u0026 keccak(left) == keccak(right));\n    }\n\n    /**\n     * @notice          Compares type inequality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are not the same\n     */\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !equal(left, right);\n    }\n\n    /**\n     * @notice          Copy the view to a location, return an unsafe memory reference\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memView   The view\n     * @param _newLoc   The new location\n     * @return          written - the unsafe memory reference\n     */\n    function unsafeCopyTo(bytes29 memView, uint256 _newLoc) private view returns (bytes29 written) {\n        require(notNull(memView), \"copyTo: Null pointer deref\");\n        require(isValid(memView), \"copyTo: Invalid pointer deref\");\n        uint256 _len = len(memView);\n        uint256 _oldLoc = loc(memView);\n\n        uint256 ptr;\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _newLoc) {\n                revert(0x60, 0x20) // empty revert message\n            }\n\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, _oldLoc, _len, _newLoc, _len)\n        }\n        require(res, \"identity: out of gas\");\n\n        written = unsafeBuildUnchecked(typeOf(memView), _newLoc, _len);\n    }\n\n    /**\n     * @notice          Copies the referenced memory to a new loc in memory,\n     *                  returning a `bytes` pointing to the new memory.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param memView   The view\n     * @return          ret - The view pointing to the new memory\n     */\n    function clone(bytes29 memView) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n            ret := ptr\n        }\n        unchecked {\n            unsafeCopyTo(memView, ptr + 0x20);\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mstore(0x40, add(add(ptr, _len), 0x20)) // write new unused pointer\n            mstore(ptr, _len) // write len of new array (in bytes)\n        }\n    }\n\n    /**\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memViews  The views\n     * @return          unsafeView - The conjoined view pointing to the new memory\n     */\n    function unsafeJoin(bytes29[] memory memViews, uint256 _location)\n        private\n        view\n        returns (bytes29 unsafeView)\n    {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _location) {\n                revert(0x60, 0x20) // empty revert message\n            }\n        }\n\n        uint256 _offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length; i++) {\n            bytes29 memView = memViews[i];\n            unchecked {\n                unsafeCopyTo(memView, _location + _offset);\n                _offset += len(memView);\n            }\n        }\n        unsafeView = unsafeBuildUnchecked(0, _location, _offset);\n    }\n\n    /**\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The keccak256 digest\n     */\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return keccak(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The sha256 digest\n     */\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return sha2(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          copies all views, joins them into a new bytearray.\n     * @param memViews  The views\n     * @return          ret - The new byte array\n     */\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n\n        bytes29 _newView;\n        unchecked {\n            _newView = unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 _written = len(_newView);\n        uint256 _footprint = footprint(_newView);\n\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // store the length\n            mstore(ptr, _written)\n            // new pointer is old + 0x20 + the footprint of the body\n            mstore(0x40, add(add(ptr, _footprint), 0x20))\n            ret := ptr\n        }\n    }\n}\n\n/// @dev CallData is a memory view over the payload to be used for an external call, i.e.\n/// recipient.call(callData). Its length is always (4 + 32 * N) bytes:\n/// - First 4 bytes represent the function selector.\n/// - 32 * N bytes represent N words that function arguments occupy.\ntype CallData is bytes29;\n/// @dev Signature is a memory view over a \"65 bytes\" array representing a ECDSA signature.\ntype Signature is bytes29;\n\nlibrary ByteString {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev non-compact ECDSA signatures are enforced as of OZ 4.7.3\n     *\n     *      Signature payload memory layout\n     * [000 .. 032) r   bytes32 32 bytes\n     * [032 .. 064) s   bytes32 32 bytes\n     * [064 .. 065) v   uint8    1 byte\n     */\n    uint256 internal constant SIGNATURE_LENGTH = 65;\n    uint256 internal constant OFFSET_R = 0;\n    uint256 internal constant OFFSET_S = 32;\n    uint256 internal constant OFFSET_V = 64;\n\n    /**\n     * @dev Calldata memory layout\n     * [000 .. 004) selector    bytes4  4 bytes\n     *      Optional: N function arguments\n     * [004 .. 036) arg1        bytes32 32 bytes\n     *      ..\n     * [AAA .. END) argN        bytes32 32 bytes\n     */\n    uint256 internal constant SELECTOR_LENGTH = 4;\n    uint256 internal constant OFFSET_SELECTOR = 0;\n    uint256 internal constant OFFSET_ARGUMENTS = SELECTOR_LENGTH;\n\n    /**\n     * @notice Returns a memory view over the given payload, treating it as raw bytes.\n     * @dev Shortcut for .ref(0) - to be deprecated once \"uint40 type\" is removed from bytes29.\n     */\n    function castToRawBytes(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref({ newType: 0 });\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              SIGNATURE                               ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Constructs the signature payload from the given values.\n     * @dev Using ByteString.formatSignature({r: r, s: s, v: v}) will make sure\n     * that params are given in the right order.\n     */\n    function formatSignature(\n        bytes32 r,\n        bytes32 s,\n        uint8 v\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(r, s, v);\n    }\n\n    /**\n     * @notice Returns a Signature view over for the given payload.\n     * @dev Will revert if the payload is not a signature.\n     */\n    function castToSignature(bytes memory _payload) internal pure returns (Signature) {\n        return castToSignature(castToRawBytes(_payload));\n    }\n\n    /**\n     * @notice Casts a memory view to a Signature view.\n     * @dev Will revert if the memory view is not over a signature.\n     */\n    function castToSignature(bytes29 _view) internal pure returns (Signature) {\n        require(isSignature(_view), \"Not a signature\");\n        return Signature.wrap(_view);\n    }\n\n    /**\n     * @notice Checks that a byte string is a signature\n     */\n    function isSignature(bytes29 _view) internal pure returns (bool) {\n        return _view.len() == SIGNATURE_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Signature _signature) internal pure returns (bytes29) {\n        return Signature.unwrap(_signature);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                          SIGNATURE SLICING                           ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /// @notice Unpacks signature payload into (r, s, v) parameters.\n    /// @dev Make sure to verify signature length with isSignature() beforehand.\n    function toRSV(Signature _signature)\n        internal\n        pure\n        returns (\n            bytes32 r,\n            bytes32 s,\n            uint8 v\n        )\n    {\n        // Get the underlying memory view\n        bytes29 _view = unwrap(_signature);\n        r = _view.index({ _index: OFFSET_R, _bytes: 32 });\n        s = _view.index({ _index: OFFSET_S, _bytes: 32 });\n        v = uint8(_view.indexUint({ _index: OFFSET_V, _bytes: 1 }));\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                               CALLDATA                               ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns a CallData view over for the given payload.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(bytes memory _payload) internal pure returns (CallData) {\n        return castToCallData(castToRawBytes(_payload));\n    }\n\n    /**\n     * @notice Casts a memory view to a CallData view.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(bytes29 _view) internal pure returns (CallData) {\n        require(isCallData(_view), \"Not a calldata\");\n        return CallData.wrap(_view);\n    }\n\n    /**\n     * @notice Checks that a byte string is a valid calldata, i.e.\n     * a function selector, followed by arbitrary amount of arguments.\n     */\n    function isCallData(bytes29 _view) internal pure returns (bool) {\n        uint256 length = _view.len();\n        // Calldata should at least have a function selector\n        if (length \u003c SELECTOR_LENGTH) return false;\n        // The remainder of the calldata should be exactly N words (N \u003e= 0), i.e.\n        // (length - SELECTOR_LENGTH) % 32 == 0\n        // We're using logical AND here to speed it up a bit\n        return (length - SELECTOR_LENGTH) \u0026 31 == 0;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(CallData _callData) internal pure returns (bytes29) {\n        return CallData.unwrap(_callData);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           CALLDATA SLICING                           ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns amount of memory words (32 byte chunks) the function arguments\n     * occupy in the calldata.\n     * @dev This might differ from amount of arguments supplied, if any of the arguments\n     * occupies more than one memory slot. It is true, however, that argument part of the payload\n     * occupies exactly N words, even for dynamic types like `bytes`\n     */\n    function argumentWords(CallData _callData) internal pure returns (uint256) {\n        // Get the underlying memory view\n        bytes29 _view = unwrap(_callData);\n        // Equivalent of (length - SELECTOR_LENGTH) / 32\n        return (_view.len() - SELECTOR_LENGTH) \u003e\u003e 5;\n    }\n\n    /// @notice Returns selector for the provided calldata.\n    function callSelector(CallData _callData) internal pure returns (bytes29) {\n        // Get the underlying memory view\n        bytes29 _view = unwrap(_callData);\n        return _view.slice({ _index: OFFSET_SELECTOR, _len: SELECTOR_LENGTH, newType: 0 });\n    }\n\n    /// @notice Returns abi encoded arguments for the provided calldata.\n    function arguments(CallData _callData) internal pure returns (bytes29) {\n        // Get the underlying memory view\n        bytes29 _view = unwrap(_callData);\n        return _view.sliceFrom({ _index: OFFSET_ARGUMENTS, newType: 0 });\n    }\n}\n\nlibrary TypeCasts {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    function coerceBytes32(string memory _s) internal pure returns (bytes32 _b) {\n        _b = bytes(_s).ref(0).index(0, uint8(bytes(_s).length));\n    }\n\n    // treat it as a null-terminated string of max 32 bytes\n    function coerceString(bytes32 _buf) internal pure returns (string memory _newStr) {\n        uint8 _slen = 0;\n        while (_slen \u003c 32 \u0026\u0026 _buf[_slen] != 0) {\n            _slen++;\n        }\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            _newStr := mload(0x40)\n            mstore(0x40, add(_newStr, 0x40)) // may end up with extra\n            mstore(_newStr, _slen)\n            mstore(add(_newStr, 0x20), _buf)\n        }\n    }\n\n    // alignment preserving cast\n    function addressToBytes32(address _addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(_addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 _buf) internal pure returns (address) {\n        return address(uint160(uint256(_buf)));\n    }\n}\n\n/// @dev Header is a memory over over a formatted message header payload.\ntype Header is bytes29;\n/// @dev Attach library functions to Header\nusing {\n    HeaderLib.unwrap,\n    HeaderLib.version,\n    HeaderLib.origin,\n    HeaderLib.sender,\n    HeaderLib.nonce,\n    HeaderLib.destination,\n    HeaderLib.recipient,\n    HeaderLib.optimisticSeconds,\n    HeaderLib.recipientAddress\n} for Header global;\n\n/**\n * @notice Library for versioned formatting [the header part]\n * of [the messages used by Origin and Destination].\n */\nlibrary HeaderLib {\n    using ByteString for bytes;\n    using TypedMemView for bytes29;\n\n    uint16 internal constant HEADER_VERSION = 1;\n\n    /**\n     * @dev Header memory layout\n     * [000 .. 002): version            uint16   2 bytes\n     * [002 .. 006): origin             uint32   4 bytes\n     * [006 .. 038): sender             bytes32 32 bytes\n     * [038 .. 042): nonce              uint32   4 bytes\n     * [042 .. 046): destination        uint32   4 bytes\n     * [046 .. 078): recipient          bytes32 32 bytes\n     * [078 .. 082): optimisticSeconds  uint32   4 bytes\n     */\n\n    uint256 internal constant OFFSET_VERSION = 0;\n    uint256 internal constant OFFSET_ORIGIN = 2;\n    uint256 internal constant OFFSET_SENDER = 6;\n    uint256 internal constant OFFSET_NONCE = 38;\n    uint256 internal constant OFFSET_DESTINATION = 42;\n    uint256 internal constant OFFSET_RECIPIENT = 46;\n    uint256 internal constant OFFSET_OPTIMISTIC_SECONDS = 78;\n\n    uint256 internal constant HEADER_LENGTH = 82;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns a formatted Header payload with provided fields\n     * @param _origin               Domain of origin chain\n     * @param _sender               Address that sent the message\n     * @param _nonce                Message nonce on origin chain\n     * @param _destination          Domain of destination chain\n     * @param _recipient            Address that will receive the message\n     * @param _optimisticSeconds    Optimistic period for message execution\n     * @return Formatted header\n     **/\n    function formatHeader(\n        uint32 _origin,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destination,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodePacked(\n                HEADER_VERSION,\n                _origin,\n                _sender,\n                _nonce,\n                _destination,\n                _recipient,\n                _optimisticSeconds\n            );\n    }\n\n    /**\n     * @notice Returns a Header view over for the given payload.\n     * @dev Will revert if the payload is not a header payload.\n     */\n    function castToHeader(bytes memory _payload) internal pure returns (Header) {\n        return castToHeader(_payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a Header view.\n     * @dev Will revert if the memory view is not over a header payload.\n     */\n    function castToHeader(bytes29 _view) internal pure returns (Header) {\n        require(isHeader(_view), \"Not a header payload\");\n        return Header.wrap(_view);\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Header.\n     */\n    function isHeader(bytes29 _view) internal pure returns (bool) {\n        uint256 length = _view.len();\n        // Check if version exists in the payload\n        if (length \u003c 2) return false;\n        // Check that header version and its length matches\n        return _getVersion(_view) == HEADER_VERSION \u0026\u0026 length == HEADER_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Header _header) internal pure returns (bytes29) {\n        return Header.unwrap(_header);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                            HEADER SLICING                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /// @notice Returns header's version field.\n    function version(Header _header) internal pure returns (uint16) {\n        // Get the underlying memory view\n        bytes29 _view = unwrap(_header);\n        return _getVersion(_view);\n    }\n\n    /// @notice Returns header's origin field\n    function origin(Header _header) internal pure returns (uint32) {\n        bytes29 _view = unwrap(_header);\n        return uint32(_view.indexUint(OFFSET_ORIGIN, 4));\n    }\n\n    /// @notice Returns header's sender field\n    function sender(Header _header) internal pure returns (bytes32) {\n        bytes29 _view = unwrap(_header);\n        return _view.index(OFFSET_SENDER, 32);\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(Header _header) internal pure returns (uint32) {\n        bytes29 _view = unwrap(_header);\n        return uint32(_view.indexUint(OFFSET_NONCE, 4));\n    }\n\n    /// @notice Returns header's destination field\n    function destination(Header _header) internal pure returns (uint32) {\n        bytes29 _view = unwrap(_header);\n        return uint32(_view.indexUint(OFFSET_DESTINATION, 4));\n    }\n\n    /// @notice Returns header's recipient field as bytes32\n    function recipient(Header _header) internal pure returns (bytes32) {\n        bytes29 _view = unwrap(_header);\n        return _view.index(OFFSET_RECIPIENT, 32);\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticSeconds(Header _header) internal pure returns (uint32) {\n        bytes29 _view = unwrap(_header);\n        return uint32(_view.indexUint(OFFSET_OPTIMISTIC_SECONDS, 4));\n    }\n\n    /// @notice Returns header's recipient field as an address\n    function recipientAddress(Header _header) internal pure returns (address) {\n        return TypeCasts.bytes32ToAddress(recipient(_header));\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           PRIVATE HELPERS                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /// @notice Returns a version field without checking if payload is properly formatted.\n    function _getVersion(bytes29 _view) internal pure returns (uint16) {\n        return uint16(_view.indexUint(OFFSET_VERSION, 2));\n    }\n}\n\n/// @dev Tips is a memory over over a formatted message tips payload.\ntype Tips is bytes29;\n/// @dev Attach library functions to Tips\nusing {\n    TipsLib.unwrap,\n    TipsLib.version,\n    TipsLib.notaryTip,\n    TipsLib.broadcasterTip,\n    TipsLib.proverTip,\n    TipsLib.executorTip,\n    TipsLib.totalTips\n} for Tips global;\n\n/**\n * @notice Library for versioned formatting [the tips part]\n * of [the messages used by Origin and Destination].\n */\nlibrary TipsLib {\n    using ByteString for bytes;\n    using TypedMemView for bytes29;\n\n    uint16 internal constant TIPS_VERSION = 1;\n\n    // TODO: determine if we need to pack the tips values,\n    // or if using uint256 instead will suffice.\n\n    /**\n     * @dev Tips memory layout\n     * [000 .. 002): version            uint16\t 2 bytes\n     * [002 .. 014): notaryTip          uint96\t12 bytes\n     * [014 .. 026): broadcasterTip     uint96\t12 bytes\n     * [026 .. 038): proverTip          uint96\t12 bytes\n     * [038 .. 050): executorTip        uint96\t12 bytes\n     */\n\n    uint256 internal constant OFFSET_VERSION = 0;\n    uint256 internal constant OFFSET_NOTARY = 2;\n    uint256 internal constant OFFSET_BROADCASTER = 14;\n    uint256 internal constant OFFSET_PROVER = 26;\n    uint256 internal constant OFFSET_EXECUTOR = 38;\n\n    uint256 internal constant TIPS_LENGTH = 50;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                                 TIPS                                 ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns a formatted Tips payload with provided fields\n     * @param _notaryTip        Tip for the Notary\n     * @param _broadcasterTip   Tip for the Broadcaster\n     * @param _proverTip        Tip for the Prover\n     * @param _executorTip      Tip for the Executor\n     * @return Formatted tips\n     **/\n    function formatTips(\n        uint96 _notaryTip,\n        uint96 _broadcasterTip,\n        uint96 _proverTip,\n        uint96 _executorTip\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodePacked(TIPS_VERSION, _notaryTip, _broadcasterTip, _proverTip, _executorTip);\n    }\n\n    /**\n     * @notice Returns a formatted Tips payload specifying empty tips.\n     * @return Formatted tips\n     **/\n    function emptyTips() internal pure returns (bytes memory) {\n        return formatTips(0, 0, 0, 0);\n    }\n\n    /**\n     * @notice Returns a Tips view over for the given payload.\n     * @dev Will revert if the payload is not a tips payload.\n     */\n    function castToTips(bytes memory _payload) internal pure returns (Tips) {\n        return castToTips(_payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a Tips view.\n     * @dev Will revert if the memory view is not over a tips payload.\n     */\n    function castToTips(bytes29 _view) internal pure returns (Tips) {\n        require(isTips(_view), \"Not a tips payload\");\n        return Tips.wrap(_view);\n    }\n\n    /// @notice Checks that a payload is a formatted Tips payload.\n    function isTips(bytes29 _view) internal pure returns (bool) {\n        uint256 length = _view.len();\n        // Check if version exists in the payload\n        if (length \u003c OFFSET_NOTARY) return false;\n        // Check that tips version and its length matches\n        return _getVersion(_view) == TIPS_VERSION \u0026\u0026 length == TIPS_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Tips _tips) internal pure returns (bytes29) {\n        return Tips.unwrap(_tips);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                             TIPS SLICING                             ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /// @notice Returns version of formatted tips\n    function version(Tips _tips) internal pure returns (uint16) {\n        // Get the underlying memory view\n        bytes29 _view = _tips.unwrap();\n        return _getVersion(_view);\n    }\n\n    /// @notice Returns notaryTip field\n    function notaryTip(Tips _tips) internal pure returns (uint96) {\n        bytes29 _view = _tips.unwrap();\n        return uint96(_view.indexUint(OFFSET_NOTARY, 12));\n    }\n\n    /// @notice Returns broadcasterTip field\n    function broadcasterTip(Tips _tips) internal pure returns (uint96) {\n        bytes29 _view = _tips.unwrap();\n        return uint96(_view.indexUint(OFFSET_BROADCASTER, 12));\n    }\n\n    /// @notice Returns proverTip field\n    function proverTip(Tips _tips) internal pure returns (uint96) {\n        bytes29 _view = _tips.unwrap();\n        return uint96(_view.indexUint(OFFSET_PROVER, 12));\n    }\n\n    /// @notice Returns executorTip field\n    function executorTip(Tips _tips) internal pure returns (uint96) {\n        bytes29 _view = _tips.unwrap();\n        return uint96(_view.indexUint(OFFSET_EXECUTOR, 12));\n    }\n\n    /// @notice Returns total tip amount.\n    function totalTips(Tips _tips) internal pure returns (uint96) {\n        // In practice there's no chance that the total tips value would not fit into uint96.\n        // TODO: determine if we want to use uint256 here instead anyway.\n        return notaryTip(_tips) + broadcasterTip(_tips) + proverTip(_tips) + executorTip(_tips);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           PRIVATE HELPERS                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /// @notice Returns a version field without checking if payload is properly formatted.\n    function _getVersion(bytes29 _view) private pure returns (uint16) {\n        return uint16(_view.indexUint(OFFSET_VERSION, 2));\n    }\n}\n\n/// @dev Message is a memory over over a formatted message payload.\ntype Message is bytes29;\n/// @dev Attach library functions to Message\nusing {\n    MessageLib.unwrap,\n    MessageLib.version,\n    MessageLib.header,\n    MessageLib.tips,\n    MessageLib.body,\n    MessageLib.leaf\n} for Message global;\n\n/**\n * @notice  Library for versioned formatting the messages used by Origin and Destination.\n */\nlibrary MessageLib {\n    using HeaderLib for bytes29;\n    using TipsLib for bytes29;\n    using ByteString for bytes;\n    using TypedMemView for bytes29;\n\n    enum Parts {\n        Version,\n        Header,\n        Tips,\n        Body\n    }\n\n    /**\n     * @dev This is only updated if the whole message structure is changed,\n     *      i.e. if a new part is added.\n     *      If already existing part is changed, the message version does not get bumped.\n     */\n    uint16 internal constant MESSAGE_VERSION = 1;\n\n    /**\n     * @dev Message memory layout\n     * [000 .. 002): version            uint16  2 bytes\n     * [002 .. 004): header length      uint16  2 bytes (length == AAA - 6)\n     * [004 .. 006): tips length        uint16  2 bytes (length == BBB - AAA)\n     * [006 .. AAA): header             bytes   ? bytes\n     * [AAA .. BBB): tips               bytes   ? bytes\n     * [BBB .. CCC): body               bytes   ? bytes (length could be zero)\n     */\n\n    uint256 internal constant OFFSET_VERSION = 0;\n\n    /// @dev How much bytes is used for storing the version, or a single offset value\n    uint8 internal constant TWO_BYTES = 2;\n    /// @dev This value reflects the header offset in the latest message version\n    uint16 internal constant OFFSET_HEADER = TWO_BYTES * uint8(type(Parts).max);\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns formatted message with provided fields\n     * @param _header       Formatted header payload\n     * @param _tips         Formatted tips payload\n     * @param _messageBody  Raw bytes of message body\n     * @return Formatted message\n     **/\n    function formatMessage(\n        bytes memory _header,\n        bytes memory _tips,\n        bytes memory _messageBody\n    ) internal pure returns (bytes memory) {\n        // Header and Tips are supposed to fit within 65535 bytes\n        return\n            abi.encodePacked(\n                MESSAGE_VERSION,\n                uint16(_header.length),\n                uint16(_tips.length),\n                _header,\n                _tips,\n                _messageBody\n            );\n    }\n\n    /**\n     * @notice Returns formatted message with provided fields\n     * @param _origin               Domain of origin chain\n     * @param _sender               Address that sent the message\n     * @param _nonce                Message nonce on origin chain\n     * @param _destination          Domain of destination chain\n     * @param _recipient            Address that will receive the message\n     * @param _optimisticSeconds    Optimistic period for message execution\n     * @param _tips                 Formatted tips payload\n     * @param _messageBody          Raw bytes of message body\n     * @return Formatted message\n     **/\n    function formatMessage(\n        uint32 _origin,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destination,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds,\n        bytes memory _tips,\n        bytes memory _messageBody\n    ) internal pure returns (bytes memory) {\n        return\n            formatMessage(\n                HeaderLib.formatHeader(\n                    _origin,\n                    _sender,\n                    _nonce,\n                    _destination,\n                    _recipient,\n                    _optimisticSeconds\n                ),\n                _tips,\n                _messageBody\n            );\n    }\n\n    /**\n     * @notice Returns a Message view over for the given payload.\n     * @dev Will revert if the payload is not a message payload.\n     */\n    function castToMessage(bytes memory _payload) internal pure returns (Message) {\n        return castToMessage(_payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a Message view.\n     * @dev Will revert if the memory view is not over a message payload.\n     */\n    function castToMessage(bytes29 _view) internal pure returns (Message) {\n        require(isMessage(_view), \"Not a message payload\");\n        return Message.wrap(_view);\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Message.\n     */\n    function isMessage(bytes29 _view) internal pure returns (bool) {\n        uint256 length = _view.len();\n        // Check if version and lengths exist in the payload\n        if (length \u003c OFFSET_HEADER) return false;\n        // Check message version\n        if (_getVersion(_view) != MESSAGE_VERSION) return false;\n\n        uint256 headerLength = _getLen(_view, Parts.Header);\n        uint256 tipsLength = _getLen(_view, Parts.Tips);\n        // Header and Tips need to exist\n        // Body could be empty, thus \u003e\n        if (OFFSET_HEADER + headerLength + tipsLength \u003e length) return false;\n\n        // Check header for being a formatted header payload\n        // Check tips for being a formatted tips payload\n        if (!_getHeader(_view).isHeader() || !_getTips(_view).isTips()) return false;\n        return true;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Message _msg) internal pure returns (bytes29) {\n        return Message.unwrap(_msg);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           MESSAGE SLICING                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /// @notice Returns message's version field.\n    function version(Message _msg) internal pure returns (uint16) {\n        // Get the underlying memory view\n        bytes29 _view = _msg.unwrap();\n        return _getVersion(_view);\n    }\n\n    /// @notice Returns message's header field as a Header view.\n    function header(Message _msg) internal pure returns (Header) {\n        bytes29 _view = _msg.unwrap();\n        return _getHeader(_view).castToHeader();\n    }\n\n    /// @notice Returns message's tips field as a Tips view.\n    function tips(Message _msg) internal pure returns (Tips) {\n        bytes29 _view = _msg.unwrap();\n        return _getTips(_view).castToTips();\n    }\n\n    /// @notice Returns message's body field as a generic memory view.\n    function body(Message _msg) internal pure returns (bytes29) {\n        bytes29 _view = _msg.unwrap();\n        // Determine index where message body payload starts\n        uint256 index = OFFSET_HEADER + _getLen(_view, Parts.Header) + _getLen(_view, Parts.Tips);\n        return _view.sliceFrom({ _index: index, newType: 0 });\n    }\n\n    /// @notice Returns message's hash: a leaf to be inserted in the Merkle tree.\n    function leaf(Message _msg) internal pure returns (bytes32) {\n        bytes29 _view = _msg.unwrap();\n        return _view.keccak();\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           PRIVATE HELPERS                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /// @dev Returns length for a given part of the message\n    /// without checking if the payload is properly formatted.\n    function _getLen(bytes29 _view, Parts _part) private pure returns (uint256) {\n        return _view.indexUint(uint256(_part) * TWO_BYTES, TWO_BYTES);\n    }\n\n    /// @dev Returns a version field without checking if the payload is properly formatted.\n    function _getVersion(bytes29 _view) private pure returns (uint16) {\n        return uint16(_view.indexUint(OFFSET_VERSION, 2));\n    }\n\n    /// @dev Returns a generic memory view over the header field without checking\n    /// if the whole payload or the header are properly formatted.\n    function _getHeader(bytes29 _view) private pure returns (bytes29) {\n        uint256 length = _getLen(_view, Parts.Header);\n        return _view.slice({ _index: OFFSET_HEADER, _len: length, newType: 0 });\n    }\n\n    /// @dev Returns a generic memory view over the tips field without checking\n    /// if the whole payload or the tips are properly formatted.\n    function _getTips(bytes29 _view) private pure returns (bytes29) {\n        // Determine index where tips payload starts\n        uint256 indexFrom = OFFSET_HEADER + _getLen(_view, Parts.Header);\n        uint256 length = _getLen(_view, Parts.Tips);\n        return _view.slice({ _index: indexFrom, _len: length, newType: 0 });\n    }\n}\n\n/**\n * @notice Exposes Message methods for testing against golang.\n */\ncontract MessageHarness {\n    using MessageLib for bytes;\n    using MessageLib for bytes29;\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                               GETTERS                                ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    function castToMessage(bytes memory _payload) public view returns (bytes memory) {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        Message _msg = MessageLib.castToMessage(_payload);\n        return _msg.unwrap().clone();\n    }\n\n    function header(bytes memory _payload) public view returns (bytes memory) {\n        return _payload.castToMessage().header().unwrap().clone();\n    }\n\n    function tips(bytes memory _payload) public view returns (bytes memory) {\n        return _payload.castToMessage().tips().unwrap().clone();\n    }\n\n    function body(bytes memory _payload) public view returns (bytes memory) {\n        return _payload.castToMessage().body().clone();\n    }\n\n    function version(bytes memory _payload) public pure returns (uint16) {\n        return _payload.castToMessage().version();\n    }\n\n    function leaf(bytes memory _payload) public pure returns (bytes32) {\n        return _payload.castToMessage().leaf();\n    }\n\n    function isMessage(bytes memory _payload) public pure returns (bool) {\n        return _payload.ref(0).isMessage();\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    function formatMessage(\n        uint32 _origin,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destination,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds,\n        // tips params\n        uint96 _notaryTip,\n        uint96 _broadcasterTip,\n        uint96 _proverTip,\n        uint96 _executorTip,\n        bytes memory _messageBody\n    ) public pure returns (bytes memory) {\n        bytes memory _tips = TipsLib.formatTips(\n            _notaryTip,\n            _broadcasterTip,\n            _proverTip,\n            _executorTip\n        );\n\n        bytes memory _header = HeaderLib.formatHeader(\n            _origin,\n            _sender,\n            _nonce,\n            _destination,\n            _recipient,\n            _optimisticSeconds\n        );\n        return formatMessage(_header, _tips, _messageBody);\n    }\n\n    function formatMessage(\n        uint32 _origin,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destination,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds,\n        bytes memory _tips,\n        bytes memory _messageBody\n    ) public pure returns (bytes memory) {\n        return\n            MessageLib.formatMessage(\n                _origin,\n                _sender,\n                _nonce,\n                _destination,\n                _recipient,\n                _optimisticSeconds,\n                _tips,\n                _messageBody\n            );\n    }\n\n    function formatMessage(\n        bytes memory _header,\n        bytes memory _tips,\n        bytes memory _messageBody\n    ) public pure returns (bytes memory) {\n        return MessageLib.formatMessage(_header, _tips, _messageBody);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           CONSTANT GETTERS                           ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    function messageVersion() public pure returns (uint16) {\n        return MessageLib.MESSAGE_VERSION;\n    }\n\n    function offsetVersion() public pure returns (uint256) {\n        return MessageLib.OFFSET_VERSION;\n    }\n\n    function offsetHeader() public pure returns (uint256) {\n        return MessageLib.OFFSET_HEADER;\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"53341:6248:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;53341:6248:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"53341:6248:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"notice":"Library for versioned formatting [the tips part] of [the messages used by Origin and Destination].","version":1},"developerDoc":{"kind":"dev","methods":{},"stateVariables":{"OFFSET_VERSION":{"details":"Tips memory layout [000 .. 002): version            uint16\t 2 bytes [002 .. 014): notaryTip          uint96\t12 bytes [014 .. 026): broadcasterTip     uint96\t12 bytes [026 .. 038): proverTip          uint96\t12 bytes [038 .. 050): executorTip        uint96\t12 bytes"}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"stateVariables\":{\"OFFSET_VERSION\":{\"details\":\"Tips memory layout [000 .. 002): version            uint16\\t 2 bytes [002 .. 014): notaryTip          uint96\\t12 bytes [014 .. 026): broadcasterTip     uint96\\t12 bytes [026 .. 038): proverTip          uint96\\t12 bytes [038 .. 050): executorTip        uint96\\t12 bytes\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"Library for versioned formatting [the tips part] of [the messages used by Origin and Destination].\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/MessageHarness.t.sol\":\"TipsLib\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/MessageHarness.t.sol\":{\"keccak256\":\"0x3904cba9f384c6433257789b24cdb15655a5775a36df2c4c297958af081b2acc\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://eff1071fd96ffa0ae24c5a5d8de738a1545769b12ccc3c5ec469a9d7e16b21db\",\"dweb:/ipfs/QmYyQsoEqF9QJ5aHaVw5545ePNt9Z7GqXfVyCFGrEh4y84\"]}},\"version\":1}"},"hashes":{}},"solidity/MessageHarness.t.sol:TypeCasts":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220e807b0181733dd9109070a6bddf91bd27e9e76884e820047df3c712e81c8e65f64736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220e807b0181733dd9109070a6bddf91bd27e9e76884e820047df3c712e81c8e65f64736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nlibrary TypedMemView {\n    // Why does this exist?\n    // the solidity `bytes memory` type has a few weaknesses.\n    // 1. You can't index ranges effectively\n    // 2. You can't slice without copying\n    // 3. The underlying data may represent any type\n    // 4. Solidity never deallocates memory, and memory costs grow\n    //    superlinearly\n\n    // By using a memory view instead of a `bytes memory` we get the following\n    // advantages:\n    // 1. Slices are done on the stack, by manipulating the pointer\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\n    // 3. We can insert type info into the pointer, and typecheck at runtime\n\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\n    // algorithms.\n\n    // Why bytes29?\n    // We want to avoid confusion between views, digests, and other common\n    // types so we chose a large and uncommonly used odd number of bytes\n    //\n    // Note that while bytes are left-aligned in a word, integers and addresses\n    // are right-aligned. This means when working in assembly we have to\n    // account for the 3 unused bytes on the righthand side\n    //\n    // First 5 bytes are a type flag.\n    // - ff_ffff_fffe is reserved for unknown type.\n    // - ff_ffff_ffff is reserved for invalid types/errors.\n    // next 12 are memory address\n    // next 12 are len\n    // bottom 3 bytes are empty\n\n    // Assumptions:\n    // - non-modification of memory.\n    // - No Solidity updates\n    // - - wrt free mem point\n    // - - wrt bytes representation in memory\n    // - - wrt memory addressing in general\n\n    // Usage:\n    // - create type constants\n    // - use `assertType` for runtime type assertions\n    // - - unfortunately we can't do this at compile time yet :(\n    // - recommended: implement modifiers that perform type checking\n    // - - e.g.\n    // - - `uint40 constant MY_TYPE = 3;`\n    // - - ` modifier onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n    // - instantiate a typed view from a bytearray using `ref`\n    // - use `index` to inspect the contents of the view\n    // - use `slice` to create smaller views into the same memory\n    // - - `slice` can increase the offset\n    // - - `slice can decrease the length`\n    // - - must specify the output type of `slice`\n    // - - `slice` will return a null view if you try to overrun\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\n    // - use `equal` for typed comparisons.\n\n    // The null view\n    bytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n\n    /**\n     * @dev Memory layout for bytes29\n     * TODO (Chi): with the user defined types storing type is no longer necessary.\n     * Update the library, transforming bytes29 to bytes24 in the process.\n     * [000..005)   type     5 bytes    Type flag for the pointer\n     * [005..017)   loc     12 bytes    Memory address of underlying bytes\n     * [017..029)   len     12 bytes    Length of underlying bytes\n     * [029..032)   empty    3 bytes    Not used\n     */\n    uint256 public constant BITS_TYPE = 40;\n    uint256 public constant BITS_LOC = 96;\n    uint256 public constant BITS_LEN = 96;\n    uint256 public constant BITS_EMPTY = 24;\n\n    // `SHIFT_X` is how much bits to shift for `X` to be in the very bottom bits\n    uint256 public constant SHIFT_LEN = BITS_EMPTY; // 24\n    uint256 public constant SHIFT_LOC = SHIFT_LEN + BITS_LEN; // 24 + 96 = 120\n    uint256 public constant SHIFT_TYPE = SHIFT_LOC + BITS_LOC; // 24 + 96 + 96 = 216\n    // Bitmask for the lowest 96 bits\n    uint256 public constant LOW_96_BITS_MASK = type(uint96).max;\n\n    // For nibble encoding\n    bytes private constant NIBBLE_LOOKUP = \"0123456789abcdef\";\n\n    /**\n     * @notice Returns the encoded hex character that represents the lower 4 bits of the argument.\n     * @param _byte     The byte\n     * @return _char    The encoded hex character\n     */\n    function nibbleHex(uint8 _byte) internal pure returns (uint8 _char) {\n        uint8 _nibble = _byte \u0026 0x0f; // keep bottom 4 bits, zero out top 4 bits\n        _char = uint8(NIBBLE_LOOKUP[_nibble]);\n    }\n\n    /**\n     * @notice      Returns a uint16 containing the hex-encoded byte.\n     * @param _b    The byte\n     * @return      encoded - The hex-encoded byte\n     */\n    function byteHex(uint8 _b) internal pure returns (uint16 encoded) {\n        encoded |= nibbleHex(_b \u003e\u003e 4); // top 4 bits\n        encoded \u003c\u003c= 8;\n        encoded |= nibbleHex(_b); // lower 4 bits\n    }\n\n    /**\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\n     *              `second` contains the encoded lower 16 bytes.\n     *\n     * @param _b    The 32 bytes as uint256\n     * @return      first - The top 16 bytes\n     * @return      second - The bottom 16 bytes\n     */\n    function encodeHex(uint256 _b) internal pure returns (uint256 first, uint256 second) {\n        for (uint8 i = 31; i \u003e 15; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            first |= byteHex(_byte);\n            if (i != 16) {\n                first \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n\n        // abusing underflow here =_=\n        for (uint8 i = 15; i \u003c 255; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            second |= byteHex(_byte);\n            if (i != 0) {\n                second \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n    }\n\n    /**\n     * @notice          Changes the endianness of a uint256.\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n     * @param _b        The unsigned integer to reverse\n     * @return          v - The reversed value\n     */\n    function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\n        v = _b;\n\n        // swap bytes\n        v =\n            ((v \u003e\u003e 8) \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\n            ((v \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) \u003c\u003c 8);\n        // swap 2-byte long pairs\n        v =\n            ((v \u003e\u003e 16) \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\n            ((v \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) \u003c\u003c 16);\n        // swap 4-byte long pairs\n        v =\n            ((v \u003e\u003e 32) \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\n            ((v \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) \u003c\u003c 32);\n        // swap 8-byte long pairs\n        v =\n            ((v \u003e\u003e 64) \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\n            ((v \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) \u003c\u003c 64);\n        // swap 16-byte long pairs\n        v = (v \u003e\u003e 128) | (v \u003c\u003c 128);\n    }\n\n    /**\n     * @notice      Create a mask with the highest `_len` bits set.\n     * @param _len  The length\n     * @return      mask - The mask\n     */\n    function leftMask(uint8 _len) private pure returns (uint256 mask) {\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(\n                sub(_len, 1),\n                0x8000000000000000000000000000000000000000000000000000000000000000\n            )\n        }\n    }\n\n    /**\n     * @notice      Return the null view.\n     * @return      bytes29 - The null view\n     */\n    // solhint-disable-next-line ordering\n    function nullView() internal pure returns (bytes29) {\n        return NULL;\n    }\n\n    /**\n     * @notice      Check if the view is null.\n     * @return      bool - True if the view is null\n     */\n    function isNull(bytes29 memView) internal pure returns (bool) {\n        return memView == NULL;\n    }\n\n    /**\n     * @notice      Check if the view is not null.\n     * @return      bool - True if the view is not null\n     */\n    function notNull(bytes29 memView) internal pure returns (bool) {\n        return !isNull(memView);\n    }\n\n    /**\n     * @notice          Check if the view is of a valid type and points to a valid location\n     *                  in memory.\n     * @dev             We perform this check by examining solidity's unallocated memory\n     *                  pointer and ensuring that the view's upper bound is less than that.\n     * @param memView   The view\n     * @return          ret - True if the view is valid\n     */\n    function isValid(bytes29 memView) internal pure returns (bool ret) {\n        if (typeOf(memView) == 0xffffffffff) {\n            return false;\n        }\n        uint256 _end = end(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // View is valid if (\"upper bound\" \u003c= \"unallocated memory pointer\")\n            // Upper bound is exclusive, hence \"\u003c=\"\n            ret := not(gt(_end, mload(0x40)))\n        }\n    }\n\n    /**\n     * @notice          Require that a typed memory view be valid.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @return          bytes29 - The validated view\n     */\n    function assertValid(bytes29 memView) internal pure returns (bytes29) {\n        require(isValid(memView), \"Validity assertion failed\");\n        return memView;\n    }\n\n    /**\n     * @notice          Return true if the memview is of the expected type. Otherwise false.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bool - True if the memview is of the expected type\n     */\n    function isType(bytes29 memView, uint40 _expected) internal pure returns (bool) {\n        return typeOf(memView) == _expected;\n    }\n\n    /**\n     * @notice          Require that a typed memory view has a specific type.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bytes29 - The view with validated type\n     */\n    function assertType(bytes29 memView, uint40 _expected) internal pure returns (bytes29) {\n        if (!isType(memView, _expected)) {\n            (, uint256 g) = encodeHex(uint256(typeOf(memView)));\n            (, uint256 e) = encodeHex(uint256(_expected));\n            string memory err = string(\n                abi.encodePacked(\n                    \"Type assertion failed. Got 0x\",\n                    uint80(g),\n                    \". Expected 0x\",\n                    uint80(e)\n                )\n            );\n            revert(err);\n        }\n        return memView;\n    }\n\n    /**\n     * @notice          Return an identical view with a different type.\n     * @param memView   The view\n     * @param _newType  The new type\n     * @return          newView - The new view with the specified type\n     */\n    function castTo(bytes29 memView, uint40 _newType) internal pure returns (bytes29 newView) {\n        // How many bits are the \"type bits\" occupying\n        uint256 _bitsType = BITS_TYPE;\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 _shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // shift off the \"type bits\" (shift left, then sift right)\n            newView := or(newView, shr(_bitsType, shl(_bitsType, memView)))\n            // set the new \"type bits\" (shift left, then OR)\n            newView := or(newView, shl(_shiftType, _newType))\n        }\n    }\n\n    /**\n     * @notice          Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function unsafeBuildUnchecked(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) private pure returns (bytes29 newView) {\n        uint256 _bitsLoc = BITS_LOC;\n        uint256 _bitsLen = BITS_LEN;\n        uint256 _bitsEmpty = BITS_EMPTY;\n        // Ref memory layout\n        // [000..005) 5 bytes of type\n        // [005..017) 12 bytes of location\n        // [017..029) 12 bytes of length\n        // last 3 bits are blank and dropped in typecast\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // insert `type`, shift to prepare empty bits for `loc`\n            newView := shl(_bitsLoc, or(newView, _type))\n            // insert `loc`, shift to prepare empty bits for `len`\n            newView := shl(_bitsLen, or(newView, _loc))\n            // insert `len`, shift to insert 3 blank lowest bits\n            newView := shl(_bitsEmpty, or(newView, _len))\n        }\n    }\n\n    /**\n     * @notice          Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function build(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) internal pure returns (bytes29 newView) {\n        uint256 _end = _loc + _len;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(_end, mload(0x40)) {\n                _end := 0\n            }\n        }\n        if (_end == 0) {\n            return NULL;\n        }\n        newView = unsafeBuildUnchecked(_type, _loc, _len);\n    }\n\n    /**\n     * @notice          Instantiate a memory view from a byte array.\n     * @dev             Note that due to Solidity memory representation, it is not possible to\n     *                  implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr       The byte array\n     * @param newType   The type\n     * @return          bytes29 - The memory view\n     */\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\n        uint256 _len = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 _loc;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            _loc := add(arr, 0x20)\n        }\n\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Return the associated type information.\n     * @param memView   The memory view\n     * @return          _type - The type associated with the view\n     */\n    function typeOf(bytes29 memView) internal pure returns (uint40 _type) {\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 _shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"type bits\". \"type bits\" are occupying\n            // the highest bits, so all that's left is \"type bits\", OR is not required.\n            _type := shr(_shiftType, memView)\n        }\n    }\n\n    /**\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the 5-byte type flag is equal\n     */\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\n        // Check that the highest 5 bytes are equal: xor and shift out lower 27 bytes\n        return (left ^ right) \u003e\u003e SHIFT_TYPE == 0;\n    }\n\n    /**\n     * @notice          Return the memory address of the underlying bytes.\n     * @param memView   The view\n     * @return          _loc - The memory address\n     */\n    function loc(bytes29 memView) internal pure returns (uint96 _loc) {\n        // How many bits are the \"loc bits\" shifted from the bottom\n        uint256 _shiftLoc = SHIFT_LOC;\n        // Mask for the bottom 96 bits\n        uint256 _uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"loc bits\".\n            // Then use the lowest 96 bits to determine `loc` by applying the bit-mask.\n            _loc := and(shr(_shiftLoc, memView), _uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          The number of memory words this memory view occupies, rounded up.\n     * @param memView   The view\n     * @return          uint256 - The number of memory words\n     */\n    function words(bytes29 memView) internal pure returns (uint256) {\n        // returning ceil(length / 32.0)\n        return (uint256(len(memView)) + 31) / 32;\n    }\n\n    /**\n     * @notice          The in-memory footprint of a fresh copy of the view.\n     * @param memView   The view\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(bytes29 memView) internal pure returns (uint256) {\n        return words(memView) * 32;\n    }\n\n    /**\n     * @notice          The number of bytes of the view.\n     * @param memView   The view\n     * @return          _len - The length of the view\n     */\n    function len(bytes29 memView) internal pure returns (uint96 _len) {\n        // How many bits are the \"len bits\" shifted from the bottom\n        uint256 _shiftLen = SHIFT_LEN;\n        // Mask for the bottom 96 bits\n        uint256 _uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"len bits\".\n            // Then use the lowest 96 bits to determine `len` by applying the bit-mask.\n            _len := and(shr(_shiftLen, memView), _uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          Returns the endpoint of `memView`.\n     * @param memView   The view\n     * @return          uint256 - The endpoint of `memView`\n     */\n    function end(bytes29 memView) internal pure returns (uint256) {\n        unchecked {\n            return loc(memView) + len(memView);\n        }\n    }\n\n    /**\n     * @notice          Safe slicing without memory modification.\n     * @param memView   The view\n     * @param _index    The start index\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function slice(\n        bytes29 memView,\n        uint256 _index,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        uint256 _loc = loc(memView);\n\n        // Ensure it doesn't overrun the view\n        if (_loc + _index + _len \u003e end(memView)) {\n            return NULL;\n        }\n\n        _loc = _loc + _index;\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing\n     *                  bytes from `_index` to end(memView).\n     * @param memView   The view\n     * @param _index    The start index\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function sliceFrom(\n        bytes29 memView,\n        uint256 _index,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, _index, len(memView) - _index, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the first `_len` bytes.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function prefix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, 0, _len, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the last `_len` byte.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function postfix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, uint256(len(memView)) - _len, _len, newType);\n    }\n\n    /**\n     * @notice          Construct an error message for an indexing overrun.\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @param _index    The index\n     * @param _slice    The slice where the overrun occurred\n     * @return          err - The err\n     */\n    function indexErrOverrun(\n        uint256 _loc,\n        uint256 _len,\n        uint256 _index,\n        uint256 _slice\n    ) internal pure returns (string memory err) {\n        (, uint256 a) = encodeHex(_loc);\n        (, uint256 b) = encodeHex(_len);\n        (, uint256 c) = encodeHex(_index);\n        (, uint256 d) = encodeHex(_slice);\n        err = string(\n            abi.encodePacked(\n                \"TypedMemView/index - Overran the view. Slice is at 0x\",\n                uint48(a),\n                \" with length 0x\",\n                uint48(b),\n                \". Attempted to index at offset 0x\",\n                uint48(c),\n                \" with length 0x\",\n                uint48(d),\n                \".\"\n            )\n        );\n    }\n\n    /**\n     * @notice          Load up to 32 bytes from the view onto the stack.\n     * @dev             Returns a bytes32 with only the `_bytes` highest bytes set.\n     *                  This can be immediately cast to a smaller fixed-length byte array.\n     *                  To automatically cast to an integer, use `indexUint`.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The 32 byte result\n     */\n    function index(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (bytes32 result) {\n        if (_bytes == 0) {\n            return bytes32(0);\n        }\n        if (_index + _bytes \u003e len(memView)) {\n            revert(indexErrOverrun(loc(memView), len(memView), _index, uint256(_bytes)));\n        }\n        require(_bytes \u003c= 32, \"Index: more than 32 bytes\");\n\n        uint8 bitLength;\n        unchecked {\n            bitLength = _bytes * 8;\n        }\n        uint256 _loc = loc(memView);\n        // Get a mask with `bitLength` highest bits set\n        uint256 _mask = leftMask(bitLength);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(_loc, _index)), _mask)\n        }\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from the view at `_index`.\n     * @dev             Requires that the view have \u003e= `_bytes` bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        // `index()` returns left-aligned `_bytes`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word\n        return uint256(index(memView, _index, _bytes)) \u003e\u003e ((32 - _bytes) * 8);\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from LE bytes.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexLEUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return reverseUint256(uint256(index(memView, _index, _bytes)));\n    }\n\n    /**\n     * @notice          Parse an address from the view at `_index`.\n     *                  Requires that the view have \u003e= 20 bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @return          address - The address\n     */\n    function indexAddress(bytes29 memView, uint256 _index) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(indexUint(memView, _index, 20)));\n    }\n\n    /**\n     * @notice          Return the keccak256 hash of the underlying memory\n     * @param memView   The view\n     * @return          digest - The keccak256 hash of the underlying memory\n     */\n    function keccak(bytes29 memView) internal pure returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(_loc, _len)\n        }\n    }\n\n    /**\n     * @notice          Return the sha2 digest of the underlying memory.\n     * @dev             We explicitly deallocate memory afterwards.\n     * @param memView   The view\n     * @return          digest - The sha2 hash of the underlying memory\n     */\n    function sha2(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            digest := mload(ptr)\n        }\n        require(res, \"sha2: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n     * @param memView   The pre-image\n     * @return          digest - the Digest\n     */\n    function hash160(bytes29 memView) internal view returns (bytes20 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            // rmd160 precompile is 0x03\n            res := and(res, staticcall(gas(), 0x03, ptr, 0x20, ptr, 0x20))\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\n        }\n        require(res, \"hash160: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash256 (double sha2)\n     * @param memView   A view of the preimage\n     * @return          digest - the Digest\n     */\n    function hash256(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            res := and(res, staticcall(gas(), 0x02, ptr, 0x20, ptr, 0x20))\n            digest := mload(ptr)\n        }\n        require(res, \"hash256: out of gas\");\n    }\n\n    /**\n     * @notice          Return true if the underlying memory is equal. Else false.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the underlying memory is equal\n     */\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return\n            (loc(left) == loc(right) \u0026\u0026 len(left) == len(right)) || keccak(left) == keccak(right);\n    }\n\n    /**\n     * @notice          Return false if the underlying memory is equal. Else true.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - False if the underlying memory is equal\n     */\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !untypedEqual(left, right);\n    }\n\n    /**\n     * @notice          Compares type equality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are the same\n     */\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return left == right || (typeOf(left) == typeOf(right) \u0026\u0026 keccak(left) == keccak(right));\n    }\n\n    /**\n     * @notice          Compares type inequality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are not the same\n     */\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !equal(left, right);\n    }\n\n    /**\n     * @notice          Copy the view to a location, return an unsafe memory reference\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memView   The view\n     * @param _newLoc   The new location\n     * @return          written - the unsafe memory reference\n     */\n    function unsafeCopyTo(bytes29 memView, uint256 _newLoc) private view returns (bytes29 written) {\n        require(notNull(memView), \"copyTo: Null pointer deref\");\n        require(isValid(memView), \"copyTo: Invalid pointer deref\");\n        uint256 _len = len(memView);\n        uint256 _oldLoc = loc(memView);\n\n        uint256 ptr;\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _newLoc) {\n                revert(0x60, 0x20) // empty revert message\n            }\n\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, _oldLoc, _len, _newLoc, _len)\n        }\n        require(res, \"identity: out of gas\");\n\n        written = unsafeBuildUnchecked(typeOf(memView), _newLoc, _len);\n    }\n\n    /**\n     * @notice          Copies the referenced memory to a new loc in memory,\n     *                  returning a `bytes` pointing to the new memory.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param memView   The view\n     * @return          ret - The view pointing to the new memory\n     */\n    function clone(bytes29 memView) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n            ret := ptr\n        }\n        unchecked {\n            unsafeCopyTo(memView, ptr + 0x20);\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mstore(0x40, add(add(ptr, _len), 0x20)) // write new unused pointer\n            mstore(ptr, _len) // write len of new array (in bytes)\n        }\n    }\n\n    /**\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memViews  The views\n     * @return          unsafeView - The conjoined view pointing to the new memory\n     */\n    function unsafeJoin(bytes29[] memory memViews, uint256 _location)\n        private\n        view\n        returns (bytes29 unsafeView)\n    {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _location) {\n                revert(0x60, 0x20) // empty revert message\n            }\n        }\n\n        uint256 _offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length; i++) {\n            bytes29 memView = memViews[i];\n            unchecked {\n                unsafeCopyTo(memView, _location + _offset);\n                _offset += len(memView);\n            }\n        }\n        unsafeView = unsafeBuildUnchecked(0, _location, _offset);\n    }\n\n    /**\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The keccak256 digest\n     */\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return keccak(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The sha256 digest\n     */\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return sha2(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          copies all views, joins them into a new bytearray.\n     * @param memViews  The views\n     * @return          ret - The new byte array\n     */\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n\n        bytes29 _newView;\n        unchecked {\n            _newView = unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 _written = len(_newView);\n        uint256 _footprint = footprint(_newView);\n\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // store the length\n            mstore(ptr, _written)\n            // new pointer is old + 0x20 + the footprint of the body\n            mstore(0x40, add(add(ptr, _footprint), 0x20))\n            ret := ptr\n        }\n    }\n}\n\n/// @dev CallData is a memory view over the payload to be used for an external call, i.e.\n/// recipient.call(callData). Its length is always (4 + 32 * N) bytes:\n/// - First 4 bytes represent the function selector.\n/// - 32 * N bytes represent N words that function arguments occupy.\ntype CallData is bytes29;\n/// @dev Signature is a memory view over a \"65 bytes\" array representing a ECDSA signature.\ntype Signature is bytes29;\n\nlibrary ByteString {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev non-compact ECDSA signatures are enforced as of OZ 4.7.3\n     *\n     *      Signature payload memory layout\n     * [000 .. 032) r   bytes32 32 bytes\n     * [032 .. 064) s   bytes32 32 bytes\n     * [064 .. 065) v   uint8    1 byte\n     */\n    uint256 internal constant SIGNATURE_LENGTH = 65;\n    uint256 internal constant OFFSET_R = 0;\n    uint256 internal constant OFFSET_S = 32;\n    uint256 internal constant OFFSET_V = 64;\n\n    /**\n     * @dev Calldata memory layout\n     * [000 .. 004) selector    bytes4  4 bytes\n     *      Optional: N function arguments\n     * [004 .. 036) arg1        bytes32 32 bytes\n     *      ..\n     * [AAA .. END) argN        bytes32 32 bytes\n     */\n    uint256 internal constant SELECTOR_LENGTH = 4;\n    uint256 internal constant OFFSET_SELECTOR = 0;\n    uint256 internal constant OFFSET_ARGUMENTS = SELECTOR_LENGTH;\n\n    /**\n     * @notice Returns a memory view over the given payload, treating it as raw bytes.\n     * @dev Shortcut for .ref(0) - to be deprecated once \"uint40 type\" is removed from bytes29.\n     */\n    function castToRawBytes(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref({ newType: 0 });\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              SIGNATURE                               ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Constructs the signature payload from the given values.\n     * @dev Using ByteString.formatSignature({r: r, s: s, v: v}) will make sure\n     * that params are given in the right order.\n     */\n    function formatSignature(\n        bytes32 r,\n        bytes32 s,\n        uint8 v\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(r, s, v);\n    }\n\n    /**\n     * @notice Returns a Signature view over for the given payload.\n     * @dev Will revert if the payload is not a signature.\n     */\n    function castToSignature(bytes memory _payload) internal pure returns (Signature) {\n        return castToSignature(castToRawBytes(_payload));\n    }\n\n    /**\n     * @notice Casts a memory view to a Signature view.\n     * @dev Will revert if the memory view is not over a signature.\n     */\n    function castToSignature(bytes29 _view) internal pure returns (Signature) {\n        require(isSignature(_view), \"Not a signature\");\n        return Signature.wrap(_view);\n    }\n\n    /**\n     * @notice Checks that a byte string is a signature\n     */\n    function isSignature(bytes29 _view) internal pure returns (bool) {\n        return _view.len() == SIGNATURE_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Signature _signature) internal pure returns (bytes29) {\n        return Signature.unwrap(_signature);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                          SIGNATURE SLICING                           ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /// @notice Unpacks signature payload into (r, s, v) parameters.\n    /// @dev Make sure to verify signature length with isSignature() beforehand.\n    function toRSV(Signature _signature)\n        internal\n        pure\n        returns (\n            bytes32 r,\n            bytes32 s,\n            uint8 v\n        )\n    {\n        // Get the underlying memory view\n        bytes29 _view = unwrap(_signature);\n        r = _view.index({ _index: OFFSET_R, _bytes: 32 });\n        s = _view.index({ _index: OFFSET_S, _bytes: 32 });\n        v = uint8(_view.indexUint({ _index: OFFSET_V, _bytes: 1 }));\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                               CALLDATA                               ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns a CallData view over for the given payload.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(bytes memory _payload) internal pure returns (CallData) {\n        return castToCallData(castToRawBytes(_payload));\n    }\n\n    /**\n     * @notice Casts a memory view to a CallData view.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(bytes29 _view) internal pure returns (CallData) {\n        require(isCallData(_view), \"Not a calldata\");\n        return CallData.wrap(_view);\n    }\n\n    /**\n     * @notice Checks that a byte string is a valid calldata, i.e.\n     * a function selector, followed by arbitrary amount of arguments.\n     */\n    function isCallData(bytes29 _view) internal pure returns (bool) {\n        uint256 length = _view.len();\n        // Calldata should at least have a function selector\n        if (length \u003c SELECTOR_LENGTH) return false;\n        // The remainder of the calldata should be exactly N words (N \u003e= 0), i.e.\n        // (length - SELECTOR_LENGTH) % 32 == 0\n        // We're using logical AND here to speed it up a bit\n        return (length - SELECTOR_LENGTH) \u0026 31 == 0;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(CallData _callData) internal pure returns (bytes29) {\n        return CallData.unwrap(_callData);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           CALLDATA SLICING                           ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns amount of memory words (32 byte chunks) the function arguments\n     * occupy in the calldata.\n     * @dev This might differ from amount of arguments supplied, if any of the arguments\n     * occupies more than one memory slot. It is true, however, that argument part of the payload\n     * occupies exactly N words, even for dynamic types like `bytes`\n     */\n    function argumentWords(CallData _callData) internal pure returns (uint256) {\n        // Get the underlying memory view\n        bytes29 _view = unwrap(_callData);\n        // Equivalent of (length - SELECTOR_LENGTH) / 32\n        return (_view.len() - SELECTOR_LENGTH) \u003e\u003e 5;\n    }\n\n    /// @notice Returns selector for the provided calldata.\n    function callSelector(CallData _callData) internal pure returns (bytes29) {\n        // Get the underlying memory view\n        bytes29 _view = unwrap(_callData);\n        return _view.slice({ _index: OFFSET_SELECTOR, _len: SELECTOR_LENGTH, newType: 0 });\n    }\n\n    /// @notice Returns abi encoded arguments for the provided calldata.\n    function arguments(CallData _callData) internal pure returns (bytes29) {\n        // Get the underlying memory view\n        bytes29 _view = unwrap(_callData);\n        return _view.sliceFrom({ _index: OFFSET_ARGUMENTS, newType: 0 });\n    }\n}\n\nlibrary TypeCasts {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    function coerceBytes32(string memory _s) internal pure returns (bytes32 _b) {\n        _b = bytes(_s).ref(0).index(0, uint8(bytes(_s).length));\n    }\n\n    // treat it as a null-terminated string of max 32 bytes\n    function coerceString(bytes32 _buf) internal pure returns (string memory _newStr) {\n        uint8 _slen = 0;\n        while (_slen \u003c 32 \u0026\u0026 _buf[_slen] != 0) {\n            _slen++;\n        }\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            _newStr := mload(0x40)\n            mstore(0x40, add(_newStr, 0x40)) // may end up with extra\n            mstore(_newStr, _slen)\n            mstore(add(_newStr, 0x20), _buf)\n        }\n    }\n\n    // alignment preserving cast\n    function addressToBytes32(address _addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(_addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 _buf) internal pure returns (address) {\n        return address(uint160(uint256(_buf)));\n    }\n}\n\n/// @dev Header is a memory over over a formatted message header payload.\ntype Header is bytes29;\n/// @dev Attach library functions to Header\nusing {\n    HeaderLib.unwrap,\n    HeaderLib.version,\n    HeaderLib.origin,\n    HeaderLib.sender,\n    HeaderLib.nonce,\n    HeaderLib.destination,\n    HeaderLib.recipient,\n    HeaderLib.optimisticSeconds,\n    HeaderLib.recipientAddress\n} for Header global;\n\n/**\n * @notice Library for versioned formatting [the header part]\n * of [the messages used by Origin and Destination].\n */\nlibrary HeaderLib {\n    using ByteString for bytes;\n    using TypedMemView for bytes29;\n\n    uint16 internal constant HEADER_VERSION = 1;\n\n    /**\n     * @dev Header memory layout\n     * [000 .. 002): version            uint16   2 bytes\n     * [002 .. 006): origin             uint32   4 bytes\n     * [006 .. 038): sender             bytes32 32 bytes\n     * [038 .. 042): nonce              uint32   4 bytes\n     * [042 .. 046): destination        uint32   4 bytes\n     * [046 .. 078): recipient          bytes32 32 bytes\n     * [078 .. 082): optimisticSeconds  uint32   4 bytes\n     */\n\n    uint256 internal constant OFFSET_VERSION = 0;\n    uint256 internal constant OFFSET_ORIGIN = 2;\n    uint256 internal constant OFFSET_SENDER = 6;\n    uint256 internal constant OFFSET_NONCE = 38;\n    uint256 internal constant OFFSET_DESTINATION = 42;\n    uint256 internal constant OFFSET_RECIPIENT = 46;\n    uint256 internal constant OFFSET_OPTIMISTIC_SECONDS = 78;\n\n    uint256 internal constant HEADER_LENGTH = 82;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns a formatted Header payload with provided fields\n     * @param _origin               Domain of origin chain\n     * @param _sender               Address that sent the message\n     * @param _nonce                Message nonce on origin chain\n     * @param _destination          Domain of destination chain\n     * @param _recipient            Address that will receive the message\n     * @param _optimisticSeconds    Optimistic period for message execution\n     * @return Formatted header\n     **/\n    function formatHeader(\n        uint32 _origin,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destination,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodePacked(\n                HEADER_VERSION,\n                _origin,\n                _sender,\n                _nonce,\n                _destination,\n                _recipient,\n                _optimisticSeconds\n            );\n    }\n\n    /**\n     * @notice Returns a Header view over for the given payload.\n     * @dev Will revert if the payload is not a header payload.\n     */\n    function castToHeader(bytes memory _payload) internal pure returns (Header) {\n        return castToHeader(_payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a Header view.\n     * @dev Will revert if the memory view is not over a header payload.\n     */\n    function castToHeader(bytes29 _view) internal pure returns (Header) {\n        require(isHeader(_view), \"Not a header payload\");\n        return Header.wrap(_view);\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Header.\n     */\n    function isHeader(bytes29 _view) internal pure returns (bool) {\n        uint256 length = _view.len();\n        // Check if version exists in the payload\n        if (length \u003c 2) return false;\n        // Check that header version and its length matches\n        return _getVersion(_view) == HEADER_VERSION \u0026\u0026 length == HEADER_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Header _header) internal pure returns (bytes29) {\n        return Header.unwrap(_header);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                            HEADER SLICING                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /// @notice Returns header's version field.\n    function version(Header _header) internal pure returns (uint16) {\n        // Get the underlying memory view\n        bytes29 _view = unwrap(_header);\n        return _getVersion(_view);\n    }\n\n    /// @notice Returns header's origin field\n    function origin(Header _header) internal pure returns (uint32) {\n        bytes29 _view = unwrap(_header);\n        return uint32(_view.indexUint(OFFSET_ORIGIN, 4));\n    }\n\n    /// @notice Returns header's sender field\n    function sender(Header _header) internal pure returns (bytes32) {\n        bytes29 _view = unwrap(_header);\n        return _view.index(OFFSET_SENDER, 32);\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(Header _header) internal pure returns (uint32) {\n        bytes29 _view = unwrap(_header);\n        return uint32(_view.indexUint(OFFSET_NONCE, 4));\n    }\n\n    /// @notice Returns header's destination field\n    function destination(Header _header) internal pure returns (uint32) {\n        bytes29 _view = unwrap(_header);\n        return uint32(_view.indexUint(OFFSET_DESTINATION, 4));\n    }\n\n    /// @notice Returns header's recipient field as bytes32\n    function recipient(Header _header) internal pure returns (bytes32) {\n        bytes29 _view = unwrap(_header);\n        return _view.index(OFFSET_RECIPIENT, 32);\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticSeconds(Header _header) internal pure returns (uint32) {\n        bytes29 _view = unwrap(_header);\n        return uint32(_view.indexUint(OFFSET_OPTIMISTIC_SECONDS, 4));\n    }\n\n    /// @notice Returns header's recipient field as an address\n    function recipientAddress(Header _header) internal pure returns (address) {\n        return TypeCasts.bytes32ToAddress(recipient(_header));\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           PRIVATE HELPERS                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /// @notice Returns a version field without checking if payload is properly formatted.\n    function _getVersion(bytes29 _view) internal pure returns (uint16) {\n        return uint16(_view.indexUint(OFFSET_VERSION, 2));\n    }\n}\n\n/// @dev Tips is a memory over over a formatted message tips payload.\ntype Tips is bytes29;\n/// @dev Attach library functions to Tips\nusing {\n    TipsLib.unwrap,\n    TipsLib.version,\n    TipsLib.notaryTip,\n    TipsLib.broadcasterTip,\n    TipsLib.proverTip,\n    TipsLib.executorTip,\n    TipsLib.totalTips\n} for Tips global;\n\n/**\n * @notice Library for versioned formatting [the tips part]\n * of [the messages used by Origin and Destination].\n */\nlibrary TipsLib {\n    using ByteString for bytes;\n    using TypedMemView for bytes29;\n\n    uint16 internal constant TIPS_VERSION = 1;\n\n    // TODO: determine if we need to pack the tips values,\n    // or if using uint256 instead will suffice.\n\n    /**\n     * @dev Tips memory layout\n     * [000 .. 002): version            uint16\t 2 bytes\n     * [002 .. 014): notaryTip          uint96\t12 bytes\n     * [014 .. 026): broadcasterTip     uint96\t12 bytes\n     * [026 .. 038): proverTip          uint96\t12 bytes\n     * [038 .. 050): executorTip        uint96\t12 bytes\n     */\n\n    uint256 internal constant OFFSET_VERSION = 0;\n    uint256 internal constant OFFSET_NOTARY = 2;\n    uint256 internal constant OFFSET_BROADCASTER = 14;\n    uint256 internal constant OFFSET_PROVER = 26;\n    uint256 internal constant OFFSET_EXECUTOR = 38;\n\n    uint256 internal constant TIPS_LENGTH = 50;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                                 TIPS                                 ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns a formatted Tips payload with provided fields\n     * @param _notaryTip        Tip for the Notary\n     * @param _broadcasterTip   Tip for the Broadcaster\n     * @param _proverTip        Tip for the Prover\n     * @param _executorTip      Tip for the Executor\n     * @return Formatted tips\n     **/\n    function formatTips(\n        uint96 _notaryTip,\n        uint96 _broadcasterTip,\n        uint96 _proverTip,\n        uint96 _executorTip\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodePacked(TIPS_VERSION, _notaryTip, _broadcasterTip, _proverTip, _executorTip);\n    }\n\n    /**\n     * @notice Returns a formatted Tips payload specifying empty tips.\n     * @return Formatted tips\n     **/\n    function emptyTips() internal pure returns (bytes memory) {\n        return formatTips(0, 0, 0, 0);\n    }\n\n    /**\n     * @notice Returns a Tips view over for the given payload.\n     * @dev Will revert if the payload is not a tips payload.\n     */\n    function castToTips(bytes memory _payload) internal pure returns (Tips) {\n        return castToTips(_payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a Tips view.\n     * @dev Will revert if the memory view is not over a tips payload.\n     */\n    function castToTips(bytes29 _view) internal pure returns (Tips) {\n        require(isTips(_view), \"Not a tips payload\");\n        return Tips.wrap(_view);\n    }\n\n    /// @notice Checks that a payload is a formatted Tips payload.\n    function isTips(bytes29 _view) internal pure returns (bool) {\n        uint256 length = _view.len();\n        // Check if version exists in the payload\n        if (length \u003c OFFSET_NOTARY) return false;\n        // Check that tips version and its length matches\n        return _getVersion(_view) == TIPS_VERSION \u0026\u0026 length == TIPS_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Tips _tips) internal pure returns (bytes29) {\n        return Tips.unwrap(_tips);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                             TIPS SLICING                             ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /// @notice Returns version of formatted tips\n    function version(Tips _tips) internal pure returns (uint16) {\n        // Get the underlying memory view\n        bytes29 _view = _tips.unwrap();\n        return _getVersion(_view);\n    }\n\n    /// @notice Returns notaryTip field\n    function notaryTip(Tips _tips) internal pure returns (uint96) {\n        bytes29 _view = _tips.unwrap();\n        return uint96(_view.indexUint(OFFSET_NOTARY, 12));\n    }\n\n    /// @notice Returns broadcasterTip field\n    function broadcasterTip(Tips _tips) internal pure returns (uint96) {\n        bytes29 _view = _tips.unwrap();\n        return uint96(_view.indexUint(OFFSET_BROADCASTER, 12));\n    }\n\n    /// @notice Returns proverTip field\n    function proverTip(Tips _tips) internal pure returns (uint96) {\n        bytes29 _view = _tips.unwrap();\n        return uint96(_view.indexUint(OFFSET_PROVER, 12));\n    }\n\n    /// @notice Returns executorTip field\n    function executorTip(Tips _tips) internal pure returns (uint96) {\n        bytes29 _view = _tips.unwrap();\n        return uint96(_view.indexUint(OFFSET_EXECUTOR, 12));\n    }\n\n    /// @notice Returns total tip amount.\n    function totalTips(Tips _tips) internal pure returns (uint96) {\n        // In practice there's no chance that the total tips value would not fit into uint96.\n        // TODO: determine if we want to use uint256 here instead anyway.\n        return notaryTip(_tips) + broadcasterTip(_tips) + proverTip(_tips) + executorTip(_tips);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           PRIVATE HELPERS                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /// @notice Returns a version field without checking if payload is properly formatted.\n    function _getVersion(bytes29 _view) private pure returns (uint16) {\n        return uint16(_view.indexUint(OFFSET_VERSION, 2));\n    }\n}\n\n/// @dev Message is a memory over over a formatted message payload.\ntype Message is bytes29;\n/// @dev Attach library functions to Message\nusing {\n    MessageLib.unwrap,\n    MessageLib.version,\n    MessageLib.header,\n    MessageLib.tips,\n    MessageLib.body,\n    MessageLib.leaf\n} for Message global;\n\n/**\n * @notice  Library for versioned formatting the messages used by Origin and Destination.\n */\nlibrary MessageLib {\n    using HeaderLib for bytes29;\n    using TipsLib for bytes29;\n    using ByteString for bytes;\n    using TypedMemView for bytes29;\n\n    enum Parts {\n        Version,\n        Header,\n        Tips,\n        Body\n    }\n\n    /**\n     * @dev This is only updated if the whole message structure is changed,\n     *      i.e. if a new part is added.\n     *      If already existing part is changed, the message version does not get bumped.\n     */\n    uint16 internal constant MESSAGE_VERSION = 1;\n\n    /**\n     * @dev Message memory layout\n     * [000 .. 002): version            uint16  2 bytes\n     * [002 .. 004): header length      uint16  2 bytes (length == AAA - 6)\n     * [004 .. 006): tips length        uint16  2 bytes (length == BBB - AAA)\n     * [006 .. AAA): header             bytes   ? bytes\n     * [AAA .. BBB): tips               bytes   ? bytes\n     * [BBB .. CCC): body               bytes   ? bytes (length could be zero)\n     */\n\n    uint256 internal constant OFFSET_VERSION = 0;\n\n    /// @dev How much bytes is used for storing the version, or a single offset value\n    uint8 internal constant TWO_BYTES = 2;\n    /// @dev This value reflects the header offset in the latest message version\n    uint16 internal constant OFFSET_HEADER = TWO_BYTES * uint8(type(Parts).max);\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns formatted message with provided fields\n     * @param _header       Formatted header payload\n     * @param _tips         Formatted tips payload\n     * @param _messageBody  Raw bytes of message body\n     * @return Formatted message\n     **/\n    function formatMessage(\n        bytes memory _header,\n        bytes memory _tips,\n        bytes memory _messageBody\n    ) internal pure returns (bytes memory) {\n        // Header and Tips are supposed to fit within 65535 bytes\n        return\n            abi.encodePacked(\n                MESSAGE_VERSION,\n                uint16(_header.length),\n                uint16(_tips.length),\n                _header,\n                _tips,\n                _messageBody\n            );\n    }\n\n    /**\n     * @notice Returns formatted message with provided fields\n     * @param _origin               Domain of origin chain\n     * @param _sender               Address that sent the message\n     * @param _nonce                Message nonce on origin chain\n     * @param _destination          Domain of destination chain\n     * @param _recipient            Address that will receive the message\n     * @param _optimisticSeconds    Optimistic period for message execution\n     * @param _tips                 Formatted tips payload\n     * @param _messageBody          Raw bytes of message body\n     * @return Formatted message\n     **/\n    function formatMessage(\n        uint32 _origin,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destination,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds,\n        bytes memory _tips,\n        bytes memory _messageBody\n    ) internal pure returns (bytes memory) {\n        return\n            formatMessage(\n                HeaderLib.formatHeader(\n                    _origin,\n                    _sender,\n                    _nonce,\n                    _destination,\n                    _recipient,\n                    _optimisticSeconds\n                ),\n                _tips,\n                _messageBody\n            );\n    }\n\n    /**\n     * @notice Returns a Message view over for the given payload.\n     * @dev Will revert if the payload is not a message payload.\n     */\n    function castToMessage(bytes memory _payload) internal pure returns (Message) {\n        return castToMessage(_payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a Message view.\n     * @dev Will revert if the memory view is not over a message payload.\n     */\n    function castToMessage(bytes29 _view) internal pure returns (Message) {\n        require(isMessage(_view), \"Not a message payload\");\n        return Message.wrap(_view);\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Message.\n     */\n    function isMessage(bytes29 _view) internal pure returns (bool) {\n        uint256 length = _view.len();\n        // Check if version and lengths exist in the payload\n        if (length \u003c OFFSET_HEADER) return false;\n        // Check message version\n        if (_getVersion(_view) != MESSAGE_VERSION) return false;\n\n        uint256 headerLength = _getLen(_view, Parts.Header);\n        uint256 tipsLength = _getLen(_view, Parts.Tips);\n        // Header and Tips need to exist\n        // Body could be empty, thus \u003e\n        if (OFFSET_HEADER + headerLength + tipsLength \u003e length) return false;\n\n        // Check header for being a formatted header payload\n        // Check tips for being a formatted tips payload\n        if (!_getHeader(_view).isHeader() || !_getTips(_view).isTips()) return false;\n        return true;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Message _msg) internal pure returns (bytes29) {\n        return Message.unwrap(_msg);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           MESSAGE SLICING                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /// @notice Returns message's version field.\n    function version(Message _msg) internal pure returns (uint16) {\n        // Get the underlying memory view\n        bytes29 _view = _msg.unwrap();\n        return _getVersion(_view);\n    }\n\n    /// @notice Returns message's header field as a Header view.\n    function header(Message _msg) internal pure returns (Header) {\n        bytes29 _view = _msg.unwrap();\n        return _getHeader(_view).castToHeader();\n    }\n\n    /// @notice Returns message's tips field as a Tips view.\n    function tips(Message _msg) internal pure returns (Tips) {\n        bytes29 _view = _msg.unwrap();\n        return _getTips(_view).castToTips();\n    }\n\n    /// @notice Returns message's body field as a generic memory view.\n    function body(Message _msg) internal pure returns (bytes29) {\n        bytes29 _view = _msg.unwrap();\n        // Determine index where message body payload starts\n        uint256 index = OFFSET_HEADER + _getLen(_view, Parts.Header) + _getLen(_view, Parts.Tips);\n        return _view.sliceFrom({ _index: index, newType: 0 });\n    }\n\n    /// @notice Returns message's hash: a leaf to be inserted in the Merkle tree.\n    function leaf(Message _msg) internal pure returns (bytes32) {\n        bytes29 _view = _msg.unwrap();\n        return _view.keccak();\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           PRIVATE HELPERS                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /// @dev Returns length for a given part of the message\n    /// without checking if the payload is properly formatted.\n    function _getLen(bytes29 _view, Parts _part) private pure returns (uint256) {\n        return _view.indexUint(uint256(_part) * TWO_BYTES, TWO_BYTES);\n    }\n\n    /// @dev Returns a version field without checking if the payload is properly formatted.\n    function _getVersion(bytes29 _view) private pure returns (uint16) {\n        return uint16(_view.indexUint(OFFSET_VERSION, 2));\n    }\n\n    /// @dev Returns a generic memory view over the header field without checking\n    /// if the whole payload or the header are properly formatted.\n    function _getHeader(bytes29 _view) private pure returns (bytes29) {\n        uint256 length = _getLen(_view, Parts.Header);\n        return _view.slice({ _index: OFFSET_HEADER, _len: length, newType: 0 });\n    }\n\n    /// @dev Returns a generic memory view over the tips field without checking\n    /// if the whole payload or the tips are properly formatted.\n    function _getTips(bytes29 _view) private pure returns (bytes29) {\n        // Determine index where tips payload starts\n        uint256 indexFrom = OFFSET_HEADER + _getLen(_view, Parts.Header);\n        uint256 length = _getLen(_view, Parts.Tips);\n        return _view.slice({ _index: indexFrom, _len: length, newType: 0 });\n    }\n}\n\n/**\n * @notice Exposes Message methods for testing against golang.\n */\ncontract MessageHarness {\n    using MessageLib for bytes;\n    using MessageLib for bytes29;\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                               GETTERS                                ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    function castToMessage(bytes memory _payload) public view returns (bytes memory) {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        Message _msg = MessageLib.castToMessage(_payload);\n        return _msg.unwrap().clone();\n    }\n\n    function header(bytes memory _payload) public view returns (bytes memory) {\n        return _payload.castToMessage().header().unwrap().clone();\n    }\n\n    function tips(bytes memory _payload) public view returns (bytes memory) {\n        return _payload.castToMessage().tips().unwrap().clone();\n    }\n\n    function body(bytes memory _payload) public view returns (bytes memory) {\n        return _payload.castToMessage().body().clone();\n    }\n\n    function version(bytes memory _payload) public pure returns (uint16) {\n        return _payload.castToMessage().version();\n    }\n\n    function leaf(bytes memory _payload) public pure returns (bytes32) {\n        return _payload.castToMessage().leaf();\n    }\n\n    function isMessage(bytes memory _payload) public pure returns (bool) {\n        return _payload.ref(0).isMessage();\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    function formatMessage(\n        uint32 _origin,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destination,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds,\n        // tips params\n        uint96 _notaryTip,\n        uint96 _broadcasterTip,\n        uint96 _proverTip,\n        uint96 _executorTip,\n        bytes memory _messageBody\n    ) public pure returns (bytes memory) {\n        bytes memory _tips = TipsLib.formatTips(\n            _notaryTip,\n            _broadcasterTip,\n            _proverTip,\n            _executorTip\n        );\n\n        bytes memory _header = HeaderLib.formatHeader(\n            _origin,\n            _sender,\n            _nonce,\n            _destination,\n            _recipient,\n            _optimisticSeconds\n        );\n        return formatMessage(_header, _tips, _messageBody);\n    }\n\n    function formatMessage(\n        uint32 _origin,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destination,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds,\n        bytes memory _tips,\n        bytes memory _messageBody\n    ) public pure returns (bytes memory) {\n        return\n            MessageLib.formatMessage(\n                _origin,\n                _sender,\n                _nonce,\n                _destination,\n                _recipient,\n                _optimisticSeconds,\n                _tips,\n                _messageBody\n            );\n    }\n\n    function formatMessage(\n        bytes memory _header,\n        bytes memory _tips,\n        bytes memory _messageBody\n    ) public pure returns (bytes memory) {\n        return MessageLib.formatMessage(_header, _tips, _messageBody);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           CONSTANT GETTERS                           ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    function messageVersion() public pure returns (uint16) {\n        return MessageLib.MESSAGE_VERSION;\n    }\n\n    function offsetVersion() public pure returns (uint256) {\n        return MessageLib.OFFSET_VERSION;\n    }\n\n    function offsetHeader() public pure returns (uint256) {\n        return MessageLib.OFFSET_HEADER;\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"44350:1110:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;44350:1110:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"44350:1110:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/MessageHarness.t.sol\":\"TypeCasts\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/MessageHarness.t.sol\":{\"keccak256\":\"0x3904cba9f384c6433257789b24cdb15655a5775a36df2c4c297958af081b2acc\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://eff1071fd96ffa0ae24c5a5d8de738a1545769b12ccc3c5ec469a9d7e16b21db\",\"dweb:/ipfs/QmYyQsoEqF9QJ5aHaVw5545ePNt9Z7GqXfVyCFGrEh4y84\"]}},\"version\":1}"},"hashes":{}},"solidity/MessageHarness.t.sol:TypedMemView":{"code":"0x6101f061003a600b82828239805160001a60731461002d57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600436106100ad5760003560e01c806397b8ad4a11610080578063eb74062811610065578063eb740628146100f8578063f26be3fc14610100578063fb734584146100f857600080fd5b806397b8ad4a146100cd578063b602d173146100e557600080fd5b806310153fce146100b25780631136e7ea146100cd57806313090c5a146100d55780631bfe17ce146100dd575b600080fd5b6100ba602881565b6040519081526020015b60405180910390f35b6100ba601881565b6100ba610158565b6100ba610172565b6100ba6bffffffffffffffffffffffff81565b6100ba606081565b6101277fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000081565b6040517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000090911681526020016100c4565b606061016581601861017a565b61016f919061017a565b81565b61016f606060185b808201808211156101b4577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b9291505056fea2646970667358221220ecba40e82ec47223b12176dad6289ca5402336fd3b8f732cb449412c08ff417f64736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600436106100ad5760003560e01c806397b8ad4a11610080578063eb74062811610065578063eb740628146100f8578063f26be3fc14610100578063fb734584146100f857600080fd5b806397b8ad4a146100cd578063b602d173146100e557600080fd5b806310153fce146100b25780631136e7ea146100cd57806313090c5a146100d55780631bfe17ce146100dd575b600080fd5b6100ba602881565b6040519081526020015b60405180910390f35b6100ba601881565b6100ba610158565b6100ba610172565b6100ba6bffffffffffffffffffffffff81565b6100ba606081565b6101277fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000081565b6040517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000090911681526020016100c4565b606061016581601861017a565b61016f919061017a565b81565b61016f606060185b808201808211156101b4577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b9291505056fea2646970667358221220ecba40e82ec47223b12176dad6289ca5402336fd3b8f732cb449412c08ff417f64736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nlibrary TypedMemView {\n    // Why does this exist?\n    // the solidity `bytes memory` type has a few weaknesses.\n    // 1. You can't index ranges effectively\n    // 2. You can't slice without copying\n    // 3. The underlying data may represent any type\n    // 4. Solidity never deallocates memory, and memory costs grow\n    //    superlinearly\n\n    // By using a memory view instead of a `bytes memory` we get the following\n    // advantages:\n    // 1. Slices are done on the stack, by manipulating the pointer\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\n    // 3. We can insert type info into the pointer, and typecheck at runtime\n\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\n    // algorithms.\n\n    // Why bytes29?\n    // We want to avoid confusion between views, digests, and other common\n    // types so we chose a large and uncommonly used odd number of bytes\n    //\n    // Note that while bytes are left-aligned in a word, integers and addresses\n    // are right-aligned. This means when working in assembly we have to\n    // account for the 3 unused bytes on the righthand side\n    //\n    // First 5 bytes are a type flag.\n    // - ff_ffff_fffe is reserved for unknown type.\n    // - ff_ffff_ffff is reserved for invalid types/errors.\n    // next 12 are memory address\n    // next 12 are len\n    // bottom 3 bytes are empty\n\n    // Assumptions:\n    // - non-modification of memory.\n    // - No Solidity updates\n    // - - wrt free mem point\n    // - - wrt bytes representation in memory\n    // - - wrt memory addressing in general\n\n    // Usage:\n    // - create type constants\n    // - use `assertType` for runtime type assertions\n    // - - unfortunately we can't do this at compile time yet :(\n    // - recommended: implement modifiers that perform type checking\n    // - - e.g.\n    // - - `uint40 constant MY_TYPE = 3;`\n    // - - ` modifier onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n    // - instantiate a typed view from a bytearray using `ref`\n    // - use `index` to inspect the contents of the view\n    // - use `slice` to create smaller views into the same memory\n    // - - `slice` can increase the offset\n    // - - `slice can decrease the length`\n    // - - must specify the output type of `slice`\n    // - - `slice` will return a null view if you try to overrun\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\n    // - use `equal` for typed comparisons.\n\n    // The null view\n    bytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n\n    /**\n     * @dev Memory layout for bytes29\n     * TODO (Chi): with the user defined types storing type is no longer necessary.\n     * Update the library, transforming bytes29 to bytes24 in the process.\n     * [000..005)   type     5 bytes    Type flag for the pointer\n     * [005..017)   loc     12 bytes    Memory address of underlying bytes\n     * [017..029)   len     12 bytes    Length of underlying bytes\n     * [029..032)   empty    3 bytes    Not used\n     */\n    uint256 public constant BITS_TYPE = 40;\n    uint256 public constant BITS_LOC = 96;\n    uint256 public constant BITS_LEN = 96;\n    uint256 public constant BITS_EMPTY = 24;\n\n    // `SHIFT_X` is how much bits to shift for `X` to be in the very bottom bits\n    uint256 public constant SHIFT_LEN = BITS_EMPTY; // 24\n    uint256 public constant SHIFT_LOC = SHIFT_LEN + BITS_LEN; // 24 + 96 = 120\n    uint256 public constant SHIFT_TYPE = SHIFT_LOC + BITS_LOC; // 24 + 96 + 96 = 216\n    // Bitmask for the lowest 96 bits\n    uint256 public constant LOW_96_BITS_MASK = type(uint96).max;\n\n    // For nibble encoding\n    bytes private constant NIBBLE_LOOKUP = \"0123456789abcdef\";\n\n    /**\n     * @notice Returns the encoded hex character that represents the lower 4 bits of the argument.\n     * @param _byte     The byte\n     * @return _char    The encoded hex character\n     */\n    function nibbleHex(uint8 _byte) internal pure returns (uint8 _char) {\n        uint8 _nibble = _byte \u0026 0x0f; // keep bottom 4 bits, zero out top 4 bits\n        _char = uint8(NIBBLE_LOOKUP[_nibble]);\n    }\n\n    /**\n     * @notice      Returns a uint16 containing the hex-encoded byte.\n     * @param _b    The byte\n     * @return      encoded - The hex-encoded byte\n     */\n    function byteHex(uint8 _b) internal pure returns (uint16 encoded) {\n        encoded |= nibbleHex(_b \u003e\u003e 4); // top 4 bits\n        encoded \u003c\u003c= 8;\n        encoded |= nibbleHex(_b); // lower 4 bits\n    }\n\n    /**\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\n     *              `second` contains the encoded lower 16 bytes.\n     *\n     * @param _b    The 32 bytes as uint256\n     * @return      first - The top 16 bytes\n     * @return      second - The bottom 16 bytes\n     */\n    function encodeHex(uint256 _b) internal pure returns (uint256 first, uint256 second) {\n        for (uint8 i = 31; i \u003e 15; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            first |= byteHex(_byte);\n            if (i != 16) {\n                first \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n\n        // abusing underflow here =_=\n        for (uint8 i = 15; i \u003c 255; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            second |= byteHex(_byte);\n            if (i != 0) {\n                second \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n    }\n\n    /**\n     * @notice          Changes the endianness of a uint256.\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n     * @param _b        The unsigned integer to reverse\n     * @return          v - The reversed value\n     */\n    function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\n        v = _b;\n\n        // swap bytes\n        v =\n            ((v \u003e\u003e 8) \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\n            ((v \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) \u003c\u003c 8);\n        // swap 2-byte long pairs\n        v =\n            ((v \u003e\u003e 16) \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\n            ((v \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) \u003c\u003c 16);\n        // swap 4-byte long pairs\n        v =\n            ((v \u003e\u003e 32) \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\n            ((v \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) \u003c\u003c 32);\n        // swap 8-byte long pairs\n        v =\n            ((v \u003e\u003e 64) \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\n            ((v \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) \u003c\u003c 64);\n        // swap 16-byte long pairs\n        v = (v \u003e\u003e 128) | (v \u003c\u003c 128);\n    }\n\n    /**\n     * @notice      Create a mask with the highest `_len` bits set.\n     * @param _len  The length\n     * @return      mask - The mask\n     */\n    function leftMask(uint8 _len) private pure returns (uint256 mask) {\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(\n                sub(_len, 1),\n                0x8000000000000000000000000000000000000000000000000000000000000000\n            )\n        }\n    }\n\n    /**\n     * @notice      Return the null view.\n     * @return      bytes29 - The null view\n     */\n    // solhint-disable-next-line ordering\n    function nullView() internal pure returns (bytes29) {\n        return NULL;\n    }\n\n    /**\n     * @notice      Check if the view is null.\n     * @return      bool - True if the view is null\n     */\n    function isNull(bytes29 memView) internal pure returns (bool) {\n        return memView == NULL;\n    }\n\n    /**\n     * @notice      Check if the view is not null.\n     * @return      bool - True if the view is not null\n     */\n    function notNull(bytes29 memView) internal pure returns (bool) {\n        return !isNull(memView);\n    }\n\n    /**\n     * @notice          Check if the view is of a valid type and points to a valid location\n     *                  in memory.\n     * @dev             We perform this check by examining solidity's unallocated memory\n     *                  pointer and ensuring that the view's upper bound is less than that.\n     * @param memView   The view\n     * @return          ret - True if the view is valid\n     */\n    function isValid(bytes29 memView) internal pure returns (bool ret) {\n        if (typeOf(memView) == 0xffffffffff) {\n            return false;\n        }\n        uint256 _end = end(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // View is valid if (\"upper bound\" \u003c= \"unallocated memory pointer\")\n            // Upper bound is exclusive, hence \"\u003c=\"\n            ret := not(gt(_end, mload(0x40)))\n        }\n    }\n\n    /**\n     * @notice          Require that a typed memory view be valid.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @return          bytes29 - The validated view\n     */\n    function assertValid(bytes29 memView) internal pure returns (bytes29) {\n        require(isValid(memView), \"Validity assertion failed\");\n        return memView;\n    }\n\n    /**\n     * @notice          Return true if the memview is of the expected type. Otherwise false.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bool - True if the memview is of the expected type\n     */\n    function isType(bytes29 memView, uint40 _expected) internal pure returns (bool) {\n        return typeOf(memView) == _expected;\n    }\n\n    /**\n     * @notice          Require that a typed memory view has a specific type.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bytes29 - The view with validated type\n     */\n    function assertType(bytes29 memView, uint40 _expected) internal pure returns (bytes29) {\n        if (!isType(memView, _expected)) {\n            (, uint256 g) = encodeHex(uint256(typeOf(memView)));\n            (, uint256 e) = encodeHex(uint256(_expected));\n            string memory err = string(\n                abi.encodePacked(\n                    \"Type assertion failed. Got 0x\",\n                    uint80(g),\n                    \". Expected 0x\",\n                    uint80(e)\n                )\n            );\n            revert(err);\n        }\n        return memView;\n    }\n\n    /**\n     * @notice          Return an identical view with a different type.\n     * @param memView   The view\n     * @param _newType  The new type\n     * @return          newView - The new view with the specified type\n     */\n    function castTo(bytes29 memView, uint40 _newType) internal pure returns (bytes29 newView) {\n        // How many bits are the \"type bits\" occupying\n        uint256 _bitsType = BITS_TYPE;\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 _shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // shift off the \"type bits\" (shift left, then sift right)\n            newView := or(newView, shr(_bitsType, shl(_bitsType, memView)))\n            // set the new \"type bits\" (shift left, then OR)\n            newView := or(newView, shl(_shiftType, _newType))\n        }\n    }\n\n    /**\n     * @notice          Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function unsafeBuildUnchecked(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) private pure returns (bytes29 newView) {\n        uint256 _bitsLoc = BITS_LOC;\n        uint256 _bitsLen = BITS_LEN;\n        uint256 _bitsEmpty = BITS_EMPTY;\n        // Ref memory layout\n        // [000..005) 5 bytes of type\n        // [005..017) 12 bytes of location\n        // [017..029) 12 bytes of length\n        // last 3 bits are blank and dropped in typecast\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // insert `type`, shift to prepare empty bits for `loc`\n            newView := shl(_bitsLoc, or(newView, _type))\n            // insert `loc`, shift to prepare empty bits for `len`\n            newView := shl(_bitsLen, or(newView, _loc))\n            // insert `len`, shift to insert 3 blank lowest bits\n            newView := shl(_bitsEmpty, or(newView, _len))\n        }\n    }\n\n    /**\n     * @notice          Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function build(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) internal pure returns (bytes29 newView) {\n        uint256 _end = _loc + _len;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(_end, mload(0x40)) {\n                _end := 0\n            }\n        }\n        if (_end == 0) {\n            return NULL;\n        }\n        newView = unsafeBuildUnchecked(_type, _loc, _len);\n    }\n\n    /**\n     * @notice          Instantiate a memory view from a byte array.\n     * @dev             Note that due to Solidity memory representation, it is not possible to\n     *                  implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr       The byte array\n     * @param newType   The type\n     * @return          bytes29 - The memory view\n     */\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\n        uint256 _len = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 _loc;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            _loc := add(arr, 0x20)\n        }\n\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Return the associated type information.\n     * @param memView   The memory view\n     * @return          _type - The type associated with the view\n     */\n    function typeOf(bytes29 memView) internal pure returns (uint40 _type) {\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 _shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"type bits\". \"type bits\" are occupying\n            // the highest bits, so all that's left is \"type bits\", OR is not required.\n            _type := shr(_shiftType, memView)\n        }\n    }\n\n    /**\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the 5-byte type flag is equal\n     */\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\n        // Check that the highest 5 bytes are equal: xor and shift out lower 27 bytes\n        return (left ^ right) \u003e\u003e SHIFT_TYPE == 0;\n    }\n\n    /**\n     * @notice          Return the memory address of the underlying bytes.\n     * @param memView   The view\n     * @return          _loc - The memory address\n     */\n    function loc(bytes29 memView) internal pure returns (uint96 _loc) {\n        // How many bits are the \"loc bits\" shifted from the bottom\n        uint256 _shiftLoc = SHIFT_LOC;\n        // Mask for the bottom 96 bits\n        uint256 _uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"loc bits\".\n            // Then use the lowest 96 bits to determine `loc` by applying the bit-mask.\n            _loc := and(shr(_shiftLoc, memView), _uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          The number of memory words this memory view occupies, rounded up.\n     * @param memView   The view\n     * @return          uint256 - The number of memory words\n     */\n    function words(bytes29 memView) internal pure returns (uint256) {\n        // returning ceil(length / 32.0)\n        return (uint256(len(memView)) + 31) / 32;\n    }\n\n    /**\n     * @notice          The in-memory footprint of a fresh copy of the view.\n     * @param memView   The view\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(bytes29 memView) internal pure returns (uint256) {\n        return words(memView) * 32;\n    }\n\n    /**\n     * @notice          The number of bytes of the view.\n     * @param memView   The view\n     * @return          _len - The length of the view\n     */\n    function len(bytes29 memView) internal pure returns (uint96 _len) {\n        // How many bits are the \"len bits\" shifted from the bottom\n        uint256 _shiftLen = SHIFT_LEN;\n        // Mask for the bottom 96 bits\n        uint256 _uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"len bits\".\n            // Then use the lowest 96 bits to determine `len` by applying the bit-mask.\n            _len := and(shr(_shiftLen, memView), _uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          Returns the endpoint of `memView`.\n     * @param memView   The view\n     * @return          uint256 - The endpoint of `memView`\n     */\n    function end(bytes29 memView) internal pure returns (uint256) {\n        unchecked {\n            return loc(memView) + len(memView);\n        }\n    }\n\n    /**\n     * @notice          Safe slicing without memory modification.\n     * @param memView   The view\n     * @param _index    The start index\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function slice(\n        bytes29 memView,\n        uint256 _index,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        uint256 _loc = loc(memView);\n\n        // Ensure it doesn't overrun the view\n        if (_loc + _index + _len \u003e end(memView)) {\n            return NULL;\n        }\n\n        _loc = _loc + _index;\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing\n     *                  bytes from `_index` to end(memView).\n     * @param memView   The view\n     * @param _index    The start index\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function sliceFrom(\n        bytes29 memView,\n        uint256 _index,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, _index, len(memView) - _index, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the first `_len` bytes.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function prefix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, 0, _len, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the last `_len` byte.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function postfix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, uint256(len(memView)) - _len, _len, newType);\n    }\n\n    /**\n     * @notice          Construct an error message for an indexing overrun.\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @param _index    The index\n     * @param _slice    The slice where the overrun occurred\n     * @return          err - The err\n     */\n    function indexErrOverrun(\n        uint256 _loc,\n        uint256 _len,\n        uint256 _index,\n        uint256 _slice\n    ) internal pure returns (string memory err) {\n        (, uint256 a) = encodeHex(_loc);\n        (, uint256 b) = encodeHex(_len);\n        (, uint256 c) = encodeHex(_index);\n        (, uint256 d) = encodeHex(_slice);\n        err = string(\n            abi.encodePacked(\n                \"TypedMemView/index - Overran the view. Slice is at 0x\",\n                uint48(a),\n                \" with length 0x\",\n                uint48(b),\n                \". Attempted to index at offset 0x\",\n                uint48(c),\n                \" with length 0x\",\n                uint48(d),\n                \".\"\n            )\n        );\n    }\n\n    /**\n     * @notice          Load up to 32 bytes from the view onto the stack.\n     * @dev             Returns a bytes32 with only the `_bytes` highest bytes set.\n     *                  This can be immediately cast to a smaller fixed-length byte array.\n     *                  To automatically cast to an integer, use `indexUint`.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The 32 byte result\n     */\n    function index(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (bytes32 result) {\n        if (_bytes == 0) {\n            return bytes32(0);\n        }\n        if (_index + _bytes \u003e len(memView)) {\n            revert(indexErrOverrun(loc(memView), len(memView), _index, uint256(_bytes)));\n        }\n        require(_bytes \u003c= 32, \"Index: more than 32 bytes\");\n\n        uint8 bitLength;\n        unchecked {\n            bitLength = _bytes * 8;\n        }\n        uint256 _loc = loc(memView);\n        // Get a mask with `bitLength` highest bits set\n        uint256 _mask = leftMask(bitLength);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(_loc, _index)), _mask)\n        }\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from the view at `_index`.\n     * @dev             Requires that the view have \u003e= `_bytes` bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        // `index()` returns left-aligned `_bytes`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word\n        return uint256(index(memView, _index, _bytes)) \u003e\u003e ((32 - _bytes) * 8);\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from LE bytes.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexLEUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return reverseUint256(uint256(index(memView, _index, _bytes)));\n    }\n\n    /**\n     * @notice          Parse an address from the view at `_index`.\n     *                  Requires that the view have \u003e= 20 bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @return          address - The address\n     */\n    function indexAddress(bytes29 memView, uint256 _index) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(indexUint(memView, _index, 20)));\n    }\n\n    /**\n     * @notice          Return the keccak256 hash of the underlying memory\n     * @param memView   The view\n     * @return          digest - The keccak256 hash of the underlying memory\n     */\n    function keccak(bytes29 memView) internal pure returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(_loc, _len)\n        }\n    }\n\n    /**\n     * @notice          Return the sha2 digest of the underlying memory.\n     * @dev             We explicitly deallocate memory afterwards.\n     * @param memView   The view\n     * @return          digest - The sha2 hash of the underlying memory\n     */\n    function sha2(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            digest := mload(ptr)\n        }\n        require(res, \"sha2: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n     * @param memView   The pre-image\n     * @return          digest - the Digest\n     */\n    function hash160(bytes29 memView) internal view returns (bytes20 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            // rmd160 precompile is 0x03\n            res := and(res, staticcall(gas(), 0x03, ptr, 0x20, ptr, 0x20))\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\n        }\n        require(res, \"hash160: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash256 (double sha2)\n     * @param memView   A view of the preimage\n     * @return          digest - the Digest\n     */\n    function hash256(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            res := and(res, staticcall(gas(), 0x02, ptr, 0x20, ptr, 0x20))\n            digest := mload(ptr)\n        }\n        require(res, \"hash256: out of gas\");\n    }\n\n    /**\n     * @notice          Return true if the underlying memory is equal. Else false.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the underlying memory is equal\n     */\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return\n            (loc(left) == loc(right) \u0026\u0026 len(left) == len(right)) || keccak(left) == keccak(right);\n    }\n\n    /**\n     * @notice          Return false if the underlying memory is equal. Else true.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - False if the underlying memory is equal\n     */\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !untypedEqual(left, right);\n    }\n\n    /**\n     * @notice          Compares type equality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are the same\n     */\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return left == right || (typeOf(left) == typeOf(right) \u0026\u0026 keccak(left) == keccak(right));\n    }\n\n    /**\n     * @notice          Compares type inequality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are not the same\n     */\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !equal(left, right);\n    }\n\n    /**\n     * @notice          Copy the view to a location, return an unsafe memory reference\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memView   The view\n     * @param _newLoc   The new location\n     * @return          written - the unsafe memory reference\n     */\n    function unsafeCopyTo(bytes29 memView, uint256 _newLoc) private view returns (bytes29 written) {\n        require(notNull(memView), \"copyTo: Null pointer deref\");\n        require(isValid(memView), \"copyTo: Invalid pointer deref\");\n        uint256 _len = len(memView);\n        uint256 _oldLoc = loc(memView);\n\n        uint256 ptr;\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _newLoc) {\n                revert(0x60, 0x20) // empty revert message\n            }\n\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, _oldLoc, _len, _newLoc, _len)\n        }\n        require(res, \"identity: out of gas\");\n\n        written = unsafeBuildUnchecked(typeOf(memView), _newLoc, _len);\n    }\n\n    /**\n     * @notice          Copies the referenced memory to a new loc in memory,\n     *                  returning a `bytes` pointing to the new memory.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param memView   The view\n     * @return          ret - The view pointing to the new memory\n     */\n    function clone(bytes29 memView) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n            ret := ptr\n        }\n        unchecked {\n            unsafeCopyTo(memView, ptr + 0x20);\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mstore(0x40, add(add(ptr, _len), 0x20)) // write new unused pointer\n            mstore(ptr, _len) // write len of new array (in bytes)\n        }\n    }\n\n    /**\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memViews  The views\n     * @return          unsafeView - The conjoined view pointing to the new memory\n     */\n    function unsafeJoin(bytes29[] memory memViews, uint256 _location)\n        private\n        view\n        returns (bytes29 unsafeView)\n    {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _location) {\n                revert(0x60, 0x20) // empty revert message\n            }\n        }\n\n        uint256 _offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length; i++) {\n            bytes29 memView = memViews[i];\n            unchecked {\n                unsafeCopyTo(memView, _location + _offset);\n                _offset += len(memView);\n            }\n        }\n        unsafeView = unsafeBuildUnchecked(0, _location, _offset);\n    }\n\n    /**\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The keccak256 digest\n     */\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return keccak(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The sha256 digest\n     */\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return sha2(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          copies all views, joins them into a new bytearray.\n     * @param memViews  The views\n     * @return          ret - The new byte array\n     */\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n\n        bytes29 _newView;\n        unchecked {\n            _newView = unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 _written = len(_newView);\n        uint256 _footprint = footprint(_newView);\n\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // store the length\n            mstore(ptr, _written)\n            // new pointer is old + 0x20 + the footprint of the body\n            mstore(0x40, add(add(ptr, _footprint), 0x20))\n            ret := ptr\n        }\n    }\n}\n\n/// @dev CallData is a memory view over the payload to be used for an external call, i.e.\n/// recipient.call(callData). Its length is always (4 + 32 * N) bytes:\n/// - First 4 bytes represent the function selector.\n/// - 32 * N bytes represent N words that function arguments occupy.\ntype CallData is bytes29;\n/// @dev Signature is a memory view over a \"65 bytes\" array representing a ECDSA signature.\ntype Signature is bytes29;\n\nlibrary ByteString {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev non-compact ECDSA signatures are enforced as of OZ 4.7.3\n     *\n     *      Signature payload memory layout\n     * [000 .. 032) r   bytes32 32 bytes\n     * [032 .. 064) s   bytes32 32 bytes\n     * [064 .. 065) v   uint8    1 byte\n     */\n    uint256 internal constant SIGNATURE_LENGTH = 65;\n    uint256 internal constant OFFSET_R = 0;\n    uint256 internal constant OFFSET_S = 32;\n    uint256 internal constant OFFSET_V = 64;\n\n    /**\n     * @dev Calldata memory layout\n     * [000 .. 004) selector    bytes4  4 bytes\n     *      Optional: N function arguments\n     * [004 .. 036) arg1        bytes32 32 bytes\n     *      ..\n     * [AAA .. END) argN        bytes32 32 bytes\n     */\n    uint256 internal constant SELECTOR_LENGTH = 4;\n    uint256 internal constant OFFSET_SELECTOR = 0;\n    uint256 internal constant OFFSET_ARGUMENTS = SELECTOR_LENGTH;\n\n    /**\n     * @notice Returns a memory view over the given payload, treating it as raw bytes.\n     * @dev Shortcut for .ref(0) - to be deprecated once \"uint40 type\" is removed from bytes29.\n     */\n    function castToRawBytes(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref({ newType: 0 });\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              SIGNATURE                               ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Constructs the signature payload from the given values.\n     * @dev Using ByteString.formatSignature({r: r, s: s, v: v}) will make sure\n     * that params are given in the right order.\n     */\n    function formatSignature(\n        bytes32 r,\n        bytes32 s,\n        uint8 v\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(r, s, v);\n    }\n\n    /**\n     * @notice Returns a Signature view over for the given payload.\n     * @dev Will revert if the payload is not a signature.\n     */\n    function castToSignature(bytes memory _payload) internal pure returns (Signature) {\n        return castToSignature(castToRawBytes(_payload));\n    }\n\n    /**\n     * @notice Casts a memory view to a Signature view.\n     * @dev Will revert if the memory view is not over a signature.\n     */\n    function castToSignature(bytes29 _view) internal pure returns (Signature) {\n        require(isSignature(_view), \"Not a signature\");\n        return Signature.wrap(_view);\n    }\n\n    /**\n     * @notice Checks that a byte string is a signature\n     */\n    function isSignature(bytes29 _view) internal pure returns (bool) {\n        return _view.len() == SIGNATURE_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Signature _signature) internal pure returns (bytes29) {\n        return Signature.unwrap(_signature);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                          SIGNATURE SLICING                           ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /// @notice Unpacks signature payload into (r, s, v) parameters.\n    /// @dev Make sure to verify signature length with isSignature() beforehand.\n    function toRSV(Signature _signature)\n        internal\n        pure\n        returns (\n            bytes32 r,\n            bytes32 s,\n            uint8 v\n        )\n    {\n        // Get the underlying memory view\n        bytes29 _view = unwrap(_signature);\n        r = _view.index({ _index: OFFSET_R, _bytes: 32 });\n        s = _view.index({ _index: OFFSET_S, _bytes: 32 });\n        v = uint8(_view.indexUint({ _index: OFFSET_V, _bytes: 1 }));\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                               CALLDATA                               ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns a CallData view over for the given payload.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(bytes memory _payload) internal pure returns (CallData) {\n        return castToCallData(castToRawBytes(_payload));\n    }\n\n    /**\n     * @notice Casts a memory view to a CallData view.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(bytes29 _view) internal pure returns (CallData) {\n        require(isCallData(_view), \"Not a calldata\");\n        return CallData.wrap(_view);\n    }\n\n    /**\n     * @notice Checks that a byte string is a valid calldata, i.e.\n     * a function selector, followed by arbitrary amount of arguments.\n     */\n    function isCallData(bytes29 _view) internal pure returns (bool) {\n        uint256 length = _view.len();\n        // Calldata should at least have a function selector\n        if (length \u003c SELECTOR_LENGTH) return false;\n        // The remainder of the calldata should be exactly N words (N \u003e= 0), i.e.\n        // (length - SELECTOR_LENGTH) % 32 == 0\n        // We're using logical AND here to speed it up a bit\n        return (length - SELECTOR_LENGTH) \u0026 31 == 0;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(CallData _callData) internal pure returns (bytes29) {\n        return CallData.unwrap(_callData);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           CALLDATA SLICING                           ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns amount of memory words (32 byte chunks) the function arguments\n     * occupy in the calldata.\n     * @dev This might differ from amount of arguments supplied, if any of the arguments\n     * occupies more than one memory slot. It is true, however, that argument part of the payload\n     * occupies exactly N words, even for dynamic types like `bytes`\n     */\n    function argumentWords(CallData _callData) internal pure returns (uint256) {\n        // Get the underlying memory view\n        bytes29 _view = unwrap(_callData);\n        // Equivalent of (length - SELECTOR_LENGTH) / 32\n        return (_view.len() - SELECTOR_LENGTH) \u003e\u003e 5;\n    }\n\n    /// @notice Returns selector for the provided calldata.\n    function callSelector(CallData _callData) internal pure returns (bytes29) {\n        // Get the underlying memory view\n        bytes29 _view = unwrap(_callData);\n        return _view.slice({ _index: OFFSET_SELECTOR, _len: SELECTOR_LENGTH, newType: 0 });\n    }\n\n    /// @notice Returns abi encoded arguments for the provided calldata.\n    function arguments(CallData _callData) internal pure returns (bytes29) {\n        // Get the underlying memory view\n        bytes29 _view = unwrap(_callData);\n        return _view.sliceFrom({ _index: OFFSET_ARGUMENTS, newType: 0 });\n    }\n}\n\nlibrary TypeCasts {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    function coerceBytes32(string memory _s) internal pure returns (bytes32 _b) {\n        _b = bytes(_s).ref(0).index(0, uint8(bytes(_s).length));\n    }\n\n    // treat it as a null-terminated string of max 32 bytes\n    function coerceString(bytes32 _buf) internal pure returns (string memory _newStr) {\n        uint8 _slen = 0;\n        while (_slen \u003c 32 \u0026\u0026 _buf[_slen] != 0) {\n            _slen++;\n        }\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            _newStr := mload(0x40)\n            mstore(0x40, add(_newStr, 0x40)) // may end up with extra\n            mstore(_newStr, _slen)\n            mstore(add(_newStr, 0x20), _buf)\n        }\n    }\n\n    // alignment preserving cast\n    function addressToBytes32(address _addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(_addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 _buf) internal pure returns (address) {\n        return address(uint160(uint256(_buf)));\n    }\n}\n\n/// @dev Header is a memory over over a formatted message header payload.\ntype Header is bytes29;\n/// @dev Attach library functions to Header\nusing {\n    HeaderLib.unwrap,\n    HeaderLib.version,\n    HeaderLib.origin,\n    HeaderLib.sender,\n    HeaderLib.nonce,\n    HeaderLib.destination,\n    HeaderLib.recipient,\n    HeaderLib.optimisticSeconds,\n    HeaderLib.recipientAddress\n} for Header global;\n\n/**\n * @notice Library for versioned formatting [the header part]\n * of [the messages used by Origin and Destination].\n */\nlibrary HeaderLib {\n    using ByteString for bytes;\n    using TypedMemView for bytes29;\n\n    uint16 internal constant HEADER_VERSION = 1;\n\n    /**\n     * @dev Header memory layout\n     * [000 .. 002): version            uint16   2 bytes\n     * [002 .. 006): origin             uint32   4 bytes\n     * [006 .. 038): sender             bytes32 32 bytes\n     * [038 .. 042): nonce              uint32   4 bytes\n     * [042 .. 046): destination        uint32   4 bytes\n     * [046 .. 078): recipient          bytes32 32 bytes\n     * [078 .. 082): optimisticSeconds  uint32   4 bytes\n     */\n\n    uint256 internal constant OFFSET_VERSION = 0;\n    uint256 internal constant OFFSET_ORIGIN = 2;\n    uint256 internal constant OFFSET_SENDER = 6;\n    uint256 internal constant OFFSET_NONCE = 38;\n    uint256 internal constant OFFSET_DESTINATION = 42;\n    uint256 internal constant OFFSET_RECIPIENT = 46;\n    uint256 internal constant OFFSET_OPTIMISTIC_SECONDS = 78;\n\n    uint256 internal constant HEADER_LENGTH = 82;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns a formatted Header payload with provided fields\n     * @param _origin               Domain of origin chain\n     * @param _sender               Address that sent the message\n     * @param _nonce                Message nonce on origin chain\n     * @param _destination          Domain of destination chain\n     * @param _recipient            Address that will receive the message\n     * @param _optimisticSeconds    Optimistic period for message execution\n     * @return Formatted header\n     **/\n    function formatHeader(\n        uint32 _origin,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destination,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodePacked(\n                HEADER_VERSION,\n                _origin,\n                _sender,\n                _nonce,\n                _destination,\n                _recipient,\n                _optimisticSeconds\n            );\n    }\n\n    /**\n     * @notice Returns a Header view over for the given payload.\n     * @dev Will revert if the payload is not a header payload.\n     */\n    function castToHeader(bytes memory _payload) internal pure returns (Header) {\n        return castToHeader(_payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a Header view.\n     * @dev Will revert if the memory view is not over a header payload.\n     */\n    function castToHeader(bytes29 _view) internal pure returns (Header) {\n        require(isHeader(_view), \"Not a header payload\");\n        return Header.wrap(_view);\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Header.\n     */\n    function isHeader(bytes29 _view) internal pure returns (bool) {\n        uint256 length = _view.len();\n        // Check if version exists in the payload\n        if (length \u003c 2) return false;\n        // Check that header version and its length matches\n        return _getVersion(_view) == HEADER_VERSION \u0026\u0026 length == HEADER_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Header _header) internal pure returns (bytes29) {\n        return Header.unwrap(_header);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                            HEADER SLICING                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /// @notice Returns header's version field.\n    function version(Header _header) internal pure returns (uint16) {\n        // Get the underlying memory view\n        bytes29 _view = unwrap(_header);\n        return _getVersion(_view);\n    }\n\n    /// @notice Returns header's origin field\n    function origin(Header _header) internal pure returns (uint32) {\n        bytes29 _view = unwrap(_header);\n        return uint32(_view.indexUint(OFFSET_ORIGIN, 4));\n    }\n\n    /// @notice Returns header's sender field\n    function sender(Header _header) internal pure returns (bytes32) {\n        bytes29 _view = unwrap(_header);\n        return _view.index(OFFSET_SENDER, 32);\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(Header _header) internal pure returns (uint32) {\n        bytes29 _view = unwrap(_header);\n        return uint32(_view.indexUint(OFFSET_NONCE, 4));\n    }\n\n    /// @notice Returns header's destination field\n    function destination(Header _header) internal pure returns (uint32) {\n        bytes29 _view = unwrap(_header);\n        return uint32(_view.indexUint(OFFSET_DESTINATION, 4));\n    }\n\n    /// @notice Returns header's recipient field as bytes32\n    function recipient(Header _header) internal pure returns (bytes32) {\n        bytes29 _view = unwrap(_header);\n        return _view.index(OFFSET_RECIPIENT, 32);\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticSeconds(Header _header) internal pure returns (uint32) {\n        bytes29 _view = unwrap(_header);\n        return uint32(_view.indexUint(OFFSET_OPTIMISTIC_SECONDS, 4));\n    }\n\n    /// @notice Returns header's recipient field as an address\n    function recipientAddress(Header _header) internal pure returns (address) {\n        return TypeCasts.bytes32ToAddress(recipient(_header));\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           PRIVATE HELPERS                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /// @notice Returns a version field without checking if payload is properly formatted.\n    function _getVersion(bytes29 _view) internal pure returns (uint16) {\n        return uint16(_view.indexUint(OFFSET_VERSION, 2));\n    }\n}\n\n/// @dev Tips is a memory over over a formatted message tips payload.\ntype Tips is bytes29;\n/// @dev Attach library functions to Tips\nusing {\n    TipsLib.unwrap,\n    TipsLib.version,\n    TipsLib.notaryTip,\n    TipsLib.broadcasterTip,\n    TipsLib.proverTip,\n    TipsLib.executorTip,\n    TipsLib.totalTips\n} for Tips global;\n\n/**\n * @notice Library for versioned formatting [the tips part]\n * of [the messages used by Origin and Destination].\n */\nlibrary TipsLib {\n    using ByteString for bytes;\n    using TypedMemView for bytes29;\n\n    uint16 internal constant TIPS_VERSION = 1;\n\n    // TODO: determine if we need to pack the tips values,\n    // or if using uint256 instead will suffice.\n\n    /**\n     * @dev Tips memory layout\n     * [000 .. 002): version            uint16\t 2 bytes\n     * [002 .. 014): notaryTip          uint96\t12 bytes\n     * [014 .. 026): broadcasterTip     uint96\t12 bytes\n     * [026 .. 038): proverTip          uint96\t12 bytes\n     * [038 .. 050): executorTip        uint96\t12 bytes\n     */\n\n    uint256 internal constant OFFSET_VERSION = 0;\n    uint256 internal constant OFFSET_NOTARY = 2;\n    uint256 internal constant OFFSET_BROADCASTER = 14;\n    uint256 internal constant OFFSET_PROVER = 26;\n    uint256 internal constant OFFSET_EXECUTOR = 38;\n\n    uint256 internal constant TIPS_LENGTH = 50;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                                 TIPS                                 ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns a formatted Tips payload with provided fields\n     * @param _notaryTip        Tip for the Notary\n     * @param _broadcasterTip   Tip for the Broadcaster\n     * @param _proverTip        Tip for the Prover\n     * @param _executorTip      Tip for the Executor\n     * @return Formatted tips\n     **/\n    function formatTips(\n        uint96 _notaryTip,\n        uint96 _broadcasterTip,\n        uint96 _proverTip,\n        uint96 _executorTip\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodePacked(TIPS_VERSION, _notaryTip, _broadcasterTip, _proverTip, _executorTip);\n    }\n\n    /**\n     * @notice Returns a formatted Tips payload specifying empty tips.\n     * @return Formatted tips\n     **/\n    function emptyTips() internal pure returns (bytes memory) {\n        return formatTips(0, 0, 0, 0);\n    }\n\n    /**\n     * @notice Returns a Tips view over for the given payload.\n     * @dev Will revert if the payload is not a tips payload.\n     */\n    function castToTips(bytes memory _payload) internal pure returns (Tips) {\n        return castToTips(_payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a Tips view.\n     * @dev Will revert if the memory view is not over a tips payload.\n     */\n    function castToTips(bytes29 _view) internal pure returns (Tips) {\n        require(isTips(_view), \"Not a tips payload\");\n        return Tips.wrap(_view);\n    }\n\n    /// @notice Checks that a payload is a formatted Tips payload.\n    function isTips(bytes29 _view) internal pure returns (bool) {\n        uint256 length = _view.len();\n        // Check if version exists in the payload\n        if (length \u003c OFFSET_NOTARY) return false;\n        // Check that tips version and its length matches\n        return _getVersion(_view) == TIPS_VERSION \u0026\u0026 length == TIPS_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Tips _tips) internal pure returns (bytes29) {\n        return Tips.unwrap(_tips);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                             TIPS SLICING                             ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /// @notice Returns version of formatted tips\n    function version(Tips _tips) internal pure returns (uint16) {\n        // Get the underlying memory view\n        bytes29 _view = _tips.unwrap();\n        return _getVersion(_view);\n    }\n\n    /// @notice Returns notaryTip field\n    function notaryTip(Tips _tips) internal pure returns (uint96) {\n        bytes29 _view = _tips.unwrap();\n        return uint96(_view.indexUint(OFFSET_NOTARY, 12));\n    }\n\n    /// @notice Returns broadcasterTip field\n    function broadcasterTip(Tips _tips) internal pure returns (uint96) {\n        bytes29 _view = _tips.unwrap();\n        return uint96(_view.indexUint(OFFSET_BROADCASTER, 12));\n    }\n\n    /// @notice Returns proverTip field\n    function proverTip(Tips _tips) internal pure returns (uint96) {\n        bytes29 _view = _tips.unwrap();\n        return uint96(_view.indexUint(OFFSET_PROVER, 12));\n    }\n\n    /// @notice Returns executorTip field\n    function executorTip(Tips _tips) internal pure returns (uint96) {\n        bytes29 _view = _tips.unwrap();\n        return uint96(_view.indexUint(OFFSET_EXECUTOR, 12));\n    }\n\n    /// @notice Returns total tip amount.\n    function totalTips(Tips _tips) internal pure returns (uint96) {\n        // In practice there's no chance that the total tips value would not fit into uint96.\n        // TODO: determine if we want to use uint256 here instead anyway.\n        return notaryTip(_tips) + broadcasterTip(_tips) + proverTip(_tips) + executorTip(_tips);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           PRIVATE HELPERS                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /// @notice Returns a version field without checking if payload is properly formatted.\n    function _getVersion(bytes29 _view) private pure returns (uint16) {\n        return uint16(_view.indexUint(OFFSET_VERSION, 2));\n    }\n}\n\n/// @dev Message is a memory over over a formatted message payload.\ntype Message is bytes29;\n/// @dev Attach library functions to Message\nusing {\n    MessageLib.unwrap,\n    MessageLib.version,\n    MessageLib.header,\n    MessageLib.tips,\n    MessageLib.body,\n    MessageLib.leaf\n} for Message global;\n\n/**\n * @notice  Library for versioned formatting the messages used by Origin and Destination.\n */\nlibrary MessageLib {\n    using HeaderLib for bytes29;\n    using TipsLib for bytes29;\n    using ByteString for bytes;\n    using TypedMemView for bytes29;\n\n    enum Parts {\n        Version,\n        Header,\n        Tips,\n        Body\n    }\n\n    /**\n     * @dev This is only updated if the whole message structure is changed,\n     *      i.e. if a new part is added.\n     *      If already existing part is changed, the message version does not get bumped.\n     */\n    uint16 internal constant MESSAGE_VERSION = 1;\n\n    /**\n     * @dev Message memory layout\n     * [000 .. 002): version            uint16  2 bytes\n     * [002 .. 004): header length      uint16  2 bytes (length == AAA - 6)\n     * [004 .. 006): tips length        uint16  2 bytes (length == BBB - AAA)\n     * [006 .. AAA): header             bytes   ? bytes\n     * [AAA .. BBB): tips               bytes   ? bytes\n     * [BBB .. CCC): body               bytes   ? bytes (length could be zero)\n     */\n\n    uint256 internal constant OFFSET_VERSION = 0;\n\n    /// @dev How much bytes is used for storing the version, or a single offset value\n    uint8 internal constant TWO_BYTES = 2;\n    /// @dev This value reflects the header offset in the latest message version\n    uint16 internal constant OFFSET_HEADER = TWO_BYTES * uint8(type(Parts).max);\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns formatted message with provided fields\n     * @param _header       Formatted header payload\n     * @param _tips         Formatted tips payload\n     * @param _messageBody  Raw bytes of message body\n     * @return Formatted message\n     **/\n    function formatMessage(\n        bytes memory _header,\n        bytes memory _tips,\n        bytes memory _messageBody\n    ) internal pure returns (bytes memory) {\n        // Header and Tips are supposed to fit within 65535 bytes\n        return\n            abi.encodePacked(\n                MESSAGE_VERSION,\n                uint16(_header.length),\n                uint16(_tips.length),\n                _header,\n                _tips,\n                _messageBody\n            );\n    }\n\n    /**\n     * @notice Returns formatted message with provided fields\n     * @param _origin               Domain of origin chain\n     * @param _sender               Address that sent the message\n     * @param _nonce                Message nonce on origin chain\n     * @param _destination          Domain of destination chain\n     * @param _recipient            Address that will receive the message\n     * @param _optimisticSeconds    Optimistic period for message execution\n     * @param _tips                 Formatted tips payload\n     * @param _messageBody          Raw bytes of message body\n     * @return Formatted message\n     **/\n    function formatMessage(\n        uint32 _origin,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destination,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds,\n        bytes memory _tips,\n        bytes memory _messageBody\n    ) internal pure returns (bytes memory) {\n        return\n            formatMessage(\n                HeaderLib.formatHeader(\n                    _origin,\n                    _sender,\n                    _nonce,\n                    _destination,\n                    _recipient,\n                    _optimisticSeconds\n                ),\n                _tips,\n                _messageBody\n            );\n    }\n\n    /**\n     * @notice Returns a Message view over for the given payload.\n     * @dev Will revert if the payload is not a message payload.\n     */\n    function castToMessage(bytes memory _payload) internal pure returns (Message) {\n        return castToMessage(_payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a Message view.\n     * @dev Will revert if the memory view is not over a message payload.\n     */\n    function castToMessage(bytes29 _view) internal pure returns (Message) {\n        require(isMessage(_view), \"Not a message payload\");\n        return Message.wrap(_view);\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Message.\n     */\n    function isMessage(bytes29 _view) internal pure returns (bool) {\n        uint256 length = _view.len();\n        // Check if version and lengths exist in the payload\n        if (length \u003c OFFSET_HEADER) return false;\n        // Check message version\n        if (_getVersion(_view) != MESSAGE_VERSION) return false;\n\n        uint256 headerLength = _getLen(_view, Parts.Header);\n        uint256 tipsLength = _getLen(_view, Parts.Tips);\n        // Header and Tips need to exist\n        // Body could be empty, thus \u003e\n        if (OFFSET_HEADER + headerLength + tipsLength \u003e length) return false;\n\n        // Check header for being a formatted header payload\n        // Check tips for being a formatted tips payload\n        if (!_getHeader(_view).isHeader() || !_getTips(_view).isTips()) return false;\n        return true;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Message _msg) internal pure returns (bytes29) {\n        return Message.unwrap(_msg);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           MESSAGE SLICING                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /// @notice Returns message's version field.\n    function version(Message _msg) internal pure returns (uint16) {\n        // Get the underlying memory view\n        bytes29 _view = _msg.unwrap();\n        return _getVersion(_view);\n    }\n\n    /// @notice Returns message's header field as a Header view.\n    function header(Message _msg) internal pure returns (Header) {\n        bytes29 _view = _msg.unwrap();\n        return _getHeader(_view).castToHeader();\n    }\n\n    /// @notice Returns message's tips field as a Tips view.\n    function tips(Message _msg) internal pure returns (Tips) {\n        bytes29 _view = _msg.unwrap();\n        return _getTips(_view).castToTips();\n    }\n\n    /// @notice Returns message's body field as a generic memory view.\n    function body(Message _msg) internal pure returns (bytes29) {\n        bytes29 _view = _msg.unwrap();\n        // Determine index where message body payload starts\n        uint256 index = OFFSET_HEADER + _getLen(_view, Parts.Header) + _getLen(_view, Parts.Tips);\n        return _view.sliceFrom({ _index: index, newType: 0 });\n    }\n\n    /// @notice Returns message's hash: a leaf to be inserted in the Merkle tree.\n    function leaf(Message _msg) internal pure returns (bytes32) {\n        bytes29 _view = _msg.unwrap();\n        return _view.keccak();\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           PRIVATE HELPERS                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /// @dev Returns length for a given part of the message\n    /// without checking if the payload is properly formatted.\n    function _getLen(bytes29 _view, Parts _part) private pure returns (uint256) {\n        return _view.indexUint(uint256(_part) * TWO_BYTES, TWO_BYTES);\n    }\n\n    /// @dev Returns a version field without checking if the payload is properly formatted.\n    function _getVersion(bytes29 _view) private pure returns (uint16) {\n        return uint16(_view.indexUint(OFFSET_VERSION, 2));\n    }\n\n    /// @dev Returns a generic memory view over the header field without checking\n    /// if the whole payload or the header are properly formatted.\n    function _getHeader(bytes29 _view) private pure returns (bytes29) {\n        uint256 length = _getLen(_view, Parts.Header);\n        return _view.slice({ _index: OFFSET_HEADER, _len: length, newType: 0 });\n    }\n\n    /// @dev Returns a generic memory view over the tips field without checking\n    /// if the whole payload or the tips are properly formatted.\n    function _getTips(bytes29 _view) private pure returns (bytes29) {\n        // Determine index where tips payload starts\n        uint256 indexFrom = OFFSET_HEADER + _getLen(_view, Parts.Header);\n        uint256 length = _getLen(_view, Parts.Tips);\n        return _view.slice({ _index: indexFrom, _len: length, newType: 0 });\n    }\n}\n\n/**\n * @notice Exposes Message methods for testing against golang.\n */\ncontract MessageHarness {\n    using MessageLib for bytes;\n    using MessageLib for bytes29;\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                               GETTERS                                ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    function castToMessage(bytes memory _payload) public view returns (bytes memory) {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        Message _msg = MessageLib.castToMessage(_payload);\n        return _msg.unwrap().clone();\n    }\n\n    function header(bytes memory _payload) public view returns (bytes memory) {\n        return _payload.castToMessage().header().unwrap().clone();\n    }\n\n    function tips(bytes memory _payload) public view returns (bytes memory) {\n        return _payload.castToMessage().tips().unwrap().clone();\n    }\n\n    function body(bytes memory _payload) public view returns (bytes memory) {\n        return _payload.castToMessage().body().clone();\n    }\n\n    function version(bytes memory _payload) public pure returns (uint16) {\n        return _payload.castToMessage().version();\n    }\n\n    function leaf(bytes memory _payload) public pure returns (bytes32) {\n        return _payload.castToMessage().leaf();\n    }\n\n    function isMessage(bytes memory _payload) public pure returns (bool) {\n        return _payload.ref(0).isMessage();\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    function formatMessage(\n        uint32 _origin,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destination,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds,\n        // tips params\n        uint96 _notaryTip,\n        uint96 _broadcasterTip,\n        uint96 _proverTip,\n        uint96 _executorTip,\n        bytes memory _messageBody\n    ) public pure returns (bytes memory) {\n        bytes memory _tips = TipsLib.formatTips(\n            _notaryTip,\n            _broadcasterTip,\n            _proverTip,\n            _executorTip\n        );\n\n        bytes memory _header = HeaderLib.formatHeader(\n            _origin,\n            _sender,\n            _nonce,\n            _destination,\n            _recipient,\n            _optimisticSeconds\n        );\n        return formatMessage(_header, _tips, _messageBody);\n    }\n\n    function formatMessage(\n        uint32 _origin,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destination,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds,\n        bytes memory _tips,\n        bytes memory _messageBody\n    ) public pure returns (bytes memory) {\n        return\n            MessageLib.formatMessage(\n                _origin,\n                _sender,\n                _nonce,\n                _destination,\n                _recipient,\n                _optimisticSeconds,\n                _tips,\n                _messageBody\n            );\n    }\n\n    function formatMessage(\n        bytes memory _header,\n        bytes memory _tips,\n        bytes memory _messageBody\n    ) public pure returns (bytes memory) {\n        return MessageLib.formatMessage(_header, _tips, _messageBody);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           CONSTANT GETTERS                           ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    function messageVersion() public pure returns (uint16) {\n        return MessageLib.MESSAGE_VERSION;\n    }\n\n    function offsetVersion() public pure returns (uint256) {\n        return MessageLib.OFFSET_VERSION;\n    }\n\n    function offsetHeader() public pure returns (uint256) {\n        return MessageLib.OFFSET_HEADER;\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"58:35667:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;58:35667:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"58:35667:0:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3143:38;;3179:2;3143:38;;;;;168:25:1;;;156:2;141:18;3143:38:0;;;;;;;;3400:46;;3310:2;3400:46;;3537:57;;;:::i;3458:56::-;;;:::i;3660:59::-;;3703:16;3660:59;;3230:37;;3265:2;3230:37;;2572:94;;;;;;;;388:66:1;376:79;;;358:98;;346:2;331:18;2572:94:0;204:258:1;3537:57:0;3222:2;3494:20;3222:2;3310;3494:20;:::i;:::-;3574;;;;:::i;:::-;3537:57;:::o;3458:56::-;3494:20;3265:2;3310;467:279:1;532:9;;;553:10;;;550:190;;;596:77;593:1;586:88;697:4;694:1;687:15;725:4;722:1;715:15;550:190;467:279;;;;:::o","abiDefinition":[{"inputs":[],"name":"BITS_EMPTY","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"BITS_LEN","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"BITS_LOC","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"BITS_TYPE","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"LOW_96_BITS_MASK","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"NULL","outputs":[{"internalType":"bytes29","name":"","type":"bytes29"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"SHIFT_LEN","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"SHIFT_LOC","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"SHIFT_TYPE","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"stateVariables":{"BITS_TYPE":{"details":"Memory layout for bytes29 TODO (Chi): with the user defined types storing type is no longer necessary. Update the library, transforming bytes29 to bytes24 in the process. [000..005)   type     5 bytes    Type flag for the pointer [005..017)   loc     12 bytes    Memory address of underlying bytes [017..029)   len     12 bytes    Length of underlying bytes [029..032)   empty    3 bytes    Not used"}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"BITS_EMPTY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BITS_LEN\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BITS_LOC\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BITS_TYPE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LOW_96_BITS_MASK\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NULL\",\"outputs\":[{\"internalType\":\"bytes29\",\"name\":\"\",\"type\":\"bytes29\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SHIFT_LEN\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SHIFT_LOC\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SHIFT_TYPE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"stateVariables\":{\"BITS_TYPE\":{\"details\":\"Memory layout for bytes29 TODO (Chi): with the user defined types storing type is no longer necessary. Update the library, transforming bytes29 to bytes24 in the process. [000..005)   type     5 bytes    Type flag for the pointer [005..017)   loc     12 bytes    Memory address of underlying bytes [017..029)   len     12 bytes    Length of underlying bytes [029..032)   empty    3 bytes    Not used\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/MessageHarness.t.sol\":\"TypedMemView\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/MessageHarness.t.sol\":{\"keccak256\":\"0x3904cba9f384c6433257789b24cdb15655a5775a36df2c4c297958af081b2acc\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://eff1071fd96ffa0ae24c5a5d8de738a1545769b12ccc3c5ec469a9d7e16b21db\",\"dweb:/ipfs/QmYyQsoEqF9QJ5aHaVw5545ePNt9Z7GqXfVyCFGrEh4y84\"]}},\"version\":1}"},"hashes":{"BITS_EMPTY()":"97b8ad4a","BITS_LEN()":"eb740628","BITS_LOC()":"fb734584","BITS_TYPE()":"10153fce","LOW_96_BITS_MASK()":"b602d173","NULL()":"f26be3fc","SHIFT_LEN()":"1136e7ea","SHIFT_LOC()":"1bfe17ce","SHIFT_TYPE()":"13090c5a"}}}